###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         08/Feb/2022  20:54:16
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang\heap_4.c
#        [UTF-8]
#    Command line                 =
#        -f
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS\heap_4.o.rsp
#        (D:\99_Project\GitHub\TouchGFX\MyApplication\Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang\heap_4.c
#        -D USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Middlewares\FreeRTOS
#        -lA
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Middlewares\FreeRTOS
#        -o
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Core/Inc\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/App\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS\heap_4.o.d
#    Locale                       =  C
#    List file                    =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Middlewares\FreeRTOS\heap_4.lst
#    Object file                  =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS\heap_4.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

D:\99_Project\GitHub\TouchGFX\MyApplication\Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang\heap_4.c
      1          /*
      2           * FreeRTOS Kernel V10.3.1
      3           * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
      4           *
      5           * Permission is hereby granted, free of charge, to any person obtaining a copy of
      6           * this software and associated documentation files (the "Software"), to deal in
      7           * the Software without restriction, including without limitation the rights to
      8           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
      9           * the Software, and to permit persons to whom the Software is furnished to do so,
     10           * subject to the following conditions:
     11           *
     12           * The above copyright notice and this permission notice shall be included in all
     13           * copies or substantial portions of the Software.
     14           *
     15           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     16           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     17           * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     18           * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     19           * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     20           * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     21           *
     22           * http://www.FreeRTOS.org
     23           * http://aws.amazon.com/freertos
     24           *
     25           * 1 tab == 4 spaces!
     26           */
     27          
     28          /*
     29           * A sample implementation of pvPortMalloc() and vPortFree() that combines
     30           * (coalescences) adjacent memory blocks as they are freed, and in so doing
     31           * limits memory fragmentation.
     32           *
     33           * See heap_1.c, heap_2.c and heap_3.c for alternative implementations, and the
     34           * memory management pages of http://www.FreeRTOS.org for more information.
     35           */
     36          #include <stdlib.h>
     37          
     38          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     39          all the API functions to use the MPU wrappers.  That should only be done when
     40          task.h is included from an application file. */
     41          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     42          
     43          #include "FreeRTOS.h"
     44          #include "task.h"
     45          
     46          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     47          
     48          #if( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
     49          	#error This file must not be used if configSUPPORT_DYNAMIC_ALLOCATION is 0
     50          #endif
     51          
     52          /* Block sizes must not get too small. */
     53          #define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( xHeapStructSize << 1 ) )
     54          
     55          /* Assumes 8bit bytes! */
     56          #define heapBITS_PER_BYTE		( ( size_t ) 8 )
     57          
     58          /* Allocate the memory for the heap. */
     59          #if( configAPPLICATION_ALLOCATED_HEAP == 1 )
     60          	/* The application writer has already defined the array used for the RTOS
     61          	heap - probably so it can be placed in a special segment or address. */
     62          	extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
     63          #else

   \                                 In section .bss, align 4
     64          	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
   \                     ucHeap:
   \        0x0                      DS8 32'768
     65          #endif /* configAPPLICATION_ALLOCATED_HEAP */
     66          
     67          /* Define the linked list structure.  This is used to link free blocks in order
     68          of their memory address. */
     69          typedef struct A_BLOCK_LINK
     70          {
     71          	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
     72          	size_t xBlockSize;						/*<< The size of the free block. */
     73          } BlockLink_t;
     74          
     75          /*-----------------------------------------------------------*/
     76          
     77          /*
     78           * Inserts a block of memory that is being freed into the correct position in
     79           * the list of free memory blocks.  The block being freed will be merged with
     80           * the block in front it and/or the block behind it if the memory blocks are
     81           * adjacent to each other.
     82           */
     83          static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert );
     84          
     85          /*
     86           * Called automatically to setup the required heap structures the first time
     87           * pvPortMalloc() is called.
     88           */
     89          static void prvHeapInit( void );
     90          
     91          /*-----------------------------------------------------------*/
     92          
     93          /* The size of the structure placed at the beginning of each allocated memory
     94          block must by correctly byte aligned. */

   \                                 In section .rodata, align 4
     95          static const size_t xHeapStructSize	= ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
   \                     xHeapStructSize:
   \        0x0   0x0000'0008        DC32 8
     96          
     97          /* Create a couple of list links to mark the start and end of the list. */

   \                                 In section .bss, align 4
     98          static BlockLink_t xStart, *pxEnd = NULL;
   \                     xStart:
   \        0x0                      DS8 8

   \                                 In section .bss, align 4
   \                     pxEnd:
   \        0x0                      DS8 4
     99          
    100          /* Keeps track of the number of calls to allocate and free memory as well as the
    101          number of free bytes remaining, but says nothing about fragmentation. */

   \                                 In section .bss, align 4
    102          static size_t xFreeBytesRemaining = 0U;
   \                     xFreeBytesRemaining:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    103          static size_t xMinimumEverFreeBytesRemaining = 0U;
   \                     xMinimumEverFreeBytesRemaining:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    104          static size_t xNumberOfSuccessfulAllocations = 0;
   \                     xNumberOfSuccessfulAllocations:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    105          static size_t xNumberOfSuccessfulFrees = 0;
   \                     xNumberOfSuccessfulFrees:
   \        0x0                      DS8 4
    106          
    107          /* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize
    108          member of an BlockLink_t structure is set then the block belongs to the
    109          application.  When the bit is free the block is still part of the free heap
    110          space. */

   \                                 In section .bss, align 4
    111          static size_t xBlockAllocatedBit = 0;
   \                     xBlockAllocatedBit:
   \        0x0                      DS8 4
    112          
    113          /*-----------------------------------------------------------*/
    114          

   \                                 In section .text, align 2, keep-with-next
    115          void *pvPortMalloc( size_t xWantedSize )
    116          {
   \                     pvPortMalloc: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
    117          BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
    118          void *pvReturn = NULL;
   \        0x6   0x2500             MOVS     R5,#+0
    119          
    120          	vTaskSuspendAll();
   \        0x8   0x.... 0x....      BL       vTaskSuspendAll
    121          	{
    122          		/* If this is the first call to malloc then the heap will require
    123          		initialisation to setup the list of free blocks. */
    124          		if( pxEnd == NULL )
   \        0xC   0x.... 0x....      LDR.W    R9,??DataTable6
   \       0x10   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??pvPortMalloc_0
    125          		{
    126          			prvHeapInit();
   \       0x18   0x.... 0x....      BL       prvHeapInit
    127          		}
    128          		else
    129          		{
    130          			mtCOVERAGE_TEST_MARKER();
    131          		}
    132          
    133          		/* Check the requested block size is not so large that the top bit is
    134          		set.  The top bit of the block size member of the BlockLink_t structure
    135          		is used to determine who owns the block - the application or the
    136          		kernel, so it must be free. */
    137          		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
   \                     ??pvPortMalloc_0: (+1)
   \       0x1C   0x....             LDR.N    R7,??DataTable6_1
   \       0x1E   0x6838             LDR      R0,[R7, #+0]
   \       0x20   0x4204             TST      R4,R0
   \       0x22   0xD16A             BNE.N    ??pvPortMalloc_1
    138          		{
    139          			/* The wanted size is increased so it can contain a BlockLink_t
    140          			structure in addition to the requested amount of bytes. */
    141          			if( xWantedSize > 0 )
   \       0x24   0x2C00             CMP      R4,#+0
   \       0x26   0xD015             BEQ.N    ??pvPortMalloc_2
    142          			{
    143          				xWantedSize += xHeapStructSize;
   \       0x28   0x....             LDR.N    R0,??DataTable6_2
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0x1904             ADDS     R4,R0,R4
    144          
    145          				/* Ensure that blocks are always aligned to the required number
    146          				of bytes. */
    147          				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
   \       0x2E   0xF014 0x0F07      TST      R4,#0x7
   \       0x32   0xD00F             BEQ.N    ??pvPortMalloc_2
    148          				{
    149          					/* Byte alignment required. */
    150          					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   \       0x34   0xF114 0x0008      ADDS     R0,R4,#+8
   \       0x38   0xF014 0x0407      ANDS     R4,R4,#0x7
   \       0x3C   0x1B04             SUBS     R4,R0,R4
    151          					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
   \       0x3E   0xF014 0x0F07      TST      R4,#0x7
   \       0x42   0xD007             BEQ.N    ??pvPortMalloc_2
   \       0x44   0x2050             MOVS     R0,#+80
   \       0x46   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x4A   0xF3BF 0x8F4F      DSB      SY
   \       0x4E   0xF3BF 0x8F6F      ISB      SY
   \                     ??pvPortMalloc_3: (+1)
   \       0x52   0xE7FE             B.N      ??pvPortMalloc_3
    152          				}
    153          				else
    154          				{
    155          					mtCOVERAGE_TEST_MARKER();
    156          				}
    157          			}
    158          			else
    159          			{
    160          				mtCOVERAGE_TEST_MARKER();
    161          			}
    162          
    163          			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
   \                     ??pvPortMalloc_2: (+1)
   \       0x54   0x2C00             CMP      R4,#+0
   \       0x56   0xD050             BEQ.N    ??pvPortMalloc_1
   \       0x58   0x.... 0x....      LDR.W    R8,??DataTable6_3
   \       0x5C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x60   0x42A0             CMP      R0,R4
   \       0x62   0xD34A             BCC.N    ??pvPortMalloc_1
    164          			{
    165          				/* Traverse the list from the start	(lowest address) block until
    166          				one	of adequate size is found. */
    167          				pxPreviousBlock = &xStart;
   \       0x64   0x....             LDR.N    R0,??DataTable6_4
   \       0x66   0x0001             MOVS     R1,R0
    168          				pxBlock = xStart.pxNextFreeBlock;
   \       0x68   0x6806             LDR      R6,[R0, #+0]
   \       0x6A   0xE001             B.N      ??pvPortMalloc_4
    169          				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    170          				{
    171          					pxPreviousBlock = pxBlock;
   \                     ??pvPortMalloc_5: (+1)
   \       0x6C   0x0031             MOVS     R1,R6
    172          					pxBlock = pxBlock->pxNextFreeBlock;
   \       0x6E   0x6836             LDR      R6,[R6, #+0]
    173          				}
   \                     ??pvPortMalloc_4: (+1)
   \       0x70   0x6870             LDR      R0,[R6, #+4]
   \       0x72   0x42A0             CMP      R0,R4
   \       0x74   0xD202             BCS.N    ??pvPortMalloc_6
   \       0x76   0x6830             LDR      R0,[R6, #+0]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD1F7             BNE.N    ??pvPortMalloc_5
    174          
    175          				/* If the end marker was reached then a block of adequate size
    176          				was	not found. */
    177          				if( pxBlock != pxEnd )
   \                     ??pvPortMalloc_6: (+1)
   \       0x7C   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x80   0x4286             CMP      R6,R0
   \       0x82   0xD03A             BEQ.N    ??pvPortMalloc_1
    178          				{
    179          					/* Return the memory space pointed to - jumping over the
    180          					BlockLink_t structure at its start. */
    181          					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
   \       0x84   0x....             LDR.N    R0,??DataTable6_2
   \       0x86   0x680A             LDR      R2,[R1, #+0]
   \       0x88   0x6803             LDR      R3,[R0, #+0]
   \       0x8A   0xEB02 0x0503      ADD      R5,R2,R3
    182          
    183          					/* This block is being returned for use so must be taken out
    184          					of the list of free blocks. */
    185          					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
   \       0x8E   0x6832             LDR      R2,[R6, #+0]
   \       0x90   0x600A             STR      R2,[R1, #+0]
    186          
    187          					/* If the block is larger than required it can be split into
    188          					two. */
    189          					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
   \       0x92   0x6800             LDR      R0,[R0, #+0]
   \       0x94   0x0040             LSLS     R0,R0,#+1
   \       0x96   0x6871             LDR      R1,[R6, #+4]
   \       0x98   0x1B09             SUBS     R1,R1,R4
   \       0x9A   0x4288             CMP      R0,R1
   \       0x9C   0xD214             BCS.N    ??pvPortMalloc_7
    190          					{
    191          						/* This block is to be split into two.  Create a new
    192          						block following the number of bytes requested. The void
    193          						cast is used to prevent byte alignment warnings from the
    194          						compiler. */
    195          						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
   \       0x9E   0xEB06 0x0104      ADD      R1,R6,R4
    196          						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
   \       0xA2   0xF011 0x0007      ANDS     R0,R1,#0x7
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD007             BEQ.N    ??pvPortMalloc_8
   \       0xAA   0x2050             MOVS     R0,#+80
   \       0xAC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0xB0   0xF3BF 0x8F4F      DSB      SY
   \       0xB4   0xF3BF 0x8F6F      ISB      SY
   \                     ??pvPortMalloc_9: (+1)
   \       0xB8   0xE7FE             B.N      ??pvPortMalloc_9
    197          
    198          						/* Calculate the sizes of two blocks split from the
    199          						single block. */
    200          						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
   \                     ??pvPortMalloc_8: (+1)
   \       0xBA   0x6870             LDR      R0,[R6, #+4]
   \       0xBC   0x1B00             SUBS     R0,R0,R4
   \       0xBE   0x6048             STR      R0,[R1, #+4]
    201          						pxBlock->xBlockSize = xWantedSize;
   \       0xC0   0x6074             STR      R4,[R6, #+4]
    202          
    203          						/* Insert the new block into the list of free blocks. */
    204          						prvInsertBlockIntoFreeList( pxNewBlockLink );
   \       0xC2   0x0008             MOVS     R0,R1
   \       0xC4   0x.... 0x....      BL       prvInsertBlockIntoFreeList
    205          					}
    206          					else
    207          					{
    208          						mtCOVERAGE_TEST_MARKER();
    209          					}
    210          
    211          					xFreeBytesRemaining -= pxBlock->xBlockSize;
   \                     ??pvPortMalloc_7: (+1)
   \       0xC8   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0xCC   0x6870             LDR      R0,[R6, #+4]
   \       0xCE   0x1A09             SUBS     R1,R1,R0
   \       0xD0   0xF8C8 0x1000      STR      R1,[R8, #+0]
    212          
    213          					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
   \       0xD4   0x....             LDR.N    R0,??DataTable6_5
   \       0xD6   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0xDA   0x6802             LDR      R2,[R0, #+0]
   \       0xDC   0x4291             CMP      R1,R2
   \       0xDE   0xD202             BCS.N    ??pvPortMalloc_10
    214          					{
    215          						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
   \       0xE0   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0xE4   0x6001             STR      R1,[R0, #+0]
    216          					}
    217          					else
    218          					{
    219          						mtCOVERAGE_TEST_MARKER();
    220          					}
    221          
    222          					/* The block is being returned - it is allocated and owned
    223          					by the application and has no "next" block. */
    224          					pxBlock->xBlockSize |= xBlockAllocatedBit;
   \                     ??pvPortMalloc_10: (+1)
   \       0xE6   0x6871             LDR      R1,[R6, #+4]
   \       0xE8   0x6838             LDR      R0,[R7, #+0]
   \       0xEA   0x4301             ORRS     R1,R0,R1
   \       0xEC   0x6071             STR      R1,[R6, #+4]
    225          					pxBlock->pxNextFreeBlock = NULL;
   \       0xEE   0x2000             MOVS     R0,#+0
   \       0xF0   0x6030             STR      R0,[R6, #+0]
    226          					xNumberOfSuccessfulAllocations++;
   \       0xF2   0x....             LDR.N    R0,??DataTable6_6
   \       0xF4   0x6801             LDR      R1,[R0, #+0]
   \       0xF6   0x1C49             ADDS     R1,R1,#+1
   \       0xF8   0x6001             STR      R1,[R0, #+0]
    227          				}
    228          				else
    229          				{
    230          					mtCOVERAGE_TEST_MARKER();
    231          				}
    232          			}
    233          			else
    234          			{
    235          				mtCOVERAGE_TEST_MARKER();
    236          			}
    237          		}
    238          		else
    239          		{
    240          			mtCOVERAGE_TEST_MARKER();
    241          		}
    242          
    243          		traceMALLOC( pvReturn, xWantedSize );
    244          	}
    245          	( void ) xTaskResumeAll();
   \                     ??pvPortMalloc_1: (+1)
   \       0xFA   0x.... 0x....      BL       xTaskResumeAll
    246          
    247          	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
    248          	{
    249          		if( pvReturn == NULL )
    250          		{
    251          			extern void vApplicationMallocFailedHook( void );
    252          			vApplicationMallocFailedHook();
    253          		}
    254          		else
    255          		{
    256          			mtCOVERAGE_TEST_MARKER();
    257          		}
    258          	}
    259          	#endif
    260          
    261          	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
   \       0xFE   0xF015 0x0007      ANDS     R0,R5,#0x7
   \      0x102   0x2800             CMP      R0,#+0
   \      0x104   0xD007             BEQ.N    ??pvPortMalloc_11
   \      0x106   0x2050             MOVS     R0,#+80
   \      0x108   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x10C   0xF3BF 0x8F4F      DSB      SY
   \      0x110   0xF3BF 0x8F6F      ISB      SY
   \                     ??pvPortMalloc_12: (+1)
   \      0x114   0xE7FE             B.N      ??pvPortMalloc_12
    262          	return pvReturn;
   \                     ??pvPortMalloc_11: (+1)
   \      0x116   0x0028             MOVS     R0,R5
   \      0x118   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    263          }
    264          /*-----------------------------------------------------------*/
    265          

   \                                 In section .text, align 2, keep-with-next
    266          void vPortFree( void *pv )
    267          {
   \                     vPortFree: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    268          uint8_t *puc = ( uint8_t * ) pv;
   \        0x2   0x0001             MOVS     R1,R0
    269          BlockLink_t *pxLink;
    270          
    271          	if( pv != NULL )
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD037             BEQ.N    ??vPortFree_0
    272          	{
    273          		/* The memory being freed will have an BlockLink_t structure immediately
    274          		before it. */
    275          		puc -= xHeapStructSize;
   \        0x8   0x....             LDR.N    R0,??DataTable6_2
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0x4240             RSBS     R0,R0,#+0
   \        0xE   0xEB01 0x0400      ADD      R4,R1,R0
    276          
    277          		/* This casting is to keep the compiler from issuing warnings. */
    278          		pxLink = ( void * ) puc;
    279          
    280          		/* Check the block is actually allocated. */
    281          		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
   \       0x12   0x....             LDR.N    R1,??DataTable6_1
   \       0x14   0x6860             LDR      R0,[R4, #+4]
   \       0x16   0x680A             LDR      R2,[R1, #+0]
   \       0x18   0x4210             TST      R0,R2
   \       0x1A   0xD107             BNE.N    ??vPortFree_1
   \       0x1C   0x2050             MOVS     R0,#+80
   \       0x1E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x22   0xF3BF 0x8F4F      DSB      SY
   \       0x26   0xF3BF 0x8F6F      ISB      SY
   \                     ??vPortFree_2: (+1)
   \       0x2A   0xE7FE             B.N      ??vPortFree_2
    282          		configASSERT( pxLink->pxNextFreeBlock == NULL );
   \                     ??vPortFree_1: (+1)
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD007             BEQ.N    ??vPortFree_3
   \       0x32   0x2050             MOVS     R0,#+80
   \       0x34   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x38   0xF3BF 0x8F4F      DSB      SY
   \       0x3C   0xF3BF 0x8F6F      ISB      SY
   \                     ??vPortFree_4: (+1)
   \       0x40   0xE7FE             B.N      ??vPortFree_4
    283          
    284          		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
   \                     ??vPortFree_3: (+1)
   \       0x42   0x6860             LDR      R0,[R4, #+4]
   \       0x44   0x680A             LDR      R2,[R1, #+0]
   \       0x46   0x4210             TST      R0,R2
   \       0x48   0xD016             BEQ.N    ??vPortFree_0
    285          		{
    286          			if( pxLink->pxNextFreeBlock == NULL )
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD113             BNE.N    ??vPortFree_0
    287          			{
    288          				/* The block is being returned to the heap - it is no longer
    289          				allocated. */
    290          				pxLink->xBlockSize &= ~xBlockAllocatedBit;
   \       0x50   0x6862             LDR      R2,[R4, #+4]
   \       0x52   0x6808             LDR      R0,[R1, #+0]
   \       0x54   0x4382             BICS     R2,R2,R0
   \       0x56   0x6062             STR      R2,[R4, #+4]
    291          
    292          				vTaskSuspendAll();
   \       0x58   0x.... 0x....      BL       vTaskSuspendAll
    293          				{
    294          					/* Add this block to the list of free blocks. */
    295          					xFreeBytesRemaining += pxLink->xBlockSize;
   \       0x5C   0x....             LDR.N    R1,??DataTable6_3
   \       0x5E   0x680A             LDR      R2,[R1, #+0]
   \       0x60   0x6860             LDR      R0,[R4, #+4]
   \       0x62   0x1882             ADDS     R2,R0,R2
   \       0x64   0x600A             STR      R2,[R1, #+0]
    296          					traceFREE( pv, pxLink->xBlockSize );
    297          					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
   \       0x66   0x0020             MOVS     R0,R4
   \       0x68   0x.... 0x....      BL       prvInsertBlockIntoFreeList
    298          					xNumberOfSuccessfulFrees++;
   \       0x6C   0x....             LDR.N    R0,??DataTable6_7
   \       0x6E   0x6801             LDR      R1,[R0, #+0]
   \       0x70   0x1C49             ADDS     R1,R1,#+1
   \       0x72   0x6001             STR      R1,[R0, #+0]
    299          				}
    300          				( void ) xTaskResumeAll();
   \       0x74   0x.... 0x....      BL       xTaskResumeAll
    301          			}
    302          			else
    303          			{
    304          				mtCOVERAGE_TEST_MARKER();
    305          			}
    306          		}
    307          		else
    308          		{
    309          			mtCOVERAGE_TEST_MARKER();
    310          		}
    311          	}
    312          }
   \                     ??vPortFree_0: (+1)
   \       0x78   0xBD10             POP      {R4,PC}
    313          /*-----------------------------------------------------------*/
    314          

   \                                 In section .text, align 2, keep-with-next
    315          size_t xPortGetFreeHeapSize( void )
    316          {
    317          	return xFreeBytesRemaining;
   \                     xPortGetFreeHeapSize: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable6_3
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
    318          }
    319          /*-----------------------------------------------------------*/
    320          

   \                                 In section .text, align 2, keep-with-next
    321          size_t xPortGetMinimumEverFreeHeapSize( void )
    322          {
    323          	return xMinimumEverFreeBytesRemaining;
   \                     xPortGetMinimumEverFreeHeapSize: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable6_5
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
    324          }
    325          /*-----------------------------------------------------------*/
    326          

   \                                 In section .text, align 2, keep-with-next
    327          void vPortInitialiseBlocks( void )
    328          {
    329          	/* This just exists to keep the linker quiet. */
    330          }
   \                     vPortInitialiseBlocks: (+1)
   \        0x0   0x4770             BX       LR
    331          /*-----------------------------------------------------------*/
    332          

   \                                 In section .text, align 2, keep-with-next
    333          static void prvHeapInit( void )
    334          {
   \                     prvHeapInit: (+1)
   \        0x0   0xB410             PUSH     {R4}
    335          BlockLink_t *pxFirstFreeBlock;
    336          uint8_t *pucAlignedHeap;
    337          size_t uxAddress;
    338          size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
   \        0x2   0xF44F 0x4200      MOV      R2,#+32768
    339          
    340          	/* Ensure the heap starts on a correctly aligned boundary. */
    341          	uxAddress = ( size_t ) ucHeap;
   \        0x6   0x....             LDR.N    R0,??DataTable6_8
   \        0x8   0x0001             MOVS     R1,R0
    342          
    343          	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
   \        0xA   0xF011 0x0F07      TST      R1,#0x7
   \        0xE   0xD004             BEQ.N    ??prvHeapInit_0
    344          	{
    345          		uxAddress += ( portBYTE_ALIGNMENT - 1 );
   \       0x10   0x1DC9             ADDS     R1,R1,#+7
    346          		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
   \       0x12   0x08C9             LSRS     R1,R1,#+3
   \       0x14   0x00C9             LSLS     R1,R1,#+3
    347          		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
   \       0x16   0x1A52             SUBS     R2,R2,R1
   \       0x18   0x1882             ADDS     R2,R0,R2
    348          	}
    349          
    350          	pucAlignedHeap = ( uint8_t * ) uxAddress;
    351          
    352          	/* xStart is used to hold a pointer to the first item in the list of free
    353          	blocks.  The void cast is used to prevent compiler warnings. */
    354          	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
   \                     ??prvHeapInit_0: (+1)
   \       0x1A   0x....             LDR.N    R0,??DataTable6_4
   \       0x1C   0x6001             STR      R1,[R0, #+0]
    355          	xStart.xBlockSize = ( size_t ) 0;
   \       0x1E   0x2300             MOVS     R3,#+0
   \       0x20   0x6043             STR      R3,[R0, #+4]
    356          
    357          	/* pxEnd is used to mark the end of the list of free blocks and is inserted
    358          	at the end of the heap space. */
    359          	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
   \       0x22   0x1852             ADDS     R2,R2,R1
    360          	uxAddress -= xHeapStructSize;
   \       0x24   0x....             LDR.N    R0,??DataTable6_2
   \       0x26   0x6800             LDR      R0,[R0, #+0]
   \       0x28   0x1A12             SUBS     R2,R2,R0
    361          	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
   \       0x2A   0x08D2             LSRS     R2,R2,#+3
   \       0x2C   0x00D2             LSLS     R2,R2,#+3
    362          	pxEnd = ( void * ) uxAddress;
   \       0x2E   0x....             LDR.N    R0,??DataTable6
   \       0x30   0x6002             STR      R2,[R0, #+0]
    363          	pxEnd->xBlockSize = 0;
   \       0x32   0x2300             MOVS     R3,#+0
   \       0x34   0x6804             LDR      R4,[R0, #+0]
   \       0x36   0x6063             STR      R3,[R4, #+4]
    364          	pxEnd->pxNextFreeBlock = NULL;
   \       0x38   0x2300             MOVS     R3,#+0
   \       0x3A   0x6804             LDR      R4,[R0, #+0]
   \       0x3C   0x6023             STR      R3,[R4, #+0]
    365          
    366          	/* To start with there is a single free block that is sized to take up the
    367          	entire heap space, minus the space taken by pxEnd. */
    368          	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
    369          	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
   \       0x3E   0x1A52             SUBS     R2,R2,R1
   \       0x40   0x604A             STR      R2,[R1, #+4]
    370          	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
   \       0x42   0x6800             LDR      R0,[R0, #+0]
   \       0x44   0x6008             STR      R0,[R1, #+0]
    371          
    372          	/* Only one block exists - and it covers the entire usable heap space. */
    373          	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
   \       0x46   0x6848             LDR      R0,[R1, #+4]
   \       0x48   0x....             LDR.N    R2,??DataTable6_5
   \       0x4A   0x6010             STR      R0,[R2, #+0]
    374          	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
   \       0x4C   0x6848             LDR      R0,[R1, #+4]
   \       0x4E   0x....             LDR.N    R1,??DataTable6_3
   \       0x50   0x6008             STR      R0,[R1, #+0]
    375          
    376          	/* Work out the position of the top bit in a size_t variable. */
    377          	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
   \       0x52   0xF05F 0x4000      MOVS     R0,#+2147483648
   \       0x56   0x....             LDR.N    R1,??DataTable6_1
   \       0x58   0x6008             STR      R0,[R1, #+0]
    378          }
   \       0x5A   0xBC10             POP      {R4}
   \       0x5C   0x4770             BX       LR
    379          /*-----------------------------------------------------------*/
    380          

   \                                 In section .text, align 2, keep-with-next
    381          static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
    382          {
   \                     prvInsertBlockIntoFreeList: (+1)
   \        0x0   0xB410             PUSH     {R4}
    383          BlockLink_t *pxIterator;
    384          uint8_t *puc;
    385          
    386          	/* Iterate through the list until a block is found that has a higher address
    387          	than the block being inserted. */
    388          	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
   \        0x2   0x....             LDR.N    R2,??DataTable6_4
   \        0x4   0xE000             B.N      ??prvInsertBlockIntoFreeList_0
   \                     ??prvInsertBlockIntoFreeList_1: (+1)
   \        0x6   0x6812             LDR      R2,[R2, #+0]
   \                     ??prvInsertBlockIntoFreeList_0: (+1)
   \        0x8   0x6811             LDR      R1,[R2, #+0]
   \        0xA   0x4281             CMP      R1,R0
   \        0xC   0xD3FB             BCC.N    ??prvInsertBlockIntoFreeList_1
    389          	{
    390          		/* Nothing to do here, just iterate to the right position. */
    391          	}
    392          
    393          	/* Do the block being inserted, and the block it is being inserted after
    394          	make a contiguous block of memory? */
    395          	puc = ( uint8_t * ) pxIterator;
   \        0xE   0x0011             MOVS     R1,R2
    396          	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
   \       0x10   0x6853             LDR      R3,[R2, #+4]
   \       0x12   0x4419             ADD      R1,R1,R3
   \       0x14   0x4281             CMP      R1,R0
   \       0x16   0xD104             BNE.N    ??prvInsertBlockIntoFreeList_2
    397          	{
    398          		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
   \       0x18   0x6851             LDR      R1,[R2, #+4]
   \       0x1A   0x6840             LDR      R0,[R0, #+4]
   \       0x1C   0x1841             ADDS     R1,R0,R1
   \       0x1E   0x6051             STR      R1,[R2, #+4]
    399          		pxBlockToInsert = pxIterator;
   \       0x20   0x0010             MOVS     R0,R2
    400          	}
    401          	else
    402          	{
    403          		mtCOVERAGE_TEST_MARKER();
    404          	}
    405          
    406          	/* Do the block being inserted, and the block it is being inserted before
    407          	make a contiguous block of memory? */
    408          	puc = ( uint8_t * ) pxBlockToInsert;
   \                     ??prvInsertBlockIntoFreeList_2: (+1)
   \       0x22   0x0001             MOVS     R1,R0
    409          	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
   \       0x24   0x6843             LDR      R3,[R0, #+4]
   \       0x26   0x4419             ADD      R1,R1,R3
   \       0x28   0x6813             LDR      R3,[R2, #+0]
   \       0x2A   0x4299             CMP      R1,R3
   \       0x2C   0xD110             BNE.N    ??prvInsertBlockIntoFreeList_3
    410          	{
    411          		if( pxIterator->pxNextFreeBlock != pxEnd )
   \       0x2E   0x....             LDR.N    R1,??DataTable6
   \       0x30   0x6813             LDR      R3,[R2, #+0]
   \       0x32   0x680C             LDR      R4,[R1, #+0]
   \       0x34   0x42A3             CMP      R3,R4
   \       0x36   0xD008             BEQ.N    ??prvInsertBlockIntoFreeList_4
    412          		{
    413          			/* Form one big block from the two blocks. */
    414          			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
   \       0x38   0x6843             LDR      R3,[R0, #+4]
   \       0x3A   0x6811             LDR      R1,[R2, #+0]
   \       0x3C   0x6849             LDR      R1,[R1, #+4]
   \       0x3E   0x18CB             ADDS     R3,R1,R3
   \       0x40   0x6043             STR      R3,[R0, #+4]
    415          			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
   \       0x42   0x6811             LDR      R1,[R2, #+0]
   \       0x44   0x6809             LDR      R1,[R1, #+0]
   \       0x46   0x6001             STR      R1,[R0, #+0]
   \       0x48   0xE004             B.N      ??prvInsertBlockIntoFreeList_5
    416          		}
    417          		else
    418          		{
    419          			pxBlockToInsert->pxNextFreeBlock = pxEnd;
   \                     ??prvInsertBlockIntoFreeList_4: (+1)
   \       0x4A   0x6809             LDR      R1,[R1, #+0]
   \       0x4C   0x6001             STR      R1,[R0, #+0]
   \       0x4E   0xE001             B.N      ??prvInsertBlockIntoFreeList_5
    420          		}
    421          	}
    422          	else
    423          	{
    424          		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
   \                     ??prvInsertBlockIntoFreeList_3: (+1)
   \       0x50   0x6811             LDR      R1,[R2, #+0]
   \       0x52   0x6001             STR      R1,[R0, #+0]
    425          	}
    426          
    427          	/* If the block being inserted plugged a gab, so was merged with the block
    428          	before and the block after, then it's pxNextFreeBlock pointer will have
    429          	already been set, and should not be set here as that would make it point
    430          	to itself. */
    431          	if( pxIterator != pxBlockToInsert )
   \                     ??prvInsertBlockIntoFreeList_5: (+1)
   \       0x54   0x4282             CMP      R2,R0
   \       0x56   0xD000             BEQ.N    ??prvInsertBlockIntoFreeList_6
    432          	{
    433          		pxIterator->pxNextFreeBlock = pxBlockToInsert;
   \       0x58   0x6010             STR      R0,[R2, #+0]
    434          	}
    435          	else
    436          	{
    437          		mtCOVERAGE_TEST_MARKER();
    438          	}
    439          }
   \                     ??prvInsertBlockIntoFreeList_6: (+1)
   \       0x5A   0xBC10             POP      {R4}
   \       0x5C   0x4770             BX       LR
    440          /*-----------------------------------------------------------*/
    441          

   \                                 In section .text, align 2, keep-with-next
    442          void vPortGetHeapStats( HeapStats_t *pxHeapStats )
    443          {
   \                     vPortGetHeapStats: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    444          BlockLink_t *pxBlock;
    445          size_t xBlocks = 0, xMaxSize = 0, xMinSize = portMAX_DELAY; /* portMAX_DELAY used as a portable way of getting the maximum value. */
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x2600             MOVS     R6,#+0
   \        0x8   0xF05F 0x37FF      MOVS     R7,#+4294967295
    446          
    447          	vTaskSuspendAll();
   \        0xC   0x.... 0x....      BL       vTaskSuspendAll
    448          	{
    449          		pxBlock = xStart.pxNextFreeBlock;
   \       0x10   0x....             LDR.N    R0,??DataTable6_4
   \       0x12   0x6800             LDR      R0,[R0, #+0]
    450          
    451          		/* pxBlock will be NULL if the heap has not been initialised.  The heap
    452          		is initialised automatically when the first allocation is made. */
    453          		if( pxBlock != NULL )
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD00D             BEQ.N    ??vPortGetHeapStats_0
    454          		{
    455          			do
    456          			{
    457          				/* Increment the number of blocks and record the largest block seen
    458          				so far. */
    459          				xBlocks++;
   \                     ??vPortGetHeapStats_1: (+1)
   \       0x18   0x1C6D             ADDS     R5,R5,#+1
    460          
    461          				if( pxBlock->xBlockSize > xMaxSize )
   \       0x1A   0x6841             LDR      R1,[R0, #+4]
   \       0x1C   0x428E             CMP      R6,R1
   \       0x1E   0xD200             BCS.N    ??vPortGetHeapStats_2
    462          				{
    463          					xMaxSize = pxBlock->xBlockSize;
   \       0x20   0x6846             LDR      R6,[R0, #+4]
    464          				}
    465          
    466          				if( pxBlock->xBlockSize < xMinSize )
   \                     ??vPortGetHeapStats_2: (+1)
   \       0x22   0x6841             LDR      R1,[R0, #+4]
   \       0x24   0x42B9             CMP      R1,R7
   \       0x26   0xD200             BCS.N    ??vPortGetHeapStats_3
    467          				{
    468          					xMinSize = pxBlock->xBlockSize;
   \       0x28   0x6847             LDR      R7,[R0, #+4]
    469          				}
    470          
    471          				/* Move to the next block in the chain until the last block is
    472          				reached. */
    473          				pxBlock = pxBlock->pxNextFreeBlock;
   \                     ??vPortGetHeapStats_3: (+1)
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
    474          			} while( pxBlock != pxEnd );
   \       0x2C   0x....             LDR.N    R1,??DataTable6
   \       0x2E   0x6809             LDR      R1,[R1, #+0]
   \       0x30   0x4288             CMP      R0,R1
   \       0x32   0xD1F1             BNE.N    ??vPortGetHeapStats_1
    475          		}
    476          	}
    477          	xTaskResumeAll();
   \                     ??vPortGetHeapStats_0: (+1)
   \       0x34   0x.... 0x....      BL       xTaskResumeAll
    478          
    479          	pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;
   \       0x38   0x6066             STR      R6,[R4, #+4]
    480          	pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;
   \       0x3A   0x60A7             STR      R7,[R4, #+8]
    481          	pxHeapStats->xNumberOfFreeBlocks = xBlocks;
   \       0x3C   0x60E5             STR      R5,[R4, #+12]
    482          
    483          	taskENTER_CRITICAL();
   \       0x3E   0x.... 0x....      BL       vPortEnterCritical
    484          	{
    485          		pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;
   \       0x42   0x....             LDR.N    R0,??DataTable6_3
   \       0x44   0x6800             LDR      R0,[R0, #+0]
   \       0x46   0x6020             STR      R0,[R4, #+0]
    486          		pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;
   \       0x48   0x....             LDR.N    R0,??DataTable6_6
   \       0x4A   0x6800             LDR      R0,[R0, #+0]
   \       0x4C   0x6160             STR      R0,[R4, #+20]
    487          		pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;
   \       0x4E   0x....             LDR.N    R0,??DataTable6_7
   \       0x50   0x6800             LDR      R0,[R0, #+0]
   \       0x52   0x61A0             STR      R0,[R4, #+24]
    488          		pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;
   \       0x54   0x....             LDR.N    R0,??DataTable6_5
   \       0x56   0x6800             LDR      R0,[R0, #+0]
   \       0x58   0x6120             STR      R0,[R4, #+16]
    489          	}
    490          	taskEXIT_CRITICAL();
   \       0x5A   0x.... 0x....      BL       vPortExitCritical
    491          }
   \       0x5E   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     pxEnd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x....'....        DC32     xBlockAllocatedBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x....'....        DC32     xHeapStructSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x....'....        DC32     xFreeBytesRemaining

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \        0x0   0x....'....        DC32     xStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \        0x0   0x....'....        DC32     xMinimumEverFreeBytesRemaining

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \        0x0   0x....'....        DC32     xNumberOfSuccessfulAllocations

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \        0x0   0x....'....        DC32     xNumberOfSuccessfulFrees

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \        0x0   0x....'....        DC32     ucHeap
    492          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   prvHeapInit
       4   prvInsertBlockIntoFreeList
      32   pvPortMalloc
        32   -> prvHeapInit
        32   -> prvInsertBlockIntoFreeList
        32   -> vTaskSuspendAll
        32   -> xTaskResumeAll
       8   vPortFree
         8   -> prvInsertBlockIntoFreeList
         8   -> vTaskSuspendAll
         8   -> xTaskResumeAll
      24   vPortGetHeapStats
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vTaskSuspendAll
        24   -> xTaskResumeAll
       0   vPortInitialiseBlocks
       0   xPortGetFreeHeapSize
       0   xPortGetMinimumEverFreeHeapSize


   Section sizes:

   Bytes   Function/Label
   -----   --------------
        4  ??DataTable6
        4  ??DataTable6_1
        4  ??DataTable6_2
        4  ??DataTable6_3
        4  ??DataTable6_4
        4  ??DataTable6_5
        4  ??DataTable6_6
        4  ??DataTable6_7
        4  ??DataTable6_8
       94  prvHeapInit
       94  prvInsertBlockIntoFreeList
      284  pvPortMalloc
        4  pxEnd
   32'768  ucHeap
      122  vPortFree
       96  vPortGetHeapStats
        2  vPortInitialiseBlocks
        4  xBlockAllocatedBit
        4  xFreeBytesRemaining
        4  xHeapStructSize
        4  xMinimumEverFreeBytesRemaining
        4  xNumberOfSuccessfulAllocations
        4  xNumberOfSuccessfulFrees
        6  xPortGetFreeHeapSize
        6  xPortGetMinimumEverFreeHeapSize
        8  xStart

 
 32'800 bytes in section .bss
      4 bytes in section .rodata
    740 bytes in section .text
 
    740 bytes of CODE  memory
      4 bytes of CONST memory
 32'800 bytes of DATA  memory

Errors: none
Warnings: none
