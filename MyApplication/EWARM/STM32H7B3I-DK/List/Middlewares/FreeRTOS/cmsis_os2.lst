###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         05/Feb/2022  17:09:41
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS_V2\cmsis_os2.c
#        [UTF-8]
#    Command line      =
#        -f
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS\cmsis_os2.o.rsp
#        (D:\99_Project\GitHub\TouchGFX\MyApplication\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS_V2\cmsis_os2.c
#        -D USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Middlewares\FreeRTOS
#        -lA
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Middlewares\FreeRTOS
#        -o
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Core/Inc\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/App\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS\cmsis_os2.o.d
#    Locale            =  C
#    List file         =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Middlewares\FreeRTOS\cmsis_os2.lst
#    Object file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS\cmsis_os2.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\99_Project\GitHub\TouchGFX\MyApplication\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS_V2\cmsis_os2.c
      1          /* --------------------------------------------------------------------------
      2           * Copyright (c) 2013-2020 Arm Limited. All rights reserved.
      3           *
      4           * SPDX-License-Identifier: Apache-2.0
      5           *
      6           * Licensed under the Apache License, Version 2.0 (the License); you may
      7           * not use this file except in compliance with the License.
      8           * You may obtain a copy of the License at
      9           *
     10           * www.apache.org/licenses/LICENSE-2.0
     11           *
     12           * Unless required by applicable law or agreed to in writing, software
     13           * distributed under the License is distributed on an AS IS BASIS, WITHOUT
     14           * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15           * See the License for the specific language governing permissions and
     16           * limitations under the License.
     17           *
     18           *      Name:    cmsis_os2.c
     19           *      Purpose: CMSIS RTOS2 wrapper for FreeRTOS
     20           *
     21           *---------------------------------------------------------------------------*/
     22          
     23          #include <string.h>
     24          
     25          #include "cmsis_os2.h"                  // ::CMSIS:RTOS2
     26          #include "cmsis_compiler.h"             // Compiler agnostic definitions
     27          
     28          #include "FreeRTOS.h"                   // ARM.FreeRTOS::RTOS:Core
     29          #include "task.h"                       // ARM.FreeRTOS::RTOS:Core
     30          #include "event_groups.h"               // ARM.FreeRTOS::RTOS:Event Groups
     31          #include "semphr.h"                     // ARM.FreeRTOS::RTOS:Core
     32          
     33          #include "freertos_mpool.h"             // osMemoryPool definitions
     34          #include "freertos_os2.h"               // Configuration check and setup

   \                                 In section .text, align 2, keep-with-next
   \   static __vfp void __NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     __NVIC_SetPriority: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   \        0x2   0xB212             SXTH     R2,R2
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD405             BMI.N    ??__NVIC_SetPriority_0
   \        0x8   0x0109             LSLS     R1,R1,#+4
   \        0xA   0x.... 0x....      LDR.W    R2,??DataTable13
   \        0xE   0xB200             SXTH     R0,R0
   \       0x10   0x5411             STRB     R1,[R2, R0]
   \       0x12   0xE008             B.N      ??__NVIC_SetPriority_1
   \                     ??__NVIC_SetPriority_0: (+1)
   \       0x14   0x0109             LSLS     R1,R1,#+4
   \       0x16   0x.... 0x....      LDR.W    R2,??DataTable13_1
   \       0x1A   0xB200             SXTH     R0,R0
   \       0x1C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x20   0x4410             ADD      R0,R2,R0
   \       0x22   0xF800 0x1C04      STRB     R1,[R0, #+4294967292]
   \                     ??__NVIC_SetPriority_1: (+1)
   \       0x26   0x4770             BX       LR
     35          
     36          /*---------------------------------------------------------------------------*/
     37          #ifndef __ARM_ARCH_6M__
     38            #define __ARM_ARCH_6M__         0
     39          #endif
     40          #ifndef __ARM_ARCH_7M__
     41            #define __ARM_ARCH_7M__         0
     42          #endif
     43          #ifndef __ARM_ARCH_7EM__
     44            #define __ARM_ARCH_7EM__        0
     45          #endif
     46          #ifndef __ARM_ARCH_8M_MAIN__
     47            #define __ARM_ARCH_8M_MAIN__    0
     48          #endif
     49          #ifndef __ARM_ARCH_7A__
     50            #define __ARM_ARCH_7A__         0
     51          #endif
     52          
     53          #if   ((__ARM_ARCH_7M__      == 1U) || \
     54                 (__ARM_ARCH_7EM__     == 1U) || \
     55                 (__ARM_ARCH_8M_MAIN__ == 1U))
     56          #define IS_IRQ_MASKED()           ((__get_PRIMASK() != 0U) || (__get_BASEPRI() != 0U))
     57          #elif  (__ARM_ARCH_6M__      == 1U)
     58          #define IS_IRQ_MASKED()           (__get_PRIMASK() != 0U)
     59          #elif (__ARM_ARCH_7A__       == 1U)
     60          /* CPSR mask bits */
     61          #define CPSR_MASKBIT_I            0x80U
     62          
     63          #define IS_IRQ_MASKED()           ((__get_CPSR() & CPSR_MASKBIT_I) != 0U)
     64          #else
     65          #define IS_IRQ_MASKED()           (__get_PRIMASK() != 0U)
     66          #endif
     67          
     68          #if    (__ARM_ARCH_7A__      == 1U)
     69          /* CPSR mode bitmasks */
     70          #define CPSR_MODE_USER            0x10U
     71          #define CPSR_MODE_SYSTEM          0x1FU
     72          
     73          #define IS_IRQ_MODE()             ((__get_mode() != CPSR_MODE_USER) && (__get_mode() != CPSR_MODE_SYSTEM))
     74          #else
     75          #define IS_IRQ_MODE()             (__get_IPSR() != 0U)
     76          #endif
     77          
     78          #define IS_IRQ()                  IS_IRQ_MODE()
     79          
     80          #define SVCall_IRQ_NBR            (IRQn_Type) -5	/* SVCall_IRQ_NBR added as SV_Call handler name is not the same for CM0 and for all other CMx */
     81          
     82          /* Limits */
     83          #define MAX_BITS_TASK_NOTIFY      31U
     84          #define MAX_BITS_EVENT_GROUPS     24U
     85          
     86          #define THREAD_FLAGS_INVALID_BITS (~((1UL << MAX_BITS_TASK_NOTIFY)  - 1U))
     87          #define EVENT_FLAGS_INVALID_BITS  (~((1UL << MAX_BITS_EVENT_GROUPS) - 1U))
     88          
     89          /* Kernel version and identification string definition (major.minor.rev: mmnnnrrrr dec) */
     90          #define KERNEL_VERSION            (((uint32_t)tskKERNEL_VERSION_MAJOR * 10000000UL) | \
     91                                             ((uint32_t)tskKERNEL_VERSION_MINOR *    10000UL) | \
     92                                             ((uint32_t)tskKERNEL_VERSION_BUILD *        1UL))
     93          
     94          #define KERNEL_ID                 ("FreeRTOS " tskKERNEL_VERSION_NUMBER)
     95          
     96          /* Timer callback information structure definition */
     97          typedef struct {
     98            osTimerFunc_t func;
     99            void         *arg;
    100          } TimerCallback_t;
    101          
    102          /* Kernel initialization state */

   \                                 In section .bss, align 4
    103          static osKernelState_t KernelState = osKernelInactive;
   \                     KernelState:
   \        0x0                      DS8 4
    104          
    105          /*
    106            Heap region definition used by heap_5 variant
    107          
    108            Define configAPPLICATION_ALLOCATED_HEAP as nonzero value in FreeRTOSConfig.h if
    109            heap regions are already defined and vPortDefineHeapRegions is called in application.
    110          
    111            Otherwise vPortDefineHeapRegions will be called by osKernelInitialize using
    112            definition configHEAP_5_REGIONS as parameter. Overriding configHEAP_5_REGIONS
    113            is possible by defining it globally or in FreeRTOSConfig.h.
    114          */
    115          #if defined(USE_FreeRTOS_HEAP_5)
    116          #if (configAPPLICATION_ALLOCATED_HEAP == 0)
    117            /*
    118              FreeRTOS heap is not defined by the application.
    119              Single region of size configTOTAL_HEAP_SIZE (defined in FreeRTOSConfig.h)
    120              is provided by default. Define configHEAP_5_REGIONS to provide custom
    121              HeapRegion_t array.
    122            */
    123            #define HEAP_5_REGION_SETUP   1
    124            
    125            #ifndef configHEAP_5_REGIONS
    126              #define configHEAP_5_REGIONS xHeapRegions
    127          
    128              static uint8_t ucHeap[configTOTAL_HEAP_SIZE];
    129          
    130              static HeapRegion_t xHeapRegions[] = {
    131                { ucHeap, configTOTAL_HEAP_SIZE },
    132                { NULL,   0                     }
    133              };
    134            #else
    135              /* Global definition is provided to override default heap array */
    136              extern HeapRegion_t configHEAP_5_REGIONS[];
    137            #endif
    138          #else
    139            /*
    140              The application already defined the array used for the FreeRTOS heap and
    141              called vPortDefineHeapRegions to initialize heap.
    142            */
    143            #define HEAP_5_REGION_SETUP   0
    144          #endif /* configAPPLICATION_ALLOCATED_HEAP */
    145          #endif /* USE_FreeRTOS_HEAP_5 */
    146          
    147          #if defined(SysTick)
    148          #undef SysTick_Handler
    149          
    150          /* CMSIS SysTick interrupt handler prototype */
    151          extern void SysTick_Handler     (void);
    152          /* FreeRTOS tick timer interrupt handler prototype */
    153          extern void xPortSysTickHandler (void);
    154          
    155          /*
    156            SysTick handler implementation that also clears overflow flag.
    157          */
    158          #if (USE_CUSTOM_SYSTICK_HANDLER_IMPLEMENTATION == 0)

   \                                 In section .text, align 2, keep-with-next
    159          void SysTick_Handler (void) {
   \                     SysTick_Handler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    160            /* Clear overflow flag */
    161            SysTick->CTRL;
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \        0x6   0x6800             LDR      R0,[R0, #+0]
    162          
    163            if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
   \        0x8   0x.... 0x....      BL       xTaskGetSchedulerState
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD001             BEQ.N    ??SysTick_Handler_0
    164              /* Call tick handler */
    165              xPortSysTickHandler();
   \       0x10   0x.... 0x....      BL       xPortSysTickHandler
    166            }
    167          }
   \                     ??SysTick_Handler_0: (+1)
   \       0x14   0xBD01             POP      {R0,PC}
    168          #endif
    169          #endif /* SysTick */
    170          
    171          /*
    172            Setup SVC to reset value.
    173          */

   \                                 In section .text, align 2, keep-with-next
    174          __STATIC_INLINE void SVC_Setup (void) {
   \                     SVC_Setup: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    175          #if (__ARM_ARCH_7A__ == 0U)
    176            /* Service Call interrupt might be configured before kernel start     */
    177            /* and when its priority is lower or equal to BASEPRI, svc intruction */
    178            /* causes a Hard Fault.                                               */
    179            NVIC_SetPriority (SVCall_IRQ_NBR, 0U);
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0xF07F 0x0004      MVNS     R0,#+4
   \        0x8   0x.... 0x....      BL       __NVIC_SetPriority
    180          #endif
    181          }
   \        0xC   0xBD01             POP      {R0,PC}
    182          
    183          /*
    184            Function macro used to retrieve semaphore count from ISR
    185          */
    186          #ifndef uxSemaphoreGetCountFromISR
    187          #define uxSemaphoreGetCountFromISR( xSemaphore ) uxQueueMessagesWaitingFromISR( ( QueueHandle_t ) ( xSemaphore ) )
    188          #endif
    189          
    190          /* Get OS Tick count value */
    191          static uint32_t OS_Tick_GetCount (void);
    192          /* Get OS Tick overflow status */
    193          static uint32_t OS_Tick_GetOverflow (void);
    194          /* Get OS Tick interval */
    195          static uint32_t OS_Tick_GetInterval (void);
    196          /*---------------------------------------------------------------------------*/
    197          

   \                                 In section .text, align 2, keep-with-next
    198          osStatus_t osKernelInitialize (void) {
    199            osStatus_t stat;
    200          
    201            if (IS_IRQ()) {
   \                     osKernelInitialize: (+1)
   \        0x0   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD002             BEQ.N    ??osKernelInitialize_0
    202              stat = osErrorISR;
   \        0x8   0xF07F 0x0005      MVNS     R0,#+5
   \        0xC   0xE00A             B.N      ??osKernelInitialize_1
    203            }
    204            else {
    205              if (KernelState == osKernelInactive) {
   \                     ??osKernelInitialize_0: (+1)
   \        0xE   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \       0x12   0x6808             LDR      R0,[R1, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD103             BNE.N    ??osKernelInitialize_2
    206                #if defined(USE_TRACE_EVENT_RECORDER)
    207                  EvrFreeRTOSSetup(0U);
    208                #endif
    209                #if defined(USE_FreeRTOS_HEAP_5) && (HEAP_5_REGION_SETUP == 1)
    210                  vPortDefineHeapRegions (configHEAP_5_REGIONS);
    211                #endif
    212                KernelState = osKernelReady;
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x6008             STR      R0,[R1, #+0]
    213                stat = osOK;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xE001             B.N      ??osKernelInitialize_1
    214              } else {
    215                stat = osError;
   \                     ??osKernelInitialize_2: (+1)
   \       0x20   0xF05F 0x30FF      MOVS     R0,#+4294967295
    216              }
    217            }
    218          
    219            return (stat);
   \                     ??osKernelInitialize_1: (+1)
   \       0x24   0x4770             BX       LR
    220          }
    221          

   \                                 In section .text, align 2, keep-with-next
    222          osStatus_t osKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size) {
   \                     osKernelGetInfo: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x000C             MOVS     R4,R1
    223          
    224            if (version != NULL) {
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD003             BEQ.N    ??osKernelGetInfo_0
    225              /* Version encoding is major.minor.rev: mmnnnrrrr dec */
    226              version->api    = KERNEL_VERSION;
   \        0x8   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \        0xC   0x6001             STR      R1,[R0, #+0]
    227              version->kernel = KERNEL_VERSION;
   \        0xE   0x6041             STR      R1,[R0, #+4]
    228            }
    229          
    230            if ((id_buf != NULL) && (id_size != 0U)) {
   \                     ??osKernelGetInfo_0: (+1)
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD009             BEQ.N    ??osKernelGetInfo_1
   \       0x14   0x2A00             CMP      R2,#+0
   \       0x16   0xD007             BEQ.N    ??osKernelGetInfo_1
    231              if (id_size > sizeof(KERNEL_ID)) {
   \       0x18   0x2A12             CMP      R2,#+18
   \       0x1A   0xD300             BCC.N    ??osKernelGetInfo_2
    232                id_size = sizeof(KERNEL_ID);
   \       0x1C   0x2211             MOVS     R2,#+17
    233              }
    234              memcpy(id_buf, KERNEL_ID, id_size);
   \                     ??osKernelGetInfo_2: (+1)
   \       0x1E   0x.... 0x....      LDR.W    R1,??DataTable13_5
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       __aeabi_memcpy
    235            }
    236          
    237            return (osOK);
   \                     ??osKernelGetInfo_1: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD10             POP      {R4,PC}
    238          }
    239          

   \                                 In section .text, align 2, keep-with-next
    240          osKernelState_t osKernelGetState (void) {
   \                     osKernelGetState: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    241            osKernelState_t state;
    242          
    243            switch (xTaskGetSchedulerState()) {
   \        0x2   0x.... 0x....      BL       xTaskGetSchedulerState
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD003             BEQ.N    ??osKernelGetState_0
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xD103             BNE.N    ??osKernelGetState_1
    244              case taskSCHEDULER_RUNNING:
    245                state = osKernelRunning;
   \                     ??osKernelGetState_2: (+1)
   \        0xE   0x2002             MOVS     R0,#+2
    246                break;
   \       0x10   0xE009             B.N      ??osKernelGetState_3
    247          
    248              case taskSCHEDULER_SUSPENDED:
    249                state = osKernelLocked;
   \                     ??osKernelGetState_0: (+1)
   \       0x12   0x2003             MOVS     R0,#+3
    250                break;
   \       0x14   0xE007             B.N      ??osKernelGetState_3
    251          
    252              case taskSCHEDULER_NOT_STARTED:
    253              default:
    254                if (KernelState == osKernelReady) {
   \                     ??osKernelGetState_1: (+1)
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD101             BNE.N    ??osKernelGetState_4
    255                  state = osKernelReady;
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xE000             B.N      ??osKernelGetState_5
    256                } else {
    257                  state = osKernelInactive;
   \                     ??osKernelGetState_4: (+1)
   \       0x24   0x2000             MOVS     R0,#+0
    258                }
    259                break;
    260            }
    261          
    262            return (state);
   \                     ??osKernelGetState_5: (+1)
   \                     ??osKernelGetState_3: (+1)
   \       0x26   0xBD02             POP      {R1,PC}
    263          }
    264          

   \                                 In section .text, align 2, keep-with-next
    265          osStatus_t osKernelStart (void) {
   \                     osKernelStart: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    266            osStatus_t stat;
    267          
    268            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD002             BEQ.N    ??osKernelStart_0
    269              stat = osErrorISR;
   \        0xA   0xF07F 0x0005      MVNS     R0,#+5
   \        0xE   0xE00E             B.N      ??osKernelStart_1
    270            }
    271            else {
    272              if (KernelState == osKernelReady) {
   \                     ??osKernelStart_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R4,??DataTable13_3
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD107             BNE.N    ??osKernelStart_2
    273                /* Ensure SVC priority is at the reset value */
    274                SVC_Setup();
   \       0x1A   0x.... 0x....      BL       SVC_Setup
    275                /* Change state to enable IRQ masking check */
    276                KernelState = osKernelRunning;
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x6020             STR      R0,[R4, #+0]
    277                /* Start the kernel scheduler */
    278                vTaskStartScheduler();
   \       0x22   0x.... 0x....      BL       vTaskStartScheduler
    279                stat = osOK;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xE001             B.N      ??osKernelStart_1
    280              } else {
    281                stat = osError;
   \                     ??osKernelStart_2: (+1)
   \       0x2A   0xF05F 0x30FF      MOVS     R0,#+4294967295
    282              }
    283            }
    284          
    285            return (stat);
   \                     ??osKernelStart_1: (+1)
   \       0x2E   0xBD10             POP      {R4,PC}
    286          }
    287          

   \                                 In section .text, align 2, keep-with-next
    288          int32_t osKernelLock (void) {
   \                     osKernelLock: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    289            int32_t lock;
    290          
    291            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD002             BEQ.N    ??osKernelLock_0
    292              lock = (int32_t)osErrorISR;
   \        0xA   0xF07F 0x0005      MVNS     R0,#+5
   \        0xE   0xE00E             B.N      ??osKernelLock_1
    293            }
    294            else {
    295              switch (xTaskGetSchedulerState()) {
   \                     ??osKernelLock_0: (+1)
   \       0x10   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD002             BEQ.N    ??osKernelLock_2
   \       0x18   0x2802             CMP      R0,#+2
   \       0x1A   0xD002             BEQ.N    ??osKernelLock_3
   \       0x1C   0xE005             B.N      ??osKernelLock_4
    296                case taskSCHEDULER_SUSPENDED:
    297                  lock = 1;
   \                     ??osKernelLock_2: (+1)
   \       0x1E   0x2001             MOVS     R0,#+1
    298                  break;
   \       0x20   0xE005             B.N      ??osKernelLock_1
    299          
    300                case taskSCHEDULER_RUNNING:
    301                  vTaskSuspendAll();
   \                     ??osKernelLock_3: (+1)
   \       0x22   0x.... 0x....      BL       vTaskSuspendAll
    302                  lock = 0;
   \       0x26   0x2000             MOVS     R0,#+0
    303                  break;
   \       0x28   0xE001             B.N      ??osKernelLock_1
    304          
    305                case taskSCHEDULER_NOT_STARTED:
    306                default:
    307                  lock = (int32_t)osError;
   \                     ??osKernelLock_4: (+1)
   \       0x2A   0xF05F 0x30FF      MOVS     R0,#+4294967295
    308                  break;
    309              }
    310            }
    311          
    312            return (lock);
   \                     ??osKernelLock_1: (+1)
   \       0x2E   0xBD02             POP      {R1,PC}
    313          }
    314          

   \                                 In section .text, align 2, keep-with-next
    315          int32_t osKernelUnlock (void) {
   \                     osKernelUnlock: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    316            int32_t lock;
    317          
    318            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD002             BEQ.N    ??osKernelUnlock_0
    319              lock = (int32_t)osErrorISR;
   \        0xA   0xF07F 0x0405      MVNS     R4,#+5
   \        0xE   0xE016             B.N      ??osKernelUnlock_1
    320            }
    321            else {
    322              switch (xTaskGetSchedulerState()) {
   \                     ??osKernelUnlock_0: (+1)
   \       0x10   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD002             BEQ.N    ??osKernelUnlock_2
   \       0x18   0x2802             CMP      R0,#+2
   \       0x1A   0xD00C             BEQ.N    ??osKernelUnlock_3
   \       0x1C   0xE00D             B.N      ??osKernelUnlock_4
    323                case taskSCHEDULER_SUSPENDED:
    324                  lock = 1;
   \                     ??osKernelUnlock_2: (+1)
   \       0x1E   0x2401             MOVS     R4,#+1
    325          
    326                  if (xTaskResumeAll() != pdTRUE) {
   \       0x20   0x.... 0x....      BL       xTaskResumeAll
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xD005             BEQ.N    ??osKernelUnlock_5
    327                    if (xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) {
   \       0x28   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD101             BNE.N    ??osKernelUnlock_5
    328                      lock = (int32_t)osError;
   \       0x30   0xF05F 0x34FF      MOVS     R4,#+4294967295
    329                    }
    330                  }
    331                  break;
   \                     ??osKernelUnlock_5: (+1)
   \       0x34   0xE003             B.N      ??osKernelUnlock_1
    332          
    333                case taskSCHEDULER_RUNNING:
    334                  lock = 0;
   \                     ??osKernelUnlock_3: (+1)
   \       0x36   0x2400             MOVS     R4,#+0
    335                  break;
   \       0x38   0xE001             B.N      ??osKernelUnlock_1
    336          
    337                case taskSCHEDULER_NOT_STARTED:
    338                default:
    339                  lock = (int32_t)osError;
   \                     ??osKernelUnlock_4: (+1)
   \       0x3A   0xF05F 0x34FF      MOVS     R4,#+4294967295
    340                  break;
    341              }
    342            }
    343          
    344            return (lock);
   \                     ??osKernelUnlock_1: (+1)
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0xBD10             POP      {R4,PC}
    345          }
    346          

   \                                 In section .text, align 2, keep-with-next
    347          int32_t osKernelRestoreLock (int32_t lock) {
   \                     osKernelRestoreLock: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    348          
    349            if (IS_IRQ()) {
   \        0x4   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??osKernelRestoreLock_0
    350              lock = (int32_t)osErrorISR;
   \        0xC   0xF07F 0x0405      MVNS     R4,#+5
   \       0x10   0xE01C             B.N      ??osKernelRestoreLock_1
    351            }
    352            else {
    353              switch (xTaskGetSchedulerState()) {
   \                     ??osKernelRestoreLock_0: (+1)
   \       0x12   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ.N    ??osKernelRestoreLock_2
   \       0x1A   0x2802             CMP      R0,#+2
   \       0x1C   0xD114             BNE.N    ??osKernelRestoreLock_3
    354                case taskSCHEDULER_SUSPENDED:
    355                case taskSCHEDULER_RUNNING:
    356                  if (lock == 1) {
   \                     ??osKernelRestoreLock_2: (+1)
   \       0x1E   0x2C01             CMP      R4,#+1
   \       0x20   0xD102             BNE.N    ??osKernelRestoreLock_4
    357                    vTaskSuspendAll();
   \       0x22   0x.... 0x....      BL       vTaskSuspendAll
   \       0x26   0xE00E             B.N      ??osKernelRestoreLock_5
    358                  }
    359                  else {
    360                    if (lock != 0) {
   \                     ??osKernelRestoreLock_4: (+1)
   \       0x28   0x2C00             CMP      R4,#+0
   \       0x2A   0xD002             BEQ.N    ??osKernelRestoreLock_6
    361                      lock = (int32_t)osError;
   \       0x2C   0xF05F 0x34FF      MOVS     R4,#+4294967295
   \       0x30   0xE009             B.N      ??osKernelRestoreLock_5
    362                    }
    363                    else {
    364                      if (xTaskResumeAll() != pdTRUE) {
   \                     ??osKernelRestoreLock_6: (+1)
   \       0x32   0x.... 0x....      BL       xTaskResumeAll
   \       0x36   0x2801             CMP      R0,#+1
   \       0x38   0xD005             BEQ.N    ??osKernelRestoreLock_5
    365                        if (xTaskGetSchedulerState() != taskSCHEDULER_RUNNING) {
   \       0x3A   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x3E   0x2802             CMP      R0,#+2
   \       0x40   0xD001             BEQ.N    ??osKernelRestoreLock_5
    366                          lock = (int32_t)osError;
   \       0x42   0xF05F 0x34FF      MOVS     R4,#+4294967295
    367                        }
    368                      }
    369                    }
    370                  }
    371                  break;
   \                     ??osKernelRestoreLock_5: (+1)
   \       0x46   0xE001             B.N      ??osKernelRestoreLock_1
    372          
    373                case taskSCHEDULER_NOT_STARTED:
    374                default:
    375                  lock = (int32_t)osError;
   \                     ??osKernelRestoreLock_3: (+1)
   \       0x48   0xF05F 0x34FF      MOVS     R4,#+4294967295
    376                  break;
    377              }
    378            }
    379          
    380            return (lock);
   \                     ??osKernelRestoreLock_1: (+1)
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0xBD10             POP      {R4,PC}
    381          }
    382          

   \                                 In section .text, align 2, keep-with-next
    383          uint32_t osKernelGetTickCount (void) {
   \                     osKernelGetTickCount: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    384            TickType_t ticks;
    385          
    386            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD002             BEQ.N    ??osKernelGetTickCount_0
    387              ticks = xTaskGetTickCountFromISR();
   \        0xA   0x.... 0x....      BL       xTaskGetTickCountFromISR
   \        0xE   0xE001             B.N      ??osKernelGetTickCount_1
    388            } else {
    389              ticks = xTaskGetTickCount();
   \                     ??osKernelGetTickCount_0: (+1)
   \       0x10   0x.... 0x....      BL       xTaskGetTickCount
    390            }
    391          
    392            return (ticks);
   \                     ??osKernelGetTickCount_1: (+1)
   \       0x14   0xBD02             POP      {R1,PC}
    393          }
    394          

   \                                 In section .text, align 2, keep-with-next
    395          uint32_t osKernelGetTickFreq (void) {
    396            return (configTICK_RATE_HZ);
   \                     osKernelGetTickFreq: (+1)
   \        0x0   0xF44F 0x707A      MOV      R0,#+1000
   \        0x4   0x4770             BX       LR
    397          }
    398          
    399          /* Get OS Tick count value */

   \                                 In section .text, align 2, keep-with-next
    400          static uint32_t OS_Tick_GetCount (void) {
    401            uint32_t load = SysTick->LOAD;
   \                     OS_Tick_GetCount: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable13_6
   \        0x4   0x6800             LDR      R0,[R0, #+0]
    402            return  (load - SysTick->VAL);
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable13_7
   \        0xA   0x6809             LDR      R1,[R1, #+0]
   \        0xC   0x1A40             SUBS     R0,R0,R1
   \        0xE   0x4770             BX       LR
    403          }
    404          
    405          /* Get OS Tick overflow status */

   \                                 In section .text, align 2, keep-with-next
    406          static uint32_t OS_Tick_GetOverflow (void) {
    407            return ((SysTick->CTRL >> 16) & 1U);
   \                     OS_Tick_GetOverflow: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0xF3C0 0x4000      UBFX     R0,R0,#+16,#+1
   \        0xA   0x4770             BX       LR
    408          }
    409          
    410          /* Get OS Tick interval */

   \                                 In section .text, align 2, keep-with-next
    411          static uint32_t OS_Tick_GetInterval (void) {
    412            return (SysTick->LOAD + 1U);
   \                     OS_Tick_GetInterval: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable13_6
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x1C40             ADDS     R0,R0,#+1
   \        0x8   0x4770             BX       LR
    413          }
    414          

   \                                 In section .text, align 2, keep-with-next
    415          uint32_t osKernelGetSysTimerCount (void) {
   \                     osKernelGetSysTimerCount: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    416            uint32_t irqmask = IS_IRQ_MASKED();
   \        0x2   0xF3EF 0x8010      MRS      R0,PRIMASK
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD103             BNE.N    ??osKernelGetSysTimerCount_0
   \        0xA   0xF3EF 0x8011      MRS      R0,BASEPRI
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD001             BEQ.N    ??osKernelGetSysTimerCount_1
   \                     ??osKernelGetSysTimerCount_0: (+1)
   \       0x12   0x2401             MOVS     R4,#+1
   \       0x14   0xE000             B.N      ??osKernelGetSysTimerCount_2
   \                     ??osKernelGetSysTimerCount_1: (+1)
   \       0x16   0x2400             MOVS     R4,#+0
   \                     ??osKernelGetSysTimerCount_2: (+1)
   \       0x18   0xB2E4             UXTB     R4,R4
    417            TickType_t ticks;
    418            uint32_t val;
    419          
    420            __disable_irq();
   \       0x1A   0xB672             CPSID    I
    421          
    422            ticks = xTaskGetTickCount();
   \       0x1C   0x.... 0x....      BL       xTaskGetTickCount
   \       0x20   0x0005             MOVS     R5,R0
    423            val   = OS_Tick_GetCount();
   \       0x22   0x.... 0x....      BL       OS_Tick_GetCount
   \       0x26   0x0006             MOVS     R6,R0
    424          
    425            if (OS_Tick_GetOverflow() != 0U) {
   \       0x28   0x.... 0x....      BL       OS_Tick_GetOverflow
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD003             BEQ.N    ??osKernelGetSysTimerCount_3
    426              val = OS_Tick_GetCount();
   \       0x30   0x.... 0x....      BL       OS_Tick_GetCount
   \       0x34   0x0006             MOVS     R6,R0
    427              ticks++;
   \       0x36   0x1C6D             ADDS     R5,R5,#+1
    428            }
    429            val += ticks * OS_Tick_GetInterval();
   \                     ??osKernelGetSysTimerCount_3: (+1)
   \       0x38   0x.... 0x....      BL       OS_Tick_GetInterval
   \       0x3C   0xFB00 0x6505      MLA      R5,R0,R5,R6
    430          
    431            if (irqmask == 0U) {
   \       0x40   0x2C00             CMP      R4,#+0
   \       0x42   0xD100             BNE.N    ??osKernelGetSysTimerCount_4
    432              __enable_irq();
   \       0x44   0xB662             CPSIE    I
    433            }
    434          
    435            return (val);
   \                     ??osKernelGetSysTimerCount_4: (+1)
   \       0x46   0x0028             MOVS     R0,R5
   \       0x48   0xBD70             POP      {R4-R6,PC}
    436          }
    437          

   \                                 In section .text, align 2, keep-with-next
    438          uint32_t osKernelGetSysTimerFreq (void) {
    439            return (configCPU_CLOCK_HZ);
   \                     osKernelGetSysTimerFreq: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable14
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x4770             BX       LR
    440          }
    441          
    442          /*---------------------------------------------------------------------------*/
    443          

   \                                 In section .text, align 2, keep-with-next
    444          osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
   \                     osThreadNew: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
    445            const char *name;
    446            uint32_t stack;
    447            TaskHandle_t hTask;
    448            UBaseType_t prio;
    449            int32_t mem;
    450          
    451            hTask = NULL;
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x9303             STR      R3,[SP, #+12]
    452          
    453            if (!IS_IRQ() && (func != NULL)) {
   \        0x8   0xF3EF 0x8305      MRS      R3,IPSR
   \        0xC   0x2B00             CMP      R3,#+0
   \        0xE   0xD156             BNE.N    ??osThreadNew_0
   \       0x10   0x0003             MOVS     R3,R0
   \       0x12   0x2B00             CMP      R3,#+0
   \       0x14   0xD053             BEQ.N    ??osThreadNew_0
    454              stack = configMINIMAL_STACK_SIZE;
   \       0x16   0x2580             MOVS     R5,#+128
    455              prio  = (UBaseType_t)osPriorityNormal;
   \       0x18   0x2318             MOVS     R3,#+24
    456          
    457              name = NULL;
   \       0x1A   0x2400             MOVS     R4,#+0
    458              mem  = -1;
   \       0x1C   0xF05F 0x36FF      MOVS     R6,#+4294967295
    459          
    460              if (attr != NULL) {
   \       0x20   0x2A00             CMP      R2,#+0
   \       0x22   0xD02E             BEQ.N    ??osThreadNew_1
    461                if (attr->name != NULL) {
   \       0x24   0x6817             LDR      R7,[R2, #+0]
   \       0x26   0x2F00             CMP      R7,#+0
   \       0x28   0xD000             BEQ.N    ??osThreadNew_2
    462                  name = attr->name;
   \       0x2A   0x6814             LDR      R4,[R2, #+0]
    463                }
    464                if (attr->priority != osPriorityNone) {
   \                     ??osThreadNew_2: (+1)
   \       0x2C   0x6997             LDR      R7,[R2, #+24]
   \       0x2E   0x2F00             CMP      R7,#+0
   \       0x30   0xD000             BEQ.N    ??osThreadNew_3
    465                  prio = (UBaseType_t)attr->priority;
   \       0x32   0x6993             LDR      R3,[R2, #+24]
    466                }
    467          
    468                if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
   \                     ??osThreadNew_3: (+1)
   \       0x34   0x2B00             CMP      R3,#+0
   \       0x36   0xD004             BEQ.N    ??osThreadNew_4
   \       0x38   0x2B39             CMP      R3,#+57
   \       0x3A   0xD202             BCS.N    ??osThreadNew_4
   \       0x3C   0x7917             LDRB     R7,[R2, #+4]
   \       0x3E   0x07FF             LSLS     R7,R7,#+31
   \       0x40   0xD501             BPL.N    ??osThreadNew_5
    469                  return (NULL);
   \                     ??osThreadNew_4: (+1)
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xE03C             B.N      ??osThreadNew_6
    470                }
    471          
    472                if (attr->stack_size > 0U) {
   \                     ??osThreadNew_5: (+1)
   \       0x46   0x6957             LDR      R7,[R2, #+20]
   \       0x48   0x2F00             CMP      R7,#+0
   \       0x4A   0xD001             BEQ.N    ??osThreadNew_7
    473                  /* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */
    474                  /* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */
    475                  stack = attr->stack_size / sizeof(StackType_t);
   \       0x4C   0x6955             LDR      R5,[R2, #+20]
   \       0x4E   0x08AD             LSRS     R5,R5,#+2
    476                }
    477          
    478                if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
    479                    (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
   \                     ??osThreadNew_7: (+1)
   \       0x50   0x6897             LDR      R7,[R2, #+8]
   \       0x52   0x2F00             CMP      R7,#+0
   \       0x54   0xD00A             BEQ.N    ??osThreadNew_8
   \       0x56   0x68D7             LDR      R7,[R2, #+12]
   \       0x58   0x2F5C             CMP      R7,#+92
   \       0x5A   0xD307             BCC.N    ??osThreadNew_8
   \       0x5C   0x6917             LDR      R7,[R2, #+16]
   \       0x5E   0x2F00             CMP      R7,#+0
   \       0x60   0xD004             BEQ.N    ??osThreadNew_8
   \       0x62   0x6957             LDR      R7,[R2, #+20]
   \       0x64   0x2F00             CMP      R7,#+0
   \       0x66   0xD001             BEQ.N    ??osThreadNew_8
    480                  mem = 1;
   \       0x68   0x2601             MOVS     R6,#+1
   \       0x6A   0xE00B             B.N      ??osThreadNew_9
    481                }
    482                else {
    483                  if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
   \                     ??osThreadNew_8: (+1)
   \       0x6C   0x6897             LDR      R7,[R2, #+8]
   \       0x6E   0x2F00             CMP      R7,#+0
   \       0x70   0xD108             BNE.N    ??osThreadNew_9
   \       0x72   0x68D7             LDR      R7,[R2, #+12]
   \       0x74   0x2F00             CMP      R7,#+0
   \       0x76   0xD105             BNE.N    ??osThreadNew_9
   \       0x78   0x6917             LDR      R7,[R2, #+16]
   \       0x7A   0x2F00             CMP      R7,#+0
   \       0x7C   0xD102             BNE.N    ??osThreadNew_9
    484                    mem = 0;
   \       0x7E   0x2600             MOVS     R6,#+0
   \       0x80   0xE000             B.N      ??osThreadNew_9
    485                  }
    486                }
    487              }
    488              else {
    489                mem = 0;
   \                     ??osThreadNew_1: (+1)
   \       0x82   0x2600             MOVS     R6,#+0
    490              }
    491          
    492              if (mem == 1) {
   \                     ??osThreadNew_9: (+1)
   \       0x84   0x2E01             CMP      R6,#+1
   \       0x86   0xD10B             BNE.N    ??osThreadNew_10
    493                #if (configSUPPORT_STATIC_ALLOCATION == 1)
    494                  hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
    495                                                                                                (StaticTask_t *)attr->cb_mem);
   \       0x88   0x6896             LDR      R6,[R2, #+8]
   \       0x8A   0x9602             STR      R6,[SP, #+8]
   \       0x8C   0x6912             LDR      R2,[R2, #+16]
   \       0x8E   0x9201             STR      R2,[SP, #+4]
   \       0x90   0x9300             STR      R3,[SP, #+0]
   \       0x92   0x000B             MOVS     R3,R1
   \       0x94   0x002A             MOVS     R2,R5
   \       0x96   0x0021             MOVS     R1,R4
   \       0x98   0x.... 0x....      BL       xTaskCreateStatic
   \       0x9C   0x9003             STR      R0,[SP, #+12]
   \       0x9E   0xE00E             B.N      ??osThreadNew_0
    496                #endif
    497              }
    498              else {
    499                if (mem == 0) {
   \                     ??osThreadNew_10: (+1)
   \       0xA0   0x2E00             CMP      R6,#+0
   \       0xA2   0xD10C             BNE.N    ??osThreadNew_0
    500                  #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
    501                    if (xTaskCreate ((TaskFunction_t)func, name, (uint16_t)stack, argument, prio, &hTask) != pdPASS) {
   \       0xA4   0xAA03             ADD      R2,SP,#+12
   \       0xA6   0x9201             STR      R2,[SP, #+4]
   \       0xA8   0x9300             STR      R3,[SP, #+0]
   \       0xAA   0x000B             MOVS     R3,R1
   \       0xAC   0x002A             MOVS     R2,R5
   \       0xAE   0xB292             UXTH     R2,R2
   \       0xB0   0x0021             MOVS     R1,R4
   \       0xB2   0x.... 0x....      BL       xTaskCreate
   \       0xB6   0x2801             CMP      R0,#+1
   \       0xB8   0xD001             BEQ.N    ??osThreadNew_0
    502                      hTask = NULL;
   \       0xBA   0x2000             MOVS     R0,#+0
   \       0xBC   0x9003             STR      R0,[SP, #+12]
    503                    }
    504                  #endif
    505                }
    506              }
    507            }
    508          
    509            return ((osThreadId_t)hTask);
   \                     ??osThreadNew_0: (+1)
   \       0xBE   0x9803             LDR      R0,[SP, #+12]
   \                     ??osThreadNew_6: (+1)
   \       0xC0   0xB005             ADD      SP,SP,#+20
   \       0xC2   0xBDF0             POP      {R4-R7,PC}
    510          }
    511          

   \                                 In section .text, align 2, keep-with-next
    512          const char *osThreadGetName (osThreadId_t thread_id) {
   \                     osThreadGetName: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    513            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    514            const char *name;
    515          
    516            if (IS_IRQ() || (hTask == NULL)) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD101             BNE.N    ??osThreadGetName_0
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD101             BNE.N    ??osThreadGetName_1
    517              name = NULL;
   \                     ??osThreadGetName_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE001             B.N      ??osThreadGetName_2
    518            } else {
    519              name = pcTaskGetName (hTask);
   \                     ??osThreadGetName_1: (+1)
   \       0x12   0x.... 0x....      BL       pcTaskGetName
    520            }
    521          
    522            return (name);
   \                     ??osThreadGetName_2: (+1)
   \       0x16   0xBD02             POP      {R1,PC}
    523          }
    524          

   \                                 In section .text, align 2, keep-with-next
    525          osThreadId_t osThreadGetId (void) {
   \                     osThreadGetId: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    526            osThreadId_t id;
    527          
    528            id = (osThreadId_t)xTaskGetCurrentTaskHandle();
   \        0x2   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
    529          
    530            return (id);
   \        0x6   0xBD02             POP      {R1,PC}
    531          }
    532          

   \                                 In section .text, align 2, keep-with-next
    533          osThreadState_t osThreadGetState (osThreadId_t thread_id) {
   \                     osThreadGetState: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    534            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    535            osThreadState_t state;
    536          
    537            if (IS_IRQ() || (hTask == NULL)) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD101             BNE.N    ??osThreadGetState_0
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD102             BNE.N    ??osThreadGetState_1
    538              state = osThreadError;
   \                     ??osThreadGetState_0: (+1)
   \        0xE   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x12   0xE014             B.N      ??osThreadGetState_2
    539            }
    540            else {
    541              switch (eTaskGetState (hTask)) {
   \                     ??osThreadGetState_1: (+1)
   \       0x14   0x.... 0x....      BL       eTaskGetState
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD006             BEQ.N    ??osThreadGetState_3
   \       0x1C   0x2802             CMP      R0,#+2
   \       0x1E   0xD008             BEQ.N    ??osThreadGetState_4
   \       0x20   0xD305             BCC.N    ??osThreadGetState_5
   \       0x22   0x2804             CMP      R0,#+4
   \       0x24   0xD007             BEQ.N    ??osThreadGetState_6
   \       0x26   0xD304             BCC.N    ??osThreadGetState_4
   \       0x28   0xE007             B.N      ??osThreadGetState_7
    542                case eRunning:   state = osThreadRunning;    break;
   \                     ??osThreadGetState_3: (+1)
   \       0x2A   0x2002             MOVS     R0,#+2
   \       0x2C   0xE007             B.N      ??osThreadGetState_2
    543                case eReady:     state = osThreadReady;      break;
   \                     ??osThreadGetState_5: (+1)
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xE005             B.N      ??osThreadGetState_2
    544                case eBlocked:
    545                case eSuspended: state = osThreadBlocked;    break;
   \                     ??osThreadGetState_4: (+1)
   \       0x32   0x2003             MOVS     R0,#+3
   \       0x34   0xE003             B.N      ??osThreadGetState_2
    546                case eDeleted:   state = osThreadTerminated; break;
   \                     ??osThreadGetState_6: (+1)
   \       0x36   0x2004             MOVS     R0,#+4
   \       0x38   0xE001             B.N      ??osThreadGetState_2
    547                case eInvalid:
    548                default:         state = osThreadError;      break;
   \                     ??osThreadGetState_7: (+1)
   \       0x3A   0xF05F 0x30FF      MOVS     R0,#+4294967295
    549              }
    550            }
    551          
    552            return (state);
   \                     ??osThreadGetState_2: (+1)
   \       0x3E   0xBD02             POP      {R1,PC}
    553          }
    554          

   \                                 In section .text, align 2, keep-with-next
    555          uint32_t osThreadGetStackSpace (osThreadId_t thread_id) {
   \                     osThreadGetStackSpace: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    556            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    557            uint32_t sz;
    558          
    559            if (IS_IRQ() || (hTask == NULL)) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD101             BNE.N    ??osThreadGetStackSpace_0
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD101             BNE.N    ??osThreadGetStackSpace_1
    560              sz = 0U;
   \                     ??osThreadGetStackSpace_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE002             B.N      ??osThreadGetStackSpace_2
    561            } else {
    562              sz = (uint32_t)(uxTaskGetStackHighWaterMark(hTask) * sizeof(StackType_t));
   \                     ??osThreadGetStackSpace_1: (+1)
   \       0x12   0x.... 0x....      BL       uxTaskGetStackHighWaterMark
   \       0x16   0x0080             LSLS     R0,R0,#+2
    563            }
    564          
    565            return (sz);
   \                     ??osThreadGetStackSpace_2: (+1)
   \       0x18   0xBD02             POP      {R1,PC}
    566          }
    567          

   \                                 In section .text, align 2, keep-with-next
    568          osStatus_t osThreadSetPriority (osThreadId_t thread_id, osPriority_t priority) {
   \                     osThreadSetPriority: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    569            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    570            osStatus_t stat;
    571          
    572            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8205      MRS      R2,IPSR
   \        0x6   0x2A00             CMP      R2,#+0
   \        0x8   0xD002             BEQ.N    ??osThreadSetPriority_0
    573              stat = osErrorISR;
   \        0xA   0xF07F 0x0405      MVNS     R4,#+5
   \        0xE   0xE00A             B.N      ??osThreadSetPriority_1
    574            }
    575            else if ((hTask == NULL) || (priority < osPriorityIdle) || (priority > osPriorityISR)) {
   \                     ??osThreadSetPriority_0: (+1)
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD002             BEQ.N    ??osThreadSetPriority_2
   \       0x14   0x1E4A             SUBS     R2,R1,#+1
   \       0x16   0x2A38             CMP      R2,#+56
   \       0x18   0xD302             BCC.N    ??osThreadSetPriority_3
    576              stat = osErrorParameter;
   \                     ??osThreadSetPriority_2: (+1)
   \       0x1A   0xF07F 0x0403      MVNS     R4,#+3
   \       0x1E   0xE002             B.N      ??osThreadSetPriority_1
    577            }
    578            else {
    579              stat = osOK;
   \                     ??osThreadSetPriority_3: (+1)
   \       0x20   0x2400             MOVS     R4,#+0
    580              vTaskPrioritySet (hTask, (UBaseType_t)priority);
   \       0x22   0x.... 0x....      BL       vTaskPrioritySet
    581            }
    582          
    583            return (stat);
   \                     ??osThreadSetPriority_1: (+1)
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0xBD10             POP      {R4,PC}
    584          }
    585          

   \                                 In section .text, align 2, keep-with-next
    586          osPriority_t osThreadGetPriority (osThreadId_t thread_id) {
   \                     osThreadGetPriority: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    587            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    588            osPriority_t prio;
    589          
    590            if (IS_IRQ() || (hTask == NULL)) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD101             BNE.N    ??osThreadGetPriority_0
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD102             BNE.N    ??osThreadGetPriority_1
    591              prio = osPriorityError;
   \                     ??osThreadGetPriority_0: (+1)
   \        0xE   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x12   0xE001             B.N      ??osThreadGetPriority_2
    592            } else {
    593              prio = (osPriority_t)((int32_t)uxTaskPriorityGet (hTask));
   \                     ??osThreadGetPriority_1: (+1)
   \       0x14   0x.... 0x....      BL       uxTaskPriorityGet
    594            }
    595          
    596            return (prio);
   \                     ??osThreadGetPriority_2: (+1)
   \       0x18   0xBD02             POP      {R1,PC}
    597          }
    598          

   \                                 In section .text, align 2, keep-with-next
    599          osStatus_t osThreadYield (void) {
    600            osStatus_t stat;
    601          
    602            if (IS_IRQ()) {
   \                     osThreadYield: (+1)
   \        0x0   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD002             BEQ.N    ??osThreadYield_0
    603              stat = osErrorISR;
   \        0x8   0xF07F 0x0005      MVNS     R0,#+5
   \        0xC   0xE009             B.N      ??osThreadYield_1
    604            } else {
    605              stat = osOK;
   \                     ??osThreadYield_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
    606              taskYIELD();
   \       0x10   0xF05F 0x5180      MOVS     R1,#+268435456
   \       0x14   0x.... 0x....      LDR.W    R2,??DataTable16
   \       0x18   0x6011             STR      R1,[R2, #+0]
   \       0x1A   0xF3BF 0x8F4F      DSB      SY
   \       0x1E   0xF3BF 0x8F6F      ISB      SY
    607            }
    608          
    609            return (stat);
   \                     ??osThreadYield_1: (+1)
   \       0x22   0x4770             BX       LR
    610          }
    611          
    612          #if (configUSE_OS2_THREAD_SUSPEND_RESUME == 1)

   \                                 In section .text, align 2, keep-with-next
    613          osStatus_t osThreadSuspend (osThreadId_t thread_id) {
   \                     osThreadSuspend: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    614            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    615            osStatus_t stat;
    616          
    617            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD002             BEQ.N    ??osThreadSuspend_0
    618              stat = osErrorISR;
   \        0xA   0xF07F 0x0405      MVNS     R4,#+5
   \        0xE   0xE007             B.N      ??osThreadSuspend_1
    619            }
    620            else if (hTask == NULL) {
   \                     ??osThreadSuspend_0: (+1)
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD102             BNE.N    ??osThreadSuspend_2
    621              stat = osErrorParameter;
   \       0x14   0xF07F 0x0403      MVNS     R4,#+3
   \       0x18   0xE002             B.N      ??osThreadSuspend_1
    622            }
    623            else {
    624              stat = osOK;
   \                     ??osThreadSuspend_2: (+1)
   \       0x1A   0x2400             MOVS     R4,#+0
    625              vTaskSuspend (hTask);
   \       0x1C   0x.... 0x....      BL       vTaskSuspend
    626            }
    627          
    628            return (stat);
   \                     ??osThreadSuspend_1: (+1)
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0xBD10             POP      {R4,PC}
    629          }
    630          

   \                                 In section .text, align 2, keep-with-next
    631          osStatus_t osThreadResume (osThreadId_t thread_id) {
   \                     osThreadResume: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    632            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    633            osStatus_t stat;
    634          
    635            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD002             BEQ.N    ??osThreadResume_0
    636              stat = osErrorISR;
   \        0xA   0xF07F 0x0405      MVNS     R4,#+5
   \        0xE   0xE007             B.N      ??osThreadResume_1
    637            }
    638            else if (hTask == NULL) {
   \                     ??osThreadResume_0: (+1)
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD102             BNE.N    ??osThreadResume_2
    639              stat = osErrorParameter;
   \       0x14   0xF07F 0x0403      MVNS     R4,#+3
   \       0x18   0xE002             B.N      ??osThreadResume_1
    640            }
    641            else {
    642              stat = osOK;
   \                     ??osThreadResume_2: (+1)
   \       0x1A   0x2400             MOVS     R4,#+0
    643              vTaskResume (hTask);
   \       0x1C   0x.... 0x....      BL       vTaskResume
    644            }
    645          
    646            return (stat);
   \                     ??osThreadResume_1: (+1)
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0xBD10             POP      {R4,PC}
    647          }
    648          #endif /* (configUSE_OS2_THREAD_SUSPEND_RESUME == 1) */
    649          

   \                                 In section .text, align 2, keep-with-next
    650          __NO_RETURN void osThreadExit (void) {
   \                     osThreadExit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    651          #ifndef USE_FreeRTOS_HEAP_1
    652            vTaskDelete (NULL);
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x.... 0x....      BL       vTaskDelete
    653          #endif
    654            for (;;);
   \                     ??osThreadExit_0: (+1)
   \        0x8   0xE7FE             B.N      ??osThreadExit_0
    655          }
    656          

   \                                 In section .text, align 2, keep-with-next
    657          osStatus_t osThreadTerminate (osThreadId_t thread_id) {
   \                     osThreadTerminate: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    658            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    659            osStatus_t stat;
    660          #ifndef USE_FreeRTOS_HEAP_1
    661            eTaskState tstate;
    662          
    663            if (IS_IRQ()) {
   \        0x4   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??osThreadTerminate_0
    664              stat = osErrorISR;
   \        0xC   0xF07F 0x0505      MVNS     R5,#+5
   \       0x10   0xE011             B.N      ??osThreadTerminate_1
    665            }
    666            else if (hTask == NULL) {
   \                     ??osThreadTerminate_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD102             BNE.N    ??osThreadTerminate_2
    667              stat = osErrorParameter;
   \       0x16   0xF07F 0x0503      MVNS     R5,#+3
   \       0x1A   0xE00C             B.N      ??osThreadTerminate_1
    668            }
    669            else {
    670              tstate = eTaskGetState (hTask);
   \                     ??osThreadTerminate_2: (+1)
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       eTaskGetState
    671          
    672              if (tstate != eDeleted) {
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x2804             CMP      R0,#+4
   \       0x26   0xD004             BEQ.N    ??osThreadTerminate_3
    673                stat = osOK;
   \       0x28   0x2500             MOVS     R5,#+0
    674                vTaskDelete (hTask);
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0x.... 0x....      BL       vTaskDelete
   \       0x30   0xE001             B.N      ??osThreadTerminate_1
    675              } else {
    676                stat = osErrorResource;
   \                     ??osThreadTerminate_3: (+1)
   \       0x32   0xF07F 0x0502      MVNS     R5,#+2
    677              }
    678            }
    679          #else
    680            stat = osError;
    681          #endif
    682          
    683            return (stat);
   \                     ??osThreadTerminate_1: (+1)
   \       0x36   0x0028             MOVS     R0,R5
   \       0x38   0xBD32             POP      {R1,R4,R5,PC}
    684          }
    685          

   \                                 In section .text, align 2, keep-with-next
    686          uint32_t osThreadGetCount (void) {
   \                     osThreadGetCount: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    687            uint32_t count;
    688          
    689            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD001             BEQ.N    ??osThreadGetCount_0
    690              count = 0U;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE001             B.N      ??osThreadGetCount_1
    691            } else {
    692              count = uxTaskGetNumberOfTasks();
   \                     ??osThreadGetCount_0: (+1)
   \        0xE   0x.... 0x....      BL       uxTaskGetNumberOfTasks
    693            }
    694          
    695            return (count);
   \                     ??osThreadGetCount_1: (+1)
   \       0x12   0xBD02             POP      {R1,PC}
    696          }
    697          
    698          #if (configUSE_OS2_THREAD_ENUMERATE == 1)

   \                                 In section .text, align 2, keep-with-next
    699          uint32_t osThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items) {
   \                     osThreadEnumerate: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
    700            uint32_t i, count;
    701            TaskStatus_t *task;
    702          
    703            if (IS_IRQ() || (thread_array == NULL) || (array_items == 0U)) {
   \        0x8   0xF3EF 0x8005      MRS      R0,IPSR
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD103             BNE.N    ??osThreadEnumerate_0
   \       0x10   0x2D00             CMP      R5,#+0
   \       0x12   0xD001             BEQ.N    ??osThreadEnumerate_0
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xD101             BNE.N    ??osThreadEnumerate_1
    704              count = 0U;
   \                     ??osThreadEnumerate_0: (+1)
   \       0x18   0x2700             MOVS     R7,#+0
   \       0x1A   0xE023             B.N      ??osThreadEnumerate_2
    705            } else {
    706              vTaskSuspendAll();
   \                     ??osThreadEnumerate_1: (+1)
   \       0x1C   0x.... 0x....      BL       vTaskSuspendAll
    707          
    708              count = uxTaskGetNumberOfTasks();
   \       0x20   0x.... 0x....      BL       uxTaskGetNumberOfTasks
   \       0x24   0x0007             MOVS     R7,R0
    709              task  = pvPortMalloc (count * sizeof(TaskStatus_t));
   \       0x26   0xF05F 0x0824      MOVS     R8,#+36
   \       0x2A   0xFB08 0xF007      MUL      R0,R8,R7
   \       0x2E   0x.... 0x....      BL       pvPortMalloc
   \       0x32   0x0004             MOVS     R4,R0
    710          
    711              if (task != NULL) {
   \       0x34   0x2C00             CMP      R4,#+0
   \       0x36   0xD010             BEQ.N    ??osThreadEnumerate_3
    712                count = uxTaskGetSystemState (task, count, NULL);
   \       0x38   0x2200             MOVS     R2,#+0
   \       0x3A   0x0039             MOVS     R1,R7
   \       0x3C   0x0020             MOVS     R0,R4
   \       0x3E   0x.... 0x....      BL       uxTaskGetSystemState
    713          
    714                for (i = 0U; (i < count) && (i < array_items); i++) {
   \       0x42   0x2700             MOVS     R7,#+0
   \       0x44   0xE005             B.N      ??osThreadEnumerate_4
    715                  thread_array[i] = (osThreadId_t)task[i].xHandle;
   \                     ??osThreadEnumerate_5: (+1)
   \       0x46   0xFB08 0xF107      MUL      R1,R8,R7
   \       0x4A   0x5861             LDR      R1,[R4, R1]
   \       0x4C   0xF845 0x1027      STR      R1,[R5, R7, LSL #+2]
    716                }
   \       0x50   0x1C7F             ADDS     R7,R7,#+1
   \                     ??osThreadEnumerate_4: (+1)
   \       0x52   0x4287             CMP      R7,R0
   \       0x54   0xD201             BCS.N    ??osThreadEnumerate_6
   \       0x56   0x42B7             CMP      R7,R6
   \       0x58   0xD3F5             BCC.N    ??osThreadEnumerate_5
    717                count = i;
    718              }
    719              (void)xTaskResumeAll();
   \                     ??osThreadEnumerate_6: (+1)
   \                     ??osThreadEnumerate_3: (+1)
   \       0x5A   0x.... 0x....      BL       xTaskResumeAll
    720          
    721              vPortFree (task);
   \       0x5E   0x0020             MOVS     R0,R4
   \       0x60   0x.... 0x....      BL       vPortFree
    722            }
    723          
    724            return (count);
   \                     ??osThreadEnumerate_2: (+1)
   \       0x64   0x0038             MOVS     R0,R7
   \       0x66   0xE8BD 0x81F0      POP      {R4-R8,PC}
    725          }
    726          #endif /* (configUSE_OS2_THREAD_ENUMERATE == 1) */
    727          
    728          #if (configUSE_OS2_THREAD_FLAGS == 1)

   \                                 In section .text, align 2, keep-with-next
    729          uint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags) {
   \                     osThreadFlagsSet: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    730            TaskHandle_t hTask = (TaskHandle_t)thread_id;
    731            uint32_t rflags;
    732            BaseType_t yield;
    733          
    734            if ((hTask == NULL) || ((flags & THREAD_FLAGS_INVALID_BITS) != 0U)) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD001             BEQ.N    ??osThreadFlagsSet_0
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD503             BPL.N    ??osThreadFlagsSet_1
    735              rflags = (uint32_t)osErrorParameter;
   \                     ??osThreadFlagsSet_0: (+1)
   \        0xC   0xF07F 0x0003      MVNS     R0,#+3
   \       0x10   0x9001             STR      R0,[SP, #+4]
   \       0x12   0xE02F             B.N      ??osThreadFlagsSet_2
    736            }
    737            else {
    738              rflags = (uint32_t)osError;
   \                     ??osThreadFlagsSet_1: (+1)
   \       0x14   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x18   0x9001             STR      R0,[SP, #+4]
    739          
    740              if (IS_IRQ()) {
   \       0x1A   0xF3EF 0x8005      MRS      R0,IPSR
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD01D             BEQ.N    ??osThreadFlagsSet_3
    741                yield = pdFALSE;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x9002             STR      R0,[SP, #+8]
    742          
    743                (void)xTaskNotifyFromISR (hTask, flags, eSetBits, &yield);
   \       0x26   0xA802             ADD      R0,SP,#+8
   \       0x28   0x9000             STR      R0,[SP, #+0]
   \       0x2A   0x2300             MOVS     R3,#+0
   \       0x2C   0x2201             MOVS     R2,#+1
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       xTaskGenericNotifyFromISR
    744                (void)xTaskNotifyAndQueryFromISR (hTask, 0, eNoAction, &rflags, NULL);
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x9000             STR      R0,[SP, #+0]
   \       0x38   0xAB01             ADD      R3,SP,#+4
   \       0x3A   0x2200             MOVS     R2,#+0
   \       0x3C   0x2100             MOVS     R1,#+0
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x.... 0x....      BL       xTaskGenericNotifyFromISR
    745          
    746                portYIELD_FROM_ISR (yield);
   \       0x44   0x9802             LDR      R0,[SP, #+8]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD014             BEQ.N    ??osThreadFlagsSet_2
   \       0x4A   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0x4E   0x.... 0x....      LDR.W    R1,??DataTable16
   \       0x52   0x6008             STR      R0,[R1, #+0]
   \       0x54   0xF3BF 0x8F4F      DSB      SY
   \       0x58   0xF3BF 0x8F6F      ISB      SY
   \       0x5C   0xE00A             B.N      ??osThreadFlagsSet_2
    747              }
    748              else {
    749                (void)xTaskNotify (hTask, flags, eSetBits);
   \                     ??osThreadFlagsSet_3: (+1)
   \       0x5E   0x2300             MOVS     R3,#+0
   \       0x60   0x2201             MOVS     R2,#+1
   \       0x62   0x0020             MOVS     R0,R4
   \       0x64   0x.... 0x....      BL       xTaskGenericNotify
    750                (void)xTaskNotifyAndQuery (hTask, 0, eNoAction, &rflags);
   \       0x68   0xAB01             ADD      R3,SP,#+4
   \       0x6A   0x2200             MOVS     R2,#+0
   \       0x6C   0x2100             MOVS     R1,#+0
   \       0x6E   0x0020             MOVS     R0,R4
   \       0x70   0x.... 0x....      BL       xTaskGenericNotify
    751              }
    752            }
    753            /* Return flags after setting */
    754            return (rflags);
   \                     ??osThreadFlagsSet_2: (+1)
   \       0x74   0x9801             LDR      R0,[SP, #+4]
   \       0x76   0xB004             ADD      SP,SP,#+16
   \       0x78   0xBD10             POP      {R4,PC}
    755          }
    756          

   \                                 In section .text, align 2, keep-with-next
    757          uint32_t osThreadFlagsClear (uint32_t flags) {
   \                     osThreadFlagsClear: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    758            TaskHandle_t hTask;
    759            uint32_t rflags, cflags;
    760          
    761            if (IS_IRQ()) {
   \        0x4   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??osThreadFlagsClear_0
    762              rflags = (uint32_t)osErrorISR;
   \        0xC   0xF07F 0x0605      MVNS     R6,#+5
   \       0x10   0xE021             B.N      ??osThreadFlagsClear_1
    763            }
    764            else if ((flags & THREAD_FLAGS_INVALID_BITS) != 0U) {
   \                     ??osThreadFlagsClear_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD502             BPL.N    ??osThreadFlagsClear_2
    765              rflags = (uint32_t)osErrorParameter;
   \       0x16   0xF07F 0x0603      MVNS     R6,#+3
   \       0x1A   0xE01C             B.N      ??osThreadFlagsClear_1
    766            }
    767            else {
    768              hTask = xTaskGetCurrentTaskHandle();
   \                     ??osThreadFlagsClear_2: (+1)
   \       0x1C   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \       0x20   0x0005             MOVS     R5,R0
    769          
    770              if (xTaskNotifyAndQuery (hTask, 0, eNoAction, &cflags) == pdPASS) {
   \       0x22   0x466B             MOV      R3,SP
   \       0x24   0x2200             MOVS     R2,#+0
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0x0028             MOVS     R0,R5
   \       0x2A   0x.... 0x....      BL       xTaskGenericNotify
   \       0x2E   0x2801             CMP      R0,#+1
   \       0x30   0xD10F             BNE.N    ??osThreadFlagsClear_3
    771                rflags = cflags;
   \       0x32   0x9E00             LDR      R6,[SP, #+0]
    772                cflags &= ~flags;
   \       0x34   0x9800             LDR      R0,[SP, #+0]
   \       0x36   0xEA30 0x0404      BICS     R4,R0,R4
   \       0x3A   0x9400             STR      R4,[SP, #+0]
    773          
    774                if (xTaskNotify (hTask, cflags, eSetValueWithOverwrite) != pdPASS) {
   \       0x3C   0x2300             MOVS     R3,#+0
   \       0x3E   0x2203             MOVS     R2,#+3
   \       0x40   0x9900             LDR      R1,[SP, #+0]
   \       0x42   0x0028             MOVS     R0,R5
   \       0x44   0x.... 0x....      BL       xTaskGenericNotify
   \       0x48   0x2801             CMP      R0,#+1
   \       0x4A   0xD004             BEQ.N    ??osThreadFlagsClear_1
    775                  rflags = (uint32_t)osError;
   \       0x4C   0xF05F 0x36FF      MOVS     R6,#+4294967295
   \       0x50   0xE001             B.N      ??osThreadFlagsClear_1
    776                }
    777              }
    778              else {
    779                rflags = (uint32_t)osError;
   \                     ??osThreadFlagsClear_3: (+1)
   \       0x52   0xF05F 0x36FF      MOVS     R6,#+4294967295
    780              }
    781            }
    782          
    783            /* Return flags before clearing */
    784            return (rflags);
   \                     ??osThreadFlagsClear_1: (+1)
   \       0x56   0x0030             MOVS     R0,R6
   \       0x58   0xBD76             POP      {R1,R2,R4-R6,PC}
    785          }
    786          

   \                                 In section .text, align 2, keep-with-next
    787          uint32_t osThreadFlagsGet (void) {
   \                     osThreadFlagsGet: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    788            TaskHandle_t hTask;
    789            uint32_t rflags;
    790          
    791            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD003             BEQ.N    ??osThreadFlagsGet_0
    792              rflags = (uint32_t)osErrorISR;
   \        0xA   0xF07F 0x0005      MVNS     R0,#+5
   \        0xE   0x9000             STR      R0,[SP, #+0]
   \       0x10   0xE00B             B.N      ??osThreadFlagsGet_1
    793            }
    794            else {
    795              hTask = xTaskGetCurrentTaskHandle();
   \                     ??osThreadFlagsGet_0: (+1)
   \       0x12   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
    796          
    797              if (xTaskNotifyAndQuery (hTask, 0, eNoAction, &rflags) != pdPASS) {
   \       0x16   0x466B             MOV      R3,SP
   \       0x18   0x2200             MOVS     R2,#+0
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0x.... 0x....      BL       xTaskGenericNotify
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD002             BEQ.N    ??osThreadFlagsGet_1
    798                rflags = (uint32_t)osError;
   \       0x24   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x28   0x9000             STR      R0,[SP, #+0]
    799              }
    800            }
    801          
    802            return (rflags);
   \                     ??osThreadFlagsGet_1: (+1)
   \       0x2A   0x9800             LDR      R0,[SP, #+0]
   \       0x2C   0xBD02             POP      {R1,PC}
    803          }
    804          

   \                                 In section .text, align 2, keep-with-next
    805          uint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout) {
   \                     osThreadFlagsWait: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    806            uint32_t rflags, nval;
    807            uint32_t clear;
    808            TickType_t t0, td, tout;
    809            BaseType_t rval;
    810          
    811            if (IS_IRQ()) {
   \        0x4   0xF3EF 0x8305      MRS      R3,IPSR
   \        0x8   0x2B00             CMP      R3,#+0
   \        0xA   0xD002             BEQ.N    ??osThreadFlagsWait_0
    812              rflags = (uint32_t)osErrorISR;
   \        0xC   0xF07F 0x0B05      MVNS     R11,#+5
   \       0x10   0xE04F             B.N      ??osThreadFlagsWait_1
    813            }
   \                     ??osThreadFlagsWait_0: (+1)
   \       0x12   0x0006             MOVS     R6,R0
    814            else if ((flags & THREAD_FLAGS_INVALID_BITS) != 0U) {
   \       0x14   0x2E00             CMP      R6,#+0
   \       0x16   0xD502             BPL.N    ??osThreadFlagsWait_2
    815              rflags = (uint32_t)osErrorParameter;
   \       0x18   0xF07F 0x0B03      MVNS     R11,#+3
   \       0x1C   0xE049             B.N      ??osThreadFlagsWait_1
    816            }
   \                     ??osThreadFlagsWait_2: (+1)
   \       0x1E   0x000F             MOVS     R7,R1
    817            else {
    818              if ((options & osFlagsNoClear) == osFlagsNoClear) {
   \       0x20   0x07B8             LSLS     R0,R7,#+30
   \       0x22   0xD502             BPL.N    ??osThreadFlagsWait_3
    819                clear = 0U;
   \       0x24   0xF05F 0x0800      MOVS     R8,#+0
   \       0x28   0xE000             B.N      ??osThreadFlagsWait_4
    820              } else {
    821                clear = flags;
   \                     ??osThreadFlagsWait_3: (+1)
   \       0x2A   0x46B0             MOV      R8,R6
   \                     ??osThreadFlagsWait_4: (+1)
   \       0x2C   0x0014             MOVS     R4,R2
    822              }
    823          
    824              rflags = 0U;
   \       0x2E   0xF05F 0x0B00      MOVS     R11,#+0
    825              tout   = timeout;
   \       0x32   0x46A1             MOV      R9,R4
    826          
    827              t0 = xTaskGetTickCount();
   \       0x34   0x.... 0x....      BL       xTaskGetTickCount
   \       0x38   0x4682             MOV      R10,R0
    828              do {
    829                rval = xTaskNotifyWait (0, clear, &nval, tout);
   \                     ??osThreadFlagsWait_5: (+1)
   \       0x3A   0x464B             MOV      R3,R9
   \       0x3C   0x466A             MOV      R2,SP
   \       0x3E   0x4641             MOV      R1,R8
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x.... 0x....      BL       xTaskNotifyWait
   \       0x46   0x0005             MOVS     R5,R0
    830          
    831                if (rval == pdPASS) {
   \       0x48   0x2D01             CMP      R5,#+1
   \       0x4A   0xD129             BNE.N    ??osThreadFlagsWait_6
    832                  rflags &= flags;
   \       0x4C   0xEA16 0x0B0B      ANDS     R11,R6,R11
   \       0x50   0x4658             MOV      R0,R11
    833                  rflags |= nval;
   \       0x52   0x4683             MOV      R11,R0
   \       0x54   0x9800             LDR      R0,[SP, #+0]
   \       0x56   0xEA50 0x0B0B      ORRS     R11,R0,R11
    834          
    835                  if ((options & osFlagsWaitAll) == osFlagsWaitAll) {
   \       0x5A   0x07F8             LSLS     R0,R7,#+31
   \       0x5C   0xD50A             BPL.N    ??osThreadFlagsWait_7
    836                    if ((flags & rflags) == flags) {
   \       0x5E   0xEA1B 0x0006      ANDS     R0,R11,R6
   \       0x62   0x42B0             CMP      R0,R6
   \       0x64   0xD002             BEQ.N    ??osThreadFlagsWait_8
    837                      break;
    838                    } else {
    839                      if (timeout == 0U) {
   \                     ??osThreadFlagsWait_9: (+1)
   \       0x66   0x2C00             CMP      R4,#+0
   \       0x68   0xD109             BNE.N    ??osThreadFlagsWait_10
   \       0x6A   0xE000             B.N      ??osThreadFlagsWait_11
   \                     ??osThreadFlagsWait_8: (+1)
   \       0x6C   0xE021             B.N      ??osThreadFlagsWait_1
    840                        rflags = (uint32_t)osErrorResource;
   \                     ??osThreadFlagsWait_11: (+1)
   \       0x6E   0xF07F 0x0B02      MVNS     R11,#+2
    841                        break;
   \       0x72   0xE01E             B.N      ??osThreadFlagsWait_1
    842                      }
    843                    }
    844                  }
    845                  else {
    846                    if ((flags & rflags) != 0) {
   \                     ??osThreadFlagsWait_7: (+1)
   \       0x74   0xEA16 0x0F0B      TST      R6,R11
   \       0x78   0xD10A             BNE.N    ??osThreadFlagsWait_12
    847                      break;
    848                    } else {
    849                      if (timeout == 0U) {
   \                     ??osThreadFlagsWait_13: (+1)
   \       0x7A   0x2C00             CMP      R4,#+0
   \       0x7C   0xD009             BEQ.N    ??osThreadFlagsWait_14
    850                        rflags = (uint32_t)osErrorResource;
    851                        break;
    852                      }
    853                    }
    854                  }
    855          
    856                  /* Update timeout */
    857                  td = xTaskGetTickCount() - t0;
   \                     ??osThreadFlagsWait_10: (+1)
   \       0x7E   0x.... 0x....      BL       xTaskGetTickCount
   \       0x82   0xEBB0 0x000A      SUBS     R0,R0,R10
    858          
    859                  if (td > tout) {
   \       0x86   0x4581             CMP      R9,R0
   \       0x88   0xD206             BCS.N    ??osThreadFlagsWait_15
    860                    tout  = 0;
   \       0x8A   0xF05F 0x0900      MOVS     R9,#+0
   \       0x8E   0xE00E             B.N      ??osThreadFlagsWait_16
    861                  } else {
   \                     ??osThreadFlagsWait_12: (+1)
   \       0x90   0xE00F             B.N      ??osThreadFlagsWait_1
   \                     ??osThreadFlagsWait_14: (+1)
   \       0x92   0xF07F 0x0B02      MVNS     R11,#+2
   \       0x96   0xE00C             B.N      ??osThreadFlagsWait_1
    862                    tout -= td;
   \                     ??osThreadFlagsWait_15: (+1)
   \       0x98   0xEBB9 0x0000      SUBS     R0,R9,R0
   \       0x9C   0x4681             MOV      R9,R0
   \       0x9E   0xE006             B.N      ??osThreadFlagsWait_16
    863                  }
    864                }
    865                else {
    866                  if (timeout == 0) {
   \                     ??osThreadFlagsWait_6: (+1)
   \       0xA0   0x2C00             CMP      R4,#+0
   \       0xA2   0xD102             BNE.N    ??osThreadFlagsWait_17
    867                    rflags = (uint32_t)osErrorResource;
   \       0xA4   0xF07F 0x0B02      MVNS     R11,#+2
   \       0xA8   0xE001             B.N      ??osThreadFlagsWait_16
    868                  } else {
    869                    rflags = (uint32_t)osErrorTimeout;
   \                     ??osThreadFlagsWait_17: (+1)
   \       0xAA   0xF07F 0x0B01      MVNS     R11,#+1
    870                  }
    871                }
    872              }
    873              while (rval != pdFAIL);
   \                     ??osThreadFlagsWait_16: (+1)
   \       0xAE   0x2D00             CMP      R5,#+0
   \       0xB0   0xD1C3             BNE.N    ??osThreadFlagsWait_5
    874            }
    875          
    876            /* Return flags before clearing */
    877            return (rflags);
   \                     ??osThreadFlagsWait_1: (+1)
   \       0xB2   0x4658             MOV      R0,R11
   \       0xB4   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    878          }
    879          #endif /* (configUSE_OS2_THREAD_FLAGS == 1) */
    880          

   \                                 In section .text, align 2, keep-with-next
    881          osStatus_t osDelay (uint32_t ticks) {
   \                     osDelay: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    882            osStatus_t stat;
    883          
    884            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD002             BEQ.N    ??osDelay_0
    885              stat = osErrorISR;
   \        0xA   0xF07F 0x0405      MVNS     R4,#+5
   \        0xE   0xE004             B.N      ??osDelay_1
    886            }
    887            else {
    888              stat = osOK;
   \                     ??osDelay_0: (+1)
   \       0x10   0x2400             MOVS     R4,#+0
    889          
    890              if (ticks != 0U) {
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD001             BEQ.N    ??osDelay_1
    891                vTaskDelay(ticks);
   \       0x16   0x.... 0x....      BL       vTaskDelay
    892              }
    893            }
    894          
    895            return (stat);
   \                     ??osDelay_1: (+1)
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0xBD10             POP      {R4,PC}
    896          }
    897          

   \                                 In section .text, align 2, keep-with-next
    898          osStatus_t osDelayUntil (uint32_t ticks) {
   \                     osDelayUntil: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    899            TickType_t tcnt, delay;
    900            osStatus_t stat;
    901          
    902            if (IS_IRQ()) {
   \        0x4   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??osDelayUntil_0
    903              stat = osErrorISR;
   \        0xC   0xF07F 0x0505      MVNS     R5,#+5
   \       0x10   0xE012             B.N      ??osDelayUntil_1
    904            }
    905            else {
    906              stat = osOK;
   \                     ??osDelayUntil_0: (+1)
   \       0x12   0x2500             MOVS     R5,#+0
    907              tcnt = xTaskGetTickCount();
   \       0x14   0x.... 0x....      BL       xTaskGetTickCount
   \       0x18   0x9000             STR      R0,[SP, #+0]
    908          
    909              /* Determine remaining number of ticks to delay */
    910              delay = (TickType_t)ticks - tcnt;
   \       0x1A   0x9800             LDR      R0,[SP, #+0]
   \       0x1C   0x1A24             SUBS     R4,R4,R0
    911          
    912              /* Check if target tick has not expired */
    913              if((delay != 0U) && (0 == (delay >> (8 * sizeof(TickType_t) - 1)))) {
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD008             BEQ.N    ??osDelayUntil_2
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x0FC0             LSRS     R0,R0,#+31
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD104             BNE.N    ??osDelayUntil_2
    914                vTaskDelayUntil (&tcnt, delay);
   \       0x2A   0x0021             MOVS     R1,R4
   \       0x2C   0x4668             MOV      R0,SP
   \       0x2E   0x.... 0x....      BL       vTaskDelayUntil
   \       0x32   0xE001             B.N      ??osDelayUntil_1
    915              }
    916              else
    917              {
    918                /* No delay or already expired */
    919                stat = osErrorParameter;
   \                     ??osDelayUntil_2: (+1)
   \       0x34   0xF07F 0x0503      MVNS     R5,#+3
    920              }
    921            }
    922          
    923            return (stat);
   \                     ??osDelayUntil_1: (+1)
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}
    924          }
    925          
    926          /*---------------------------------------------------------------------------*/
    927          #if (configUSE_OS2_TIMER == 1)
    928          

   \                                 In section .text, align 2, keep-with-next
    929          static void TimerCallback (TimerHandle_t hTimer) {
   \                     TimerCallback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    930            TimerCallback_t *callb;
    931          
    932            callb = (TimerCallback_t *)pvTimerGetTimerID (hTimer);
   \        0x2   0x.... 0x....      BL       pvTimerGetTimerID
   \        0x6   0x0001             MOVS     R1,R0
    933          
    934            if (callb != NULL) {
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD002             BEQ.N    ??TimerCallback_0
    935              callb->func (callb->arg);
   \        0xC   0x6848             LDR      R0,[R1, #+4]
   \        0xE   0x6809             LDR      R1,[R1, #+0]
   \       0x10   0x4788             BLX      R1
    936            }
    937          }
   \                     ??TimerCallback_0: (+1)
   \       0x12   0xBD01             POP      {R0,PC}
    938          

   \                                 In section .text, align 2, keep-with-next
    939          osTimerId_t osTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr) {
   \                     osTimerNew: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4691             MOV      R9,R2
   \        0xA   0x001E             MOVS     R6,R3
    940            const char *name;
    941            TimerHandle_t hTimer;
    942            TimerCallback_t *callb;
    943            UBaseType_t reload;
    944            int32_t mem;
    945          
    946            hTimer = NULL;
   \        0xC   0x2500             MOVS     R5,#+0
    947          
    948            if (!IS_IRQ() && (func != NULL)) {
   \        0xE   0xF3EF 0x8005      MRS      R0,IPSR
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD14B             BNE.N    ??osTimerNew_0
   \       0x16   0x0038             MOVS     R0,R7
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD048             BEQ.N    ??osTimerNew_0
    949              /* Allocate memory to store callback function and argument */
    950              callb = pvPortMalloc (sizeof(TimerCallback_t));
   \       0x1C   0x2008             MOVS     R0,#+8
   \       0x1E   0x.... 0x....      BL       pvPortMalloc
   \       0x22   0x0004             MOVS     R4,R0
    951          
    952              if (callb != NULL) {
   \       0x24   0x2C00             CMP      R4,#+0
   \       0x26   0xD042             BEQ.N    ??osTimerNew_0
    953                callb->func = func;
   \       0x28   0x6027             STR      R7,[R4, #+0]
    954                callb->arg  = argument;
   \       0x2A   0xF8C4 0x9004      STR      R9,[R4, #+4]
    955          
    956                if (type == osTimerOnce) {
   \       0x2E   0xFA5F 0xF888      UXTB     R8,R8
   \       0x32   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x36   0xD101             BNE.N    ??osTimerNew_1
    957                  reload = pdFALSE;
   \       0x38   0x2200             MOVS     R2,#+0
   \       0x3A   0xE000             B.N      ??osTimerNew_2
    958                } else {
    959                  reload = pdTRUE;
   \                     ??osTimerNew_1: (+1)
   \       0x3C   0x2201             MOVS     R2,#+1
    960                }
    961          
    962                mem  = -1;
   \                     ??osTimerNew_2: (+1)
   \       0x3E   0xF05F 0x33FF      MOVS     R3,#+4294967295
    963                name = NULL;
   \       0x42   0x2000             MOVS     R0,#+0
    964          
    965                if (attr != NULL) {
   \       0x44   0x2E00             CMP      R6,#+0
   \       0x46   0xD013             BEQ.N    ??osTimerNew_3
    966                  if (attr->name != NULL) {
   \       0x48   0x6831             LDR      R1,[R6, #+0]
   \       0x4A   0x2900             CMP      R1,#+0
   \       0x4C   0xD000             BEQ.N    ??osTimerNew_4
    967                    name = attr->name;
   \       0x4E   0x6830             LDR      R0,[R6, #+0]
    968                  }
    969          
    970                  if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticTimer_t))) {
   \                     ??osTimerNew_4: (+1)
   \       0x50   0x68B1             LDR      R1,[R6, #+8]
   \       0x52   0x2900             CMP      R1,#+0
   \       0x54   0xD004             BEQ.N    ??osTimerNew_5
   \       0x56   0x68F1             LDR      R1,[R6, #+12]
   \       0x58   0x292C             CMP      R1,#+44
   \       0x5A   0xD301             BCC.N    ??osTimerNew_5
    971                    mem = 1;
   \       0x5C   0x2301             MOVS     R3,#+1
   \       0x5E   0xE008             B.N      ??osTimerNew_6
    972                  }
    973                  else {
    974                    if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
   \                     ??osTimerNew_5: (+1)
   \       0x60   0x68B1             LDR      R1,[R6, #+8]
   \       0x62   0x2900             CMP      R1,#+0
   \       0x64   0xD105             BNE.N    ??osTimerNew_6
   \       0x66   0x68F1             LDR      R1,[R6, #+12]
   \       0x68   0x2900             CMP      R1,#+0
   \       0x6A   0xD102             BNE.N    ??osTimerNew_6
    975                      mem = 0;
   \       0x6C   0x2300             MOVS     R3,#+0
   \       0x6E   0xE000             B.N      ??osTimerNew_6
    976                    }
    977                  }
    978                }
    979                else {
    980                  mem = 0;
   \                     ??osTimerNew_3: (+1)
   \       0x70   0x2300             MOVS     R3,#+0
    981                }
    982          
    983                if (mem == 1) {
   \                     ??osTimerNew_6: (+1)
   \       0x72   0x2B01             CMP      R3,#+1
   \       0x74   0xD10A             BNE.N    ??osTimerNew_7
    984                  #if (configSUPPORT_STATIC_ALLOCATION == 1)
    985                    hTimer = xTimerCreateStatic (name, 1, reload, callb, TimerCallback, (StaticTimer_t *)attr->cb_mem);
   \       0x76   0x68B1             LDR      R1,[R6, #+8]
   \       0x78   0x9101             STR      R1,[SP, #+4]
   \       0x7A   0x.... 0x....      LDR.W    R1,??DataTable19
   \       0x7E   0x9100             STR      R1,[SP, #+0]
   \       0x80   0x0023             MOVS     R3,R4
   \       0x82   0x2101             MOVS     R1,#+1
   \       0x84   0x.... 0x....      BL       xTimerCreateStatic
   \       0x88   0x0005             MOVS     R5,R0
   \       0x8A   0xE009             B.N      ??osTimerNew_8
    986                  #endif
    987                }
    988                else {
    989                  if (mem == 0) {
   \                     ??osTimerNew_7: (+1)
   \       0x8C   0x2B00             CMP      R3,#+0
   \       0x8E   0xD107             BNE.N    ??osTimerNew_8
    990                    #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
    991                      hTimer = xTimerCreate (name, 1, reload, callb, TimerCallback);
   \       0x90   0x.... 0x....      LDR.W    R1,??DataTable19
   \       0x94   0x9100             STR      R1,[SP, #+0]
   \       0x96   0x0023             MOVS     R3,R4
   \       0x98   0x2101             MOVS     R1,#+1
   \       0x9A   0x.... 0x....      BL       xTimerCreate
   \       0x9E   0x0005             MOVS     R5,R0
    992                    #endif
    993                  }
    994                }
    995          
    996                if ((hTimer == NULL) && (callb != NULL)) {
   \                     ??osTimerNew_8: (+1)
   \       0xA0   0x2D00             CMP      R5,#+0
   \       0xA2   0xD104             BNE.N    ??osTimerNew_0
   \       0xA4   0x2C00             CMP      R4,#+0
   \       0xA6   0xD002             BEQ.N    ??osTimerNew_0
    997                  vPortFree (callb);
   \       0xA8   0x0020             MOVS     R0,R4
   \       0xAA   0x.... 0x....      BL       vPortFree
    998                }
    999              }
   1000            }
   1001          
   1002            return ((osTimerId_t)hTimer);
   \                     ??osTimerNew_0: (+1)
   \       0xAE   0x0028             MOVS     R0,R5
   \       0xB0   0xE8BD 0x83FE      POP      {R1-R9,PC}
   1003          }
   1004          

   \                                 In section .text, align 2, keep-with-next
   1005          const char *osTimerGetName (osTimerId_t timer_id) {
   \                     osTimerGetName: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1006            TimerHandle_t hTimer = (TimerHandle_t)timer_id;
   1007            const char *p;
   1008          
   1009            if (IS_IRQ() || (hTimer == NULL)) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD101             BNE.N    ??osTimerGetName_0
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD101             BNE.N    ??osTimerGetName_1
   1010              p = NULL;
   \                     ??osTimerGetName_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE001             B.N      ??osTimerGetName_2
   1011            } else {
   1012              p = pcTimerGetName (hTimer);
   \                     ??osTimerGetName_1: (+1)
   \       0x12   0x.... 0x....      BL       pcTimerGetName
   1013            }
   1014          
   1015            return (p);
   \                     ??osTimerGetName_2: (+1)
   \       0x16   0xBD02             POP      {R1,PC}
   1016          }
   1017          

   \                                 In section .text, align 2, keep-with-next
   1018          osStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks) {
   \                     osTimerStart: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x000A             MOVS     R2,R1
   1019            TimerHandle_t hTimer = (TimerHandle_t)timer_id;
   1020            osStatus_t stat;
   1021          
   1022            if (IS_IRQ()) {
   \        0x4   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD002             BEQ.N    ??osTimerStart_0
   1023              stat = osErrorISR;
   \        0xC   0xF07F 0x0005      MVNS     R0,#+5
   \       0x10   0xE010             B.N      ??osTimerStart_1
   1024            }
   1025            else if (hTimer == NULL) {
   \                     ??osTimerStart_0: (+1)
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD102             BNE.N    ??osTimerStart_2
   1026              stat = osErrorParameter;
   \       0x16   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1A   0xE00B             B.N      ??osTimerStart_1
   1027            }
   1028            else {
   1029              if (xTimerChangePeriod (hTimer, ticks, 0) == pdPASS) {
   \                     ??osTimerStart_2: (+1)
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x9100             STR      R1,[SP, #+0]
   \       0x20   0x2300             MOVS     R3,#+0
   \       0x22   0x2104             MOVS     R1,#+4
   \       0x24   0x.... 0x....      BL       xTimerGenericCommand
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD101             BNE.N    ??osTimerStart_3
   1030                stat = osOK;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xE001             B.N      ??osTimerStart_1
   1031              } else {
   1032                stat = osErrorResource;
   \                     ??osTimerStart_3: (+1)
   \       0x30   0xF07F 0x0002      MVNS     R0,#+2
   1033              }
   1034            }
   1035          
   1036            return (stat);
   \                     ??osTimerStart_1: (+1)
   \       0x34   0xBD02             POP      {R1,PC}
   1037          }
   1038          

   \                                 In section .text, align 2, keep-with-next
   1039          osStatus_t osTimerStop (osTimerId_t timer_id) {
   \                     osTimerStop: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1040            TimerHandle_t hTimer = (TimerHandle_t)timer_id;
   1041            osStatus_t stat;
   1042          
   1043            if (IS_IRQ()) {
   \        0x4   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??osTimerStop_0
   1044              stat = osErrorISR;
   \        0xC   0xF07F 0x0005      MVNS     R0,#+5
   \       0x10   0xE01A             B.N      ??osTimerStop_1
   1045            }
   1046            else if (hTimer == NULL) {
   \                     ??osTimerStop_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD102             BNE.N    ??osTimerStop_2
   1047              stat = osErrorParameter;
   \       0x16   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1A   0xE015             B.N      ??osTimerStop_1
   1048            }
   1049            else {
   1050              if (xTimerIsTimerActive (hTimer) == pdFALSE) {
   \                     ??osTimerStop_2: (+1)
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       xTimerIsTimerActive
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD102             BNE.N    ??osTimerStop_3
   1051                stat = osErrorResource;
   \       0x26   0xF07F 0x0002      MVNS     R0,#+2
   \       0x2A   0xE00D             B.N      ??osTimerStop_1
   1052              }
   1053              else {
   1054                if (xTimerStop (hTimer, 0) == pdPASS) {
   \                     ??osTimerStop_3: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x9000             STR      R0,[SP, #+0]
   \       0x30   0x2300             MOVS     R3,#+0
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0x2103             MOVS     R1,#+3
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x.... 0x....      BL       xTimerGenericCommand
   \       0x3C   0x2801             CMP      R0,#+1
   \       0x3E   0xD101             BNE.N    ??osTimerStop_4
   1055                  stat = osOK;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xE001             B.N      ??osTimerStop_1
   1056                } else {
   1057                  stat = osError;
   \                     ??osTimerStop_4: (+1)
   \       0x44   0xF05F 0x30FF      MOVS     R0,#+4294967295
   1058                }
   1059              }
   1060            }
   1061          
   1062            return (stat);
   \                     ??osTimerStop_1: (+1)
   \       0x48   0xBD16             POP      {R1,R2,R4,PC}
   1063          }
   1064          

   \                                 In section .text, align 2, keep-with-next
   1065          uint32_t osTimerIsRunning (osTimerId_t timer_id) {
   \                     osTimerIsRunning: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1066            TimerHandle_t hTimer = (TimerHandle_t)timer_id;
   1067            uint32_t running;
   1068          
   1069            if (IS_IRQ() || (hTimer == NULL)) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD101             BNE.N    ??osTimerIsRunning_0
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD101             BNE.N    ??osTimerIsRunning_1
   1070              running = 0U;
   \                     ??osTimerIsRunning_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE001             B.N      ??osTimerIsRunning_2
   1071            } else {
   1072              running = (uint32_t)xTimerIsTimerActive (hTimer);
   \                     ??osTimerIsRunning_1: (+1)
   \       0x12   0x.... 0x....      BL       xTimerIsTimerActive
   1073            }
   1074          
   1075            return (running);
   \                     ??osTimerIsRunning_2: (+1)
   \       0x16   0xBD02             POP      {R1,PC}
   1076          }
   1077          

   \                                 In section .text, align 2, keep-with-next
   1078          osStatus_t osTimerDelete (osTimerId_t timer_id) {
   \                     osTimerDelete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1079            TimerHandle_t hTimer = (TimerHandle_t)timer_id;
   1080            osStatus_t stat;
   1081          #ifndef USE_FreeRTOS_HEAP_1
   1082            TimerCallback_t *callb;
   1083          
   1084            if (IS_IRQ()) {
   \        0x4   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??osTimerDelete_0
   1085              stat = osErrorISR;
   \        0xC   0xF07F 0x0005      MVNS     R0,#+5
   \       0x10   0xE019             B.N      ??osTimerDelete_1
   1086            }
   1087            else if (hTimer == NULL) {
   \                     ??osTimerDelete_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD102             BNE.N    ??osTimerDelete_2
   1088              stat = osErrorParameter;
   \       0x16   0xF07F 0x0003      MVNS     R0,#+3
   \       0x1A   0xE014             B.N      ??osTimerDelete_1
   1089            }
   1090            else {
   1091              callb = (TimerCallback_t *)pvTimerGetTimerID (hTimer);
   \                     ??osTimerDelete_2: (+1)
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       pvTimerGetTimerID
   \       0x22   0x0005             MOVS     R5,R0
   1092          
   1093              if (xTimerDelete (hTimer, 0) == pdPASS) {
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x9000             STR      R0,[SP, #+0]
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0x2105             MOVS     R1,#+5
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       xTimerGenericCommand
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD104             BNE.N    ??osTimerDelete_3
   1094                vPortFree (callb);
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0x.... 0x....      BL       vPortFree
   1095                stat = osOK;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xE001             B.N      ??osTimerDelete_1
   1096              } else {
   1097                stat = osErrorResource;
   \                     ??osTimerDelete_3: (+1)
   \       0x42   0xF07F 0x0002      MVNS     R0,#+2
   1098              }
   1099            }
   1100          #else
   1101            stat = osError;
   1102          #endif
   1103          
   1104            return (stat);
   \                     ??osTimerDelete_1: (+1)
   \       0x46   0xBD32             POP      {R1,R4,R5,PC}
   1105          }
   1106          #endif /* (configUSE_OS2_TIMER == 1) */
   1107          
   1108          /*---------------------------------------------------------------------------*/
   1109          

   \                                 In section .text, align 2, keep-with-next
   1110          osEventFlagsId_t osEventFlagsNew (const osEventFlagsAttr_t *attr) {
   \                     osEventFlagsNew: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1111            EventGroupHandle_t hEventGroup;
   1112            int32_t mem;
   1113          
   1114            hEventGroup = NULL;
   \        0x2   0x2100             MOVS     R1,#+0
   1115          
   1116            if (!IS_IRQ()) {
   \        0x4   0xF3EF 0x8205      MRS      R2,IPSR
   \        0x8   0x2A00             CMP      R2,#+0
   \        0xA   0xD120             BNE.N    ??osEventFlagsNew_0
   1117              mem = -1;
   \        0xC   0xF05F 0x33FF      MOVS     R3,#+4294967295
   1118          
   1119              if (attr != NULL) {
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD00F             BEQ.N    ??osEventFlagsNew_1
   1120                if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticEventGroup_t))) {
   \       0x14   0x6882             LDR      R2,[R0, #+8]
   \       0x16   0x2A00             CMP      R2,#+0
   \       0x18   0xD004             BEQ.N    ??osEventFlagsNew_2
   \       0x1A   0x68C2             LDR      R2,[R0, #+12]
   \       0x1C   0x2A20             CMP      R2,#+32
   \       0x1E   0xD301             BCC.N    ??osEventFlagsNew_2
   1121                  mem = 1;
   \       0x20   0x2301             MOVS     R3,#+1
   \       0x22   0xE008             B.N      ??osEventFlagsNew_3
   1122                }
   1123                else {
   1124                  if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
   \                     ??osEventFlagsNew_2: (+1)
   \       0x24   0x6882             LDR      R2,[R0, #+8]
   \       0x26   0x2A00             CMP      R2,#+0
   \       0x28   0xD105             BNE.N    ??osEventFlagsNew_3
   \       0x2A   0x68C2             LDR      R2,[R0, #+12]
   \       0x2C   0x2A00             CMP      R2,#+0
   \       0x2E   0xD102             BNE.N    ??osEventFlagsNew_3
   1125                    mem = 0;
   \       0x30   0x2300             MOVS     R3,#+0
   \       0x32   0xE000             B.N      ??osEventFlagsNew_3
   1126                  }
   1127                }
   1128              }
   1129              else {
   1130                mem = 0;
   \                     ??osEventFlagsNew_1: (+1)
   \       0x34   0x2300             MOVS     R3,#+0
   1131              }
   1132          
   1133              if (mem == 1) {
   \                     ??osEventFlagsNew_3: (+1)
   \       0x36   0x2B01             CMP      R3,#+1
   \       0x38   0xD104             BNE.N    ??osEventFlagsNew_4
   1134                #if (configSUPPORT_STATIC_ALLOCATION == 1)
   1135                hEventGroup = xEventGroupCreateStatic (attr->cb_mem);
   \       0x3A   0x6880             LDR      R0,[R0, #+8]
   \       0x3C   0x.... 0x....      BL       xEventGroupCreateStatic
   \       0x40   0x0001             MOVS     R1,R0
   \       0x42   0xE004             B.N      ??osEventFlagsNew_0
   1136                #endif
   1137              }
   1138              else {
   1139                if (mem == 0) {
   \                     ??osEventFlagsNew_4: (+1)
   \       0x44   0x2B00             CMP      R3,#+0
   \       0x46   0xD102             BNE.N    ??osEventFlagsNew_0
   1140                  #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
   1141                    hEventGroup = xEventGroupCreate();
   \       0x48   0x.... 0x....      BL       xEventGroupCreate
   \       0x4C   0x0001             MOVS     R1,R0
   1142                  #endif
   1143                }
   1144              }
   1145            }
   1146          
   1147            return ((osEventFlagsId_t)hEventGroup);
   \                     ??osEventFlagsNew_0: (+1)
   \       0x4E   0x0008             MOVS     R0,R1
   \       0x50   0xBD02             POP      {R1,PC}
   1148          }
   1149          

   \                                 In section .text, align 2, keep-with-next
   1150          uint32_t osEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags) {
   \                     osEventFlagsSet: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x000C             MOVS     R4,R1
   1151            EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
   1152            uint32_t rflags;
   1153            BaseType_t yield;
   1154          
   1155            if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD002             BEQ.N    ??osEventFlagsSet_0
   \        0x8   0xF014 0x4F7F      TST      R4,#0xFF000000
   \        0xC   0xD002             BEQ.N    ??osEventFlagsSet_1
   1156              rflags = (uint32_t)osErrorParameter;
   \                     ??osEventFlagsSet_0: (+1)
   \        0xE   0xF07F 0x0403      MVNS     R4,#+3
   \       0x12   0xE01F             B.N      ??osEventFlagsSet_2
   1157            }
   1158            else if (IS_IRQ()) {
   \                     ??osEventFlagsSet_1: (+1)
   \       0x14   0xF3EF 0x8105      MRS      R1,IPSR
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xD017             BEQ.N    ??osEventFlagsSet_3
   1159            #if (configUSE_OS2_EVENTFLAGS_FROM_ISR == 0)
   1160              (void)yield;
   1161              /* Enable timers and xTimerPendFunctionCall function to support osEventFlagsSet from ISR */
   1162              rflags = (uint32_t)osErrorResource;
   1163            #else
   1164              yield = pdFALSE;
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x9100             STR      R1,[SP, #+0]
   1165          
   1166              if (xEventGroupSetBitsFromISR (hEventGroup, (EventBits_t)flags, &yield) == pdFAIL) {
   \       0x20   0x466A             MOV      R2,SP
   \       0x22   0x0021             MOVS     R1,R4
   \       0x24   0x.... 0x....      BL       xEventGroupSetBitsFromISR
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD102             BNE.N    ??osEventFlagsSet_4
   1167                rflags = (uint32_t)osErrorResource;
   \       0x2C   0xF07F 0x0402      MVNS     R4,#+2
   \       0x30   0xE010             B.N      ??osEventFlagsSet_2
   1168              } else {
   1169                rflags = flags;
   1170                portYIELD_FROM_ISR (yield);
   \                     ??osEventFlagsSet_4: (+1)
   \       0x32   0x9800             LDR      R0,[SP, #+0]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD00D             BEQ.N    ??osEventFlagsSet_2
   \       0x38   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0x3C   0x.... 0x....      LDR.W    R1,??DataTable16
   \       0x40   0x6008             STR      R0,[R1, #+0]
   \       0x42   0xF3BF 0x8F4F      DSB      SY
   \       0x46   0xF3BF 0x8F6F      ISB      SY
   \       0x4A   0xE003             B.N      ??osEventFlagsSet_2
   1171              }
   1172            #endif
   1173            }
   1174            else {
   1175              rflags = xEventGroupSetBits (hEventGroup, (EventBits_t)flags);
   \                     ??osEventFlagsSet_3: (+1)
   \       0x4C   0x0021             MOVS     R1,R4
   \       0x4E   0x.... 0x....      BL       xEventGroupSetBits
   \       0x52   0x0004             MOVS     R4,R0
   1176            }
   1177          
   1178            return (rflags);
   \                     ??osEventFlagsSet_2: (+1)
   \       0x54   0x0020             MOVS     R0,R4
   \       0x56   0xBD16             POP      {R1,R2,R4,PC}
   1179          }
   1180          

   \                                 In section .text, align 2, keep-with-next
   1181          uint32_t osEventFlagsClear (osEventFlagsId_t ef_id, uint32_t flags) {
   \                     osEventFlagsClear: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1182            EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
   1183            uint32_t rflags;
   1184          
   1185            if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD002             BEQ.N    ??osEventFlagsClear_0
   \        0xA   0xF015 0x4F7F      TST      R5,#0xFF000000
   \        0xE   0xD002             BEQ.N    ??osEventFlagsClear_1
   1186              rflags = (uint32_t)osErrorParameter;
   \                     ??osEventFlagsClear_0: (+1)
   \       0x10   0xF07F 0x0603      MVNS     R6,#+3
   \       0x14   0xE015             B.N      ??osEventFlagsClear_2
   1187            }
   1188            else if (IS_IRQ()) {
   \                     ??osEventFlagsClear_1: (+1)
   \       0x16   0xF3EF 0x8005      MRS      R0,IPSR
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD00C             BEQ.N    ??osEventFlagsClear_3
   1189            #if (configUSE_OS2_EVENTFLAGS_FROM_ISR == 0)
   1190              /* Enable timers and xTimerPendFunctionCall function to support osEventFlagsSet from ISR */
   1191              rflags = (uint32_t)osErrorResource;
   1192            #else
   1193              rflags = xEventGroupGetBitsFromISR (hEventGroup);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       xEventGroupGetBitsFromISR
   \       0x24   0x0006             MOVS     R6,R0
   1194          
   1195              if (xEventGroupClearBitsFromISR (hEventGroup, (EventBits_t)flags) == pdFAIL) {
   \       0x26   0x0029             MOVS     R1,R5
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x.... 0x....      BL       xEventGroupClearBitsFromISR
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD107             BNE.N    ??osEventFlagsClear_2
   1196                rflags = (uint32_t)osErrorResource;
   \       0x32   0xF07F 0x0602      MVNS     R6,#+2
   \       0x36   0xE004             B.N      ??osEventFlagsClear_2
   1197              }
   1198            #endif
   1199            }
   1200            else {
   1201              rflags = xEventGroupClearBits (hEventGroup, (EventBits_t)flags);
   \                     ??osEventFlagsClear_3: (+1)
   \       0x38   0x0029             MOVS     R1,R5
   \       0x3A   0x0020             MOVS     R0,R4
   \       0x3C   0x.... 0x....      BL       xEventGroupClearBits
   \       0x40   0x0006             MOVS     R6,R0
   1202            }
   1203          
   1204            return (rflags);
   \                     ??osEventFlagsClear_2: (+1)
   \       0x42   0x0030             MOVS     R0,R6
   \       0x44   0xBD70             POP      {R4-R6,PC}
   1205          }
   1206          

   \                                 In section .text, align 2, keep-with-next
   1207          uint32_t osEventFlagsGet (osEventFlagsId_t ef_id) {
   \                     osEventFlagsGet: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1208            EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
   \        0x2   0x0002             MOVS     R2,R0
   1209            uint32_t rflags;
   1210          
   1211            if (ef_id == NULL) {
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD101             BNE.N    ??osEventFlagsGet_0
   1212              rflags = 0U;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xE00B             B.N      ??osEventFlagsGet_1
   1213            }
   1214            else if (IS_IRQ()) {
   \                     ??osEventFlagsGet_0: (+1)
   \        0xC   0xF3EF 0x8005      MRS      R0,IPSR
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD003             BEQ.N    ??osEventFlagsGet_2
   1215              rflags = xEventGroupGetBitsFromISR (hEventGroup);
   \       0x14   0x0010             MOVS     R0,R2
   \       0x16   0x.... 0x....      BL       xEventGroupGetBitsFromISR
   \       0x1A   0xE003             B.N      ??osEventFlagsGet_1
   1216            }
   1217            else {
   1218              rflags = xEventGroupGetBits (hEventGroup);
   \                     ??osEventFlagsGet_2: (+1)
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x0010             MOVS     R0,R2
   \       0x20   0x.... 0x....      BL       xEventGroupClearBits
   1219            }
   1220          
   1221            return (rflags);
   \                     ??osEventFlagsGet_1: (+1)
   \       0x24   0xBD02             POP      {R1,PC}
   1222          }
   1223          

   \                                 In section .text, align 2, keep-with-next
   1224          uint32_t osEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout) {
   \                     osEventFlagsWait: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x000D             MOVS     R5,R1
   \        0x4   0x0016             MOVS     R6,R2
   \        0x6   0x001C             MOVS     R4,R3
   1225            EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
   1226            BaseType_t wait_all;
   1227            BaseType_t exit_clr;
   1228            uint32_t rflags;
   1229          
   1230            if ((hEventGroup == NULL) || ((flags & EVENT_FLAGS_INVALID_BITS) != 0U)) {
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??osEventFlagsWait_0
   \        0xC   0xF015 0x4F7F      TST      R5,#0xFF000000
   \       0x10   0xD002             BEQ.N    ??osEventFlagsWait_1
   1231              rflags = (uint32_t)osErrorParameter;
   \                     ??osEventFlagsWait_0: (+1)
   \       0x12   0xF07F 0x0003      MVNS     R0,#+3
   \       0x16   0xE02B             B.N      ??osEventFlagsWait_2
   1232            }
   1233            else if (IS_IRQ()) {
   \                     ??osEventFlagsWait_1: (+1)
   \       0x18   0xF3EF 0x8105      MRS      R1,IPSR
   \       0x1C   0x2900             CMP      R1,#+0
   \       0x1E   0xD002             BEQ.N    ??osEventFlagsWait_3
   1234              rflags = (uint32_t)osErrorISR;
   \       0x20   0xF07F 0x0005      MVNS     R0,#+5
   \       0x24   0xE024             B.N      ??osEventFlagsWait_2
   1235            }
   1236            else {
   1237              if (options & osFlagsWaitAll) {
   \                     ??osEventFlagsWait_3: (+1)
   \       0x26   0x07F1             LSLS     R1,R6,#+31
   \       0x28   0xD501             BPL.N    ??osEventFlagsWait_4
   1238                wait_all = pdTRUE;
   \       0x2A   0x2301             MOVS     R3,#+1
   \       0x2C   0xE000             B.N      ??osEventFlagsWait_5
   1239              } else {
   1240                wait_all = pdFAIL;
   \                     ??osEventFlagsWait_4: (+1)
   \       0x2E   0x2300             MOVS     R3,#+0
   1241              }
   1242          
   1243              if (options & osFlagsNoClear) {
   \                     ??osEventFlagsWait_5: (+1)
   \       0x30   0x07B1             LSLS     R1,R6,#+30
   \       0x32   0xD501             BPL.N    ??osEventFlagsWait_6
   1244                exit_clr = pdFAIL;
   \       0x34   0x2200             MOVS     R2,#+0
   \       0x36   0xE000             B.N      ??osEventFlagsWait_7
   1245              } else {
   1246                exit_clr = pdTRUE;
   \                     ??osEventFlagsWait_6: (+1)
   \       0x38   0x2201             MOVS     R2,#+1
   1247              }
   1248          
   1249              rflags = xEventGroupWaitBits (hEventGroup, (EventBits_t)flags, exit_clr, wait_all, (TickType_t)timeout);
   \                     ??osEventFlagsWait_7: (+1)
   \       0x3A   0x9400             STR      R4,[SP, #+0]
   \       0x3C   0x0029             MOVS     R1,R5
   \       0x3E   0x.... 0x....      BL       xEventGroupWaitBits
   1250          
   1251              if (options & osFlagsWaitAll) {
   \       0x42   0x07F1             LSLS     R1,R6,#+31
   \       0x44   0xD50B             BPL.N    ??osEventFlagsWait_8
   1252                if ((flags & rflags) != flags) {
   \       0x46   0xEA10 0x0105      ANDS     R1,R0,R5
   \       0x4A   0x42A9             CMP      R1,R5
   \       0x4C   0xD010             BEQ.N    ??osEventFlagsWait_2
   1253                  if (timeout > 0U) {
   \       0x4E   0x2C00             CMP      R4,#+0
   \       0x50   0xD002             BEQ.N    ??osEventFlagsWait_9
   1254                    rflags = (uint32_t)osErrorTimeout;
   \       0x52   0xF07F 0x0001      MVNS     R0,#+1
   \       0x56   0xE00B             B.N      ??osEventFlagsWait_2
   1255                  } else {
   1256                    rflags = (uint32_t)osErrorResource;
   \                     ??osEventFlagsWait_9: (+1)
   \       0x58   0xF07F 0x0002      MVNS     R0,#+2
   \       0x5C   0xE008             B.N      ??osEventFlagsWait_2
   1257                  }
   1258                }
   1259              }
   1260              else {
   1261                if ((flags & rflags) == 0U) {
   \                     ??osEventFlagsWait_8: (+1)
   \       0x5E   0x4205             TST      R5,R0
   \       0x60   0xD106             BNE.N    ??osEventFlagsWait_2
   1262                  if (timeout > 0U) {
   \       0x62   0x2C00             CMP      R4,#+0
   \       0x64   0xD002             BEQ.N    ??osEventFlagsWait_10
   1263                    rflags = (uint32_t)osErrorTimeout;
   \       0x66   0xF07F 0x0001      MVNS     R0,#+1
   \       0x6A   0xE001             B.N      ??osEventFlagsWait_2
   1264                  } else {
   1265                    rflags = (uint32_t)osErrorResource;
   \                     ??osEventFlagsWait_10: (+1)
   \       0x6C   0xF07F 0x0002      MVNS     R0,#+2
   1266                  }
   1267                }
   1268              }
   1269            }
   1270          
   1271            return (rflags);
   \                     ??osEventFlagsWait_2: (+1)
   \       0x70   0xBD76             POP      {R1,R2,R4-R6,PC}
   1272          }
   1273          

   \                                 In section .text, align 2, keep-with-next
   1274          osStatus_t osEventFlagsDelete (osEventFlagsId_t ef_id) {
   \                     osEventFlagsDelete: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1275            EventGroupHandle_t hEventGroup = (EventGroupHandle_t)ef_id;
   1276            osStatus_t stat;
   1277          
   1278          #ifndef USE_FreeRTOS_HEAP_1
   1279            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD002             BEQ.N    ??osEventFlagsDelete_0
   1280              stat = osErrorISR;
   \        0xA   0xF07F 0x0405      MVNS     R4,#+5
   \        0xE   0xE007             B.N      ??osEventFlagsDelete_1
   1281            }
   1282            else if (hEventGroup == NULL) {
   \                     ??osEventFlagsDelete_0: (+1)
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD102             BNE.N    ??osEventFlagsDelete_2
   1283              stat = osErrorParameter;
   \       0x14   0xF07F 0x0403      MVNS     R4,#+3
   \       0x18   0xE002             B.N      ??osEventFlagsDelete_1
   1284            }
   1285            else {
   1286              stat = osOK;
   \                     ??osEventFlagsDelete_2: (+1)
   \       0x1A   0x2400             MOVS     R4,#+0
   1287              vEventGroupDelete (hEventGroup);
   \       0x1C   0x.... 0x....      BL       vEventGroupDelete
   1288            }
   1289          #else
   1290            stat = osError;
   1291          #endif
   1292          
   1293            return (stat);
   \                     ??osEventFlagsDelete_1: (+1)
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0xBD10             POP      {R4,PC}
   1294          }
   1295          
   1296          /*---------------------------------------------------------------------------*/
   1297          #if (configUSE_OS2_MUTEX == 1)
   1298          

   \                                 In section .text, align 2, keep-with-next
   1299          osMutexId_t osMutexNew (const osMutexAttr_t *attr) {
   \                     osMutexNew: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1300            SemaphoreHandle_t hMutex;
   1301            uint32_t type;
   1302            uint32_t rmtx;
   1303            int32_t  mem;
   1304            #if (configQUEUE_REGISTRY_SIZE > 0)
   1305            const char *name;
   1306            #endif
   1307          
   1308            hMutex = NULL;
   \        0x4   0x2600             MOVS     R6,#+0
   1309          
   1310            if (!IS_IRQ()) {
   \        0x6   0xF3EF 0x8005      MRS      R0,IPSR
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD14D             BNE.N    ??osMutexNew_0
   1311              if (attr != NULL) {
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD001             BEQ.N    ??osMutexNew_1
   1312                type = attr->attr_bits;
   \       0x12   0x6860             LDR      R0,[R4, #+4]
   \       0x14   0xE000             B.N      ??osMutexNew_2
   1313              } else {
   1314                type = 0U;
   \                     ??osMutexNew_1: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   1315              }
   1316          
   1317              if ((type & osMutexRecursive) == osMutexRecursive) {
   \                     ??osMutexNew_2: (+1)
   \       0x18   0x07C1             LSLS     R1,R0,#+31
   \       0x1A   0xD501             BPL.N    ??osMutexNew_3
   1318                rmtx = 1U;
   \       0x1C   0x2501             MOVS     R5,#+1
   \       0x1E   0xE000             B.N      ??osMutexNew_4
   1319              } else {
   1320                rmtx = 0U;
   \                     ??osMutexNew_3: (+1)
   \       0x20   0x2500             MOVS     R5,#+0
   1321              }
   1322          
   1323              if ((type & osMutexRobust) != osMutexRobust) {
   \                     ??osMutexNew_4: (+1)
   \       0x22   0x0700             LSLS     R0,R0,#+28
   \       0x24   0xD441             BMI.N    ??osMutexNew_0
   1324                mem = -1;
   \       0x26   0xF05F 0x31FF      MOVS     R1,#+4294967295
   1325          
   1326                if (attr != NULL) {
   \       0x2A   0x2C00             CMP      R4,#+0
   \       0x2C   0xD00F             BEQ.N    ??osMutexNew_5
   1327                  if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
   \       0x2E   0x68A0             LDR      R0,[R4, #+8]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD004             BEQ.N    ??osMutexNew_6
   \       0x34   0x68E0             LDR      R0,[R4, #+12]
   \       0x36   0x2850             CMP      R0,#+80
   \       0x38   0xD301             BCC.N    ??osMutexNew_6
   1328                    mem = 1;
   \       0x3A   0x2101             MOVS     R1,#+1
   \       0x3C   0xE008             B.N      ??osMutexNew_7
   1329                  }
   1330                  else {
   1331                    if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
   \                     ??osMutexNew_6: (+1)
   \       0x3E   0x68A0             LDR      R0,[R4, #+8]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD105             BNE.N    ??osMutexNew_7
   \       0x44   0x68E0             LDR      R0,[R4, #+12]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD102             BNE.N    ??osMutexNew_7
   1332                      mem = 0;
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0xE000             B.N      ??osMutexNew_7
   1333                    }
   1334                  }
   1335                }
   1336                else {
   1337                  mem = 0;
   \                     ??osMutexNew_5: (+1)
   \       0x4E   0x2100             MOVS     R1,#+0
   1338                }
   1339          
   1340                if (mem == 1) {
   \                     ??osMutexNew_7: (+1)
   \       0x50   0x2901             CMP      R1,#+1
   \       0x52   0xD10D             BNE.N    ??osMutexNew_8
   1341                  #if (configSUPPORT_STATIC_ALLOCATION == 1)
   1342                    if (rmtx != 0U) {
   \       0x54   0x2D00             CMP      R5,#+0
   \       0x56   0xD005             BEQ.N    ??osMutexNew_9
   1343                      #if (configUSE_RECURSIVE_MUTEXES == 1)
   1344                      hMutex = xSemaphoreCreateRecursiveMutexStatic (attr->cb_mem);
   \       0x58   0x68A1             LDR      R1,[R4, #+8]
   \       0x5A   0x2004             MOVS     R0,#+4
   \       0x5C   0x.... 0x....      BL       xQueueCreateMutexStatic
   \       0x60   0x0006             MOVS     R6,R0
   \       0x62   0xE012             B.N      ??osMutexNew_10
   1345                      #endif
   1346                    }
   1347                    else {
   1348                      hMutex = xSemaphoreCreateMutexStatic (attr->cb_mem);
   \                     ??osMutexNew_9: (+1)
   \       0x64   0x68A1             LDR      R1,[R4, #+8]
   \       0x66   0x2001             MOVS     R0,#+1
   \       0x68   0x.... 0x....      BL       xQueueCreateMutexStatic
   \       0x6C   0x0006             MOVS     R6,R0
   \       0x6E   0xE00C             B.N      ??osMutexNew_10
   1349                    }
   1350                  #endif
   1351                }
   1352                else {
   1353                  if (mem == 0) {
   \                     ??osMutexNew_8: (+1)
   \       0x70   0x2900             CMP      R1,#+0
   \       0x72   0xD10A             BNE.N    ??osMutexNew_10
   1354                    #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
   1355                      if (rmtx != 0U) {
   \       0x74   0x2D00             CMP      R5,#+0
   \       0x76   0xD004             BEQ.N    ??osMutexNew_11
   1356                        #if (configUSE_RECURSIVE_MUTEXES == 1)
   1357                        hMutex = xSemaphoreCreateRecursiveMutex ();
   \       0x78   0x2004             MOVS     R0,#+4
   \       0x7A   0x.... 0x....      BL       xQueueCreateMutex
   \       0x7E   0x0006             MOVS     R6,R0
   \       0x80   0xE003             B.N      ??osMutexNew_10
   1358                        #endif
   1359                      } else {
   1360                        hMutex = xSemaphoreCreateMutex ();
   \                     ??osMutexNew_11: (+1)
   \       0x82   0x2001             MOVS     R0,#+1
   \       0x84   0x.... 0x....      BL       xQueueCreateMutex
   \       0x88   0x0006             MOVS     R6,R0
   1361                      }
   1362                    #endif
   1363                  }
   1364                }
   1365          
   1366                #if (configQUEUE_REGISTRY_SIZE > 0)
   1367                if (hMutex != NULL) {
   \                     ??osMutexNew_10: (+1)
   \       0x8A   0x2E00             CMP      R6,#+0
   \       0x8C   0xD007             BEQ.N    ??osMutexNew_12
   1368                  if (attr != NULL) {
   \       0x8E   0x2C00             CMP      R4,#+0
   \       0x90   0xD001             BEQ.N    ??osMutexNew_13
   1369                    name = attr->name;
   \       0x92   0x6821             LDR      R1,[R4, #+0]
   \       0x94   0xE000             B.N      ??osMutexNew_14
   1370                  } else {
   1371                    name = NULL;
   \                     ??osMutexNew_13: (+1)
   \       0x96   0x2100             MOVS     R1,#+0
   1372                  }
   1373                  vQueueAddToRegistry (hMutex, name);
   \                     ??osMutexNew_14: (+1)
   \       0x98   0x0030             MOVS     R0,R6
   \       0x9A   0x.... 0x....      BL       vQueueAddToRegistry
   1374                }
   1375                #endif
   1376          
   1377                if ((hMutex != NULL) && (rmtx != 0U)) {
   \                     ??osMutexNew_12: (+1)
   \       0x9E   0x2E00             CMP      R6,#+0
   \       0xA0   0xD003             BEQ.N    ??osMutexNew_0
   \       0xA2   0x2D00             CMP      R5,#+0
   \       0xA4   0xD001             BEQ.N    ??osMutexNew_0
   1378                  hMutex = (SemaphoreHandle_t)((uint32_t)hMutex | 1U);
   \       0xA6   0xF056 0x0601      ORRS     R6,R6,#0x1
   1379                }
   1380              }
   1381            }
   1382          
   1383            return ((osMutexId_t)hMutex);
   \                     ??osMutexNew_0: (+1)
   \       0xAA   0x0030             MOVS     R0,R6
   \       0xAC   0xBD70             POP      {R4-R6,PC}
   1384          }
   1385          

   \                                 In section .text, align 2, keep-with-next
   1386          osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
   \                     osMutexAcquire: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0002             MOVS     R2,R0
   \        0x4   0x000C             MOVS     R4,R1
   1387            SemaphoreHandle_t hMutex;
   1388            osStatus_t stat;
   1389            uint32_t rmtx;
   1390          
   1391            hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
   \        0x6   0x0850             LSRS     R0,R2,#+1
   \        0x8   0x0040             LSLS     R0,R0,#+1
   1392          
   1393            rmtx = (uint32_t)mutex_id & 1U;
   \        0xA   0xF012 0x0201      ANDS     R2,R2,#0x1
   1394          
   1395            stat = osOK;
   \        0xE   0x2500             MOVS     R5,#+0
   1396          
   1397            if (IS_IRQ()) {
   \       0x10   0xF3EF 0x8105      MRS      R1,IPSR
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD002             BEQ.N    ??osMutexAcquire_0
   1398              stat = osErrorISR;
   \       0x18   0xF07F 0x0505      MVNS     R5,#+5
   \       0x1C   0xE01F             B.N      ??osMutexAcquire_1
   1399            }
   1400            else if (hMutex == NULL) {
   \                     ??osMutexAcquire_0: (+1)
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD102             BNE.N    ??osMutexAcquire_2
   1401              stat = osErrorParameter;
   \       0x22   0xF07F 0x0503      MVNS     R5,#+3
   \       0x26   0xE01A             B.N      ??osMutexAcquire_1
   1402            }
   1403            else {
   1404              if (rmtx != 0U) {
   \                     ??osMutexAcquire_2: (+1)
   \       0x28   0x2A00             CMP      R2,#+0
   \       0x2A   0xD00C             BEQ.N    ??osMutexAcquire_3
   1405                #if (configUSE_RECURSIVE_MUTEXES == 1)
   1406                if (xSemaphoreTakeRecursive (hMutex, timeout) != pdPASS) {
   \       0x2C   0x0021             MOVS     R1,R4
   \       0x2E   0x.... 0x....      BL       xQueueTakeMutexRecursive
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xD013             BEQ.N    ??osMutexAcquire_1
   1407                  if (timeout != 0U) {
   \       0x36   0x2C00             CMP      R4,#+0
   \       0x38   0xD002             BEQ.N    ??osMutexAcquire_4
   1408                    stat = osErrorTimeout;
   \       0x3A   0xF07F 0x0501      MVNS     R5,#+1
   \       0x3E   0xE00E             B.N      ??osMutexAcquire_1
   1409                  } else {
   1410                    stat = osErrorResource;
   \                     ??osMutexAcquire_4: (+1)
   \       0x40   0xF07F 0x0502      MVNS     R5,#+2
   \       0x44   0xE00B             B.N      ??osMutexAcquire_1
   1411                  }
   1412                }
   1413                #endif
   1414              }
   1415              else {
   1416                if (xSemaphoreTake (hMutex, timeout) != pdPASS) {
   \                     ??osMutexAcquire_3: (+1)
   \       0x46   0x0021             MOVS     R1,R4
   \       0x48   0x.... 0x....      BL       xQueueSemaphoreTake
   \       0x4C   0x2801             CMP      R0,#+1
   \       0x4E   0xD006             BEQ.N    ??osMutexAcquire_1
   1417                  if (timeout != 0U) {
   \       0x50   0x2C00             CMP      R4,#+0
   \       0x52   0xD002             BEQ.N    ??osMutexAcquire_5
   1418                    stat = osErrorTimeout;
   \       0x54   0xF07F 0x0501      MVNS     R5,#+1
   \       0x58   0xE001             B.N      ??osMutexAcquire_1
   1419                  } else {
   1420                    stat = osErrorResource;
   \                     ??osMutexAcquire_5: (+1)
   \       0x5A   0xF07F 0x0502      MVNS     R5,#+2
   1421                  }
   1422                }
   1423              }
   1424            }
   1425          
   1426            return (stat);
   \                     ??osMutexAcquire_1: (+1)
   \       0x5E   0x0028             MOVS     R0,R5
   \       0x60   0xBD32             POP      {R1,R4,R5,PC}
   1427          }
   1428          

   \                                 In section .text, align 2, keep-with-next
   1429          osStatus_t osMutexRelease (osMutexId_t mutex_id) {
   \                     osMutexRelease: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0001             MOVS     R1,R0
   1430            SemaphoreHandle_t hMutex;
   1431            osStatus_t stat;
   1432            uint32_t rmtx;
   1433          
   1434            hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
   \        0x4   0x0848             LSRS     R0,R1,#+1
   \        0x6   0x0040             LSLS     R0,R0,#+1
   1435          
   1436            rmtx = (uint32_t)mutex_id & 1U;
   \        0x8   0xF011 0x0101      ANDS     R1,R1,#0x1
   1437          
   1438            stat = osOK;
   \        0xC   0x2400             MOVS     R4,#+0
   1439          
   1440            if (IS_IRQ()) {
   \        0xE   0xF3EF 0x8205      MRS      R2,IPSR
   \       0x12   0x2A00             CMP      R2,#+0
   \       0x14   0xD002             BEQ.N    ??osMutexRelease_0
   1441              stat = osErrorISR;
   \       0x16   0xF07F 0x0405      MVNS     R4,#+5
   \       0x1A   0xE016             B.N      ??osMutexRelease_1
   1442            }
   1443            else if (hMutex == NULL) {
   \                     ??osMutexRelease_0: (+1)
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD102             BNE.N    ??osMutexRelease_2
   1444              stat = osErrorParameter;
   \       0x20   0xF07F 0x0403      MVNS     R4,#+3
   \       0x24   0xE011             B.N      ??osMutexRelease_1
   1445            }
   1446            else {
   1447              if (rmtx != 0U) {
   \                     ??osMutexRelease_2: (+1)
   \       0x26   0x2900             CMP      R1,#+0
   \       0x28   0xD006             BEQ.N    ??osMutexRelease_3
   1448                #if (configUSE_RECURSIVE_MUTEXES == 1)
   1449                if (xSemaphoreGiveRecursive (hMutex) != pdPASS) {
   \       0x2A   0x.... 0x....      BL       xQueueGiveMutexRecursive
   \       0x2E   0x2801             CMP      R0,#+1
   \       0x30   0xD00B             BEQ.N    ??osMutexRelease_1
   1450                  stat = osErrorResource;
   \       0x32   0xF07F 0x0402      MVNS     R4,#+2
   \       0x36   0xE008             B.N      ??osMutexRelease_1
   1451                }
   1452                #endif
   1453              }
   1454              else {
   1455                if (xSemaphoreGive (hMutex) != pdPASS) {
   \                     ??osMutexRelease_3: (+1)
   \       0x38   0x2300             MOVS     R3,#+0
   \       0x3A   0x2200             MOVS     R2,#+0
   \       0x3C   0x2100             MOVS     R1,#+0
   \       0x3E   0x.... 0x....      BL       xQueueGenericSend
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD001             BEQ.N    ??osMutexRelease_1
   1456                  stat = osErrorResource;
   \       0x46   0xF07F 0x0402      MVNS     R4,#+2
   1457                }
   1458              }
   1459            }
   1460          
   1461            return (stat);
   \                     ??osMutexRelease_1: (+1)
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0xBD10             POP      {R4,PC}
   1462          }
   1463          

   \                                 In section .text, align 2, keep-with-next
   1464          osThreadId_t osMutexGetOwner (osMutexId_t mutex_id) {
   \                     osMutexGetOwner: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1465            SemaphoreHandle_t hMutex;
   1466            osThreadId_t owner;
   1467          
   1468            hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
   \        0x2   0x0840             LSRS     R0,R0,#+1
   \        0x4   0x0040             LSLS     R0,R0,#+1
   1469          
   1470            if (IS_IRQ() || (hMutex == NULL)) {
   \        0x6   0xF3EF 0x8105      MRS      R1,IPSR
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD101             BNE.N    ??osMutexGetOwner_0
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD101             BNE.N    ??osMutexGetOwner_1
   1471              owner = NULL;
   \                     ??osMutexGetOwner_0: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xE001             B.N      ??osMutexGetOwner_2
   1472            } else {
   1473              owner = (osThreadId_t)xSemaphoreGetMutexHolder (hMutex);
   \                     ??osMutexGetOwner_1: (+1)
   \       0x16   0x.... 0x....      BL       xQueueGetMutexHolder
   1474            }
   1475          
   1476            return (owner);
   \                     ??osMutexGetOwner_2: (+1)
   \       0x1A   0xBD02             POP      {R1,PC}
   1477          }
   1478          

   \                                 In section .text, align 2, keep-with-next
   1479          osStatus_t osMutexDelete (osMutexId_t mutex_id) {
   \                     osMutexDelete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1480            osStatus_t stat;
   1481          #ifndef USE_FreeRTOS_HEAP_1
   1482            SemaphoreHandle_t hMutex;
   1483          
   1484            hMutex = (SemaphoreHandle_t)((uint32_t)mutex_id & ~1U);
   \        0x4   0x0864             LSRS     R4,R4,#+1
   \        0x6   0x0064             LSLS     R4,R4,#+1
   1485          
   1486            if (IS_IRQ()) {
   \        0x8   0xF3EF 0x8005      MRS      R0,IPSR
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD002             BEQ.N    ??osMutexDelete_0
   1487              stat = osErrorISR;
   \       0x10   0xF07F 0x0505      MVNS     R5,#+5
   \       0x14   0xE00B             B.N      ??osMutexDelete_1
   1488            }
   1489            else if (hMutex == NULL) {
   \                     ??osMutexDelete_0: (+1)
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD102             BNE.N    ??osMutexDelete_2
   1490              stat = osErrorParameter;
   \       0x1A   0xF07F 0x0503      MVNS     R5,#+3
   \       0x1E   0xE006             B.N      ??osMutexDelete_1
   1491            }
   1492            else {
   1493              #if (configQUEUE_REGISTRY_SIZE > 0)
   1494              vQueueUnregisterQueue (hMutex);
   \                     ??osMutexDelete_2: (+1)
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       vQueueUnregisterQueue
   1495              #endif
   1496              stat = osOK;
   \       0x26   0x2500             MOVS     R5,#+0
   1497              vSemaphoreDelete (hMutex);
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x.... 0x....      BL       vQueueDelete
   1498            }
   1499          #else
   1500            stat = osError;
   1501          #endif
   1502          
   1503            return (stat);
   \                     ??osMutexDelete_1: (+1)
   \       0x2E   0x0028             MOVS     R0,R5
   \       0x30   0xBD32             POP      {R1,R4,R5,PC}
   1504          }
   1505          #endif /* (configUSE_OS2_MUTEX == 1) */
   1506          
   1507          /*---------------------------------------------------------------------------*/
   1508          

   \                                 In section .text, align 2, keep-with-next
   1509          osSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr) {
   \                     osSemaphoreNew: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x000E             MOVS     R6,R1
   \        0x4   0x0015             MOVS     R5,R2
   1510            SemaphoreHandle_t hSemaphore;
   1511            int32_t mem;
   1512            #if (configQUEUE_REGISTRY_SIZE > 0)
   1513            const char *name;
   1514            #endif
   1515          
   1516            hSemaphore = NULL;
   \        0x6   0x2400             MOVS     R4,#+0
   1517          
   1518            if (!IS_IRQ() && (max_count > 0U) && (initial_count <= max_count)) {
   \        0x8   0xF3EF 0x8105      MRS      R1,IPSR
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD156             BNE.N    ??osSemaphoreNew_0
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD054             BEQ.N    ??osSemaphoreNew_0
   \       0x14   0x42B0             CMP      R0,R6
   \       0x16   0xD352             BCC.N    ??osSemaphoreNew_0
   1519              mem = -1;
   \       0x18   0xF05F 0x32FF      MOVS     R2,#+4294967295
   1520          
   1521              if (attr != NULL) {
   \       0x1C   0x2D00             CMP      R5,#+0
   \       0x1E   0xD00F             BEQ.N    ??osSemaphoreNew_1
   1522                if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
   \       0x20   0x68A9             LDR      R1,[R5, #+8]
   \       0x22   0x2900             CMP      R1,#+0
   \       0x24   0xD004             BEQ.N    ??osSemaphoreNew_2
   \       0x26   0x68E9             LDR      R1,[R5, #+12]
   \       0x28   0x2950             CMP      R1,#+80
   \       0x2A   0xD301             BCC.N    ??osSemaphoreNew_2
   1523                  mem = 1;
   \       0x2C   0x2201             MOVS     R2,#+1
   \       0x2E   0xE008             B.N      ??osSemaphoreNew_3
   1524                }
   1525                else {
   1526                  if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
   \                     ??osSemaphoreNew_2: (+1)
   \       0x30   0x68A9             LDR      R1,[R5, #+8]
   \       0x32   0x2900             CMP      R1,#+0
   \       0x34   0xD105             BNE.N    ??osSemaphoreNew_3
   \       0x36   0x68E9             LDR      R1,[R5, #+12]
   \       0x38   0x2900             CMP      R1,#+0
   \       0x3A   0xD102             BNE.N    ??osSemaphoreNew_3
   1527                    mem = 0;
   \       0x3C   0x2200             MOVS     R2,#+0
   \       0x3E   0xE000             B.N      ??osSemaphoreNew_3
   1528                  }
   1529                }
   1530              }
   1531              else {
   1532                mem = 0;
   \                     ??osSemaphoreNew_1: (+1)
   \       0x40   0x2200             MOVS     R2,#+0
   1533              }
   1534          
   1535              if (mem != -1) {
   \                     ??osSemaphoreNew_3: (+1)
   \       0x42   0xF112 0x0F01      CMN      R2,#+1
   \       0x46   0xD03A             BEQ.N    ??osSemaphoreNew_0
   1536                if (max_count == 1U) {
   \       0x48   0x2801             CMP      R0,#+1
   \       0x4A   0xD122             BNE.N    ??osSemaphoreNew_4
   1537                  if (mem == 1) {
   \       0x4C   0x2A01             CMP      R2,#+1
   \       0x4E   0xD109             BNE.N    ??osSemaphoreNew_5
   1538                    #if (configSUPPORT_STATIC_ALLOCATION == 1)
   1539                      hSemaphore = xSemaphoreCreateBinaryStatic ((StaticSemaphore_t *)attr->cb_mem);
   \       0x50   0x2003             MOVS     R0,#+3
   \       0x52   0x9000             STR      R0,[SP, #+0]
   \       0x54   0x68AB             LDR      R3,[R5, #+8]
   \       0x56   0x2200             MOVS     R2,#+0
   \       0x58   0x2100             MOVS     R1,#+0
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0x.... 0x....      BL       xQueueGenericCreateStatic
   \       0x60   0x0004             MOVS     R4,R0
   \       0x62   0xE005             B.N      ??osSemaphoreNew_6
   1540                    #endif
   1541                  }
   1542                  else {
   1543                    #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
   1544                      hSemaphore = xSemaphoreCreateBinary();
   \                     ??osSemaphoreNew_5: (+1)
   \       0x64   0x2203             MOVS     R2,#+3
   \       0x66   0x2100             MOVS     R1,#+0
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0x.... 0x....      BL       xQueueGenericCreate
   \       0x6E   0x0004             MOVS     R4,R0
   1545                    #endif
   1546                  }
   1547          
   1548                  if ((hSemaphore != NULL) && (initial_count != 0U)) {
   \                     ??osSemaphoreNew_6: (+1)
   \       0x70   0x2C00             CMP      R4,#+0
   \       0x72   0xD01A             BEQ.N    ??osSemaphoreNew_7
   \       0x74   0x2E00             CMP      R6,#+0
   \       0x76   0xD018             BEQ.N    ??osSemaphoreNew_7
   1549                    if (xSemaphoreGive (hSemaphore) != pdPASS) {
   \       0x78   0x2300             MOVS     R3,#+0
   \       0x7A   0x2200             MOVS     R2,#+0
   \       0x7C   0x2100             MOVS     R1,#+0
   \       0x7E   0x0020             MOVS     R0,R4
   \       0x80   0x.... 0x....      BL       xQueueGenericSend
   \       0x84   0x2801             CMP      R0,#+1
   \       0x86   0xD010             BEQ.N    ??osSemaphoreNew_7
   1550                      vSemaphoreDelete (hSemaphore);
   \       0x88   0x0020             MOVS     R0,R4
   \       0x8A   0x.... 0x....      BL       vQueueDelete
   1551                      hSemaphore = NULL;
   \       0x8E   0x2400             MOVS     R4,#+0
   \       0x90   0xE00B             B.N      ??osSemaphoreNew_7
   1552                    }
   1553                  }
   1554                }
   1555                else {
   1556                  if (mem == 1) {
   \                     ??osSemaphoreNew_4: (+1)
   \       0x92   0x2A01             CMP      R2,#+1
   \       0x94   0xD105             BNE.N    ??osSemaphoreNew_8
   1557                    #if (configSUPPORT_STATIC_ALLOCATION == 1)
   1558                      hSemaphore = xSemaphoreCreateCountingStatic (max_count, initial_count, (StaticSemaphore_t *)attr->cb_mem);
   \       0x96   0x68AA             LDR      R2,[R5, #+8]
   \       0x98   0x0031             MOVS     R1,R6
   \       0x9A   0x.... 0x....      BL       xQueueCreateCountingSemaphoreStatic
   \       0x9E   0x0004             MOVS     R4,R0
   \       0xA0   0xE003             B.N      ??osSemaphoreNew_7
   1559                    #endif
   1560                  }
   1561                  else {
   1562                    #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
   1563                      hSemaphore = xSemaphoreCreateCounting (max_count, initial_count);
   \                     ??osSemaphoreNew_8: (+1)
   \       0xA2   0x0031             MOVS     R1,R6
   \       0xA4   0x.... 0x....      BL       xQueueCreateCountingSemaphore
   \       0xA8   0x0004             MOVS     R4,R0
   1564                    #endif
   1565                  }
   1566                }
   1567                
   1568                #if (configQUEUE_REGISTRY_SIZE > 0)
   1569                if (hSemaphore != NULL) {
   \                     ??osSemaphoreNew_7: (+1)
   \       0xAA   0x2C00             CMP      R4,#+0
   \       0xAC   0xD007             BEQ.N    ??osSemaphoreNew_0
   1570                  if (attr != NULL) {
   \       0xAE   0x2D00             CMP      R5,#+0
   \       0xB0   0xD001             BEQ.N    ??osSemaphoreNew_9
   1571                    name = attr->name;
   \       0xB2   0x6829             LDR      R1,[R5, #+0]
   \       0xB4   0xE000             B.N      ??osSemaphoreNew_10
   1572                  } else {
   1573                    name = NULL;
   \                     ??osSemaphoreNew_9: (+1)
   \       0xB6   0x2100             MOVS     R1,#+0
   1574                  }
   1575                  vQueueAddToRegistry (hSemaphore, name);
   \                     ??osSemaphoreNew_10: (+1)
   \       0xB8   0x0020             MOVS     R0,R4
   \       0xBA   0x.... 0x....      BL       vQueueAddToRegistry
   1576                }
   1577                #endif
   1578              }
   1579            }
   1580          
   1581            return ((osSemaphoreId_t)hSemaphore);
   \                     ??osSemaphoreNew_0: (+1)
   \       0xBE   0x0020             MOVS     R0,R4
   \       0xC0   0xBD76             POP      {R1,R2,R4-R6,PC}
   1582          }
   1583          

   \                                 In section .text, align 2, keep-with-next
   1584          osStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout) {
   \                     osSemaphoreAcquire: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x000C             MOVS     R4,R1
   1585            SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
   1586            osStatus_t stat;
   1587            BaseType_t yield;
   1588          
   1589            stat = osOK;
   \        0x4   0x2500             MOVS     R5,#+0
   1590          
   1591            if (hSemaphore == NULL) {
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD102             BNE.N    ??osSemaphoreAcquire_0
   1592              stat = osErrorParameter;
   \        0xA   0xF07F 0x0503      MVNS     R5,#+3
   \        0xE   0xE02B             B.N      ??osSemaphoreAcquire_1
   1593            }
   1594            else if (IS_IRQ()) {
   \                     ??osSemaphoreAcquire_0: (+1)
   \       0x10   0xF3EF 0x8105      MRS      R1,IPSR
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD01B             BEQ.N    ??osSemaphoreAcquire_2
   1595              if (timeout != 0U) {
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD002             BEQ.N    ??osSemaphoreAcquire_3
   1596                stat = osErrorParameter;
   \       0x1C   0xF07F 0x0503      MVNS     R5,#+3
   \       0x20   0xE022             B.N      ??osSemaphoreAcquire_1
   1597              }
   1598              else {
   1599                yield = pdFALSE;
   \                     ??osSemaphoreAcquire_3: (+1)
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x9100             STR      R1,[SP, #+0]
   1600          
   1601                if (xSemaphoreTakeFromISR (hSemaphore, &yield) != pdPASS) {
   \       0x26   0x466A             MOV      R2,SP
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x.... 0x....      BL       xQueueReceiveFromISR
   \       0x2E   0x2801             CMP      R0,#+1
   \       0x30   0xD002             BEQ.N    ??osSemaphoreAcquire_4
   1602                  stat = osErrorResource;
   \       0x32   0xF07F 0x0502      MVNS     R5,#+2
   \       0x36   0xE017             B.N      ??osSemaphoreAcquire_1
   1603                } else {
   1604                  portYIELD_FROM_ISR (yield);
   \                     ??osSemaphoreAcquire_4: (+1)
   \       0x38   0x9800             LDR      R0,[SP, #+0]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD014             BEQ.N    ??osSemaphoreAcquire_1
   \       0x3E   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0x42   0x....             LDR.N    R1,??DataTable16
   \       0x44   0x6008             STR      R0,[R1, #+0]
   \       0x46   0xF3BF 0x8F4F      DSB      SY
   \       0x4A   0xF3BF 0x8F6F      ISB      SY
   \       0x4E   0xE00B             B.N      ??osSemaphoreAcquire_1
   1605                }
   1606              }
   1607            }
   1608            else {
   1609              if (xSemaphoreTake (hSemaphore, (TickType_t)timeout) != pdPASS) {
   \                     ??osSemaphoreAcquire_2: (+1)
   \       0x50   0x0021             MOVS     R1,R4
   \       0x52   0x.... 0x....      BL       xQueueSemaphoreTake
   \       0x56   0x2801             CMP      R0,#+1
   \       0x58   0xD006             BEQ.N    ??osSemaphoreAcquire_1
   1610                if (timeout != 0U) {
   \       0x5A   0x2C00             CMP      R4,#+0
   \       0x5C   0xD002             BEQ.N    ??osSemaphoreAcquire_5
   1611                  stat = osErrorTimeout;
   \       0x5E   0xF07F 0x0501      MVNS     R5,#+1
   \       0x62   0xE001             B.N      ??osSemaphoreAcquire_1
   1612                } else {
   1613                  stat = osErrorResource;
   \                     ??osSemaphoreAcquire_5: (+1)
   \       0x64   0xF07F 0x0502      MVNS     R5,#+2
   1614                }
   1615              }
   1616            }
   1617          
   1618            return (stat);
   \                     ??osSemaphoreAcquire_1: (+1)
   \       0x68   0x0028             MOVS     R0,R5
   \       0x6A   0xBD32             POP      {R1,R4,R5,PC}
   1619          }
   1620          

   \                                 In section .text, align 2, keep-with-next
   1621          osStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id) {
   \                     osSemaphoreRelease: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   1622            SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
   1623            osStatus_t stat;
   1624            BaseType_t yield;
   1625          
   1626            stat = osOK;
   \        0x2   0x2400             MOVS     R4,#+0
   1627          
   1628            if (hSemaphore == NULL) {
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD102             BNE.N    ??osSemaphoreRelease_0
   1629              stat = osErrorParameter;
   \        0x8   0xF07F 0x0403      MVNS     R4,#+3
   \        0xC   0xE022             B.N      ??osSemaphoreRelease_1
   1630            }
   1631            else if (IS_IRQ()) {
   \                     ??osSemaphoreRelease_0: (+1)
   \        0xE   0xF3EF 0x8105      MRS      R1,IPSR
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD015             BEQ.N    ??osSemaphoreRelease_2
   1632              yield = pdFALSE;
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x9100             STR      R1,[SP, #+0]
   1633          
   1634              if (xSemaphoreGiveFromISR (hSemaphore, &yield) != pdTRUE) {
   \       0x1A   0x4669             MOV      R1,SP
   \       0x1C   0x.... 0x....      BL       xQueueGiveFromISR
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD002             BEQ.N    ??osSemaphoreRelease_3
   1635                stat = osErrorResource;
   \       0x24   0xF07F 0x0402      MVNS     R4,#+2
   \       0x28   0xE014             B.N      ??osSemaphoreRelease_1
   1636              } else {
   1637                portYIELD_FROM_ISR (yield);
   \                     ??osSemaphoreRelease_3: (+1)
   \       0x2A   0x9800             LDR      R0,[SP, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD011             BEQ.N    ??osSemaphoreRelease_1
   \       0x30   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0x34   0x....             LDR.N    R1,??DataTable16
   \       0x36   0x6008             STR      R0,[R1, #+0]
   \       0x38   0xF3BF 0x8F4F      DSB      SY
   \       0x3C   0xF3BF 0x8F6F      ISB      SY
   \       0x40   0xE008             B.N      ??osSemaphoreRelease_1
   1638              }
   1639            }
   1640            else {
   1641              if (xSemaphoreGive (hSemaphore) != pdPASS) {
   \                     ??osSemaphoreRelease_2: (+1)
   \       0x42   0x2300             MOVS     R3,#+0
   \       0x44   0x2200             MOVS     R2,#+0
   \       0x46   0x2100             MOVS     R1,#+0
   \       0x48   0x.... 0x....      BL       xQueueGenericSend
   \       0x4C   0x2801             CMP      R0,#+1
   \       0x4E   0xD001             BEQ.N    ??osSemaphoreRelease_1
   1642                stat = osErrorResource;
   \       0x50   0xF07F 0x0402      MVNS     R4,#+2
   1643              }
   1644            }
   1645          
   1646            return (stat);
   \                     ??osSemaphoreRelease_1: (+1)
   \       0x54   0x0020             MOVS     R0,R4
   \       0x56   0xBD16             POP      {R1,R2,R4,PC}
   1647          }
   1648          

   \                                 In section .text, align 2, keep-with-next
   1649          uint32_t osSemaphoreGetCount (osSemaphoreId_t semaphore_id) {
   \                     osSemaphoreGetCount: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1650            SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
   1651            uint32_t count;
   1652          
   1653            if (hSemaphore == NULL) {
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD101             BNE.N    ??osSemaphoreGetCount_0
   1654              count = 0U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xE008             B.N      ??osSemaphoreGetCount_1
   1655            }
   1656            else if (IS_IRQ()) {
   \                     ??osSemaphoreGetCount_0: (+1)
   \        0xA   0xF3EF 0x8105      MRS      R1,IPSR
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD002             BEQ.N    ??osSemaphoreGetCount_2
   1657              count = uxQueueMessagesWaitingFromISR (hSemaphore);
   \       0x12   0x.... 0x....      BL       uxQueueMessagesWaitingFromISR
   \       0x16   0xE001             B.N      ??osSemaphoreGetCount_1
   1658            } else {
   1659              count = (uint32_t)uxSemaphoreGetCount (hSemaphore);
   \                     ??osSemaphoreGetCount_2: (+1)
   \       0x18   0x.... 0x....      BL       uxQueueMessagesWaiting
   1660            }
   1661          
   1662            return (count);
   \                     ??osSemaphoreGetCount_1: (+1)
   \       0x1C   0xBD02             POP      {R1,PC}
   1663          }
   1664          

   \                                 In section .text, align 2, keep-with-next
   1665          osStatus_t osSemaphoreDelete (osSemaphoreId_t semaphore_id) {
   \                     osSemaphoreDelete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1666            SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
   1667            osStatus_t stat;
   1668          
   1669          #ifndef USE_FreeRTOS_HEAP_1
   1670            if (IS_IRQ()) {
   \        0x4   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??osSemaphoreDelete_0
   1671              stat = osErrorISR;
   \        0xC   0xF07F 0x0505      MVNS     R5,#+5
   \       0x10   0xE00B             B.N      ??osSemaphoreDelete_1
   1672            }
   1673            else if (hSemaphore == NULL) {
   \                     ??osSemaphoreDelete_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD102             BNE.N    ??osSemaphoreDelete_2
   1674              stat = osErrorParameter;
   \       0x16   0xF07F 0x0503      MVNS     R5,#+3
   \       0x1A   0xE006             B.N      ??osSemaphoreDelete_1
   1675            }
   1676            else {
   1677              #if (configQUEUE_REGISTRY_SIZE > 0)
   1678              vQueueUnregisterQueue (hSemaphore);
   \                     ??osSemaphoreDelete_2: (+1)
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       vQueueUnregisterQueue
   1679              #endif
   1680          
   1681              stat = osOK;
   \       0x22   0x2500             MOVS     R5,#+0
   1682              vSemaphoreDelete (hSemaphore);
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       vQueueDelete
   1683            }
   1684          #else
   1685            stat = osError;
   1686          #endif
   1687          
   1688            return (stat);
   \                     ??osSemaphoreDelete_1: (+1)
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}
   1689          }
   1690          
   1691          /*---------------------------------------------------------------------------*/
   1692          

   \                                 In section .text, align 2, keep-with-next
   1693          osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
   \                     osMessageQueueNew: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0014             MOVS     R4,R2
   1694            QueueHandle_t hQueue;
   1695            int32_t mem;
   1696            #if (configQUEUE_REGISTRY_SIZE > 0)
   1697            const char *name;
   1698            #endif
   1699          
   1700            hQueue = NULL;
   \        0x4   0x2500             MOVS     R5,#+0
   1701          
   1702            if (!IS_IRQ() && (msg_count > 0U) && (msg_size > 0U)) {
   \        0x6   0xF3EF 0x8205      MRS      R2,IPSR
   \        0xA   0x2A00             CMP      R2,#+0
   \        0xC   0xD140             BNE.N    ??osMessageQueueNew_0
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD03E             BEQ.N    ??osMessageQueueNew_0
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD03C             BEQ.N    ??osMessageQueueNew_0
   1703              mem = -1;
   \       0x16   0xF05F 0x33FF      MOVS     R3,#+4294967295
   1704          
   1705              if (attr != NULL) {
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD01D             BEQ.N    ??osMessageQueueNew_1
   1706                if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticQueue_t)) &&
   1707                    (attr->mq_mem != NULL) && (attr->mq_size >= (msg_count * msg_size))) {
   \       0x1E   0x68A2             LDR      R2,[R4, #+8]
   \       0x20   0x2A00             CMP      R2,#+0
   \       0x22   0xD00C             BEQ.N    ??osMessageQueueNew_2
   \       0x24   0x68E2             LDR      R2,[R4, #+12]
   \       0x26   0x2A50             CMP      R2,#+80
   \       0x28   0xD309             BCC.N    ??osMessageQueueNew_2
   \       0x2A   0x6922             LDR      R2,[R4, #+16]
   \       0x2C   0x2A00             CMP      R2,#+0
   \       0x2E   0xD006             BEQ.N    ??osMessageQueueNew_2
   \       0x30   0x6962             LDR      R2,[R4, #+20]
   \       0x32   0xFB01 0xF600      MUL      R6,R1,R0
   \       0x36   0x42B2             CMP      R2,R6
   \       0x38   0xD301             BCC.N    ??osMessageQueueNew_2
   1708                  mem = 1;
   \       0x3A   0x2301             MOVS     R3,#+1
   \       0x3C   0xE00E             B.N      ??osMessageQueueNew_3
   1709                }
   1710                else {
   1711                  if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) &&
   1712                      (attr->mq_mem == NULL) && (attr->mq_size == 0U)) {
   \                     ??osMessageQueueNew_2: (+1)
   \       0x3E   0x68A2             LDR      R2,[R4, #+8]
   \       0x40   0x2A00             CMP      R2,#+0
   \       0x42   0xD10B             BNE.N    ??osMessageQueueNew_3
   \       0x44   0x68E2             LDR      R2,[R4, #+12]
   \       0x46   0x2A00             CMP      R2,#+0
   \       0x48   0xD108             BNE.N    ??osMessageQueueNew_3
   \       0x4A   0x6922             LDR      R2,[R4, #+16]
   \       0x4C   0x2A00             CMP      R2,#+0
   \       0x4E   0xD105             BNE.N    ??osMessageQueueNew_3
   \       0x50   0x6962             LDR      R2,[R4, #+20]
   \       0x52   0x2A00             CMP      R2,#+0
   \       0x54   0xD102             BNE.N    ??osMessageQueueNew_3
   1713                    mem = 0;
   \       0x56   0x2300             MOVS     R3,#+0
   \       0x58   0xE000             B.N      ??osMessageQueueNew_3
   1714                  }
   1715                }
   1716              }
   1717              else {
   1718                mem = 0;
   \                     ??osMessageQueueNew_1: (+1)
   \       0x5A   0x2300             MOVS     R3,#+0
   1719              }
   1720          
   1721              if (mem == 1) {
   \                     ??osMessageQueueNew_3: (+1)
   \       0x5C   0x2B01             CMP      R3,#+1
   \       0x5E   0xD107             BNE.N    ??osMessageQueueNew_4
   1722                #if (configSUPPORT_STATIC_ALLOCATION == 1)
   1723                  hQueue = xQueueCreateStatic (msg_count, msg_size, attr->mq_mem, attr->cb_mem);
   \       0x60   0x2200             MOVS     R2,#+0
   \       0x62   0x9200             STR      R2,[SP, #+0]
   \       0x64   0x68A3             LDR      R3,[R4, #+8]
   \       0x66   0x6922             LDR      R2,[R4, #+16]
   \       0x68   0x.... 0x....      BL       xQueueGenericCreateStatic
   \       0x6C   0x0005             MOVS     R5,R0
   \       0x6E   0xE005             B.N      ??osMessageQueueNew_5
   1724                #endif
   1725              }
   1726              else {
   1727                if (mem == 0) {
   \                     ??osMessageQueueNew_4: (+1)
   \       0x70   0x2B00             CMP      R3,#+0
   \       0x72   0xD103             BNE.N    ??osMessageQueueNew_5
   1728                  #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
   1729                    hQueue = xQueueCreate (msg_count, msg_size);
   \       0x74   0x2200             MOVS     R2,#+0
   \       0x76   0x.... 0x....      BL       xQueueGenericCreate
   \       0x7A   0x0005             MOVS     R5,R0
   1730                  #endif
   1731                }
   1732              }
   1733          
   1734              #if (configQUEUE_REGISTRY_SIZE > 0)
   1735              if (hQueue != NULL) {
   \                     ??osMessageQueueNew_5: (+1)
   \       0x7C   0x2D00             CMP      R5,#+0
   \       0x7E   0xD007             BEQ.N    ??osMessageQueueNew_0
   1736                if (attr != NULL) {
   \       0x80   0x2C00             CMP      R4,#+0
   \       0x82   0xD001             BEQ.N    ??osMessageQueueNew_6
   1737                  name = attr->name;
   \       0x84   0x6821             LDR      R1,[R4, #+0]
   \       0x86   0xE000             B.N      ??osMessageQueueNew_7
   1738                } else {
   1739                  name = NULL;
   \                     ??osMessageQueueNew_6: (+1)
   \       0x88   0x2100             MOVS     R1,#+0
   1740                }
   1741                vQueueAddToRegistry (hQueue, name);
   \                     ??osMessageQueueNew_7: (+1)
   \       0x8A   0x0028             MOVS     R0,R5
   \       0x8C   0x.... 0x....      BL       vQueueAddToRegistry
   1742              }
   1743              #endif
   1744          
   1745            }
   1746          
   1747            return ((osMessageQueueId_t)hQueue);
   \                     ??osMessageQueueNew_0: (+1)
   \       0x90   0x0028             MOVS     R0,R5
   \       0x92   0xBD76             POP      {R1,R2,R4-R6,PC}
   1748          }
   1749          

   \                                 In section .text, align 2, keep-with-next
   1750          osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
   \                     osMessageQueuePut: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x001C             MOVS     R4,R3
   1751            QueueHandle_t hQueue = (QueueHandle_t)mq_id;
   1752            osStatus_t stat;
   1753            BaseType_t yield;
   1754          
   1755            (void)msg_prio; /* Message priority is ignored */
   1756          
   1757            stat = osOK;
   \        0x4   0x2500             MOVS     R5,#+0
   1758          
   1759            if (IS_IRQ()) {
   \        0x6   0xF3EF 0x8205      MRS      R2,IPSR
   \        0xA   0x2A00             CMP      R2,#+0
   \        0xC   0xD01F             BEQ.N    ??osMessageQueuePut_0
   1760              if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD003             BEQ.N    ??osMessageQueuePut_1
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD001             BEQ.N    ??osMessageQueuePut_1
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD002             BEQ.N    ??osMessageQueuePut_2
   1761                stat = osErrorParameter;
   \                     ??osMessageQueuePut_1: (+1)
   \       0x1A   0xF07F 0x0503      MVNS     R5,#+3
   \       0x1E   0xE02A             B.N      ??osMessageQueuePut_3
   1762              }
   1763              else {
   1764                yield = pdFALSE;
   \                     ??osMessageQueuePut_2: (+1)
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x9200             STR      R2,[SP, #+0]
   1765          
   1766                if (xQueueSendToBackFromISR (hQueue, msg_ptr, &yield) != pdTRUE) {
   \       0x24   0x2300             MOVS     R3,#+0
   \       0x26   0x466A             MOV      R2,SP
   \       0x28   0x.... 0x....      BL       xQueueGenericSendFromISR
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD002             BEQ.N    ??osMessageQueuePut_4
   1767                  stat = osErrorResource;
   \       0x30   0xF07F 0x0502      MVNS     R5,#+2
   \       0x34   0xE01F             B.N      ??osMessageQueuePut_3
   1768                } else {
   1769                  portYIELD_FROM_ISR (yield);
   \                     ??osMessageQueuePut_4: (+1)
   \       0x36   0x9800             LDR      R0,[SP, #+0]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD01C             BEQ.N    ??osMessageQueuePut_3
   \       0x3C   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0x40   0x....             LDR.N    R1,??DataTable16
   \       0x42   0x6008             STR      R0,[R1, #+0]
   \       0x44   0xF3BF 0x8F4F      DSB      SY
   \       0x48   0xF3BF 0x8F6F      ISB      SY
   \       0x4C   0xE013             B.N      ??osMessageQueuePut_3
   1770                }
   1771              }
   1772            }
   1773            else {
   1774              if ((hQueue == NULL) || (msg_ptr == NULL)) {
   \                     ??osMessageQueuePut_0: (+1)
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD001             BEQ.N    ??osMessageQueuePut_5
   \       0x52   0x2900             CMP      R1,#+0
   \       0x54   0xD102             BNE.N    ??osMessageQueuePut_6
   1775                stat = osErrorParameter;
   \                     ??osMessageQueuePut_5: (+1)
   \       0x56   0xF07F 0x0503      MVNS     R5,#+3
   \       0x5A   0xE00C             B.N      ??osMessageQueuePut_3
   1776              }
   1777              else {
   1778                if (xQueueSendToBack (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
   \                     ??osMessageQueuePut_6: (+1)
   \       0x5C   0x2300             MOVS     R3,#+0
   \       0x5E   0x0022             MOVS     R2,R4
   \       0x60   0x.... 0x....      BL       xQueueGenericSend
   \       0x64   0x2801             CMP      R0,#+1
   \       0x66   0xD006             BEQ.N    ??osMessageQueuePut_3
   1779                  if (timeout != 0U) {
   \       0x68   0x2C00             CMP      R4,#+0
   \       0x6A   0xD002             BEQ.N    ??osMessageQueuePut_7
   1780                    stat = osErrorTimeout;
   \       0x6C   0xF07F 0x0501      MVNS     R5,#+1
   \       0x70   0xE001             B.N      ??osMessageQueuePut_3
   1781                  } else {
   1782                    stat = osErrorResource;
   \                     ??osMessageQueuePut_7: (+1)
   \       0x72   0xF07F 0x0502      MVNS     R5,#+2
   1783                  }
   1784                }
   1785              }
   1786            }
   1787          
   1788            return (stat);
   \                     ??osMessageQueuePut_3: (+1)
   \       0x76   0x0028             MOVS     R0,R5
   \       0x78   0xBD32             POP      {R1,R4,R5,PC}
   1789          }
   1790          

   \                                 In section .text, align 2, keep-with-next
   1791          osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
   \                     osMessageQueueGet: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x001C             MOVS     R4,R3
   1792            QueueHandle_t hQueue = (QueueHandle_t)mq_id;
   1793            osStatus_t stat;
   1794            BaseType_t yield;
   1795          
   1796            (void)msg_prio; /* Message priority is ignored */
   1797          
   1798            stat = osOK;
   \        0x4   0x2500             MOVS     R5,#+0
   1799          
   1800            if (IS_IRQ()) {
   \        0x6   0xF3EF 0x8205      MRS      R2,IPSR
   \        0xA   0x2A00             CMP      R2,#+0
   \        0xC   0xD01F             BEQ.N    ??osMessageQueueGet_0
   1801              if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD003             BEQ.N    ??osMessageQueueGet_1
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD001             BEQ.N    ??osMessageQueueGet_1
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD002             BEQ.N    ??osMessageQueueGet_2
   1802                stat = osErrorParameter;
   \                     ??osMessageQueueGet_1: (+1)
   \       0x1A   0xF07F 0x0503      MVNS     R5,#+3
   \       0x1E   0xE029             B.N      ??osMessageQueueGet_3
   1803              }
   1804              else {
   1805                yield = pdFALSE;
   \                     ??osMessageQueueGet_2: (+1)
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x9200             STR      R2,[SP, #+0]
   1806          
   1807                if (xQueueReceiveFromISR (hQueue, msg_ptr, &yield) != pdPASS) {
   \       0x24   0x466A             MOV      R2,SP
   \       0x26   0x.... 0x....      BL       xQueueReceiveFromISR
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD002             BEQ.N    ??osMessageQueueGet_4
   1808                  stat = osErrorResource;
   \       0x2E   0xF07F 0x0502      MVNS     R5,#+2
   \       0x32   0xE01F             B.N      ??osMessageQueueGet_3
   1809                } else {
   1810                  portYIELD_FROM_ISR (yield);
   \                     ??osMessageQueueGet_4: (+1)
   \       0x34   0x9800             LDR      R0,[SP, #+0]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD01C             BEQ.N    ??osMessageQueueGet_3
   \       0x3A   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0x3E   0x.... 0x....      LDR.W    R1,??DataTable24
   \       0x42   0x6008             STR      R0,[R1, #+0]
   \       0x44   0xF3BF 0x8F4F      DSB      SY
   \       0x48   0xF3BF 0x8F6F      ISB      SY
   \       0x4C   0xE012             B.N      ??osMessageQueueGet_3
   1811                }
   1812              }
   1813            }
   1814            else {
   1815              if ((hQueue == NULL) || (msg_ptr == NULL)) {
   \                     ??osMessageQueueGet_0: (+1)
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD001             BEQ.N    ??osMessageQueueGet_5
   \       0x52   0x2900             CMP      R1,#+0
   \       0x54   0xD102             BNE.N    ??osMessageQueueGet_6
   1816                stat = osErrorParameter;
   \                     ??osMessageQueueGet_5: (+1)
   \       0x56   0xF07F 0x0503      MVNS     R5,#+3
   \       0x5A   0xE00B             B.N      ??osMessageQueueGet_3
   1817              }
   1818              else {
   1819                if (xQueueReceive (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
   \                     ??osMessageQueueGet_6: (+1)
   \       0x5C   0x0022             MOVS     R2,R4
   \       0x5E   0x.... 0x....      BL       xQueueReceive
   \       0x62   0x2801             CMP      R0,#+1
   \       0x64   0xD006             BEQ.N    ??osMessageQueueGet_3
   1820                  if (timeout != 0U) {
   \       0x66   0x2C00             CMP      R4,#+0
   \       0x68   0xD002             BEQ.N    ??osMessageQueueGet_7
   1821                    stat = osErrorTimeout;
   \       0x6A   0xF07F 0x0501      MVNS     R5,#+1
   \       0x6E   0xE001             B.N      ??osMessageQueueGet_3
   1822                  } else {
   1823                    stat = osErrorResource;
   \                     ??osMessageQueueGet_7: (+1)
   \       0x70   0xF07F 0x0502      MVNS     R5,#+2
   1824                  }
   1825                }
   1826              }
   1827            }
   1828          
   1829            return (stat);
   \                     ??osMessageQueueGet_3: (+1)
   \       0x74   0x0028             MOVS     R0,R5
   \       0x76   0xBD32             POP      {R1,R4,R5,PC}
   1830          }
   1831          

   \                                 In section .text, align 2, keep-with-next
   1832          uint32_t osMessageQueueGetCapacity (osMessageQueueId_t mq_id) {
   1833            StaticQueue_t *mq = (StaticQueue_t *)mq_id;
   1834            uint32_t capacity;
   1835          
   1836            if (mq == NULL) {
   \                     osMessageQueueGetCapacity: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??osMessageQueueGetCapacity_0
   1837              capacity = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xE000             B.N      ??osMessageQueueGetCapacity_1
   1838            } else {
   1839              /* capacity = pxQueue->uxLength */
   1840              capacity = mq->uxDummy4[1];
   \                     ??osMessageQueueGetCapacity_0: (+1)
   \        0x8   0x6BC0             LDR      R0,[R0, #+60]
   1841            }
   1842          
   1843            return (capacity);
   \                     ??osMessageQueueGetCapacity_1: (+1)
   \        0xA   0x4770             BX       LR
   1844          }
   1845          

   \                                 In section .text, align 2, keep-with-next
   1846          uint32_t osMessageQueueGetMsgSize (osMessageQueueId_t mq_id) {
   1847            StaticQueue_t *mq = (StaticQueue_t *)mq_id;
   1848            uint32_t size;
   1849          
   1850            if (mq == NULL) {
   \                     osMessageQueueGetMsgSize: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??osMessageQueueGetMsgSize_0
   1851              size = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xE000             B.N      ??osMessageQueueGetMsgSize_1
   1852            } else {
   1853              /* size = pxQueue->uxItemSize */
   1854              size = mq->uxDummy4[2];
   \                     ??osMessageQueueGetMsgSize_0: (+1)
   \        0x8   0x6C00             LDR      R0,[R0, #+64]
   1855            }
   1856          
   1857            return (size);
   \                     ??osMessageQueueGetMsgSize_1: (+1)
   \        0xA   0x4770             BX       LR
   1858          }
   1859          

   \                                 In section .text, align 2, keep-with-next
   1860          uint32_t osMessageQueueGetCount (osMessageQueueId_t mq_id) {
   \                     osMessageQueueGetCount: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1861            QueueHandle_t hQueue = (QueueHandle_t)mq_id;
   1862            UBaseType_t count;
   1863          
   1864            if (hQueue == NULL) {
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD101             BNE.N    ??osMessageQueueGetCount_0
   1865              count = 0U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xE008             B.N      ??osMessageQueueGetCount_1
   1866            }
   1867            else if (IS_IRQ()) {
   \                     ??osMessageQueueGetCount_0: (+1)
   \        0xA   0xF3EF 0x8105      MRS      R1,IPSR
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD002             BEQ.N    ??osMessageQueueGetCount_2
   1868              count = uxQueueMessagesWaitingFromISR (hQueue);
   \       0x12   0x.... 0x....      BL       uxQueueMessagesWaitingFromISR
   \       0x16   0xE001             B.N      ??osMessageQueueGetCount_1
   1869            }
   1870            else {
   1871              count = uxQueueMessagesWaiting (hQueue);
   \                     ??osMessageQueueGetCount_2: (+1)
   \       0x18   0x.... 0x....      BL       uxQueueMessagesWaiting
   1872            }
   1873          
   1874            return ((uint32_t)count);
   \                     ??osMessageQueueGetCount_1: (+1)
   \       0x1C   0xBD02             POP      {R1,PC}
   1875          }
   1876          

   \                                 In section .text, align 2, keep-with-next
   1877          uint32_t osMessageQueueGetSpace (osMessageQueueId_t mq_id) {
   \                     osMessageQueueGetSpace: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1878            StaticQueue_t *mq = (StaticQueue_t *)mq_id;
   1879            uint32_t space;
   1880            uint32_t isrm;
   1881          
   1882            if (mq == NULL) {
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD101             BNE.N    ??osMessageQueueGetSpace_0
   1883              space = 0U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xE014             B.N      ??osMessageQueueGetSpace_1
   1884            }
   1885            else if (IS_IRQ()) {
   \                     ??osMessageQueueGetSpace_0: (+1)
   \        0xA   0xF3EF 0x8105      MRS      R1,IPSR
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD00E             BEQ.N    ??osMessageQueueGetSpace_2
   1886              isrm = taskENTER_CRITICAL_FROM_ISR();
   \       0x12   0xF3EF 0x8111      MRS      R1,BASEPRI
   \       0x16   0x2250             MOVS     R2,#+80
   \       0x18   0xF382 0x8811      MSR      BASEPRI,R2
   \       0x1C   0xF3BF 0x8F4F      DSB      SY
   \       0x20   0xF3BF 0x8F6F      ISB      SY
   1887          
   1888              /* space = pxQueue->uxLength - pxQueue->uxMessagesWaiting; */
   1889              space = mq->uxDummy4[1] - mq->uxDummy4[0];
   \       0x24   0x6BC2             LDR      R2,[R0, #+60]
   \       0x26   0x6B80             LDR      R0,[R0, #+56]
   \       0x28   0x1A10             SUBS     R0,R2,R0
   1890          
   1891              taskEXIT_CRITICAL_FROM_ISR(isrm);
   \       0x2A   0xF381 0x8811      MSR      BASEPRI,R1
   \       0x2E   0xE001             B.N      ??osMessageQueueGetSpace_1
   1892            }
   1893            else {
   1894              space = (uint32_t)uxQueueSpacesAvailable ((QueueHandle_t)mq);
   \                     ??osMessageQueueGetSpace_2: (+1)
   \       0x30   0x.... 0x....      BL       uxQueueSpacesAvailable
   1895            }
   1896          
   1897            return (space);
   \                     ??osMessageQueueGetSpace_1: (+1)
   \       0x34   0xBD02             POP      {R1,PC}
   1898          }
   1899          

   \                                 In section .text, align 2, keep-with-next
   1900          osStatus_t osMessageQueueReset (osMessageQueueId_t mq_id) {
   \                     osMessageQueueReset: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1901            QueueHandle_t hQueue = (QueueHandle_t)mq_id;
   1902            osStatus_t stat;
   1903          
   1904            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD002             BEQ.N    ??osMessageQueueReset_0
   1905              stat = osErrorISR;
   \        0xA   0xF07F 0x0405      MVNS     R4,#+5
   \        0xE   0xE008             B.N      ??osMessageQueueReset_1
   1906            }
   1907            else if (hQueue == NULL) {
   \                     ??osMessageQueueReset_0: (+1)
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD102             BNE.N    ??osMessageQueueReset_2
   1908              stat = osErrorParameter;
   \       0x14   0xF07F 0x0403      MVNS     R4,#+3
   \       0x18   0xE003             B.N      ??osMessageQueueReset_1
   1909            }
   1910            else {
   1911              stat = osOK;
   \                     ??osMessageQueueReset_2: (+1)
   \       0x1A   0x2400             MOVS     R4,#+0
   1912              (void)xQueueReset (hQueue);
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x.... 0x....      BL       xQueueGenericReset
   1913            }
   1914          
   1915            return (stat);
   \                     ??osMessageQueueReset_1: (+1)
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0xBD10             POP      {R4,PC}
   1916          }
   1917          

   \                                 In section .text, align 2, keep-with-next
   1918          osStatus_t osMessageQueueDelete (osMessageQueueId_t mq_id) {
   \                     osMessageQueueDelete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1919            QueueHandle_t hQueue = (QueueHandle_t)mq_id;
   1920            osStatus_t stat;
   1921          
   1922          #ifndef USE_FreeRTOS_HEAP_1
   1923            if (IS_IRQ()) {
   \        0x4   0xF3EF 0x8005      MRS      R0,IPSR
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??osMessageQueueDelete_0
   1924              stat = osErrorISR;
   \        0xC   0xF07F 0x0505      MVNS     R5,#+5
   \       0x10   0xE00B             B.N      ??osMessageQueueDelete_1
   1925            }
   1926            else if (hQueue == NULL) {
   \                     ??osMessageQueueDelete_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD102             BNE.N    ??osMessageQueueDelete_2
   1927              stat = osErrorParameter;
   \       0x16   0xF07F 0x0503      MVNS     R5,#+3
   \       0x1A   0xE006             B.N      ??osMessageQueueDelete_1
   1928            }
   1929            else {
   1930              #if (configQUEUE_REGISTRY_SIZE > 0)
   1931              vQueueUnregisterQueue (hQueue);
   \                     ??osMessageQueueDelete_2: (+1)
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       vQueueUnregisterQueue
   1932              #endif
   1933          
   1934              stat = osOK;
   \       0x22   0x2500             MOVS     R5,#+0
   1935              vQueueDelete (hQueue);
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       vQueueDelete
   1936            }
   1937          #else
   1938            stat = osError;
   1939          #endif
   1940          
   1941            return (stat);
   \                     ??osMessageQueueDelete_1: (+1)
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0xBD32             POP      {R1,R4,R5,PC}
   1942          }
   1943          
   1944          /*---------------------------------------------------------------------------*/
   1945          #ifdef FREERTOS_MPOOL_H_
   1946          
   1947          /* Static memory pool functions */
   1948          static void  FreeBlock   (MemPool_t *mp, void *block);
   1949          static void *AllocBlock  (MemPool_t *mp);
   1950          static void *CreateBlock (MemPool_t *mp);
   1951          

   \                                 In section .text, align 2, keep-with-next
   1952          osMemoryPoolId_t osMemoryPoolNew (uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t *attr) {
   \                     osMemoryPoolNew: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4691             MOV      R9,R2
   1953            MemPool_t *mp;
   1954            const char *name;
   1955            int32_t mem_cb, mem_mp;
   1956            uint32_t sz;
   1957          
   1958            if (IS_IRQ()) {
   \        0xA   0xF3EF 0x8005      MRS      R0,IPSR
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD001             BEQ.N    ??osMemoryPoolNew_0
   1959              mp = NULL;
   \       0x12   0x2500             MOVS     R5,#+0
   \       0x14   0xE08F             B.N      ??osMemoryPoolNew_1
   1960            }
   1961            else if ((block_count == 0U) || (block_size == 0U)) {
   \                     ??osMemoryPoolNew_0: (+1)
   \       0x16   0x2F00             CMP      R7,#+0
   \       0x18   0xD002             BEQ.N    ??osMemoryPoolNew_2
   \       0x1A   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x1E   0xD101             BNE.N    ??osMemoryPoolNew_3
   1962              mp = NULL;
   \                     ??osMemoryPoolNew_2: (+1)
   \       0x20   0x2500             MOVS     R5,#+0
   \       0x22   0xE088             B.N      ??osMemoryPoolNew_1
   1963            }
   1964            else {
   1965              mp = NULL;
   \                     ??osMemoryPoolNew_3: (+1)
   \       0x24   0x2000             MOVS     R0,#+0
   1966              sz = MEMPOOL_ARR_SIZE (block_count, block_size);
   \       0x26   0xF118 0x0003      ADDS     R0,R8,#+3
   \       0x2A   0x0880             LSRS     R0,R0,#+2
   \       0x2C   0x4378             MULS     R0,R7,R0
   \       0x2E   0xEA5F 0x0A80      LSLS     R10,R0,#+2
   1967          
   1968              name = NULL;
   \       0x32   0xF05F 0x0B00      MOVS     R11,#+0
   1969              mem_cb = -1;
   \       0x36   0xF05F 0x36FF      MOVS     R6,#+4294967295
   \       0x3A   0x0034             MOVS     R4,R6
   1970              mem_mp = -1;
   1971          
   1972              if (attr != NULL) {
   \       0x3C   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x40   0xD031             BEQ.N    ??osMemoryPoolNew_4
   1973                if (attr->name != NULL) {
   \       0x42   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD001             BEQ.N    ??osMemoryPoolNew_5
   1974                  name = attr->name;
   \       0x4A   0xF8D9 0xB000      LDR      R11,[R9, #+0]
   1975                }
   1976          
   1977                if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(MemPool_t))) {
   \                     ??osMemoryPoolNew_5: (+1)
   \       0x4E   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD005             BEQ.N    ??osMemoryPoolNew_6
   \       0x56   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \       0x5A   0x2874             CMP      R0,#+116
   \       0x5C   0xD301             BCC.N    ??osMemoryPoolNew_6
   1978                  /* Static control block is provided */
   1979                  mem_cb = 1;
   \       0x5E   0x2401             MOVS     R4,#+1
   \       0x60   0xE008             B.N      ??osMemoryPoolNew_7
   1980                }
   1981                else if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
   \                     ??osMemoryPoolNew_6: (+1)
   \       0x62   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD104             BNE.N    ??osMemoryPoolNew_7
   \       0x6A   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD100             BNE.N    ??osMemoryPoolNew_7
   1982                  /* Allocate control block memory on heap */
   1983                  mem_cb = 0;
   \       0x72   0x2400             MOVS     R4,#+0
   1984                }
   1985          
   1986                if ((attr->mp_mem == NULL) && (attr->mp_size == 0U)) {
   \                     ??osMemoryPoolNew_7: (+1)
   \       0x74   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD105             BNE.N    ??osMemoryPoolNew_8
   \       0x7C   0xF8D9 0x0014      LDR      R0,[R9, #+20]
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD101             BNE.N    ??osMemoryPoolNew_8
   1987                  /* Allocate memory array on heap */
   1988                    mem_mp = 0;
   \       0x84   0x2600             MOVS     R6,#+0
   \       0x86   0xE010             B.N      ??osMemoryPoolNew_9
   1989                }
   1990                else {
   1991                  if (attr->mp_mem != NULL) {
   \                     ??osMemoryPoolNew_8: (+1)
   \       0x88   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD00C             BEQ.N    ??osMemoryPoolNew_9
   1992                    /* Check if array is 4-byte aligned */
   1993                    if (((uint32_t)attr->mp_mem & 3U) == 0U) {
   \       0x90   0xF899 0x0010      LDRB     R0,[R9, #+16]
   \       0x94   0xF010 0x0F03      TST      R0,#0x3
   \       0x98   0xD107             BNE.N    ??osMemoryPoolNew_9
   1994                      /* Check if array big enough */
   1995                      if (attr->mp_size >= sz) {
   \       0x9A   0xF8D9 0x0014      LDR      R0,[R9, #+20]
   \       0x9E   0x4550             CMP      R0,R10
   \       0xA0   0xD303             BCC.N    ??osMemoryPoolNew_9
   1996                        /* Static memory pool array is provided */
   1997                        mem_mp = 1;
   \       0xA2   0x2601             MOVS     R6,#+1
   \       0xA4   0xE001             B.N      ??osMemoryPoolNew_9
   1998                      }
   1999                    }
   2000                  }
   2001                }
   2002              }
   2003              else {
   2004                /* Attributes not provided, allocate memory on heap */
   2005                mem_cb = 0;
   \                     ??osMemoryPoolNew_4: (+1)
   \       0xA6   0x2400             MOVS     R4,#+0
   2006                mem_mp = 0;
   \       0xA8   0x2600             MOVS     R6,#+0
   2007              }
   2008          
   2009              if (mem_cb == 0) {
   \                     ??osMemoryPoolNew_9: (+1)
   \       0xAA   0x2C00             CMP      R4,#+0
   \       0xAC   0xD104             BNE.N    ??osMemoryPoolNew_10
   2010                mp = pvPortMalloc (sizeof(MemPool_t));
   \       0xAE   0x2074             MOVS     R0,#+116
   \       0xB0   0x.... 0x....      BL       pvPortMalloc
   \       0xB4   0x0005             MOVS     R5,R0
   \       0xB6   0xE001             B.N      ??osMemoryPoolNew_11
   2011              } else {
   2012                mp = attr->cb_mem;
   \                     ??osMemoryPoolNew_10: (+1)
   \       0xB8   0xF8D9 0x5008      LDR      R5,[R9, #+8]
   2013              }
   2014          
   2015              if (mp != NULL) {
   \                     ??osMemoryPoolNew_11: (+1)
   \       0xBC   0x2D00             CMP      R5,#+0
   \       0xBE   0xD013             BEQ.N    ??osMemoryPoolNew_12
   2016                /* Create a semaphore (max count == initial count == block_count) */
   2017                #if (configSUPPORT_STATIC_ALLOCATION == 1)
   2018                  mp->sem = xSemaphoreCreateCountingStatic (block_count, block_count, &mp->mem_sem);
   \       0xC0   0xF115 0x0224      ADDS     R2,R5,#+36
   \       0xC4   0x0039             MOVS     R1,R7
   \       0xC6   0x0038             MOVS     R0,R7
   \       0xC8   0x.... 0x....      BL       xQueueCreateCountingSemaphoreStatic
   \       0xCC   0x6068             STR      R0,[R5, #+4]
   2019                #elif (configSUPPORT_DYNAMIC_ALLOCATION == 1)
   2020                  mp->sem = xSemaphoreCreateCounting (block_count, block_count);
   2021                #else
   2022                  mp->sem == NULL;
   2023                #endif
   2024          
   2025                if (mp->sem != NULL) {
   \       0xCE   0x6868             LDR      R0,[R5, #+4]
   \       0xD0   0x2800             CMP      R0,#+0
   \       0xD2   0xD009             BEQ.N    ??osMemoryPoolNew_12
   2026                  /* Setup memory array */
   2027                  if (mem_mp == 0) {
   \       0xD4   0x2E00             CMP      R6,#+0
   \       0xD6   0xD104             BNE.N    ??osMemoryPoolNew_13
   2028                    mp->mem_arr = pvPortMalloc (sz);
   \       0xD8   0x4650             MOV      R0,R10
   \       0xDA   0x.... 0x....      BL       pvPortMalloc
   \       0xDE   0x60A8             STR      R0,[R5, #+8]
   \       0xE0   0xE002             B.N      ??osMemoryPoolNew_12
   2029                  } else {
   2030                    mp->mem_arr = attr->mp_mem;
   \                     ??osMemoryPoolNew_13: (+1)
   \       0xE2   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \       0xE6   0x60A8             STR      R0,[R5, #+8]
   2031                  }
   2032                }
   2033              }
   2034          
   2035              if ((mp != NULL) && (mp->mem_arr != NULL)) {
   \                     ??osMemoryPoolNew_12: (+1)
   \       0xE8   0x2D00             CMP      R5,#+0
   \       0xEA   0xD01C             BEQ.N    ??osMemoryPoolNew_14
   \       0xEC   0x68A8             LDR      R0,[R5, #+8]
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD019             BEQ.N    ??osMemoryPoolNew_14
   2036                /* Memory pool can be created */
   2037                mp->head    = NULL;
   \       0xF2   0x2000             MOVS     R0,#+0
   \       0xF4   0x6028             STR      R0,[R5, #+0]
   2038                mp->mem_sz  = sz;
   \       0xF6   0xF8C5 0xA00C      STR      R10,[R5, #+12]
   2039                mp->name    = name;
   \       0xFA   0xF8C5 0xB010      STR      R11,[R5, #+16]
   2040                mp->bl_sz   = block_size;
   \       0xFE   0xF8C5 0x8014      STR      R8,[R5, #+20]
   2041                mp->bl_cnt  = block_count;
   \      0x102   0x61AF             STR      R7,[R5, #+24]
   2042                mp->n       = 0U;
   \      0x104   0x2000             MOVS     R0,#+0
   \      0x106   0x61E8             STR      R0,[R5, #+28]
   2043          
   2044                /* Set heap allocated memory flags */
   2045                mp->status = MPOOL_STATUS;
   \      0x108   0x....             LDR.N    R0,??DataTable24_1
   \      0x10A   0x6228             STR      R0,[R5, #+32]
   2046          
   2047                if (mem_cb == 0) {
   \      0x10C   0x2C00             CMP      R4,#+0
   \      0x10E   0xD103             BNE.N    ??osMemoryPoolNew_15
   2048                  /* Control block on heap */
   2049                  mp->status |= 1U;
   \      0x110   0x6A28             LDR      R0,[R5, #+32]
   \      0x112   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x116   0x6228             STR      R0,[R5, #+32]
   2050                }
   2051                if (mem_mp == 0) {
   \                     ??osMemoryPoolNew_15: (+1)
   \      0x118   0x2E00             CMP      R6,#+0
   \      0x11A   0xD10C             BNE.N    ??osMemoryPoolNew_1
   2052                  /* Memory array on heap */
   2053                  mp->status |= 2U;
   \      0x11C   0x6A28             LDR      R0,[R5, #+32]
   \      0x11E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \      0x122   0x6228             STR      R0,[R5, #+32]
   \      0x124   0xE007             B.N      ??osMemoryPoolNew_1
   2054                }
   2055              }
   2056              else {
   2057                /* Memory pool cannot be created, release allocated resources */
   2058                if ((mem_cb == 0) && (mp != NULL)) {
   \                     ??osMemoryPoolNew_14: (+1)
   \      0x126   0x2C00             CMP      R4,#+0
   \      0x128   0xD104             BNE.N    ??osMemoryPoolNew_16
   \      0x12A   0x2D00             CMP      R5,#+0
   \      0x12C   0xD002             BEQ.N    ??osMemoryPoolNew_16
   2059                  /* Free control block memory */
   2060                  vPortFree (mp);
   \      0x12E   0x0028             MOVS     R0,R5
   \      0x130   0x.... 0x....      BL       vPortFree
   2061                }
   2062                mp = NULL;
   \                     ??osMemoryPoolNew_16: (+1)
   \      0x134   0x2500             MOVS     R5,#+0
   2063              }
   2064            }
   2065          
   2066            return (mp);
   \                     ??osMemoryPoolNew_1: (+1)
   \      0x136   0x0028             MOVS     R0,R5
   \      0x138   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   2067          }
   2068          

   \                                 In section .text, align 2, keep-with-next
   2069          const char *osMemoryPoolGetName (osMemoryPoolId_t mp_id) {
   2070            MemPool_t *mp = (osMemoryPoolId_t)mp_id;
   \                     osMemoryPoolGetName: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   2071            const char *p;
   2072          
   2073            if (IS_IRQ()) {
   \        0x2   0xF3EF 0x8105      MRS      R1,IPSR
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD001             BEQ.N    ??osMemoryPoolGetName_0
   2074              p = NULL;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE004             B.N      ??osMemoryPoolGetName_1
   2075            }
   2076            else if (mp_id == NULL) {
   \                     ??osMemoryPoolGetName_0: (+1)
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD101             BNE.N    ??osMemoryPoolGetName_2
   2077              p = NULL;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xE000             B.N      ??osMemoryPoolGetName_1
   2078            }
   2079            else {
   2080              p = mp->name;
   \                     ??osMemoryPoolGetName_2: (+1)
   \       0x16   0x6910             LDR      R0,[R2, #+16]
   2081            }
   2082          
   2083            return (p);
   \                     ??osMemoryPoolGetName_1: (+1)
   \       0x18   0x4770             BX       LR
   2084          }
   2085          

   \                                 In section .text, align 2, keep-with-next
   2086          void *osMemoryPoolAlloc (osMemoryPoolId_t mp_id, uint32_t timeout) {
   \                     osMemoryPoolAlloc: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   2087            MemPool_t *mp;
   2088            void *block;
   2089            uint32_t isrm;
   2090          
   2091            if (mp_id == NULL) {
   \        0x4   0x2D00             CMP      R5,#+0
   \        0x6   0xD101             BNE.N    ??osMemoryPoolAlloc_0
   2092              /* Invalid input parameters */
   2093              block = NULL;
   \        0x8   0x2400             MOVS     R4,#+0
   \        0xA   0xE043             B.N      ??osMemoryPoolAlloc_1
   2094            }
   2095            else {
   2096              block = NULL;
   \                     ??osMemoryPoolAlloc_0: (+1)
   \        0xC   0x2400             MOVS     R4,#+0
   2097          
   2098              mp = (MemPool_t *)mp_id;
   2099          
   2100              if ((mp->status & MPOOL_STATUS) == MPOOL_STATUS) {
   \        0xE   0x....             LDR.N    R6,??DataTable24_1
   \       0x10   0x6A28             LDR      R0,[R5, #+32]
   \       0x12   0x4030             ANDS     R0,R6,R0
   \       0x14   0x42B0             CMP      R0,R6
   \       0x16   0xD13D             BNE.N    ??osMemoryPoolAlloc_1
   2101                if (IS_IRQ()) {
   \       0x18   0xF3EF 0x8005      MRS      R0,IPSR
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD022             BEQ.N    ??osMemoryPoolAlloc_2
   2102                  if (timeout == 0U) {
   \       0x20   0x2900             CMP      R1,#+0
   \       0x22   0xD137             BNE.N    ??osMemoryPoolAlloc_1
   2103                    if (xSemaphoreTakeFromISR (mp->sem, NULL) == pdTRUE) {
   \       0x24   0x2200             MOVS     R2,#+0
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0x6868             LDR      R0,[R5, #+4]
   \       0x2A   0x.... 0x....      BL       xQueueReceiveFromISR
   \       0x2E   0x2801             CMP      R0,#+1
   \       0x30   0xD130             BNE.N    ??osMemoryPoolAlloc_1
   2104                      if ((mp->status & MPOOL_STATUS) == MPOOL_STATUS) {
   \       0x32   0x6A28             LDR      R0,[R5, #+32]
   \       0x34   0x4030             ANDS     R0,R6,R0
   \       0x36   0x42B0             CMP      R0,R6
   \       0x38   0xD12C             BNE.N    ??osMemoryPoolAlloc_1
   2105                        isrm  = taskENTER_CRITICAL_FROM_ISR();
   \       0x3A   0xF3EF 0x8611      MRS      R6,BASEPRI
   \       0x3E   0x2050             MOVS     R0,#+80
   \       0x40   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x44   0xF3BF 0x8F4F      DSB      SY
   \       0x48   0xF3BF 0x8F6F      ISB      SY
   2106          
   2107                        /* Get a block from the free-list */
   2108                        block = AllocBlock(mp);
   \       0x4C   0x0028             MOVS     R0,R5
   \       0x4E   0x.... 0x....      BL       AllocBlock
   \       0x52   0x0004             MOVS     R4,R0
   2109          
   2110                        if (block == NULL) {
   \       0x54   0x2C00             CMP      R4,#+0
   \       0x56   0xD103             BNE.N    ??osMemoryPoolAlloc_3
   2111                          /* List of free blocks is empty, 'create' new block */
   2112                          block = CreateBlock(mp);
   \       0x58   0x0028             MOVS     R0,R5
   \       0x5A   0x.... 0x....      BL       CreateBlock
   \       0x5E   0x0004             MOVS     R4,R0
   2113                        }
   2114          
   2115                        taskEXIT_CRITICAL_FROM_ISR(isrm);
   \                     ??osMemoryPoolAlloc_3: (+1)
   \       0x60   0xF386 0x8811      MSR      BASEPRI,R6
   \       0x64   0xE016             B.N      ??osMemoryPoolAlloc_1
   2116                      }
   2117                    }
   2118                  }
   2119                }
   2120                else {
   2121                  if (xSemaphoreTake (mp->sem, (TickType_t)timeout) == pdTRUE) {
   \                     ??osMemoryPoolAlloc_2: (+1)
   \       0x66   0x6868             LDR      R0,[R5, #+4]
   \       0x68   0x.... 0x....      BL       xQueueSemaphoreTake
   \       0x6C   0x2801             CMP      R0,#+1
   \       0x6E   0xD111             BNE.N    ??osMemoryPoolAlloc_1
   2122                    if ((mp->status & MPOOL_STATUS) == MPOOL_STATUS) {
   \       0x70   0x6A28             LDR      R0,[R5, #+32]
   \       0x72   0x4030             ANDS     R0,R6,R0
   \       0x74   0x42B0             CMP      R0,R6
   \       0x76   0xD10D             BNE.N    ??osMemoryPoolAlloc_1
   2123                      taskENTER_CRITICAL();
   \       0x78   0x.... 0x....      BL       vPortEnterCritical
   2124          
   2125                      /* Get a block from the free-list */
   2126                      block = AllocBlock(mp);
   \       0x7C   0x0028             MOVS     R0,R5
   \       0x7E   0x.... 0x....      BL       AllocBlock
   \       0x82   0x0004             MOVS     R4,R0
   2127          
   2128                      if (block == NULL) {
   \       0x84   0x2C00             CMP      R4,#+0
   \       0x86   0xD103             BNE.N    ??osMemoryPoolAlloc_4
   2129                        /* List of free blocks is empty, 'create' new block */
   2130                        block = CreateBlock(mp);
   \       0x88   0x0028             MOVS     R0,R5
   \       0x8A   0x.... 0x....      BL       CreateBlock
   \       0x8E   0x0004             MOVS     R4,R0
   2131                      }
   2132          
   2133                      taskEXIT_CRITICAL();
   \                     ??osMemoryPoolAlloc_4: (+1)
   \       0x90   0x.... 0x....      BL       vPortExitCritical
   2134                    }
   2135                  }
   2136                }
   2137              }
   2138            }
   2139          
   2140            return (block);
   \                     ??osMemoryPoolAlloc_1: (+1)
   \       0x94   0x0020             MOVS     R0,R4
   \       0x96   0xBD70             POP      {R4-R6,PC}
   2141          }
   2142          

   \                                 In section .text, align 2, keep-with-next
   2143          osStatus_t osMemoryPoolFree (osMemoryPoolId_t mp_id, void *block) {
   \                     osMemoryPoolFree: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2144            MemPool_t *mp;
   2145            osStatus_t stat;
   2146            uint32_t isrm;
   2147            BaseType_t yield;
   2148          
   2149            if ((mp_id == NULL) || (block == NULL)) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD001             BEQ.N    ??osMemoryPoolFree_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD102             BNE.N    ??osMemoryPoolFree_1
   2150              /* Invalid input parameters */
   2151              stat = osErrorParameter;
   \                     ??osMemoryPoolFree_0: (+1)
   \        0xE   0xF07F 0x0603      MVNS     R6,#+3
   \       0x12   0xE059             B.N      ??osMemoryPoolFree_2
   2152            }
   2153            else {
   2154              mp = (MemPool_t *)mp_id;
   2155          
   2156              if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
   \                     ??osMemoryPoolFree_1: (+1)
   \       0x14   0x....             LDR.N    R0,??DataTable24_1
   \       0x16   0x6A21             LDR      R1,[R4, #+32]
   \       0x18   0x4001             ANDS     R1,R0,R1
   \       0x1A   0x4281             CMP      R1,R0
   \       0x1C   0xD002             BEQ.N    ??osMemoryPoolFree_3
   2157                /* Invalid object status */
   2158                stat = osErrorResource;
   \       0x1E   0xF07F 0x0602      MVNS     R6,#+2
   \       0x22   0xE051             B.N      ??osMemoryPoolFree_2
   2159              }
   2160              else if ((block < (void *)&mp->mem_arr[0]) || (block > (void*)&mp->mem_arr[mp->mem_sz-1])) {
   \                     ??osMemoryPoolFree_3: (+1)
   \       0x24   0x68A0             LDR      R0,[R4, #+8]
   \       0x26   0x4285             CMP      R5,R0
   \       0x28   0xD305             BCC.N    ??osMemoryPoolFree_4
   \       0x2A   0x68A0             LDR      R0,[R4, #+8]
   \       0x2C   0x68E1             LDR      R1,[R4, #+12]
   \       0x2E   0x4408             ADD      R0,R0,R1
   \       0x30   0x1E40             SUBS     R0,R0,#+1
   \       0x32   0x42A8             CMP      R0,R5
   \       0x34   0xD202             BCS.N    ??osMemoryPoolFree_5
   2161                /* Block pointer outside of memory array area */
   2162                stat = osErrorParameter;
   \                     ??osMemoryPoolFree_4: (+1)
   \       0x36   0xF07F 0x0603      MVNS     R6,#+3
   \       0x3A   0xE045             B.N      ??osMemoryPoolFree_2
   2163              }
   2164              else {
   2165                stat = osOK;
   \                     ??osMemoryPoolFree_5: (+1)
   \       0x3C   0x2600             MOVS     R6,#+0
   2166          
   2167                if (IS_IRQ()) {
   \       0x3E   0xF3EF 0x8005      MRS      R0,IPSR
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD029             BEQ.N    ??osMemoryPoolFree_6
   2168                  if (uxSemaphoreGetCountFromISR (mp->sem) == mp->bl_cnt) {
   \       0x46   0x6860             LDR      R0,[R4, #+4]
   \       0x48   0x.... 0x....      BL       uxQueueMessagesWaitingFromISR
   \       0x4C   0x69A1             LDR      R1,[R4, #+24]
   \       0x4E   0x4288             CMP      R0,R1
   \       0x50   0xD102             BNE.N    ??osMemoryPoolFree_7
   2169                    stat = osErrorResource;
   \       0x52   0xF07F 0x0602      MVNS     R6,#+2
   \       0x56   0xE037             B.N      ??osMemoryPoolFree_2
   2170                  }
   2171                  else {
   2172                    isrm = taskENTER_CRITICAL_FROM_ISR();
   \                     ??osMemoryPoolFree_7: (+1)
   \       0x58   0xF3EF 0x8711      MRS      R7,BASEPRI
   \       0x5C   0x2050             MOVS     R0,#+80
   \       0x5E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x62   0xF3BF 0x8F4F      DSB      SY
   \       0x66   0xF3BF 0x8F6F      ISB      SY
   2173          
   2174                    /* Add block to the list of free blocks */
   2175                    FreeBlock(mp, block);
   \       0x6A   0x0029             MOVS     R1,R5
   \       0x6C   0x0020             MOVS     R0,R4
   \       0x6E   0x.... 0x....      BL       FreeBlock
   2176          
   2177                    taskEXIT_CRITICAL_FROM_ISR(isrm);
   \       0x72   0xF387 0x8811      MSR      BASEPRI,R7
   2178          
   2179                    yield = pdFALSE;
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x9000             STR      R0,[SP, #+0]
   2180                    xSemaphoreGiveFromISR (mp->sem, &yield);
   \       0x7A   0x4669             MOV      R1,SP
   \       0x7C   0x6860             LDR      R0,[R4, #+4]
   \       0x7E   0x.... 0x....      BL       xQueueGiveFromISR
   2181                    portYIELD_FROM_ISR (yield);
   \       0x82   0x9800             LDR      R0,[SP, #+0]
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD01F             BEQ.N    ??osMemoryPoolFree_2
   \       0x88   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0x8C   0x....             LDR.N    R1,??DataTable24
   \       0x8E   0x6008             STR      R0,[R1, #+0]
   \       0x90   0xF3BF 0x8F4F      DSB      SY
   \       0x94   0xF3BF 0x8F6F      ISB      SY
   \       0x98   0xE016             B.N      ??osMemoryPoolFree_2
   2182                  }
   2183                }
   2184                else {
   2185                  if (uxSemaphoreGetCount (mp->sem) == mp->bl_cnt) {
   \                     ??osMemoryPoolFree_6: (+1)
   \       0x9A   0x6860             LDR      R0,[R4, #+4]
   \       0x9C   0x.... 0x....      BL       uxQueueMessagesWaiting
   \       0xA0   0x69A1             LDR      R1,[R4, #+24]
   \       0xA2   0x4288             CMP      R0,R1
   \       0xA4   0xD102             BNE.N    ??osMemoryPoolFree_8
   2186                    stat = osErrorResource;
   \       0xA6   0xF07F 0x0602      MVNS     R6,#+2
   \       0xAA   0xE00D             B.N      ??osMemoryPoolFree_2
   2187                  }
   2188                  else {
   2189                    taskENTER_CRITICAL();
   \                     ??osMemoryPoolFree_8: (+1)
   \       0xAC   0x.... 0x....      BL       vPortEnterCritical
   2190          
   2191                    /* Add block to the list of free blocks */
   2192                    FreeBlock(mp, block);
   \       0xB0   0x0029             MOVS     R1,R5
   \       0xB2   0x0020             MOVS     R0,R4
   \       0xB4   0x.... 0x....      BL       FreeBlock
   2193          
   2194                    taskEXIT_CRITICAL();
   \       0xB8   0x.... 0x....      BL       vPortExitCritical
   2195          
   2196                    xSemaphoreGive (mp->sem);
   \       0xBC   0x2300             MOVS     R3,#+0
   \       0xBE   0x2200             MOVS     R2,#+0
   \       0xC0   0x2100             MOVS     R1,#+0
   \       0xC2   0x6860             LDR      R0,[R4, #+4]
   \       0xC4   0x.... 0x....      BL       xQueueGenericSend
   2197                  }
   2198                }
   2199              }
   2200            }
   2201          
   2202            return (stat);
   \                     ??osMemoryPoolFree_2: (+1)
   \       0xC8   0x0030             MOVS     R0,R6
   \       0xCA   0xBDF2             POP      {R1,R4-R7,PC}
   2203          }
   2204          

   \                                 In section .text, align 2, keep-with-next
   2205          uint32_t osMemoryPoolGetCapacity (osMemoryPoolId_t mp_id) {
   2206            MemPool_t *mp;
   2207            uint32_t  n;
   2208          
   2209            if (mp_id == NULL) {
   \                     osMemoryPoolGetCapacity: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??osMemoryPoolGetCapacity_0
   2210              /* Invalid input parameters */
   2211              n = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xE007             B.N      ??osMemoryPoolGetCapacity_1
   2212            }
   2213            else {
   2214              mp = (MemPool_t *)mp_id;
   2215          
   2216              if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
   \                     ??osMemoryPoolGetCapacity_0: (+1)
   \        0x8   0x....             LDR.N    R1,??DataTable24_1
   \        0xA   0x6A02             LDR      R2,[R0, #+32]
   \        0xC   0x400A             ANDS     R2,R1,R2
   \        0xE   0x428A             CMP      R2,R1
   \       0x10   0xD001             BEQ.N    ??osMemoryPoolGetCapacity_2
   2217                /* Invalid object status */
   2218                n = 0U;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xE000             B.N      ??osMemoryPoolGetCapacity_1
   2219              }
   2220              else {
   2221                n = mp->bl_cnt;
   \                     ??osMemoryPoolGetCapacity_2: (+1)
   \       0x16   0x6980             LDR      R0,[R0, #+24]
   2222              }
   2223            }
   2224          
   2225            /* Return maximum number of memory blocks */
   2226            return (n);
   \                     ??osMemoryPoolGetCapacity_1: (+1)
   \       0x18   0x4770             BX       LR
   2227          }
   2228          

   \                                 In section .text, align 2, keep-with-next
   2229          uint32_t osMemoryPoolGetBlockSize (osMemoryPoolId_t mp_id) {
   2230            MemPool_t *mp;
   2231            uint32_t  sz;
   2232          
   2233            if (mp_id == NULL) {
   \                     osMemoryPoolGetBlockSize: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD101             BNE.N    ??osMemoryPoolGetBlockSize_0
   2234              /* Invalid input parameters */
   2235              sz = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xE007             B.N      ??osMemoryPoolGetBlockSize_1
   2236            }
   2237            else {
   2238              mp = (MemPool_t *)mp_id;
   2239          
   2240              if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
   \                     ??osMemoryPoolGetBlockSize_0: (+1)
   \        0x8   0x....             LDR.N    R1,??DataTable24_1
   \        0xA   0x6A02             LDR      R2,[R0, #+32]
   \        0xC   0x400A             ANDS     R2,R1,R2
   \        0xE   0x428A             CMP      R2,R1
   \       0x10   0xD001             BEQ.N    ??osMemoryPoolGetBlockSize_2
   2241                /* Invalid object status */
   2242                sz = 0U;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xE000             B.N      ??osMemoryPoolGetBlockSize_1
   2243              }
   2244              else {
   2245                sz = mp->bl_sz;
   \                     ??osMemoryPoolGetBlockSize_2: (+1)
   \       0x16   0x6940             LDR      R0,[R0, #+20]
   2246              }
   2247            }
   2248          
   2249            /* Return memory block size in bytes */
   2250            return (sz);
   \                     ??osMemoryPoolGetBlockSize_1: (+1)
   \       0x18   0x4770             BX       LR
   2251          }
   2252          

   \                                 In section .text, align 2, keep-with-next
   2253          uint32_t osMemoryPoolGetCount (osMemoryPoolId_t mp_id) {
   \                     osMemoryPoolGetCount: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2254            MemPool_t *mp;
   2255            uint32_t  n;
   2256          
   2257            if (mp_id == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??osMemoryPoolGetCount_0
   2258              /* Invalid input parameters */
   2259              n = 0U;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xE013             B.N      ??osMemoryPoolGetCount_1
   2260            }
   2261            else {
   2262              mp = (MemPool_t *)mp_id;
   2263          
   2264              if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
   \                     ??osMemoryPoolGetCount_0: (+1)
   \        0xC   0x....             LDR.N    R0,??DataTable24_1
   \        0xE   0x6A21             LDR      R1,[R4, #+32]
   \       0x10   0x4001             ANDS     R1,R0,R1
   \       0x12   0x4281             CMP      R1,R0
   \       0x14   0xD001             BEQ.N    ??osMemoryPoolGetCount_2
   2265                /* Invalid object status */
   2266                n = 0U;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE00C             B.N      ??osMemoryPoolGetCount_1
   2267              }
   2268              else {
   2269                if (IS_IRQ()) {
   \                     ??osMemoryPoolGetCount_2: (+1)
   \       0x1A   0xF3EF 0x8005      MRS      R0,IPSR
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD003             BEQ.N    ??osMemoryPoolGetCount_3
   2270                  n = uxSemaphoreGetCountFromISR (mp->sem);
   \       0x22   0x6860             LDR      R0,[R4, #+4]
   \       0x24   0x.... 0x....      BL       uxQueueMessagesWaitingFromISR
   \       0x28   0xE002             B.N      ??osMemoryPoolGetCount_4
   2271                } else {
   2272                  n = uxSemaphoreGetCount        (mp->sem);
   \                     ??osMemoryPoolGetCount_3: (+1)
   \       0x2A   0x6860             LDR      R0,[R4, #+4]
   \       0x2C   0x.... 0x....      BL       uxQueueMessagesWaiting
   2273                }
   2274          
   2275                n = mp->bl_cnt - n;
   \                     ??osMemoryPoolGetCount_4: (+1)
   \       0x30   0x69A1             LDR      R1,[R4, #+24]
   \       0x32   0x1A08             SUBS     R0,R1,R0
   2276              }
   2277            }
   2278          
   2279            /* Return number of memory blocks used */
   2280            return (n);
   \                     ??osMemoryPoolGetCount_1: (+1)
   \       0x34   0xBD10             POP      {R4,PC}
   2281          }
   2282          

   \                                 In section .text, align 2, keep-with-next
   2283          uint32_t osMemoryPoolGetSpace (osMemoryPoolId_t mp_id) {
   \                     osMemoryPoolGetSpace: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2284            MemPool_t *mp;
   2285            uint32_t  n;
   2286          
   2287            if (mp_id == NULL) {
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD101             BNE.N    ??osMemoryPoolGetSpace_0
   2288              /* Invalid input parameters */
   2289              n = 0U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xE011             B.N      ??osMemoryPoolGetSpace_1
   2290            }
   2291            else {
   2292              mp = (MemPool_t *)mp_id;
   2293          
   2294              if ((mp->status & MPOOL_STATUS) != MPOOL_STATUS) {
   \                     ??osMemoryPoolGetSpace_0: (+1)
   \        0xA   0x....             LDR.N    R1,??DataTable24_1
   \        0xC   0x6A02             LDR      R2,[R0, #+32]
   \        0xE   0x400A             ANDS     R2,R1,R2
   \       0x10   0x428A             CMP      R2,R1
   \       0x12   0xD001             BEQ.N    ??osMemoryPoolGetSpace_2
   2295                /* Invalid object status */
   2296                n = 0U;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE00A             B.N      ??osMemoryPoolGetSpace_1
   2297              }
   2298              else {
   2299                if (IS_IRQ()) {
   \                     ??osMemoryPoolGetSpace_2: (+1)
   \       0x18   0xF3EF 0x8105      MRS      R1,IPSR
   \       0x1C   0x2900             CMP      R1,#+0
   \       0x1E   0xD003             BEQ.N    ??osMemoryPoolGetSpace_3
   2300                  n = uxSemaphoreGetCountFromISR (mp->sem);
   \       0x20   0x6840             LDR      R0,[R0, #+4]
   \       0x22   0x.... 0x....      BL       uxQueueMessagesWaitingFromISR
   \       0x26   0xE002             B.N      ??osMemoryPoolGetSpace_1
   2301                } else {
   2302                  n = uxSemaphoreGetCount        (mp->sem);
   \                     ??osMemoryPoolGetSpace_3: (+1)
   \       0x28   0x6840             LDR      R0,[R0, #+4]
   \       0x2A   0x.... 0x....      BL       uxQueueMessagesWaiting
   2303                }
   2304              }
   2305            }
   2306          
   2307            /* Return number of memory blocks available */
   2308            return (n);
   \                     ??osMemoryPoolGetSpace_1: (+1)
   \       0x2E   0xBD02             POP      {R1,PC}
   2309          }
   2310          

   \                                 In section .text, align 2, keep-with-next
   2311          osStatus_t osMemoryPoolDelete (osMemoryPoolId_t mp_id) {
   \                     osMemoryPoolDelete: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2312            MemPool_t *mp;
   2313            osStatus_t stat;
   2314          
   2315            if (mp_id == NULL) {
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD102             BNE.N    ??osMemoryPoolDelete_0
   2316              /* Invalid input parameters */
   2317              stat = osErrorParameter;
   \        0x8   0xF07F 0x0003      MVNS     R0,#+3
   \        0xC   0xE029             B.N      ??osMemoryPoolDelete_1
   2318            }
   2319            else if (IS_IRQ()) {
   \                     ??osMemoryPoolDelete_0: (+1)
   \        0xE   0xF3EF 0x8005      MRS      R0,IPSR
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD002             BEQ.N    ??osMemoryPoolDelete_2
   2320              stat = osErrorISR;
   \       0x16   0xF07F 0x0005      MVNS     R0,#+5
   \       0x1A   0xE022             B.N      ??osMemoryPoolDelete_1
   2321            }
   2322            else {
   2323              mp = (MemPool_t *)mp_id;
   2324          
   2325              taskENTER_CRITICAL();
   \                     ??osMemoryPoolDelete_2: (+1)
   \       0x1C   0x.... 0x....      BL       vPortEnterCritical
   2326          
   2327              /* Invalidate control block status */
   2328              mp->status  = mp->status & 3U;
   \       0x20   0x6A20             LDR      R0,[R4, #+32]
   \       0x22   0xF010 0x0003      ANDS     R0,R0,#0x3
   \       0x26   0x6220             STR      R0,[R4, #+32]
   2329          
   2330              /* Wake-up tasks waiting for pool semaphore */
   2331              while (xSemaphoreGive (mp->sem) == pdTRUE);
   \                     ??osMemoryPoolDelete_3: (+1)
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x6860             LDR      R0,[R4, #+4]
   \       0x30   0x.... 0x....      BL       xQueueGenericSend
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD0F7             BEQ.N    ??osMemoryPoolDelete_3
   2332          
   2333              mp->head    = NULL;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x6020             STR      R0,[R4, #+0]
   2334              mp->bl_sz   = 0U;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x6160             STR      R0,[R4, #+20]
   2335              mp->bl_cnt  = 0U;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x61A0             STR      R0,[R4, #+24]
   2336          
   2337              if ((mp->status & 2U) != 0U) {
   \       0x44   0x6A20             LDR      R0,[R4, #+32]
   \       0x46   0x0780             LSLS     R0,R0,#+30
   \       0x48   0xD502             BPL.N    ??osMemoryPoolDelete_4
   2338                /* Memory pool array allocated on heap */
   2339                vPortFree (mp->mem_arr);
   \       0x4A   0x68A0             LDR      R0,[R4, #+8]
   \       0x4C   0x.... 0x....      BL       vPortFree
   2340              }
   2341              if ((mp->status & 1U) != 0U) {
   \                     ??osMemoryPoolDelete_4: (+1)
   \       0x50   0x6A20             LDR      R0,[R4, #+32]
   \       0x52   0x07C0             LSLS     R0,R0,#+31
   \       0x54   0xD502             BPL.N    ??osMemoryPoolDelete_5
   2342                /* Memory pool control block allocated on heap */
   2343                vPortFree (mp);
   \       0x56   0x0020             MOVS     R0,R4
   \       0x58   0x.... 0x....      BL       vPortFree
   2344              }
   2345          
   2346              taskEXIT_CRITICAL();
   \                     ??osMemoryPoolDelete_5: (+1)
   \       0x5C   0x.... 0x....      BL       vPortExitCritical
   2347          
   2348              stat = osOK;
   \       0x60   0x2000             MOVS     R0,#+0
   2349            }
   2350          
   2351            return (stat);
   \                     ??osMemoryPoolDelete_1: (+1)
   \       0x62   0xBD10             POP      {R4,PC}
   2352          }
   2353          
   2354          /*
   2355            Create new block given according to the current block index.
   2356          */

   \                                 In section .text, align 2, keep-with-next
   2357          static void *CreateBlock (MemPool_t *mp) {
   \                     CreateBlock: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   2358            MemPoolBlock_t *p = NULL;
   \        0x2   0x2000             MOVS     R0,#+0
   2359          
   2360            if (mp->n < mp->bl_cnt) {
   \        0x4   0x69CA             LDR      R2,[R1, #+28]
   \        0x6   0x698B             LDR      R3,[R1, #+24]
   \        0x8   0x429A             CMP      R2,R3
   \        0xA   0xD208             BCS.N    ??CreateBlock_0
   2361              /* Unallocated blocks exist, set pointer to new block */
   2362              p = (void *)(mp->mem_arr + (mp->bl_sz * mp->n));
   \        0xC   0x688A             LDR      R2,[R1, #+8]
   \        0xE   0x694B             LDR      R3,[R1, #+20]
   \       0x10   0x69C8             LDR      R0,[R1, #+28]
   \       0x12   0x4343             MULS     R3,R0,R3
   \       0x14   0xEB02 0x0003      ADD      R0,R2,R3
   2363          
   2364              /* Increment block index */
   2365              mp->n += 1U;
   \       0x18   0x69CA             LDR      R2,[R1, #+28]
   \       0x1A   0x1C52             ADDS     R2,R2,#+1
   \       0x1C   0x61CA             STR      R2,[R1, #+28]
   2366            }
   2367          
   2368            return (p);
   \                     ??CreateBlock_0: (+1)
   \       0x1E   0x4770             BX       LR
   2369          }
   2370          
   2371          /*
   2372            Allocate a block by reading the list of free blocks.
   2373          */

   \                                 In section .text, align 2, keep-with-next
   2374          static void *AllocBlock (MemPool_t *mp) {
   \                     AllocBlock: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   2375            MemPoolBlock_t *p = NULL;
   \        0x2   0x2000             MOVS     R0,#+0
   2376          
   2377            if (mp->head != NULL) {
   \        0x4   0x6811             LDR      R1,[R2, #+0]
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD002             BEQ.N    ??AllocBlock_0
   2378              /* List of free block exists, get head block */
   2379              p = mp->head;
   \        0xA   0x6810             LDR      R0,[R2, #+0]
   2380          
   2381              /* Head block is now next on the list */
   2382              mp->head = p->next;
   \        0xC   0x6801             LDR      R1,[R0, #+0]
   \        0xE   0x6011             STR      R1,[R2, #+0]
   2383            }
   2384          
   2385            return (p);
   \                     ??AllocBlock_0: (+1)
   \       0x10   0x4770             BX       LR
   2386          }
   2387          
   2388          /*
   2389            Free block by putting it to the list of free blocks.
   2390          */

   \                                 In section .text, align 2, keep-with-next
   2391          static void FreeBlock (MemPool_t *mp, void *block) {
   2392            MemPoolBlock_t *p = block;
   2393          
   2394            /* Store current head into block memory space */
   2395            p->next = mp->head;
   \                     FreeBlock: (+1)
   \        0x0   0x6802             LDR      R2,[R0, #+0]
   \        0x2   0x600A             STR      R2,[R1, #+0]
   2396          
   2397            /* Store current block as new head */
   2398            mp->head = p;
   \        0x4   0x6001             STR      R1,[R0, #+0]
   2399          }
   \        0x6   0x4770             BX       LR
   2400          #endif /* FREERTOS_MPOOL_H_ */
   2401          /*---------------------------------------------------------------------------*/
   2402          
   2403          /* Callback function prototypes */
   2404          extern void vApplicationIdleHook (void);
   2405          extern void vApplicationTickHook (void);
   2406          extern void vApplicationMallocFailedHook (void);
   2407          extern void vApplicationDaemonTaskStartupHook (void);
   2408          extern void vApplicationStackOverflowHook (TaskHandle_t xTask, signed char *pcTaskName);
   2409          
   2410          /**
   2411            Dummy implementation of the callback function vApplicationIdleHook().
   2412          */
   2413          #if (configUSE_IDLE_HOOK == 1)
   2414          __WEAK void vApplicationIdleHook (void){}
   2415          #endif
   2416          
   2417          /**
   2418            Dummy implementation of the callback function vApplicationTickHook().
   2419          */
   2420          #if (configUSE_TICK_HOOK == 1)
   2421           __WEAK void vApplicationTickHook (void){}
   2422          #endif
   2423          
   2424          /**
   2425            Dummy implementation of the callback function vApplicationMallocFailedHook().
   2426          */
   2427          #if (configUSE_MALLOC_FAILED_HOOK == 1)
   2428          __WEAK void vApplicationMallocFailedHook (void){}
   2429          #endif
   2430          
   2431          /**
   2432            Dummy implementation of the callback function vApplicationDaemonTaskStartupHook().
   2433          */
   2434          #if (configUSE_DAEMON_TASK_STARTUP_HOOK == 1)
   2435          __WEAK void vApplicationDaemonTaskStartupHook (void){}
   2436          #endif
   2437          
   2438          /**
   2439            Dummy implementation of the callback function vApplicationStackOverflowHook().
   2440          */
   2441          #if (configCHECK_FOR_STACK_OVERFLOW > 0)
   2442          __WEAK void vApplicationStackOverflowHook (TaskHandle_t xTask, signed char *pcTaskName) {
   2443            (void)xTask;
   2444            (void)pcTaskName;
   2445            configASSERT(0);
   2446          }
   2447          #endif
   2448          
   2449          /*---------------------------------------------------------------------------*/
   2450          #if (configSUPPORT_STATIC_ALLOCATION == 1)
   2451          /* External Idle and Timer task static memory allocation functions */
   2452          extern void vApplicationGetIdleTaskMemory  (StaticTask_t **ppxIdleTaskTCBBuffer,  StackType_t **ppxIdleTaskStackBuffer,  uint32_t *pulIdleTaskStackSize);
   2453          extern void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize);
   2454          
   2455          /*
   2456            vApplicationGetIdleTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
   2457            equals to 1 and is required for static memory allocation support.
   2458          */

   \                                 In section .text, align 4
   2459          __WEAK void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
   2460            /* Idle task control block and stack */
   2461            static StaticTask_t Idle_TCB;
   2462            static StackType_t  Idle_Stack[configMINIMAL_STACK_SIZE];
   2463          
   2464            *ppxIdleTaskTCBBuffer   = &Idle_TCB;
   \                     vApplicationGetIdleTaskMemory: (+1)
   \        0x0   0x4B03             LDR.N    R3,??vApplicationGetIdleTaskMemory_0
   \        0x2   0x6003             STR      R3,[R0, #+0]
   2465            *ppxIdleTaskStackBuffer = &Idle_Stack[0];
   \        0x4   0x4803             LDR.N    R0,??vApplicationGetIdleTaskMemory_0+0x4
   \        0x6   0x6008             STR      R0,[R1, #+0]
   2466            *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
   \        0x8   0x2080             MOVS     R0,#+128
   \        0xA   0x6010             STR      R0,[R2, #+0]
   2467          }
   \        0xC   0x4770             BX       LR
   \        0xE   0xBF00             Nop
   \                     ??vApplicationGetIdleTaskMemory_0:
   \       0x10   0x....'....        DC32     `vApplicationGetIdleTaskMemory::Idle_TCB`
   \       0x14   0x....'....        DC32     `vApplicationGetIdleTaskMemory::Idle_Stack`

   \                                 In section .bss, align 4
   \                     `vApplicationGetIdleTaskMemory::Idle_TCB`:
   \        0x0                      DS8 92

   \                                 In section .bss, align 4
   \                     `vApplicationGetIdleTaskMemory::Idle_Stack`:
   \        0x0                      DS8 512
   2468          
   2469          /*
   2470            vApplicationGetTimerTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
   2471            equals to 1 and is required for static memory allocation support.
   2472          */

   \                                 In section .text, align 4
   2473          __WEAK void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
   2474            /* Timer task control block and stack */
   2475            static StaticTask_t Timer_TCB;
   2476            static StackType_t  Timer_Stack[configTIMER_TASK_STACK_DEPTH];
   2477          
   2478            *ppxTimerTaskTCBBuffer   = &Timer_TCB;
   \                     vApplicationGetTimerTaskMemory: (+1)
   \        0x0   0x4B03             LDR.N    R3,??vApplicationGetTimerTaskMemory_0
   \        0x2   0x6003             STR      R3,[R0, #+0]
   2479            *ppxTimerTaskStackBuffer = &Timer_Stack[0];
   \        0x4   0x4803             LDR.N    R0,??vApplicationGetTimerTaskMemory_0+0x4
   \        0x6   0x6008             STR      R0,[R1, #+0]
   2480            *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
   \        0x8   0xF44F 0x7080      MOV      R0,#+256
   \        0xC   0x6010             STR      R0,[R2, #+0]
   2481          }
   \        0xE   0x4770             BX       LR
   \                     ??vApplicationGetTimerTaskMemory_0:
   \       0x10   0x....'....        DC32     `vApplicationGetTimerTaskMemory::Timer_TCB`
   \       0x14   0x....'....        DC32     `vApplicationGetTimerTaskMemory::Timer_Stack`

   \                                 In section .bss, align 4
   \                     `vApplicationGetTimerTaskMemory::Timer_TCB`:
   \        0x0                      DS8 92

   \                                 In section .bss, align 4
   \                     `vApplicationGetTimerTaskMemory::Timer_Stack`:
   \        0x0                      DS8 1'024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0xE000'E400        DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0xE000'ED18        DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0xE000'E010        DC32     0xe000e010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \        0x0   0x....'....        DC32     KernelState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \        0x0   0x05F5'F531        DC32     0x5f5f531

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \        0x0   0xE000'E014        DC32     0xe000e014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \        0x0   0xE000'E018        DC32     0xe000e018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0xE000'ED04        DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0x....'....        DC32     TimerCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0xE000'ED04        DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \        0x0   0x5EED'0000        DC32     0x5eed0000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x46 0x72          DC8 "FreeRTOS V10.3.1"

   \              0x65 0x65    

   \              0x52 0x54    

   \              0x4F 0x53    

   \              0x20 0x56    

   \              0x31 0x30    

   \              0x2E 0x33    

   \              0x2E 0x31    

   \              0x00
   \       0x11                      DS8 3
   2482          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AllocBlock
       0   CreateBlock
       0   FreeBlock
       0   OS_Tick_GetCount
       0   OS_Tick_GetInterval
       0   OS_Tick_GetOverflow
       8   SVC_Setup
         8   -> __NVIC_SetPriority
       8   SysTick_Handler
         8   -> xPortSysTickHandler
         8   -> xTaskGetSchedulerState
       8   TimerCallback
         8   -- Indirect call
         8   -> pvTimerGetTimerID
       0   __NVIC_SetPriority
       8   osDelay
         8   -> vTaskDelay
      16   osDelayUntil
        16   -> vTaskDelayUntil
        16   -> xTaskGetTickCount
      16   osEventFlagsClear
        16   -> xEventGroupClearBits
        16   -> xEventGroupClearBitsFromISR
        16   -> xEventGroupGetBitsFromISR
       8   osEventFlagsDelete
         8   -> vEventGroupDelete
       8   osEventFlagsGet
         8   -> xEventGroupClearBits
         8   -> xEventGroupGetBitsFromISR
       8   osEventFlagsNew
         8   -> xEventGroupCreate
         8   -> xEventGroupCreateStatic
      16   osEventFlagsSet
        16   -> xEventGroupSetBits
        16   -> xEventGroupSetBitsFromISR
      24   osEventFlagsWait
        24   -> xEventGroupWaitBits
       8   osKernelGetInfo
         8   -> __aeabi_memcpy
       8   osKernelGetState
         8   -> xTaskGetSchedulerState
      16   osKernelGetSysTimerCount
        16   -> OS_Tick_GetCount
        16   -> OS_Tick_GetInterval
        16   -> OS_Tick_GetOverflow
        16   -> xTaskGetTickCount
       0   osKernelGetSysTimerFreq
       8   osKernelGetTickCount
         8   -> xTaskGetTickCount
         8   -> xTaskGetTickCountFromISR
       0   osKernelGetTickFreq
       0   osKernelInitialize
       8   osKernelLock
         8   -> vTaskSuspendAll
         8   -> xTaskGetSchedulerState
       8   osKernelRestoreLock
         8   -> vTaskSuspendAll
         8   -> xTaskGetSchedulerState
         8   -> xTaskResumeAll
       8   osKernelStart
         8   -> SVC_Setup
         8   -> vTaskStartScheduler
       8   osKernelUnlock
         8   -> xTaskGetSchedulerState
         8   -> xTaskResumeAll
      16   osMemoryPoolAlloc
        16   -> AllocBlock
        16   -> CreateBlock
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> xQueueReceiveFromISR
        16   -> xQueueSemaphoreTake
       8   osMemoryPoolDelete
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
         8   -> vPortFree
         8   -> xQueueGenericSend
      24   osMemoryPoolFree
        24   -> FreeBlock
        24   -> uxQueueMessagesWaiting
        24   -> uxQueueMessagesWaitingFromISR
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> xQueueGenericSend
        24   -> xQueueGiveFromISR
       0   osMemoryPoolGetBlockSize
       0   osMemoryPoolGetCapacity
       8   osMemoryPoolGetCount
         8   -> uxQueueMessagesWaiting
         8   -> uxQueueMessagesWaitingFromISR
       0   osMemoryPoolGetName
       8   osMemoryPoolGetSpace
         8   -> uxQueueMessagesWaiting
         8   -> uxQueueMessagesWaitingFromISR
      40   osMemoryPoolNew
        40   -> pvPortMalloc
        40   -> vPortFree
        40   -> xQueueCreateCountingSemaphoreStatic
      16   osMessageQueueDelete
        16   -> vQueueDelete
        16   -> vQueueUnregisterQueue
      16   osMessageQueueGet
        16   -> xQueueReceive
        16   -> xQueueReceiveFromISR
       0   osMessageQueueGetCapacity
       8   osMessageQueueGetCount
         8   -> uxQueueMessagesWaiting
         8   -> uxQueueMessagesWaitingFromISR
       0   osMessageQueueGetMsgSize
       8   osMessageQueueGetSpace
         8   -> uxQueueSpacesAvailable
      24   osMessageQueueNew
        24   -> vQueueAddToRegistry
        24   -> xQueueGenericCreate
        24   -> xQueueGenericCreateStatic
      16   osMessageQueuePut
        16   -> xQueueGenericSend
        16   -> xQueueGenericSendFromISR
       8   osMessageQueueReset
         8   -> xQueueGenericReset
      16   osMutexAcquire
        16   -> xQueueSemaphoreTake
        16   -> xQueueTakeMutexRecursive
      16   osMutexDelete
        16   -> vQueueDelete
        16   -> vQueueUnregisterQueue
       8   osMutexGetOwner
         8   -> xQueueGetMutexHolder
      16   osMutexNew
        16   -> vQueueAddToRegistry
        16   -> xQueueCreateMutex
        16   -> xQueueCreateMutexStatic
       8   osMutexRelease
         8   -> xQueueGenericSend
         8   -> xQueueGiveMutexRecursive
      16   osSemaphoreAcquire
        16   -> xQueueReceiveFromISR
        16   -> xQueueSemaphoreTake
      16   osSemaphoreDelete
        16   -> vQueueDelete
        16   -> vQueueUnregisterQueue
       8   osSemaphoreGetCount
         8   -> uxQueueMessagesWaiting
         8   -> uxQueueMessagesWaitingFromISR
      24   osSemaphoreNew
        24   -> vQueueAddToRegistry
        24   -> vQueueDelete
        24   -> xQueueCreateCountingSemaphore
        24   -> xQueueCreateCountingSemaphoreStatic
        24   -> xQueueGenericCreate
        24   -> xQueueGenericCreateStatic
        24   -> xQueueGenericSend
      16   osSemaphoreRelease
        16   -> xQueueGenericSend
        16   -> xQueueGiveFromISR
      24   osThreadEnumerate
        24   -> pvPortMalloc
        24   -> uxTaskGetNumberOfTasks
        24   -> uxTaskGetSystemState
        24   -> vPortFree
        24   -> vTaskSuspendAll
        24   -> xTaskResumeAll
       8   osThreadExit
         8   -> vTaskDelete
      24   osThreadFlagsClear
        24   -> xTaskGenericNotify
        24   -> xTaskGetCurrentTaskHandle
       8   osThreadFlagsGet
         8   -> xTaskGenericNotify
         8   -> xTaskGetCurrentTaskHandle
      24   osThreadFlagsSet
        24   -> xTaskGenericNotify
        24   -> xTaskGenericNotifyFromISR
      40   osThreadFlagsWait
        40   -> xTaskGetTickCount
        40   -> xTaskNotifyWait
       8   osThreadGetCount
         8   -> uxTaskGetNumberOfTasks
       8   osThreadGetId
         8   -> xTaskGetCurrentTaskHandle
       8   osThreadGetName
         8   -> pcTaskGetName
       8   osThreadGetPriority
         8   -> uxTaskPriorityGet
       8   osThreadGetStackSpace
         8   -> uxTaskGetStackHighWaterMark
       8   osThreadGetState
         8   -> eTaskGetState
      40   osThreadNew
        40   -> xTaskCreate
        40   -> xTaskCreateStatic
       8   osThreadResume
         8   -> vTaskResume
       8   osThreadSetPriority
         8   -> vTaskPrioritySet
       8   osThreadSuspend
         8   -> vTaskSuspend
      16   osThreadTerminate
        16   -> eTaskGetState
        16   -> vTaskDelete
       0   osThreadYield
      16   osTimerDelete
        16   -> pvTimerGetTimerID
        16   -> vPortFree
        16   -> xTimerGenericCommand
       8   osTimerGetName
         8   -> pcTimerGetName
       8   osTimerIsRunning
         8   -> xTimerIsTimerActive
      40   osTimerNew
        40   -> pvPortMalloc
        40   -> vPortFree
        40   -> xTimerCreate
        40   -> xTimerCreateStatic
       8   osTimerStart
         8   -> xTimerGenericCommand
      16   osTimerStop
        16   -> xTimerGenericCommand
        16   -> xTimerIsTimerActive
       0   vApplicationGetIdleTaskMemory
       0   vApplicationGetTimerTaskMemory


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable14
       4  ??DataTable16
       4  ??DataTable19
       4  ??DataTable24
       4  ??DataTable24_1
      20  ?_0
      18  AllocBlock
      32  CreateBlock
       8  FreeBlock
     512  Idle_Stack
      92  Idle_TCB
       4  KernelState
      16  OS_Tick_GetCount
      10  OS_Tick_GetInterval
      12  OS_Tick_GetOverflow
      14  SVC_Setup
      22  SysTick_Handler
      20  TimerCallback
   1'024  Timer_Stack
      92  Timer_TCB
      40  __NVIC_SetPriority
      30  osDelay
      60  osDelayUntil
      70  osEventFlagsClear
      36  osEventFlagsDelete
      38  osEventFlagsGet
      82  osEventFlagsNew
      88  osEventFlagsSet
     114  osEventFlagsWait
      44  osKernelGetInfo
      40  osKernelGetState
      74  osKernelGetSysTimerCount
       8  osKernelGetSysTimerFreq
      22  osKernelGetTickCount
       6  osKernelGetTickFreq
      38  osKernelInitialize
      48  osKernelLock
      80  osKernelRestoreLock
      48  osKernelStart
      66  osKernelUnlock
     152  osMemoryPoolAlloc
     100  osMemoryPoolDelete
     204  osMemoryPoolFree
      26  osMemoryPoolGetBlockSize
      26  osMemoryPoolGetCapacity
      54  osMemoryPoolGetCount
      26  osMemoryPoolGetName
      48  osMemoryPoolGetSpace
     316  osMemoryPoolNew
      46  osMessageQueueDelete
     120  osMessageQueueGet
      12  osMessageQueueGetCapacity
      30  osMessageQueueGetCount
      12  osMessageQueueGetMsgSize
      54  osMessageQueueGetSpace
     148  osMessageQueueNew
     122  osMessageQueuePut
      38  osMessageQueueReset
      98  osMutexAcquire
      50  osMutexDelete
      28  osMutexGetOwner
     174  osMutexNew
      78  osMutexRelease
     108  osSemaphoreAcquire
      46  osSemaphoreDelete
      30  osSemaphoreGetCount
     194  osSemaphoreNew
      88  osSemaphoreRelease
     106  osThreadEnumerate
      10  osThreadExit
      90  osThreadFlagsClear
      46  osThreadFlagsGet
     122  osThreadFlagsSet
     184  osThreadFlagsWait
      20  osThreadGetCount
       8  osThreadGetId
      24  osThreadGetName
      26  osThreadGetPriority
      26  osThreadGetStackSpace
      64  osThreadGetState
     196  osThreadNew
      36  osThreadResume
      42  osThreadSetPriority
      36  osThreadSuspend
      58  osThreadTerminate
      36  osThreadYield
      72  osTimerDelete
      24  osTimerGetName
      24  osTimerIsRunning
     180  osTimerNew
      54  osTimerStart
      74  osTimerStop
      24  vApplicationGetIdleTaskMemory
      24  vApplicationGetTimerTaskMemory

 
 1'724 bytes in section .bss
    20 bytes in section .rodata
 5'270 bytes in section .text
 
 5'222 bytes of CODE  memory (+ 48 bytes shared)
    20 bytes of CONST memory
 1'724 bytes of DATA  memory

Errors: none
Warnings: none
