###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         08/Feb/2022  20:54:17
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\Middlewares\Third_Party\FreeRTOS\Source\event_groups.c
#        [UTF-8]
#    Command line                 =
#        -f
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS\event_groups.o.rsp
#        (D:\99_Project\GitHub\TouchGFX\MyApplication\Middlewares\Third_Party\FreeRTOS\Source\event_groups.c
#        -D USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Middlewares\FreeRTOS
#        -lA
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Middlewares\FreeRTOS
#        -o
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Core/Inc\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/App\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS\event_groups.o.d
#    Locale                       =  C
#    List file                    =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Middlewares\FreeRTOS\event_groups.lst
#    Object file                  =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS\event_groups.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

D:\99_Project\GitHub\TouchGFX\MyApplication\Middlewares\Third_Party\FreeRTOS\Source\event_groups.c
      1          /*
      2           * FreeRTOS Kernel V10.3.1
      3           * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
      4           *
      5           * Permission is hereby granted, free of charge, to any person obtaining a copy of
      6           * this software and associated documentation files (the "Software"), to deal in
      7           * the Software without restriction, including without limitation the rights to
      8           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
      9           * the Software, and to permit persons to whom the Software is furnished to do so,
     10           * subject to the following conditions:
     11           *
     12           * The above copyright notice and this permission notice shall be included in all
     13           * copies or substantial portions of the Software.
     14           *
     15           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     16           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     17           * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     18           * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     19           * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     20           * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     21           *
     22           * http://www.FreeRTOS.org
     23           * http://aws.amazon.com/freertos
     24           *
     25           * 1 tab == 4 spaces!
     26           */
     27          
     28          /* Standard includes. */
     29          #include <stdlib.h>
     30          
     31          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     32          all the API functions to use the MPU wrappers.  That should only be done when
     33          task.h is included from an application file. */
     34          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     35          
     36          /* FreeRTOS includes. */
     37          #include "FreeRTOS.h"
     38          #include "task.h"
     39          #include "timers.h"
     40          #include "event_groups.h"
     41          
     42          /* Lint e961, e750 and e9021 are suppressed as a MISRA exception justified
     43          because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
     44          for the header files above, but not in this file, in order to generate the
     45          correct privileged Vs unprivileged linkage and placement. */
     46          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021 See comment above. */
     47          
     48          /* The following bit fields convey control information in a task's event list
     49          item value.  It is important they don't clash with the
     50          taskEVENT_LIST_ITEM_VALUE_IN_USE definition. */
     51          #if configUSE_16_BIT_TICKS == 1
     52          	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x0100U
     53          	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x0200U
     54          	#define eventWAIT_FOR_ALL_BITS			0x0400U
     55          	#define eventEVENT_BITS_CONTROL_BYTES	0xff00U
     56          #else
     57          	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x01000000UL
     58          	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x02000000UL
     59          	#define eventWAIT_FOR_ALL_BITS			0x04000000UL
     60          	#define eventEVENT_BITS_CONTROL_BYTES	0xff000000UL
     61          #endif
     62          
     63          typedef struct EventGroupDef_t
     64          {
     65          	EventBits_t uxEventBits;
     66          	List_t xTasksWaitingForBits;		/*< List of tasks waiting for a bit to be set. */
     67          
     68          	#if( configUSE_TRACE_FACILITY == 1 )
     69          		UBaseType_t uxEventGroupNumber;
     70          	#endif
     71          
     72          	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
     73          		uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the event group is statically allocated to ensure no attempt is made to free the memory. */
     74          	#endif
     75          } EventGroup_t;
     76          
     77          /*-----------------------------------------------------------*/
     78          
     79          /*
     80           * Test the bits set in uxCurrentEventBits to see if the wait condition is met.
     81           * The wait condition is defined by xWaitForAllBits.  If xWaitForAllBits is
     82           * pdTRUE then the wait condition is met if all the bits set in uxBitsToWaitFor
     83           * are also set in uxCurrentEventBits.  If xWaitForAllBits is pdFALSE then the
     84           * wait condition is met if any of the bits set in uxBitsToWait for are also set
     85           * in uxCurrentEventBits.
     86           */
     87          static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits ) PRIVILEGED_FUNCTION;
     88          
     89          /*-----------------------------------------------------------*/
     90          
     91          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
     92          

   \                                 In section .text, align 2, keep-with-next
     93          	EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer )
     94          	{
   \                     xEventGroupCreateStatic: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     95          	EventGroup_t *pxEventBits;
     96          
     97          		/* A StaticEventGroup_t object must be provided. */
     98          		configASSERT( pxEventGroupBuffer );
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD107             BNE.N    ??xEventGroupCreateStatic_0
   \        0x8   0x2050             MOVS     R0,#+80
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupCreateStatic_1: (+1)
   \       0x16   0xE7FE             B.N      ??xEventGroupCreateStatic_1
     99          
    100          		#if( configASSERT_DEFINED == 1 )
    101          		{
    102          			/* Sanity check that the size of the structure used to declare a
    103          			variable of type StaticEventGroup_t equals the size of the real
    104          			event group structure. */
    105          			volatile size_t xSize = sizeof( StaticEventGroup_t );
   \                     ??xEventGroupCreateStatic_0: (+1)
   \       0x18   0x2020             MOVS     R0,#+32
   \       0x1A   0x9000             STR      R0,[SP, #+0]
    106          			configASSERT( xSize == sizeof( EventGroup_t ) );
   \       0x1C   0x9800             LDR      R0,[SP, #+0]
   \       0x1E   0x2820             CMP      R0,#+32
   \       0x20   0xD007             BEQ.N    ??xEventGroupCreateStatic_2
   \       0x22   0x2050             MOVS     R0,#+80
   \       0x24   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x28   0xF3BF 0x8F4F      DSB      SY
   \       0x2C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupCreateStatic_3: (+1)
   \       0x30   0xE7FE             B.N      ??xEventGroupCreateStatic_3
    107          		} /*lint !e529 xSize is referenced if configASSERT() is defined. */
    108          		#endif /* configASSERT_DEFINED */
    109          
    110          		/* The user has provided a statically allocated event group - use it. */
    111          		pxEventBits = ( EventGroup_t * ) pxEventGroupBuffer; /*lint !e740 !e9087 EventGroup_t and StaticEventGroup_t are deliberately aliased for data hiding purposes and guaranteed to have the same size and alignment requirement - checked by configASSERT(). */
    112          
    113          		if( pxEventBits != NULL )
   \                     ??xEventGroupCreateStatic_2: (+1)
   \       0x32   0x2C00             CMP      R4,#+0
   \       0x34   0xD006             BEQ.N    ??xEventGroupCreateStatic_4
    114          		{
    115          			pxEventBits->uxEventBits = 0;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x6020             STR      R0,[R4, #+0]
    116          			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
   \       0x3A   0x1D20             ADDS     R0,R4,#+4
   \       0x3C   0x.... 0x....      BL       vListInitialise
    117          
    118          			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    119          			{
    120          				/* Both static and dynamic allocation can be used, so note that
    121          				this event group was created statically in case the event group
    122          				is later deleted. */
    123          				pxEventBits->ucStaticallyAllocated = pdTRUE;
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0x7720             STRB     R0,[R4, #+28]
    124          			}
    125          			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    126          
    127          			traceEVENT_GROUP_CREATE( pxEventBits );
    128          		}
    129          		else
    130          		{
    131          			/* xEventGroupCreateStatic should only ever be called with
    132          			pxEventGroupBuffer pointing to a pre-allocated (compile time
    133          			allocated) StaticEventGroup_t variable. */
    134          			traceEVENT_GROUP_CREATE_FAILED();
    135          		}
    136          
    137          		return pxEventBits;
   \                     ??xEventGroupCreateStatic_4: (+1)
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0xBD16             POP      {R1,R2,R4,PC}
    138          	}
    139          
    140          #endif /* configSUPPORT_STATIC_ALLOCATION */
    141          /*-----------------------------------------------------------*/
    142          
    143          #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    144          

   \                                 In section .text, align 2, keep-with-next
    145          	EventGroupHandle_t xEventGroupCreate( void )
    146          	{
   \                     xEventGroupCreate: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    147          	EventGroup_t *pxEventBits;
    148          
    149          		/* Allocate the event group.  Justification for MISRA deviation as
    150          		follows:  pvPortMalloc() always ensures returned memory blocks are
    151          		aligned per the requirements of the MCU stack.  In this case
    152          		pvPortMalloc() must return a pointer that is guaranteed to meet the
    153          		alignment requirements of the EventGroup_t structure - which (if you
    154          		follow it through) is the alignment requirements of the TickType_t type
    155          		(EventBits_t being of TickType_t itself).  Therefore, whenever the
    156          		stack alignment requirements are greater than or equal to the
    157          		TickType_t alignment requirements the cast is safe.  In other cases,
    158          		where the natural word size of the architecture is less than
    159          		sizeof( TickType_t ), the TickType_t variables will be accessed in two
    160          		or more reads operations, and the alignment requirements is only that
    161          		of each individual read. */
    162          		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
   \        0x2   0x2020             MOVS     R0,#+32
   \        0x4   0x.... 0x....      BL       pvPortMalloc
   \        0x8   0x0004             MOVS     R4,R0
    163          
    164          		if( pxEventBits != NULL )
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD006             BEQ.N    ??xEventGroupCreate_0
    165          		{
    166          			pxEventBits->uxEventBits = 0;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x6020             STR      R0,[R4, #+0]
    167          			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
   \       0x12   0x1D20             ADDS     R0,R4,#+4
   \       0x14   0x.... 0x....      BL       vListInitialise
    168          
    169          			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
    170          			{
    171          				/* Both static and dynamic allocation can be used, so note this
    172          				event group was allocated statically in case the event group is
    173          				later deleted. */
    174          				pxEventBits->ucStaticallyAllocated = pdFALSE;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x7720             STRB     R0,[R4, #+28]
    175          			}
    176          			#endif /* configSUPPORT_STATIC_ALLOCATION */
    177          
    178          			traceEVENT_GROUP_CREATE( pxEventBits );
    179          		}
    180          		else
    181          		{
    182          			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
    183          		}
    184          
    185          		return pxEventBits;
   \                     ??xEventGroupCreate_0: (+1)
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0xBD10             POP      {R4,PC}
    186          	}
    187          
    188          #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    189          /*-----------------------------------------------------------*/
    190          

   \                                 In section .text, align 2, keep-with-next
    191          EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
    192          {
   \                     xEventGroupSync: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001C             MOVS     R4,R3
    193          EventBits_t uxOriginalBitValue, uxReturn;
    194          EventGroup_t *pxEventBits = xEventGroup;
   \        0xC   0x4647             MOV      R7,R8
    195          BaseType_t xAlreadyYielded;
    196          BaseType_t xTimeoutOccurred = pdFALSE;
   \        0xE   0x2000             MOVS     R0,#+0
    197          
    198          	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \       0x10   0xF015 0x4F7F      TST      R5,#0xFF000000
   \       0x14   0xD007             BEQ.N    ??xEventGroupSync_0
   \       0x16   0x2050             MOVS     R0,#+80
   \       0x18   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x1C   0xF3BF 0x8F4F      DSB      SY
   \       0x20   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSync_1: (+1)
   \       0x24   0xE7FE             B.N      ??xEventGroupSync_1
    199          	configASSERT( uxBitsToWaitFor != 0 );
   \                     ??xEventGroupSync_0: (+1)
   \       0x26   0x2D00             CMP      R5,#+0
   \       0x28   0xD107             BNE.N    ??xEventGroupSync_2
   \       0x2A   0x2050             MOVS     R0,#+80
   \       0x2C   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x30   0xF3BF 0x8F4F      DSB      SY
   \       0x34   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSync_3: (+1)
   \       0x38   0xE7FE             B.N      ??xEventGroupSync_3
    200          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    201          	{
    202          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??xEventGroupSync_2: (+1)
   \       0x3A   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD101             BNE.N    ??xEventGroupSync_4
   \       0x42   0x2C00             CMP      R4,#+0
   \       0x44   0xD101             BNE.N    ??xEventGroupSync_5
   \                     ??xEventGroupSync_4: (+1)
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0xE000             B.N      ??xEventGroupSync_6
   \                     ??xEventGroupSync_5: (+1)
   \       0x4A   0x2000             MOVS     R0,#+0
   \                     ??xEventGroupSync_6: (+1)
   \       0x4C   0xB2C0             UXTB     R0,R0
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD107             BNE.N    ??xEventGroupSync_7
   \       0x52   0x2050             MOVS     R0,#+80
   \       0x54   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x58   0xF3BF 0x8F4F      DSB      SY
   \       0x5C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSync_8: (+1)
   \       0x60   0xE7FE             B.N      ??xEventGroupSync_8
    203          	}
    204          	#endif
    205          
    206          	vTaskSuspendAll();
   \                     ??xEventGroupSync_7: (+1)
   \       0x62   0x.... 0x....      BL       vTaskSuspendAll
    207          	{
    208          		uxOriginalBitValue = pxEventBits->uxEventBits;
   \       0x66   0xF8D7 0x9000      LDR      R9,[R7, #+0]
    209          
    210          		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
   \       0x6A   0x0031             MOVS     R1,R6
   \       0x6C   0x4640             MOV      R0,R8
   \       0x6E   0x.... 0x....      BL       xEventGroupSetBits
    211          
    212          		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \       0x72   0xEA56 0x0009      ORRS     R0,R6,R9
   \       0x76   0x4028             ANDS     R0,R5,R0
   \       0x78   0x42A8             CMP      R0,R5
   \       0x7A   0xD106             BNE.N    ??xEventGroupSync_9
    213          		{
    214          			/* All the rendezvous bits are now set - no need to block. */
    215          			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
   \       0x7C   0xEA56 0x0609      ORRS     R6,R6,R9
    216          
    217          			/* Rendezvous always clear the bits.  They will have been cleared
    218          			already unless this is the only task in the rendezvous. */
    219          			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \       0x80   0x6838             LDR      R0,[R7, #+0]
   \       0x82   0x43A8             BICS     R0,R0,R5
   \       0x84   0x6038             STR      R0,[R7, #+0]
    220          
    221          			xTicksToWait = 0;
   \       0x86   0x2400             MOVS     R4,#+0
   \       0x88   0xE00B             B.N      ??xEventGroupSync_10
    222          		}
    223          		else
    224          		{
    225          			if( xTicksToWait != ( TickType_t ) 0 )
   \                     ??xEventGroupSync_9: (+1)
   \       0x8A   0x2C00             CMP      R4,#+0
   \       0x8C   0xD007             BEQ.N    ??xEventGroupSync_11
    226          			{
    227          				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
    228          
    229          				/* Store the bits that the calling task is waiting for in the
    230          				task's event list item so the kernel knows when a match is
    231          				found.  Then enter the blocked state. */
    232          				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
   \       0x8E   0x0022             MOVS     R2,R4
   \       0x90   0xF055 0x61A0      ORRS     R1,R5,#0x5000000
   \       0x94   0x1D38             ADDS     R0,R7,#+4
   \       0x96   0x.... 0x....      BL       vTaskPlaceOnUnorderedEventList
    233          
    234          				/* This assignment is obsolete as uxReturn will get set after
    235          				the task unblocks, but some compilers mistakenly generate a
    236          				warning about uxReturn being returned without being set if the
    237          				assignment is omitted. */
    238          				uxReturn = 0;
   \       0x9A   0x2600             MOVS     R6,#+0
   \       0x9C   0xE001             B.N      ??xEventGroupSync_10
    239          			}
    240          			else
    241          			{
    242          				/* The rendezvous bits were not set, but no block time was
    243          				specified - just return the current event bit value. */
    244          				uxReturn = pxEventBits->uxEventBits;
   \                     ??xEventGroupSync_11: (+1)
   \       0x9E   0x683E             LDR      R6,[R7, #+0]
    245          				xTimeoutOccurred = pdTRUE;
   \       0xA0   0x2001             MOVS     R0,#+1
    246          			}
    247          		}
    248          	}
    249          	xAlreadyYielded = xTaskResumeAll();
   \                     ??xEventGroupSync_10: (+1)
   \       0xA2   0x.... 0x....      BL       xTaskResumeAll
    250          
    251          	if( xTicksToWait != ( TickType_t ) 0 )
   \       0xA6   0x2C00             CMP      R4,#+0
   \       0xA8   0xD01E             BEQ.N    ??xEventGroupSync_12
    252          	{
    253          		if( xAlreadyYielded == pdFALSE )
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD107             BNE.N    ??xEventGroupSync_13
    254          		{
    255          			portYIELD_WITHIN_API();
   \       0xAE   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0xB2   0x....             LDR.N    R1,??DataTable3
   \       0xB4   0x6008             STR      R0,[R1, #+0]
   \       0xB6   0xF3BF 0x8F4F      DSB      SY
   \       0xBA   0xF3BF 0x8F6F      ISB      SY
    256          		}
    257          		else
    258          		{
    259          			mtCOVERAGE_TEST_MARKER();
    260          		}
    261          
    262          		/* The task blocked to wait for its required bits to be set - at this
    263          		point either the required bits were set or the block time expired.  If
    264          		the required bits were set they will have been stored in the task's
    265          		event list item, and they should now be retrieved then cleared. */
    266          		uxReturn = uxTaskResetEventItemValue();
   \                     ??xEventGroupSync_13: (+1)
   \       0xBE   0x.... 0x....      BL       uxTaskResetEventItemValue
   \       0xC2   0x0006             MOVS     R6,R0
    267          
    268          		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
   \       0xC4   0x01B0             LSLS     R0,R6,#+6
   \       0xC6   0xD40D             BMI.N    ??xEventGroupSync_14
    269          		{
    270          			/* The task timed out, just return the current event bit value. */
    271          			taskENTER_CRITICAL();
   \       0xC8   0x.... 0x....      BL       vPortEnterCritical
    272          			{
    273          				uxReturn = pxEventBits->uxEventBits;
   \       0xCC   0x683E             LDR      R6,[R7, #+0]
    274          
    275          				/* Although the task got here because it timed out before the
    276          				bits it was waiting for were set, it is possible that since it
    277          				unblocked another task has set the bits.  If this is the case
    278          				then it needs to clear the bits before exiting. */
    279          				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \       0xCE   0xEA15 0x0006      ANDS     R0,R5,R6
   \       0xD2   0x42A8             CMP      R0,R5
   \       0xD4   0xD103             BNE.N    ??xEventGroupSync_15
    280          				{
    281          					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \       0xD6   0x6838             LDR      R0,[R7, #+0]
   \       0xD8   0xEA30 0x0505      BICS     R5,R0,R5
   \       0xDC   0x603D             STR      R5,[R7, #+0]
    282          				}
    283          				else
    284          				{
    285          					mtCOVERAGE_TEST_MARKER();
    286          				}
    287          			}
    288          			taskEXIT_CRITICAL();
   \                     ??xEventGroupSync_15: (+1)
   \       0xDE   0x.... 0x....      BL       vPortExitCritical
    289          
    290          			xTimeoutOccurred = pdTRUE;
   \       0xE2   0x2001             MOVS     R0,#+1
    291          		}
    292          		else
    293          		{
    294          			/* The task unblocked because the bits were set. */
    295          		}
    296          
    297          		/* Control bits might be set as the task had blocked should not be
    298          		returned. */
    299          		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
   \                     ??xEventGroupSync_14: (+1)
   \       0xE4   0xF026 0x467F      BIC      R6,R6,#0xFF000000
    300          	}
    301          
    302          	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
    303          
    304          	/* Prevent compiler warnings when trace macros are not used. */
    305          	( void ) xTimeoutOccurred;
    306          
    307          	return uxReturn;
   \                     ??xEventGroupSync_12: (+1)
   \       0xE8   0x0030             MOVS     R0,R6
   \       0xEA   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    308          }
    309          /*-----------------------------------------------------------*/
    310          

   \                                 In section .text, align 2, keep-with-next
    311          EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
    312          {
   \                     xEventGroupWaitBits: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0014             MOVS     R4,R2
   \        0x6   0x001F             MOVS     R7,R3
    313          EventGroup_t *pxEventBits = xEventGroup;
   \        0x8   0x4680             MOV      R8,R0
    314          EventBits_t uxReturn, uxControlBits = 0;
   \        0xA   0xF05F 0x0900      MOVS     R9,#+0
    315          BaseType_t xWaitConditionMet, xAlreadyYielded;
    316          BaseType_t xTimeoutOccurred = pdFALSE;
   \        0xE   0x2200             MOVS     R2,#+0
    317          
    318          	/* Check the user is not attempting to wait on the bits used by the kernel
    319          	itself, and that at least one bit is being requested. */
    320          	configASSERT( xEventGroup );
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD107             BNE.N    ??xEventGroupWaitBits_0
   \       0x14   0x2050             MOVS     R0,#+80
   \       0x16   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x1A   0xF3BF 0x8F4F      DSB      SY
   \       0x1E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupWaitBits_1: (+1)
   \       0x22   0xE7FE             B.N      ??xEventGroupWaitBits_1
   \                     ??xEventGroupWaitBits_0: (+1)
   \       0x24   0x000E             MOVS     R6,R1
    321          	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \       0x26   0xF016 0x4F7F      TST      R6,#0xFF000000
   \       0x2A   0xD007             BEQ.N    ??xEventGroupWaitBits_2
   \       0x2C   0x2050             MOVS     R0,#+80
   \       0x2E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x32   0xF3BF 0x8F4F      DSB      SY
   \       0x36   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupWaitBits_3: (+1)
   \       0x3A   0xE7FE             B.N      ??xEventGroupWaitBits_3
    322          	configASSERT( uxBitsToWaitFor != 0 );
   \                     ??xEventGroupWaitBits_2: (+1)
   \       0x3C   0x2E00             CMP      R6,#+0
   \       0x3E   0xD107             BNE.N    ??xEventGroupWaitBits_4
   \       0x40   0x2050             MOVS     R0,#+80
   \       0x42   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x46   0xF3BF 0x8F4F      DSB      SY
   \       0x4A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupWaitBits_5: (+1)
   \       0x4E   0xE7FE             B.N      ??xEventGroupWaitBits_5
   \                     ??xEventGroupWaitBits_4: (+1)
   \       0x50   0x9D08             LDR      R5,[SP, #+32]
    323          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    324          	{
    325          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \       0x52   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD101             BNE.N    ??xEventGroupWaitBits_6
   \       0x5A   0x2D00             CMP      R5,#+0
   \       0x5C   0xD101             BNE.N    ??xEventGroupWaitBits_7
   \                     ??xEventGroupWaitBits_6: (+1)
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0xE000             B.N      ??xEventGroupWaitBits_8
   \                     ??xEventGroupWaitBits_7: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \                     ??xEventGroupWaitBits_8: (+1)
   \       0x64   0xB2C0             UXTB     R0,R0
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD107             BNE.N    ??xEventGroupWaitBits_9
   \       0x6A   0x2050             MOVS     R0,#+80
   \       0x6C   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x70   0xF3BF 0x8F4F      DSB      SY
   \       0x74   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupWaitBits_10: (+1)
   \       0x78   0xE7FE             B.N      ??xEventGroupWaitBits_10
    326          	}
    327          	#endif
    328          
    329          	vTaskSuspendAll();
   \                     ??xEventGroupWaitBits_9: (+1)
   \       0x7A   0x.... 0x....      BL       vTaskSuspendAll
    330          	{
    331          		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
   \       0x7E   0xF8D8 0xA000      LDR      R10,[R8, #+0]
    332          
    333          		/* Check to see if the wait condition is already met or not. */
    334          		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
   \       0x82   0x003A             MOVS     R2,R7
   \       0x84   0x0031             MOVS     R1,R6
   \       0x86   0x4650             MOV      R0,R10
   \       0x88   0x.... 0x....      BL       prvTestWaitCondition
    335          
    336          		if( xWaitConditionMet != pdFALSE )
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD008             BEQ.N    ??xEventGroupWaitBits_11
    337          		{
    338          			/* The wait condition has already been met so there is no need to
    339          			block. */
    340          			uxReturn = uxCurrentEventBits;
    341          			xTicksToWait = ( TickType_t ) 0;
   \       0x90   0x2500             MOVS     R5,#+0
    342          
    343          			/* Clear the wait bits if requested to do so. */
    344          			if( xClearOnExit != pdFALSE )
   \       0x92   0x2C00             CMP      R4,#+0
   \       0x94   0xD01B             BEQ.N    ??xEventGroupWaitBits_12
    345          			{
    346          				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \       0x96   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x9A   0x43B0             BICS     R0,R0,R6
   \       0x9C   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \       0xA0   0xE015             B.N      ??xEventGroupWaitBits_12
    347          			}
    348          			else
    349          			{
    350          				mtCOVERAGE_TEST_MARKER();
    351          			}
    352          		}
    353          		else if( xTicksToWait == ( TickType_t ) 0 )
   \                     ??xEventGroupWaitBits_11: (+1)
   \       0xA2   0x2D00             CMP      R5,#+0
   \       0xA4   0xD101             BNE.N    ??xEventGroupWaitBits_13
    354          		{
    355          			/* The wait condition has not been met, but no block time was
    356          			specified, so just return the current value. */
    357          			uxReturn = uxCurrentEventBits;
    358          			xTimeoutOccurred = pdTRUE;
   \       0xA6   0x2001             MOVS     R0,#+1
   \       0xA8   0xE011             B.N      ??xEventGroupWaitBits_12
    359          		}
    360          		else
    361          		{
    362          			/* The task is going to block to wait for its required bits to be
    363          			set.  uxControlBits are used to remember the specified behaviour of
    364          			this call to xEventGroupWaitBits() - for use when the event bits
    365          			unblock the task. */
    366          			if( xClearOnExit != pdFALSE )
   \                     ??xEventGroupWaitBits_13: (+1)
   \       0xAA   0x2C00             CMP      R4,#+0
   \       0xAC   0xD001             BEQ.N    ??xEventGroupWaitBits_14
    367          			{
    368          				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
   \       0xAE   0xF059 0x7980      ORRS     R9,R9,#0x1000000
    369          			}
    370          			else
    371          			{
    372          				mtCOVERAGE_TEST_MARKER();
    373          			}
    374          
    375          			if( xWaitForAllBits != pdFALSE )
   \                     ??xEventGroupWaitBits_14: (+1)
   \       0xB2   0x2F00             CMP      R7,#+0
   \       0xB4   0xD001             BEQ.N    ??xEventGroupWaitBits_15
    376          			{
    377          				uxControlBits |= eventWAIT_FOR_ALL_BITS;
   \       0xB6   0xF059 0x6980      ORRS     R9,R9,#0x4000000
    378          			}
    379          			else
    380          			{
    381          				mtCOVERAGE_TEST_MARKER();
    382          			}
    383          
    384          			/* Store the bits that the calling task is waiting for in the
    385          			task's event list item so the kernel knows when a match is
    386          			found.  Then enter the blocked state. */
    387          			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
   \                     ??xEventGroupWaitBits_15: (+1)
   \       0xBA   0x002A             MOVS     R2,R5
   \       0xBC   0xEA59 0x0906      ORRS     R9,R9,R6
   \       0xC0   0x4649             MOV      R1,R9
   \       0xC2   0xF118 0x0004      ADDS     R0,R8,#+4
   \       0xC6   0x.... 0x....      BL       vTaskPlaceOnUnorderedEventList
    388          
    389          			/* This is obsolete as it will get set after the task unblocks, but
    390          			some compilers mistakenly generate a warning about the variable
    391          			being returned without being set if it is not done. */
    392          			uxReturn = 0;
   \       0xCA   0xF05F 0x0A00      MOVS     R10,#+0
    393          
    394          			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
    395          		}
    396          	}
    397          	xAlreadyYielded = xTaskResumeAll();
   \                     ??xEventGroupWaitBits_12: (+1)
   \       0xCE   0x.... 0x....      BL       xTaskResumeAll
    398          
    399          	if( xTicksToWait != ( TickType_t ) 0 )
   \       0xD2   0x2D00             CMP      R5,#+0
   \       0xD4   0xD027             BEQ.N    ??xEventGroupWaitBits_16
    400          	{
    401          		if( xAlreadyYielded == pdFALSE )
   \       0xD6   0x2800             CMP      R0,#+0
   \       0xD8   0xD107             BNE.N    ??xEventGroupWaitBits_17
    402          		{
    403          			portYIELD_WITHIN_API();
   \       0xDA   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0xDE   0x....             LDR.N    R1,??DataTable3
   \       0xE0   0x6008             STR      R0,[R1, #+0]
   \       0xE2   0xF3BF 0x8F4F      DSB      SY
   \       0xE6   0xF3BF 0x8F6F      ISB      SY
    404          		}
    405          		else
    406          		{
    407          			mtCOVERAGE_TEST_MARKER();
    408          		}
    409          
    410          		/* The task blocked to wait for its required bits to be set - at this
    411          		point either the required bits were set or the block time expired.  If
    412          		the required bits were set they will have been stored in the task's
    413          		event list item, and they should now be retrieved then cleared. */
    414          		uxReturn = uxTaskResetEventItemValue();
   \                     ??xEventGroupWaitBits_17: (+1)
   \       0xEA   0x.... 0x....      BL       uxTaskResetEventItemValue
   \       0xEE   0x4682             MOV      R10,R0
    415          
    416          		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
   \       0xF0   0xEA5F 0x108A      LSLS     R0,R10,#+6
   \       0xF4   0xD415             BMI.N    ??xEventGroupWaitBits_18
    417          		{
    418          			taskENTER_CRITICAL();
   \       0xF6   0x.... 0x....      BL       vPortEnterCritical
    419          			{
    420          				/* The task timed out, just return the current event bit value. */
    421          				uxReturn = pxEventBits->uxEventBits;
   \       0xFA   0xF8D8 0xA000      LDR      R10,[R8, #+0]
    422          
    423          				/* It is possible that the event bits were updated between this
    424          				task leaving the Blocked state and running again. */
    425          				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
   \       0xFE   0x003A             MOVS     R2,R7
   \      0x100   0x0031             MOVS     R1,R6
   \      0x102   0x4650             MOV      R0,R10
   \      0x104   0x.... 0x....      BL       prvTestWaitCondition
   \      0x108   0x2800             CMP      R0,#+0
   \      0x10A   0xD007             BEQ.N    ??xEventGroupWaitBits_19
    426          				{
    427          					if( xClearOnExit != pdFALSE )
   \      0x10C   0x2C00             CMP      R4,#+0
   \      0x10E   0xD005             BEQ.N    ??xEventGroupWaitBits_19
    428          					{
    429          						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   \      0x110   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x114   0xEA30 0x0606      BICS     R6,R0,R6
   \      0x118   0xF8C8 0x6000      STR      R6,[R8, #+0]
    430          					}
    431          					else
    432          					{
    433          						mtCOVERAGE_TEST_MARKER();
    434          					}
    435          				}
    436          				else
    437          				{
    438          					mtCOVERAGE_TEST_MARKER();
    439          				}
    440          				xTimeoutOccurred = pdTRUE;
   \                     ??xEventGroupWaitBits_19: (+1)
   \      0x11C   0x2001             MOVS     R0,#+1
    441          			}
    442          			taskEXIT_CRITICAL();
   \      0x11E   0x.... 0x....      BL       vPortExitCritical
    443          		}
    444          		else
    445          		{
    446          			/* The task unblocked because the bits were set. */
    447          		}
    448          
    449          		/* The task blocked so control bits may have been set. */
    450          		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
   \                     ??xEventGroupWaitBits_18: (+1)
   \      0x122   0xF02A 0x4A7F      BIC      R10,R10,#0xFF000000
    451          	}
    452          	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
    453          
    454          	/* Prevent compiler warnings when trace macros are not used. */
    455          	( void ) xTimeoutOccurred;
    456          
    457          	return uxReturn;
   \                     ??xEventGroupWaitBits_16: (+1)
   \      0x126   0x4650             MOV      R0,R10
   \      0x128   0xE8BD 0x87F0      POP      {R4-R10,PC}
    458          }
    459          /*-----------------------------------------------------------*/
    460          

   \                                 In section .text, align 2, keep-with-next
    461          EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
    462          {
   \                     xEventGroupClearBits: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x000C             MOVS     R4,R1
    463          EventGroup_t *pxEventBits = xEventGroup;
   \        0x4   0x0005             MOVS     R5,R0
    464          EventBits_t uxReturn;
    465          
    466          	/* Check the user is not attempting to clear the bits used by the kernel
    467          	itself. */
    468          	configASSERT( xEventGroup );
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD107             BNE.N    ??xEventGroupClearBits_0
   \        0xA   0x2050             MOVS     R0,#+80
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupClearBits_1: (+1)
   \       0x18   0xE7FE             B.N      ??xEventGroupClearBits_1
    469          	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \                     ??xEventGroupClearBits_0: (+1)
   \       0x1A   0xF014 0x4F7F      TST      R4,#0xFF000000
   \       0x1E   0xD007             BEQ.N    ??xEventGroupClearBits_2
   \       0x20   0x2050             MOVS     R0,#+80
   \       0x22   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x26   0xF3BF 0x8F4F      DSB      SY
   \       0x2A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupClearBits_3: (+1)
   \       0x2E   0xE7FE             B.N      ??xEventGroupClearBits_3
    470          
    471          	taskENTER_CRITICAL();
   \                     ??xEventGroupClearBits_2: (+1)
   \       0x30   0x.... 0x....      BL       vPortEnterCritical
    472          	{
    473          		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
    474          
    475          		/* The value returned is the event group value prior to the bits being
    476          		cleared. */
    477          		uxReturn = pxEventBits->uxEventBits;
   \       0x34   0x682E             LDR      R6,[R5, #+0]
    478          
    479          		/* Clear the bits. */
    480          		pxEventBits->uxEventBits &= ~uxBitsToClear;
   \       0x36   0x6828             LDR      R0,[R5, #+0]
   \       0x38   0xEA30 0x0404      BICS     R4,R0,R4
   \       0x3C   0x602C             STR      R4,[R5, #+0]
    481          	}
    482          	taskEXIT_CRITICAL();
   \       0x3E   0x.... 0x....      BL       vPortExitCritical
    483          
    484          	return uxReturn;
   \       0x42   0x0030             MOVS     R0,R6
   \       0x44   0xBD70             POP      {R4-R6,PC}
    485          }
    486          /*-----------------------------------------------------------*/
    487          
    488          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
    489          

   \                                 In section .text, align 2, keep-with-next
    490          	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
    491          	{
   \                     xEventGroupClearBitsFromISR: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x000A             MOVS     R2,R1
    492          		BaseType_t xReturn;
    493          
    494          		traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
    495          		xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL ); /*lint !e9087 Can't avoid cast to void* as a generic callback function not specific to this use case. Callback casts back to original type so safe. */
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x0001             MOVS     R1,R0
   \        0x8   0x.... 0x....      ADR.W    R0,vEventGroupClearBitsCallback
   \        0xC   0x.... 0x....      BL       xTimerPendFunctionCallFromISR
    496          
    497          		return xReturn;
   \       0x10   0xBD02             POP      {R1,PC}
    498          	}
    499          
    500          #endif
    501          /*-----------------------------------------------------------*/
    502          

   \                                 In section .text, align 2, keep-with-next
    503          EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
    504          {
    505          UBaseType_t uxSavedInterruptStatus;
    506          EventGroup_t const * const pxEventBits = xEventGroup;
    507          EventBits_t uxReturn;
    508          
    509          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \                     xEventGroupGetBitsFromISR: (+1)
   \        0x0   0xF3EF 0x8111      MRS      R1,BASEPRI
   \        0x4   0x2250             MOVS     R2,#+80
   \        0x6   0xF382 0x8811      MSR      BASEPRI,R2
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
    510          	{
    511          		uxReturn = pxEventBits->uxEventBits;
   \       0x12   0x6800             LDR      R0,[R0, #+0]
    512          	}
    513          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \       0x14   0xF381 0x8811      MSR      BASEPRI,R1
    514          
    515          	return uxReturn;
   \       0x18   0x4770             BX       LR
    516          } /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    517          /*-----------------------------------------------------------*/
    518          

   \                                 In section .text, align 2, keep-with-next
    519          EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
    520          {
   \                     xEventGroupSetBits: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x000F             MOVS     R7,R1
    521          ListItem_t *pxListItem, *pxNext;
    522          ListItem_t const *pxListEnd;
    523          List_t const * pxList;
    524          EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
   \        0x6   0x2500             MOVS     R5,#+0
    525          EventGroup_t *pxEventBits = xEventGroup;
   \        0x8   0x0004             MOVS     R4,R0
    526          BaseType_t xMatchFound = pdFALSE;
   \        0xA   0x2100             MOVS     R1,#+0
    527          
    528          	/* Check the user is not attempting to set the bits used by the kernel
    529          	itself. */
    530          	configASSERT( xEventGroup );
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD107             BNE.N    ??xEventGroupSetBits_0
   \       0x10   0x2050             MOVS     R0,#+80
   \       0x12   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x16   0xF3BF 0x8F4F      DSB      SY
   \       0x1A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSetBits_1: (+1)
   \       0x1E   0xE7FE             B.N      ??xEventGroupSetBits_1
    531          	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
   \                     ??xEventGroupSetBits_0: (+1)
   \       0x20   0xF017 0x4F7F      TST      R7,#0xFF000000
   \       0x24   0xD007             BEQ.N    ??xEventGroupSetBits_2
   \       0x26   0x2050             MOVS     R0,#+80
   \       0x28   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2C   0xF3BF 0x8F4F      DSB      SY
   \       0x30   0xF3BF 0x8F6F      ISB      SY
   \                     ??xEventGroupSetBits_3: (+1)
   \       0x34   0xE7FE             B.N      ??xEventGroupSetBits_3
    532          
    533          	pxList = &( pxEventBits->xTasksWaitingForBits );
   \                     ??xEventGroupSetBits_2: (+1)
   \       0x36   0xF114 0x0804      ADDS     R8,R4,#+4
    534          	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   \       0x3A   0xF118 0x0608      ADDS     R6,R8,#+8
    535          	vTaskSuspendAll();
   \       0x3E   0x.... 0x....      BL       vTaskSuspendAll
    536          	{
    537          		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
    538          
    539          		pxListItem = listGET_HEAD_ENTRY( pxList );
   \       0x42   0xF8D8 0x200C      LDR      R2,[R8, #+12]
    540          
    541          		/* Set the bits. */
    542          		pxEventBits->uxEventBits |= uxBitsToSet;
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x4307             ORRS     R7,R7,R0
   \       0x4A   0x6027             STR      R7,[R4, #+0]
   \       0x4C   0xE023             B.N      ??xEventGroupSetBits_4
    543          
    544          		/* See if the new bit value should unblock any tasks. */
    545          		while( pxListItem != pxListEnd )
    546          		{
    547          			pxNext = listGET_NEXT( pxListItem );
    548          			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    549          			xMatchFound = pdFALSE;
    550          
    551          			/* Split the bits waited for from the control bits. */
    552          			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    553          			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    554          
    555          			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    556          			{
    557          				/* Just looking for single bit being set. */
    558          				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    559          				{
    560          					xMatchFound = pdTRUE;
    561          				}
    562          				else
    563          				{
    564          					mtCOVERAGE_TEST_MARKER();
    565          				}
    566          			}
    567          			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
   \                     ??xEventGroupSetBits_5: (+1)
   \       0x4E   0xF8D4 0xC000      LDR      R12,[R4, #+0]
   \       0x52   0xEA1C 0x0C01      ANDS     R12,R12,R1
   \       0x56   0x458C             CMP      R12,R1
   \       0x58   0xD111             BNE.N    ??xEventGroupSetBits_6
    568          			{
    569          				/* All bits are set. */
    570          				xMatchFound = pdTRUE;
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0xE00F             B.N      ??xEventGroupSetBits_6
    571          			}
   \                     ??xEventGroupSetBits_7: (+1)
   \       0x5E   0x6857             LDR      R7,[R2, #+4]
   \       0x60   0x6811             LDR      R1,[R2, #+0]
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xF011 0x437F      ANDS     R3,R1,#0xFF000000
   \       0x68   0xF021 0x417F      BIC      R1,R1,#0xFF000000
   \       0x6C   0xEA5F 0x1C43      LSLS     R12,R3,#+5
   \       0x70   0xD4ED             BMI.N    ??xEventGroupSetBits_5
   \       0x72   0xF8D4 0xC000      LDR      R12,[R4, #+0]
   \       0x76   0xEA11 0x0F0C      TST      R1,R12
   \       0x7A   0xD000             BEQ.N    ??xEventGroupSetBits_6
   \       0x7C   0x2001             MOVS     R0,#+1
    572          			else
    573          			{
    574          				/* Need all bits to be set, but not all the bits were set. */
    575          			}
    576          
    577          			if( xMatchFound != pdFALSE )
   \                     ??xEventGroupSetBits_6: (+1)
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD008             BEQ.N    ??xEventGroupSetBits_8
    578          			{
    579          				/* The bits match.  Should the bits be cleared on exit? */
    580          				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
   \       0x82   0x01D8             LSLS     R0,R3,#+7
   \       0x84   0xD500             BPL.N    ??xEventGroupSetBits_9
    581          				{
    582          					uxBitsToClear |= uxBitsWaitedFor;
   \       0x86   0x430D             ORRS     R5,R1,R5
    583          				}
    584          				else
    585          				{
    586          					mtCOVERAGE_TEST_MARKER();
    587          				}
    588          
    589          				/* Store the actual event flag value in the task's event list
    590          				item before removing the task from the event list.  The
    591          				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
    592          				that is was unblocked due to its required bits matching, rather
    593          				than because it timed out. */
    594          				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
   \                     ??xEventGroupSetBits_9: (+1)
   \       0x88   0x6821             LDR      R1,[R4, #+0]
   \       0x8A   0xF051 0x7100      ORRS     R1,R1,#0x2000000
   \       0x8E   0x0010             MOVS     R0,R2
   \       0x90   0x.... 0x....      BL       vTaskRemoveFromUnorderedEventList
    595          			}
    596          
    597          			/* Move onto the next list item.  Note pxListItem->pxNext is not
    598          			used here as the list item may have been removed from the event list
    599          			and inserted into the ready/pending reading list. */
    600          			pxListItem = pxNext;
   \                     ??xEventGroupSetBits_8: (+1)
   \       0x94   0x003A             MOVS     R2,R7
    601          		}
   \                     ??xEventGroupSetBits_4: (+1)
   \       0x96   0x42B2             CMP      R2,R6
   \       0x98   0xD1E1             BNE.N    ??xEventGroupSetBits_7
    602          
    603          		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
    604          		bit was set in the control word. */
    605          		pxEventBits->uxEventBits &= ~uxBitsToClear;
   \                     ??xEventGroupSetBits_10: (+1)
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0xEA30 0x0505      BICS     R5,R0,R5
   \       0xA0   0x6025             STR      R5,[R4, #+0]
    606          	}
    607          	( void ) xTaskResumeAll();
   \       0xA2   0x.... 0x....      BL       xTaskResumeAll
    608          
    609          	return pxEventBits->uxEventBits;
   \       0xA6   0x6820             LDR      R0,[R4, #+0]
   \       0xA8   0xE8BD 0x81F0      POP      {R4-R8,PC}
    610          }
    611          /*-----------------------------------------------------------*/
    612          

   \                                 In section .text, align 2, keep-with-next
    613          void vEventGroupDelete( EventGroupHandle_t xEventGroup )
    614          {
   \                     vEventGroupDelete: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    615          EventGroup_t *pxEventBits = xEventGroup;
    616          const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
   \        0x4   0x1D25             ADDS     R5,R4,#+4
    617          
    618          	vTaskSuspendAll();
   \        0x6   0x.... 0x....      BL       vTaskSuspendAll
   \        0xA   0xE004             B.N      ??vEventGroupDelete_0
    619          	{
    620          		traceEVENT_GROUP_DELETE( xEventGroup );
    621          
    622          		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    623          		{
    624          			/* Unblock the task, returning 0 as the event list is being deleted
    625          			and cannot therefore have any bits set. */
    626          			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
    627          			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
   \                     ??vEventGroupDelete_1: (+1)
   \        0xC   0xF05F 0x7100      MOVS     R1,#+33554432
   \       0x10   0x68E8             LDR      R0,[R5, #+12]
   \       0x12   0x.... 0x....      BL       vTaskRemoveFromUnorderedEventList
   \                     ??vEventGroupDelete_0: (+1)
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD00C             BEQ.N    ??vEventGroupDelete_2
   \       0x1C   0x68E8             LDR      R0,[R5, #+12]
   \       0x1E   0xF115 0x0108      ADDS     R1,R5,#+8
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD1F2             BNE.N    ??vEventGroupDelete_1
   \       0x26   0x2050             MOVS     R0,#+80
   \       0x28   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2C   0xF3BF 0x8F4F      DSB      SY
   \       0x30   0xF3BF 0x8F6F      ISB      SY
   \                     ??vEventGroupDelete_3: (+1)
   \       0x34   0xE7FE             B.N      ??vEventGroupDelete_3
    628          		}
    629          
    630          		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    631          		{
    632          			/* The event group can only have been allocated dynamically - free
    633          			it again. */
    634          			vPortFree( pxEventBits );
    635          		}
    636          		#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    637          		{
    638          			/* The event group could have been allocated statically or
    639          			dynamically, so check before attempting to free the memory. */
    640          			if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
   \                     ??vEventGroupDelete_2: (+1)
   \       0x36   0x7F20             LDRB     R0,[R4, #+28]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD102             BNE.N    ??vEventGroupDelete_4
    641          			{
    642          				vPortFree( pxEventBits );
   \       0x3C   0x0020             MOVS     R0,R4
   \       0x3E   0x.... 0x....      BL       vPortFree
    643          			}
    644          			else
    645          			{
    646          				mtCOVERAGE_TEST_MARKER();
    647          			}
    648          		}
    649          		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    650          	}
    651          	( void ) xTaskResumeAll();
   \                     ??vEventGroupDelete_4: (+1)
   \       0x42   0x.... 0x....      BL       xTaskResumeAll
    652          }
   \       0x46   0xBD31             POP      {R0,R4,R5,PC}
    653          /*-----------------------------------------------------------*/
    654          
    655          /* For internal use only - execute a 'set bits' command that was pended from
    656          an interrupt. */

   \                                 In section .text, align 2, keep-with-next
    657          void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
    658          {
   \                     vEventGroupSetBitsCallback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    659          	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
   \        0x2   0x.... 0x....      BL       xEventGroupSetBits
    660          }
   \        0x6   0xBD01             POP      {R0,PC}
    661          /*-----------------------------------------------------------*/
    662          
    663          /* For internal use only - execute a 'clear bits' command that was pended from
    664          an interrupt. */

   \                                 In section .text, align 4, keep-with-next
    665          void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
    666          {
   \                     vEventGroupClearBitsCallback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    667          	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
   \        0x2   0x.... 0x....      BL       xEventGroupClearBits
    668          }
   \        0x6   0xBD01             POP      {R0,PC}
    669          /*-----------------------------------------------------------*/
    670          

   \                                 In section .text, align 2, keep-with-next
    671          static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
    672          {
   \                     prvTestWaitCondition: (+1)
   \        0x0   0x0003             MOVS     R3,R0
    673          BaseType_t xWaitConditionMet = pdFALSE;
   \        0x2   0x2000             MOVS     R0,#+0
    674          
    675          	if( xWaitForAllBits == pdFALSE )
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD103             BNE.N    ??prvTestWaitCondition_0
    676          	{
    677          		/* Task only has to wait for one bit within uxBitsToWaitFor to be
    678          		set.  Is one already set? */
    679          		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
   \        0x8   0x420B             TST      R3,R1
   \        0xA   0xD005             BEQ.N    ??prvTestWaitCondition_1
    680          		{
    681          			xWaitConditionMet = pdTRUE;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE003             B.N      ??prvTestWaitCondition_1
    682          		}
    683          		else
    684          		{
    685          			mtCOVERAGE_TEST_MARKER();
    686          		}
    687          	}
    688          	else
    689          	{
    690          		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
    691          		Are they set already? */
    692          		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
   \                     ??prvTestWaitCondition_0: (+1)
   \       0x10   0x400B             ANDS     R3,R1,R3
   \       0x12   0x428B             CMP      R3,R1
   \       0x14   0xD100             BNE.N    ??prvTestWaitCondition_1
    693          		{
    694          			xWaitConditionMet = pdTRUE;
   \       0x16   0x2001             MOVS     R0,#+1
    695          		}
    696          		else
    697          		{
    698          			mtCOVERAGE_TEST_MARKER();
    699          		}
    700          	}
    701          
    702          	return xWaitConditionMet;
   \                     ??prvTestWaitCondition_1: (+1)
   \       0x18   0x4770             BX       LR
    703          }
    704          /*-----------------------------------------------------------*/
    705          
    706          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
    707          

   \                                 In section .text, align 2, keep-with-next
    708          	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
    709          	{
   \                     xEventGroupSetBitsFromISR: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x0013             MOVS     R3,R2
    710          	BaseType_t xReturn;
    711          
    712          		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
    713          		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken ); /*lint !e9087 Can't avoid cast to void* as a generic callback function not specific to this use case. Callback casts back to original type so safe. */
   \        0x4   0x000A             MOVS     R2,R1
   \        0x6   0x0001             MOVS     R1,R0
   \        0x8   0x....             LDR.N    R0,??DataTable3_1
   \        0xA   0x.... 0x....      BL       xTimerPendFunctionCallFromISR
    714          
    715          		return xReturn;
   \        0xE   0xBD02             POP      {R1,PC}
    716          	}
    717          
    718          #endif
    719          /*-----------------------------------------------------------*/
    720          
    721          #if (configUSE_TRACE_FACILITY == 1)
    722          

   \                                 In section .text, align 2, keep-with-next
    723          	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
    724          	{
    725          	UBaseType_t xReturn;
    726          	EventGroup_t const *pxEventBits = ( EventGroup_t * ) xEventGroup; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
   \                     uxEventGroupGetNumber: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    727          
    728          		if( xEventGroup == NULL )
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD101             BNE.N    ??uxEventGroupGetNumber_0
    729          		{
    730          			xReturn = 0;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xE000             B.N      ??uxEventGroupGetNumber_1
    731          		}
    732          		else
    733          		{
    734          			xReturn = pxEventBits->uxEventGroupNumber;
   \                     ??uxEventGroupGetNumber_0: (+1)
   \        0xA   0x6988             LDR      R0,[R1, #+24]
    735          		}
    736          
    737          		return xReturn;
   \                     ??uxEventGroupGetNumber_1: (+1)
   \        0xC   0x4770             BX       LR
    738          	}
    739          
    740          #endif /* configUSE_TRACE_FACILITY */
    741          /*-----------------------------------------------------------*/
    742          
    743          #if ( configUSE_TRACE_FACILITY == 1 )
    744          

   \                                 In section .text, align 2, keep-with-next
    745          	void vEventGroupSetNumber( void * xEventGroup, UBaseType_t uxEventGroupNumber )
    746          	{
    747          		( ( EventGroup_t * ) xEventGroup )->uxEventGroupNumber = uxEventGroupNumber; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
   \                     vEventGroupSetNumber: (+1)
   \        0x0   0x6181             STR      R1,[R0, #+24]
    748          	}
   \        0x2   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0xE000'ED04        DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     vEventGroupSetBitsCallback
    749          
    750          #endif /* configUSE_TRACE_FACILITY */
    751          /*-----------------------------------------------------------*/
    752          
    753          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   prvTestWaitCondition
       0   uxEventGroupGetNumber
       8   vEventGroupClearBitsCallback
         8   -> xEventGroupClearBits
      16   vEventGroupDelete
        16   -> vPortFree
        16   -> vTaskRemoveFromUnorderedEventList
        16   -> vTaskSuspendAll
        16   -> xTaskResumeAll
       8   vEventGroupSetBitsCallback
         8   -> xEventGroupSetBits
       0   vEventGroupSetNumber
      16   xEventGroupClearBits
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
       8   xEventGroupClearBitsFromISR
         8   -> xTimerPendFunctionCallFromISR
       8   xEventGroupCreate
         8   -> pvPortMalloc
         8   -> vListInitialise
      16   xEventGroupCreateStatic
        16   -> vListInitialise
       0   xEventGroupGetBitsFromISR
      24   xEventGroupSetBits
        24   -> vTaskRemoveFromUnorderedEventList
        24   -> vTaskSuspendAll
        24   -> xTaskResumeAll
       8   xEventGroupSetBitsFromISR
         8   -> xTimerPendFunctionCallFromISR
      32   xEventGroupSync
        32   -> uxTaskResetEventItemValue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vTaskPlaceOnUnorderedEventList
        32   -> vTaskSuspendAll
        32   -> xEventGroupSetBits
        32   -> xTaskGetSchedulerState
        32   -> xTaskResumeAll
      32   xEventGroupWaitBits
        32   -> prvTestWaitCondition
        32   -> uxTaskResetEventItemValue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vTaskPlaceOnUnorderedEventList
        32   -> vTaskSuspendAll
        32   -> xTaskGetSchedulerState
        32   -> xTaskResumeAll


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
      26  prvTestWaitCondition
      14  uxEventGroupGetNumber
       8  vEventGroupClearBitsCallback
      72  vEventGroupDelete
       8  vEventGroupSetBitsCallback
       4  vEventGroupSetNumber
      70  xEventGroupClearBits
      18  xEventGroupClearBitsFromISR
      32  xEventGroupCreate
      72  xEventGroupCreateStatic
      26  xEventGroupGetBitsFromISR
     172  xEventGroupSetBits
      16  xEventGroupSetBitsFromISR
     238  xEventGroupSync
     300  xEventGroupWaitBits

 
 1'084 bytes in section .text
 
 1'084 bytes of CODE memory

Errors: none
Warnings: none
