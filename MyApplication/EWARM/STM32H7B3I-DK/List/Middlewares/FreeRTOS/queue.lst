###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         07/Feb/2022  20:39:52
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\Middlewares\Third_Party\FreeRTOS\Source\queue.c
#        [UTF-8]
#    Command line                 =
#        -f
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS\queue.o.rsp
#        (D:\99_Project\GitHub\TouchGFX\MyApplication\Middlewares\Third_Party\FreeRTOS\Source\queue.c
#        -D USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Middlewares\FreeRTOS
#        -lA
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Middlewares\FreeRTOS
#        -o
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Core/Inc\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/App\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS\queue.o.d
#    Locale                       =  C
#    List file                    =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Middlewares\FreeRTOS\queue.lst
#    Object file                  =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS\queue.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

D:\99_Project\GitHub\TouchGFX\MyApplication\Middlewares\Third_Party\FreeRTOS\Source\queue.c
      1          /*
      2           * FreeRTOS Kernel V10.3.1
      3           * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
      4           *
      5           * Permission is hereby granted, free of charge, to any person obtaining a copy of
      6           * this software and associated documentation files (the "Software"), to deal in
      7           * the Software without restriction, including without limitation the rights to
      8           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
      9           * the Software, and to permit persons to whom the Software is furnished to do so,
     10           * subject to the following conditions:
     11           *
     12           * The above copyright notice and this permission notice shall be included in all
     13           * copies or substantial portions of the Software.
     14           *
     15           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     16           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     17           * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     18           * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     19           * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     20           * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     21           *
     22           * http://www.FreeRTOS.org
     23           * http://aws.amazon.com/freertos
     24           *
     25           * 1 tab == 4 spaces!
     26           */
     27          
     28          #include <stdlib.h>
     29          #include <string.h>
     30          
     31          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     32          all the API functions to use the MPU wrappers.  That should only be done when
     33          task.h is included from an application file. */
     34          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     35          
     36          #include "FreeRTOS.h"
     37          #include "task.h"
     38          #include "queue.h"
     39          
     40          #if ( configUSE_CO_ROUTINES == 1 )
     41          	#include "croutine.h"
     42          #endif
     43          
     44          /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
     45          because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
     46          for the header files above, but not in this file, in order to generate the
     47          correct privileged Vs unprivileged linkage and placement. */
     48          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
     49          
     50          
     51          /* Constants used with the cRxLock and cTxLock structure members. */
     52          #define queueUNLOCKED					( ( int8_t ) -1 )
     53          #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
     54          
     55          /* When the Queue_t structure is used to represent a base queue its pcHead and
     56          pcTail members are used as pointers into the queue storage area.  When the
     57          Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
     58          not necessary, and the pcHead pointer is set to NULL to indicate that the
     59          structure instead holds a pointer to the mutex holder (if any).  Map alternative
     60          names to the pcHead and structure member to ensure the readability of the code
     61          is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
     62          a union as their usage is mutually exclusive dependent on what the queue is
     63          being used for. */
     64          #define uxQueueType						pcHead
     65          #define queueQUEUE_IS_MUTEX				NULL
     66          
     67          typedef struct QueuePointers
     68          {
     69          	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
     70          	int8_t *pcReadFrom;				/*< Points to the last place that a queued item was read from when the structure is used as a queue. */
     71          } QueuePointers_t;
     72          
     73          typedef struct SemaphoreData
     74          {
     75          	TaskHandle_t xMutexHolder;		 /*< The handle of the task that holds the mutex. */
     76          	UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
     77          } SemaphoreData_t;
     78          
     79          /* Semaphores do not actually store or copy data, so have an item size of
     80          zero. */
     81          #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
     82          #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
     83          
     84          #if( configUSE_PREEMPTION == 0 )
     85          	/* If the cooperative scheduler is being used then a yield should not be
     86          	performed just because a higher priority task has been woken. */
     87          	#define queueYIELD_IF_USING_PREEMPTION()
     88          #else
     89          	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
     90          #endif
     91          
     92          /*
     93           * Definition of the queue used by the scheduler.
     94           * Items are queued by copy, not reference.  See the following link for the
     95           * rationale: https://www.freertos.org/Embedded-RTOS-Queues.html
     96           */
     97          typedef struct QueueDefinition 		/* The old naming convention is used to prevent breaking kernel aware debuggers. */
     98          {
     99          	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
    100          	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
    101          
    102          	union
    103          	{
    104          		QueuePointers_t xQueue;		/*< Data required exclusively when this structure is used as a queue. */
    105          		SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaphore. */
    106          	} u;
    107          
    108          	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
    109          	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
    110          
    111          	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
    112          	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
    113          	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
    114          
    115          	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
    116          	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
    117          
    118          	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    119          		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */
    120          	#endif
    121          
    122          	#if ( configUSE_QUEUE_SETS == 1 )
    123          		struct QueueDefinition *pxQueueSetContainer;
    124          	#endif
    125          
    126          	#if ( configUSE_TRACE_FACILITY == 1 )
    127          		UBaseType_t uxQueueNumber;
    128          		uint8_t ucQueueType;
    129          	#endif
    130          
    131          } xQUEUE;
    132          
    133          /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
    134          name below to enable the use of older kernel aware debuggers. */
    135          typedef xQUEUE Queue_t;
    136          
    137          /*-----------------------------------------------------------*/
    138          
    139          /*
    140           * The queue registry is just a means for kernel aware debuggers to locate
    141           * queue structures.  It has no other purpose so is an optional component.
    142           */
    143          #if ( configQUEUE_REGISTRY_SIZE > 0 )
    144          
    145          	/* The type stored within the queue registry array.  This allows a name
    146          	to be assigned to each queue making kernel aware debugging a little
    147          	more user friendly. */
    148          	typedef struct QUEUE_REGISTRY_ITEM
    149          	{
    150          		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    151          		QueueHandle_t xHandle;
    152          	} xQueueRegistryItem;
    153          
    154          	/* The old xQueueRegistryItem name is maintained above then typedefed to the
    155          	new xQueueRegistryItem name below to enable the use of older kernel aware
    156          	debuggers. */
    157          	typedef xQueueRegistryItem QueueRegistryItem_t;
    158          
    159          	/* The queue registry is simply an array of QueueRegistryItem_t structures.
    160          	The pcQueueName member of a structure being NULL is indicative of the
    161          	array position being vacant. */

   \                                 In section .bss, align 4
    162          	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
   \                     xQueueRegistry:
   \        0x0                      DS8 64
    163          
    164          #endif /* configQUEUE_REGISTRY_SIZE */
    165          
    166          /*
    167           * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
    168           * prevent an ISR from adding or removing items to the queue, but does prevent
    169           * an ISR from removing tasks from the queue event lists.  If an ISR finds a
    170           * queue is locked it will instead increment the appropriate queue lock count
    171           * to indicate that a task may require unblocking.  When the queue in unlocked
    172           * these lock counts are inspected, and the appropriate action taken.
    173           */
    174          static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
    175          
    176          /*
    177           * Uses a critical section to determine if there is any data in a queue.
    178           *
    179           * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
    180           */
    181          static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
    182          
    183          /*
    184           * Uses a critical section to determine if there is any space in a queue.
    185           *
    186           * @return pdTRUE if there is no space, otherwise pdFALSE;
    187           */
    188          static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
    189          
    190          /*
    191           * Copies an item into the queue, either at the front of the queue or the
    192           * back of the queue.
    193           */
    194          static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
    195          
    196          /*
    197           * Copies an item out of a queue.
    198           */
    199          static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
    200          
    201          #if ( configUSE_QUEUE_SETS == 1 )
    202          	/*
    203          	 * Checks to see if a queue is a member of a queue set, and if so, notifies
    204          	 * the queue set that the queue contains data.
    205          	 */
    206          	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
    207          #endif
    208          
    209          /*
    210           * Called after a Queue_t structure has been allocated either statically or
    211           * dynamically to fill in the structure's members.
    212           */
    213          static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
    214          
    215          /*
    216           * Mutexes are a special type of queue.  When a mutex is created, first the
    217           * queue is created, then prvInitialiseMutex() is called to configure the queue
    218           * as a mutex.
    219           */
    220          #if( configUSE_MUTEXES == 1 )
    221          	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
    222          #endif
    223          
    224          #if( configUSE_MUTEXES == 1 )
    225          	/*
    226          	 * If a task waiting for a mutex causes the mutex holder to inherit a
    227          	 * priority, but the waiting task times out, then the holder should
    228          	 * disinherit the priority - but only down to the highest priority of any
    229          	 * other tasks that are waiting for the same mutex.  This function returns
    230          	 * that priority.
    231          	 */
    232          	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
    233          #endif
    234          /*-----------------------------------------------------------*/
    235          
    236          /*
    237           * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
    238           * accessing the queue event lists.
    239           */
    240          #define prvLockQueue( pxQueue )								\
    241          	taskENTER_CRITICAL();									\
    242          	{														\
    243          		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
    244          		{													\
    245          			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
    246          		}													\
    247          		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
    248          		{													\
    249          			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
    250          		}													\
    251          	}														\
    252          	taskEXIT_CRITICAL()
    253          /*-----------------------------------------------------------*/
    254          

   \                                 In section .text, align 2, keep-with-next
    255          BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
    256          {
   \                     xQueueGenericReset: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    257          Queue_t * const pxQueue = xQueue;
    258          
    259          	configASSERT( pxQueue );
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD107             BNE.N    ??xQueueGenericReset_0
   \        0xA   0x2050             MOVS     R0,#+80
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericReset_1: (+1)
   \       0x18   0xE7FE             B.N      ??xQueueGenericReset_1
    260          
    261          	taskENTER_CRITICAL();
   \                     ??xQueueGenericReset_0: (+1)
   \       0x1A   0x.... 0x....      BL       vPortEnterCritical
    262          	{
    263          		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   \       0x1E   0x6821             LDR      R1,[R4, #+0]
   \       0x20   0x6BE2             LDR      R2,[R4, #+60]
   \       0x22   0x6C20             LDR      R0,[R4, #+64]
   \       0x24   0x4342             MULS     R2,R0,R2
   \       0x26   0xEB01 0x0002      ADD      R0,R1,R2
   \       0x2A   0x60A0             STR      R0,[R4, #+8]
    264          		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x63A0             STR      R0,[R4, #+56]
    265          		pxQueue->pcWriteTo = pxQueue->pcHead;
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6060             STR      R0,[R4, #+4]
    266          		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   \       0x34   0x6821             LDR      R1,[R4, #+0]
   \       0x36   0x6BE2             LDR      R2,[R4, #+60]
   \       0x38   0x1E52             SUBS     R2,R2,#+1
   \       0x3A   0x6C20             LDR      R0,[R4, #+64]
   \       0x3C   0x4342             MULS     R2,R0,R2
   \       0x3E   0xEB01 0x0002      ADD      R0,R1,R2
   \       0x42   0x60E0             STR      R0,[R4, #+12]
    267          		pxQueue->cRxLock = queueUNLOCKED;
   \       0x44   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x48   0xF884 0x0044      STRB     R0,[R4, #+68]
    268          		pxQueue->cTxLock = queueUNLOCKED;
   \       0x4C   0xF884 0x0045      STRB     R0,[R4, #+69]
    269          
    270          		if( xNewQueue == pdFALSE )
   \       0x50   0x2D00             CMP      R5,#+0
   \       0x52   0xD112             BNE.N    ??xQueueGenericReset_2
    271          		{
    272          			/* If there are tasks blocked waiting to read from the queue, then
    273          			the tasks will remain blocked as after this function exits the queue
    274          			will still be empty.  If there are tasks blocked waiting to write to
    275          			the queue, then one should be unblocked as after this function exits
    276          			it will be possible to write to it. */
    277          			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   \       0x54   0x6920             LDR      R0,[R4, #+16]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD017             BEQ.N    ??xQueueGenericReset_3
    278          			{
    279          				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   \       0x5A   0xF114 0x0010      ADDS     R0,R4,#+16
   \       0x5E   0x.... 0x....      BL       xTaskRemoveFromEventList
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD011             BEQ.N    ??xQueueGenericReset_3
    280          				{
    281          					queueYIELD_IF_USING_PREEMPTION();
   \       0x66   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0x6A   0x.... 0x....      LDR.W    R1,??DataTable4
   \       0x6E   0x6008             STR      R0,[R1, #+0]
   \       0x70   0xF3BF 0x8F4F      DSB      SY
   \       0x74   0xF3BF 0x8F6F      ISB      SY
   \       0x78   0xE007             B.N      ??xQueueGenericReset_3
    282          				}
    283          				else
    284          				{
    285          					mtCOVERAGE_TEST_MARKER();
    286          				}
    287          			}
    288          			else
    289          			{
    290          				mtCOVERAGE_TEST_MARKER();
    291          			}
    292          		}
    293          		else
    294          		{
    295          			/* Ensure the event queues start in the correct state. */
    296          			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   \                     ??xQueueGenericReset_2: (+1)
   \       0x7A   0xF114 0x0010      ADDS     R0,R4,#+16
   \       0x7E   0x.... 0x....      BL       vListInitialise
    297          			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   \       0x82   0xF114 0x0024      ADDS     R0,R4,#+36
   \       0x86   0x.... 0x....      BL       vListInitialise
    298          		}
    299          	}
    300          	taskEXIT_CRITICAL();
   \                     ??xQueueGenericReset_3: (+1)
   \       0x8A   0x.... 0x....      BL       vPortExitCritical
    301          
    302          	/* A value is returned for calling semantic consistency with previous
    303          	versions. */
    304          	return pdPASS;
   \       0x8E   0x2001             MOVS     R0,#+1
   \       0x90   0xBD32             POP      {R1,R4,R5,PC}
    305          }
    306          /*-----------------------------------------------------------*/
    307          
    308          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    309          

   \                                 In section .text, align 2, keep-with-next
    310          	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
    311          	{
   \                     xQueueGenericCreateStatic: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x001C             MOVS     R4,R3
    312          	Queue_t *pxNewQueue;
    313          
    314          		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD107             BNE.N    ??xQueueGenericCreateStatic_0
   \        0x8   0x2050             MOVS     R0,#+80
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericCreateStatic_1: (+1)
   \       0x16   0xE7FE             B.N      ??xQueueGenericCreateStatic_1
    315          
    316          		/* The StaticQueue_t structure and the queue storage area must be
    317          		supplied. */
    318          		configASSERT( pxStaticQueue != NULL );
   \                     ??xQueueGenericCreateStatic_0: (+1)
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD107             BNE.N    ??xQueueGenericCreateStatic_2
   \       0x1C   0x2050             MOVS     R0,#+80
   \       0x1E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x22   0xF3BF 0x8F4F      DSB      SY
   \       0x26   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericCreateStatic_3: (+1)
   \       0x2A   0xE7FE             B.N      ??xQueueGenericCreateStatic_3
    319          
    320          		/* A queue storage area should be provided if the item size is not 0, and
    321          		should not be provided if the item size is 0. */
    322          		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
   \                     ??xQueueGenericCreateStatic_2: (+1)
   \       0x2C   0x2A00             CMP      R2,#+0
   \       0x2E   0xD001             BEQ.N    ??xQueueGenericCreateStatic_4
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD001             BEQ.N    ??xQueueGenericCreateStatic_5
   \                     ??xQueueGenericCreateStatic_4: (+1)
   \       0x34   0x2301             MOVS     R3,#+1
   \       0x36   0xE000             B.N      ??xQueueGenericCreateStatic_6
   \                     ??xQueueGenericCreateStatic_5: (+1)
   \       0x38   0x2300             MOVS     R3,#+0
   \                     ??xQueueGenericCreateStatic_6: (+1)
   \       0x3A   0xB2DB             UXTB     R3,R3
   \       0x3C   0x2B00             CMP      R3,#+0
   \       0x3E   0xD107             BNE.N    ??xQueueGenericCreateStatic_7
   \       0x40   0x2050             MOVS     R0,#+80
   \       0x42   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x46   0xF3BF 0x8F4F      DSB      SY
   \       0x4A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericCreateStatic_8: (+1)
   \       0x4E   0xE7FE             B.N      ??xQueueGenericCreateStatic_8
    323          		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
   \                     ??xQueueGenericCreateStatic_7: (+1)
   \       0x50   0x2A00             CMP      R2,#+0
   \       0x52   0xD101             BNE.N    ??xQueueGenericCreateStatic_9
   \       0x54   0x2900             CMP      R1,#+0
   \       0x56   0xD101             BNE.N    ??xQueueGenericCreateStatic_10
   \                     ??xQueueGenericCreateStatic_9: (+1)
   \       0x58   0x2301             MOVS     R3,#+1
   \       0x5A   0xE000             B.N      ??xQueueGenericCreateStatic_11
   \                     ??xQueueGenericCreateStatic_10: (+1)
   \       0x5C   0x2300             MOVS     R3,#+0
   \                     ??xQueueGenericCreateStatic_11: (+1)
   \       0x5E   0xB2DB             UXTB     R3,R3
   \       0x60   0x2B00             CMP      R3,#+0
   \       0x62   0xD107             BNE.N    ??xQueueGenericCreateStatic_12
   \       0x64   0x2050             MOVS     R0,#+80
   \       0x66   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x6A   0xF3BF 0x8F4F      DSB      SY
   \       0x6E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericCreateStatic_13: (+1)
   \       0x72   0xE7FE             B.N      ??xQueueGenericCreateStatic_13
    324          
    325          		#if( configASSERT_DEFINED == 1 )
    326          		{
    327          			/* Sanity check that the size of the structure used to declare a
    328          			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
    329          			the real queue and semaphore structures. */
    330          			volatile size_t xSize = sizeof( StaticQueue_t );
   \                     ??xQueueGenericCreateStatic_12: (+1)
   \       0x74   0x2350             MOVS     R3,#+80
   \       0x76   0x9300             STR      R3,[SP, #+0]
    331          			configASSERT( xSize == sizeof( Queue_t ) );
   \       0x78   0x9B00             LDR      R3,[SP, #+0]
   \       0x7A   0x2B50             CMP      R3,#+80
   \       0x7C   0xD007             BEQ.N    ??xQueueGenericCreateStatic_14
   \       0x7E   0x2050             MOVS     R0,#+80
   \       0x80   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x84   0xF3BF 0x8F4F      DSB      SY
   \       0x88   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericCreateStatic_15: (+1)
   \       0x8C   0xE7FE             B.N      ??xQueueGenericCreateStatic_15
    332          			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
   \                     ??xQueueGenericCreateStatic_14: (+1)
   \       0x8E   0x9B00             LDR      R3,[SP, #+0]
    333          		}
    334          		#endif /* configASSERT_DEFINED */
    335          
    336          		/* The address of a statically allocated queue was passed in, use it.
    337          		The address of a statically allocated storage area was also passed in
    338          		but is already set. */
    339          		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
    340          
    341          		if( pxNewQueue != NULL )
   \       0x90   0x2C00             CMP      R4,#+0
   \       0x92   0xD007             BEQ.N    ??xQueueGenericCreateStatic_16
   \       0x94   0x9B04             LDR      R3,[SP, #+16]
    342          		{
    343          			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    344          			{
    345          				/* Queues can be allocated wither statically or dynamically, so
    346          				note this queue was allocated statically in case the queue is
    347          				later deleted. */
    348          				pxNewQueue->ucStaticallyAllocated = pdTRUE;
   \       0x96   0x2501             MOVS     R5,#+1
   \       0x98   0xF884 0x5046      STRB     R5,[R4, #+70]
    349          			}
    350          			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    351          
    352          			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
   \       0x9C   0x9400             STR      R4,[SP, #+0]
   \       0x9E   0xB2DB             UXTB     R3,R3
   \       0xA0   0x.... 0x....      BL       prvInitialiseNewQueue
    353          		}
    354          		else
    355          		{
    356          			traceQUEUE_CREATE_FAILED( ucQueueType );
    357          			mtCOVERAGE_TEST_MARKER();
    358          		}
    359          
    360          		return pxNewQueue;
   \                     ??xQueueGenericCreateStatic_16: (+1)
   \       0xA4   0x0020             MOVS     R0,R4
   \       0xA6   0xBD32             POP      {R1,R4,R5,PC}
    361          	}
    362          
    363          #endif /* configSUPPORT_STATIC_ALLOCATION */
    364          /*-----------------------------------------------------------*/
    365          
    366          #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    367          

   \                                 In section .text, align 2, keep-with-next
    368          	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
    369          	{
   \                     xQueueGenericCreate: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0017             MOVS     R7,R2
    370          	Queue_t *pxNewQueue;
    371          	size_t xQueueSizeInBytes;
    372          	uint8_t *pucQueueStorage;
    373          
    374          		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
   \        0x8   0x2D00             CMP      R5,#+0
   \        0xA   0xD107             BNE.N    ??xQueueGenericCreate_0
   \        0xC   0x2050             MOVS     R0,#+80
   \        0xE   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x12   0xF3BF 0x8F4F      DSB      SY
   \       0x16   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericCreate_1: (+1)
   \       0x1A   0xE7FE             B.N      ??xQueueGenericCreate_1
    375          
    376          		/* Allocate enough space to hold the maximum number of items that
    377          		can be in the queue at any time.  It is valid for uxItemSize to be
    378          		zero in the case the queue is used as a semaphore. */
    379          		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \                     ??xQueueGenericCreate_0: (+1)
   \       0x1C   0xFB06 0xF005      MUL      R0,R6,R5
    380          
    381          		/* Allocate the queue and storage area.  Justification for MISRA
    382          		deviation as follows:  pvPortMalloc() always ensures returned memory
    383          		blocks are aligned per the requirements of the MCU stack.  In this case
    384          		pvPortMalloc() must return a pointer that is guaranteed to meet the
    385          		alignment requirements of the Queue_t structure - which in this case
    386          		is an int8_t *.  Therefore, whenever the stack alignment requirements
    387          		are greater than or equal to the pointer to char requirements the cast
    388          		is safe.  In other cases alignment requirements are not strict (one or
    389          		two bytes). */
    390          		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
   \       0x20   0x3050             ADDS     R0,R0,#+80
   \       0x22   0x.... 0x....      BL       pvPortMalloc
   \       0x26   0x0004             MOVS     R4,R0
    391          
    392          		if( pxNewQueue != NULL )
   \       0x28   0x2C00             CMP      R4,#+0
   \       0x2A   0xD00C             BEQ.N    ??xQueueGenericCreate_2
    393          		{
    394          			/* Jump past the queue structure to find the location of the queue
    395          			storage area. */
    396          			pucQueueStorage = ( uint8_t * ) pxNewQueue;
   \       0x2C   0x0020             MOVS     R0,R4
    397          			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   \       0x2E   0xF110 0x0250      ADDS     R2,R0,#+80
    398          
    399          			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
    400          			{
    401          				/* Queues can be created either statically or dynamically, so
    402          				note this task was created dynamically in case it is later
    403          				deleted. */
    404          				pxNewQueue->ucStaticallyAllocated = pdFALSE;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xF884 0x0046      STRB     R0,[R4, #+70]
    405          			}
    406          			#endif /* configSUPPORT_STATIC_ALLOCATION */
    407          
    408          			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
   \       0x38   0x9400             STR      R4,[SP, #+0]
   \       0x3A   0x003B             MOVS     R3,R7
   \       0x3C   0xB2DB             UXTB     R3,R3
   \       0x3E   0x0031             MOVS     R1,R6
   \       0x40   0x0028             MOVS     R0,R5
   \       0x42   0x.... 0x....      BL       prvInitialiseNewQueue
    409          		}
    410          		else
    411          		{
    412          			traceQUEUE_CREATE_FAILED( ucQueueType );
    413          			mtCOVERAGE_TEST_MARKER();
    414          		}
    415          
    416          		return pxNewQueue;
   \                     ??xQueueGenericCreate_2: (+1)
   \       0x46   0x0020             MOVS     R0,R4
   \       0x48   0xBDF2             POP      {R1,R4-R7,PC}
    417          	}
    418          
    419          #endif /* configSUPPORT_STATIC_ALLOCATION */
    420          /*-----------------------------------------------------------*/
    421          

   \                                 In section .text, align 2, keep-with-next
    422          static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
    423          {
   \                     prvInitialiseNewQueue: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x001C             MOVS     R4,R3
   \        0x4   0x9D04             LDR      R5,[SP, #+16]
    424          	/* Remove compiler warnings about unused parameters should
    425          	configUSE_TRACE_FACILITY not be set to 1. */
    426          	( void ) ucQueueType;
    427          
    428          	if( uxItemSize == ( UBaseType_t ) 0 )
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD101             BNE.N    ??prvInitialiseNewQueue_0
    429          	{
    430          		/* No RAM was allocated for the queue storage area, but PC head cannot
    431          		be set to NULL because NULL is used as a key to say the queue is used as
    432          		a mutex.  Therefore just set pcHead to point to the queue as a benign
    433          		value that is known to be within the memory map. */
    434          		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
   \        0xA   0x602D             STR      R5,[R5, #+0]
   \        0xC   0xE000             B.N      ??prvInitialiseNewQueue_1
    435          	}
    436          	else
    437          	{
    438          		/* Set the head to the start of the queue storage area. */
    439          		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
   \                     ??prvInitialiseNewQueue_0: (+1)
   \        0xE   0x602A             STR      R2,[R5, #+0]
    440          	}
    441          
    442          	/* Initialise the queue members as described where the queue type is
    443          	defined. */
    444          	pxNewQueue->uxLength = uxQueueLength;
   \                     ??prvInitialiseNewQueue_1: (+1)
   \       0x10   0x63E8             STR      R0,[R5, #+60]
    445          	pxNewQueue->uxItemSize = uxItemSize;
   \       0x12   0x6429             STR      R1,[R5, #+64]
    446          	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0x0028             MOVS     R0,R5
   \       0x18   0x.... 0x....      BL       xQueueGenericReset
    447          
    448          	#if ( configUSE_TRACE_FACILITY == 1 )
    449          	{
    450          		pxNewQueue->ucQueueType = ucQueueType;
   \       0x1C   0xF885 0x404C      STRB     R4,[R5, #+76]
    451          	}
    452          	#endif /* configUSE_TRACE_FACILITY */
    453          
    454          	#if( configUSE_QUEUE_SETS == 1 )
    455          	{
    456          		pxNewQueue->pxQueueSetContainer = NULL;
    457          	}
    458          	#endif /* configUSE_QUEUE_SETS */
    459          
    460          	traceQUEUE_CREATE( pxNewQueue );
    461          }
   \       0x20   0xBD31             POP      {R0,R4,R5,PC}
    462          /*-----------------------------------------------------------*/
    463          
    464          #if( configUSE_MUTEXES == 1 )
    465          

   \                                 In section .text, align 2, keep-with-next
    466          	static void prvInitialiseMutex( Queue_t *pxNewQueue )
    467          	{
   \                     prvInitialiseMutex: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    468          		if( pxNewQueue != NULL )
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD00A             BEQ.N    ??prvInitialiseMutex_0
    469          		{
    470          			/* The queue create function will set all the queue structure members
    471          			correctly for a generic queue, but this function is creating a
    472          			mutex.  Overwrite those members that need to be set differently -
    473          			in particular the information required for priority inheritance. */
    474          			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6081             STR      R1,[R0, #+8]
    475          			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x6001             STR      R1,[R0, #+0]
    476          
    477          			/* In case this is a recursive mutex. */
    478          			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x60C1             STR      R1,[R0, #+12]
    479          
    480          			traceCREATE_MUTEX( pxNewQueue );
    481          
    482          			/* Start with the semaphore in the expected state. */
    483          			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
   \       0x12   0x2300             MOVS     R3,#+0
   \       0x14   0x2200             MOVS     R2,#+0
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x.... 0x....      BL       xQueueGenericSend
    484          		}
    485          		else
    486          		{
    487          			traceCREATE_MUTEX_FAILED();
    488          		}
    489          	}
   \                     ??prvInitialiseMutex_0: (+1)
   \       0x1C   0xBD01             POP      {R0,PC}
    490          
    491          #endif /* configUSE_MUTEXES */
    492          /*-----------------------------------------------------------*/
    493          
    494          #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    495          

   \                                 In section .text, align 2, keep-with-next
    496          	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    497          	{
   \                     xQueueCreateMutex: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0002             MOVS     R2,R0
    498          	QueueHandle_t xNewQueue;
    499          	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x2100             MOVS     R1,#+0
    500          
    501          		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
   \        0x8   0xB2D2             UXTB     R2,R2
   \        0xA   0x.... 0x....      BL       xQueueGenericCreate
   \        0xE   0x0004             MOVS     R4,R0
    502          		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0x.... 0x....      BL       prvInitialiseMutex
    503          
    504          		return xNewQueue;
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0xBD10             POP      {R4,PC}
    505          	}
    506          
    507          #endif /* configUSE_MUTEXES */
    508          /*-----------------------------------------------------------*/
    509          
    510          #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    511          

   \                                 In section .text, align 2, keep-with-next
    512          	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
    513          	{
   \                     xQueueCreateMutexStatic: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x000B             MOVS     R3,R1
    514          	QueueHandle_t xNewQueue;
    515          	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
   \        0x4   0x2401             MOVS     R4,#+1
   \        0x6   0x2100             MOVS     R1,#+0
    516          
    517          		/* Prevent compiler warnings about unused parameters if
    518          		configUSE_TRACE_FACILITY does not equal 1. */
    519          		( void ) ucQueueType;
    520          
    521          		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x9000             STR      R0,[SP, #+0]
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x.... 0x....      BL       xQueueGenericCreateStatic
   \       0x14   0x0004             MOVS     R4,R0
    522          		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       prvInitialiseMutex
    523          
    524          		return xNewQueue;
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0xBD16             POP      {R1,R2,R4,PC}
    525          	}
    526          
    527          #endif /* configUSE_MUTEXES */
    528          /*-----------------------------------------------------------*/
    529          
    530          #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
    531          

   \                                 In section .text, align 2, keep-with-next
    532          	TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
    533          	{
   \                     xQueueGetMutexHolder: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    534          	TaskHandle_t pxReturn;
    535          	Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
    536          
    537          		/* This function is called by xSemaphoreGetMutexHolder(), and should not
    538          		be called directly.  Note:  This is a good way of determining if the
    539          		calling task is the mutex holder, but not a good way of determining the
    540          		identity of the mutex holder, as the holder may change between the
    541          		following critical section exiting and the function returning. */
    542          		taskENTER_CRITICAL();
   \        0x4   0x.... 0x....      BL       vPortEnterCritical
    543          		{
    544          			if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD101             BNE.N    ??xQueueGetMutexHolder_0
    545          			{
    546          				pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
   \        0xE   0x68A4             LDR      R4,[R4, #+8]
   \       0x10   0xE000             B.N      ??xQueueGetMutexHolder_1
    547          			}
    548          			else
    549          			{
    550          				pxReturn = NULL;
   \                     ??xQueueGetMutexHolder_0: (+1)
   \       0x12   0x2400             MOVS     R4,#+0
    551          			}
    552          		}
    553          		taskEXIT_CRITICAL();
   \                     ??xQueueGetMutexHolder_1: (+1)
   \       0x14   0x.... 0x....      BL       vPortExitCritical
    554          
    555          		return pxReturn;
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0xBD10             POP      {R4,PC}
    556          	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
    557          
    558          #endif
    559          /*-----------------------------------------------------------*/
    560          
    561          #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
    562          

   \                                 In section .text, align 2, keep-with-next
    563          	TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
    564          	{
    565          	TaskHandle_t pxReturn;
    566          
    567          		configASSERT( xSemaphore );
   \                     xQueueGetMutexHolderFromISR: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD107             BNE.N    ??xQueueGetMutexHolderFromISR_0
   \        0x4   0x2050             MOVS     R0,#+80
   \        0x6   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGetMutexHolderFromISR_1: (+1)
   \       0x12   0xE7FE             B.N      ??xQueueGetMutexHolderFromISR_1
    568          
    569          		/* Mutexes cannot be used in interrupt service routines, so the mutex
    570          		holder should not change in an ISR, and therefore a critical section is
    571          		not required here. */
    572          		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
   \                     ??xQueueGetMutexHolderFromISR_0: (+1)
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD101             BNE.N    ??xQueueGetMutexHolderFromISR_2
    573          		{
    574          			pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
   \       0x1A   0x6880             LDR      R0,[R0, #+8]
   \       0x1C   0xE000             B.N      ??xQueueGetMutexHolderFromISR_3
    575          		}
    576          		else
    577          		{
    578          			pxReturn = NULL;
   \                     ??xQueueGetMutexHolderFromISR_2: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
    579          		}
    580          
    581          		return pxReturn;
   \                     ??xQueueGetMutexHolderFromISR_3: (+1)
   \       0x20   0x4770             BX       LR
    582          	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
    583          
    584          #endif
    585          /*-----------------------------------------------------------*/
    586          
    587          #if ( configUSE_RECURSIVE_MUTEXES == 1 )
    588          

   \                                 In section .text, align 2, keep-with-next
    589          	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
    590          	{
   \                     xQueueGiveMutexRecursive: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    591          	BaseType_t xReturn;
    592          	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    593          
    594          		configASSERT( pxMutex );
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD107             BNE.N    ??xQueueGiveMutexRecursive_0
   \        0x8   0x2050             MOVS     R0,#+80
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGiveMutexRecursive_1: (+1)
   \       0x16   0xE7FE             B.N      ??xQueueGiveMutexRecursive_1
    595          
    596          		/* If this is the task that holds the mutex then xMutexHolder will not
    597          		change outside of this task.  If this task does not hold the mutex then
    598          		pxMutexHolder can never coincidentally equal the tasks handle, and as
    599          		this is the only condition we are interested in it does not matter if
    600          		pxMutexHolder is accessed simultaneously by another task.  Therefore no
    601          		mutual exclusion is required to test the pxMutexHolder variable. */
    602          		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
   \                     ??xQueueGiveMutexRecursive_0: (+1)
   \       0x18   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \       0x1C   0x68A1             LDR      R1,[R4, #+8]
   \       0x1E   0x4281             CMP      R1,R0
   \       0x20   0xD10D             BNE.N    ??xQueueGiveMutexRecursive_2
    603          		{
    604          			traceGIVE_MUTEX_RECURSIVE( pxMutex );
    605          
    606          			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
    607          			the task handle, therefore no underflow check is required.  Also,
    608          			uxRecursiveCallCount is only modified by the mutex holder, and as
    609          			there can only be one, no mutual exclusion is required to modify the
    610          			uxRecursiveCallCount member. */
    611          			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
   \       0x22   0x68E0             LDR      R0,[R4, #+12]
   \       0x24   0x1E40             SUBS     R0,R0,#+1
   \       0x26   0x60E0             STR      R0,[R4, #+12]
    612          
    613          			/* Has the recursive call count unwound to 0? */
    614          			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
   \       0x28   0x68E0             LDR      R0,[R4, #+12]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD105             BNE.N    ??xQueueGiveMutexRecursive_3
    615          			{
    616          				/* Return the mutex.  This will automatically unblock any other
    617          				task that might be waiting to access the mutex. */
    618          				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
   \       0x2E   0x2300             MOVS     R3,#+0
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       xQueueGenericSend
    619          			}
    620          			else
    621          			{
    622          				mtCOVERAGE_TEST_MARKER();
    623          			}
    624          
    625          			xReturn = pdPASS;
   \                     ??xQueueGiveMutexRecursive_3: (+1)
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0xE000             B.N      ??xQueueGiveMutexRecursive_4
    626          		}
    627          		else
    628          		{
    629          			/* The mutex cannot be given because the calling task is not the
    630          			holder. */
    631          			xReturn = pdFAIL;
   \                     ??xQueueGiveMutexRecursive_2: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
    632          
    633          			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
    634          		}
    635          
    636          		return xReturn;
   \                     ??xQueueGiveMutexRecursive_4: (+1)
   \       0x40   0xBD10             POP      {R4,PC}
    637          	}
    638          
    639          #endif /* configUSE_RECURSIVE_MUTEXES */
    640          /*-----------------------------------------------------------*/
    641          
    642          #if ( configUSE_RECURSIVE_MUTEXES == 1 )
    643          

   \                                 In section .text, align 2, keep-with-next
    644          	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
    645          	{
   \                     xQueueTakeMutexRecursive: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    646          	BaseType_t xReturn;
    647          	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    648          
    649          		configASSERT( pxMutex );
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD107             BNE.N    ??xQueueTakeMutexRecursive_0
   \        0xA   0x2050             MOVS     R0,#+80
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueTakeMutexRecursive_1: (+1)
   \       0x18   0xE7FE             B.N      ??xQueueTakeMutexRecursive_1
    650          
    651          		/* Comments regarding mutual exclusion as per those within
    652          		xQueueGiveMutexRecursive(). */
    653          
    654          		traceTAKE_MUTEX_RECURSIVE( pxMutex );
    655          
    656          		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
   \                     ??xQueueTakeMutexRecursive_0: (+1)
   \       0x1A   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \       0x1E   0x68A1             LDR      R1,[R4, #+8]
   \       0x20   0x4281             CMP      R1,R0
   \       0x22   0xD104             BNE.N    ??xQueueTakeMutexRecursive_2
    657          		{
    658          			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
   \       0x24   0x68E0             LDR      R0,[R4, #+12]
   \       0x26   0x1C40             ADDS     R0,R0,#+1
   \       0x28   0x60E0             STR      R0,[R4, #+12]
    659          			xReturn = pdPASS;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE008             B.N      ??xQueueTakeMutexRecursive_3
    660          		}
    661          		else
    662          		{
    663          			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
   \                     ??xQueueTakeMutexRecursive_2: (+1)
   \       0x2E   0x0029             MOVS     R1,R5
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       xQueueSemaphoreTake
    664          
    665          			/* pdPASS will only be returned if the mutex was successfully
    666          			obtained.  The calling task may have entered the Blocked state
    667          			before reaching here. */
    668          			if( xReturn != pdFAIL )
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD002             BEQ.N    ??xQueueTakeMutexRecursive_3
    669          			{
    670          				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
   \       0x3A   0x68E1             LDR      R1,[R4, #+12]
   \       0x3C   0x1C49             ADDS     R1,R1,#+1
   \       0x3E   0x60E1             STR      R1,[R4, #+12]
    671          			}
    672          			else
    673          			{
    674          				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
    675          			}
    676          		}
    677          
    678          		return xReturn;
   \                     ??xQueueTakeMutexRecursive_3: (+1)
   \       0x40   0xBD32             POP      {R1,R4,R5,PC}
    679          	}
    680          
    681          #endif /* configUSE_RECURSIVE_MUTEXES */
    682          /*-----------------------------------------------------------*/
    683          
    684          #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    685          

   \                                 In section .text, align 2, keep-with-next
    686          	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue )
    687          	{
   \                     xQueueCreateCountingSemaphoreStatic: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x000C             MOVS     R4,R1
   \        0x4   0x0013             MOVS     R3,R2
    688          	QueueHandle_t xHandle;
    689          
    690          		configASSERT( uxMaxCount != 0 );
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD107             BNE.N    ??xQueueCreateCountingSemaphoreStatic_0
   \        0xA   0x2050             MOVS     R0,#+80
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueCreateCountingSemaphoreStatic_1: (+1)
   \       0x18   0xE7FE             B.N      ??xQueueCreateCountingSemaphoreStatic_1
    691          		configASSERT( uxInitialCount <= uxMaxCount );
   \                     ??xQueueCreateCountingSemaphoreStatic_0: (+1)
   \       0x1A   0x42A0             CMP      R0,R4
   \       0x1C   0xD207             BCS.N    ??xQueueCreateCountingSemaphoreStatic_2
   \       0x1E   0x2050             MOVS     R0,#+80
   \       0x20   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x24   0xF3BF 0x8F4F      DSB      SY
   \       0x28   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueCreateCountingSemaphoreStatic_3: (+1)
   \       0x2C   0xE7FE             B.N      ??xQueueCreateCountingSemaphoreStatic_3
    692          
    693          		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
   \                     ??xQueueCreateCountingSemaphoreStatic_2: (+1)
   \       0x2E   0x2102             MOVS     R1,#+2
   \       0x30   0x9100             STR      R1,[SP, #+0]
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x.... 0x....      BL       xQueueGenericCreateStatic
    694          
    695          		if( xHandle != NULL )
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD000             BEQ.N    ??xQueueCreateCountingSemaphoreStatic_4
    696          		{
    697          			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
   \       0x3E   0x6384             STR      R4,[R0, #+56]
    698          
    699          			traceCREATE_COUNTING_SEMAPHORE();
    700          		}
    701          		else
    702          		{
    703          			traceCREATE_COUNTING_SEMAPHORE_FAILED();
    704          		}
    705          
    706          		return xHandle;
   \                     ??xQueueCreateCountingSemaphoreStatic_4: (+1)
   \       0x40   0xBD16             POP      {R1,R2,R4,PC}
    707          	}
    708          
    709          #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
    710          /*-----------------------------------------------------------*/
    711          
    712          #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    713          

   \                                 In section .text, align 2, keep-with-next
    714          	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
    715          	{
   \                     xQueueCreateCountingSemaphore: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x000C             MOVS     R4,R1
    716          	QueueHandle_t xHandle;
    717          
    718          		configASSERT( uxMaxCount != 0 );
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD107             BNE.N    ??xQueueCreateCountingSemaphore_0
   \        0x8   0x2050             MOVS     R0,#+80
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueCreateCountingSemaphore_1: (+1)
   \       0x16   0xE7FE             B.N      ??xQueueCreateCountingSemaphore_1
    719          		configASSERT( uxInitialCount <= uxMaxCount );
   \                     ??xQueueCreateCountingSemaphore_0: (+1)
   \       0x18   0x42A0             CMP      R0,R4
   \       0x1A   0xD207             BCS.N    ??xQueueCreateCountingSemaphore_2
   \       0x1C   0x2050             MOVS     R0,#+80
   \       0x1E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x22   0xF3BF 0x8F4F      DSB      SY
   \       0x26   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueCreateCountingSemaphore_3: (+1)
   \       0x2A   0xE7FE             B.N      ??xQueueCreateCountingSemaphore_3
    720          
    721          		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
   \                     ??xQueueCreateCountingSemaphore_2: (+1)
   \       0x2C   0x2202             MOVS     R2,#+2
   \       0x2E   0x2100             MOVS     R1,#+0
   \       0x30   0x.... 0x....      BL       xQueueGenericCreate
    722          
    723          		if( xHandle != NULL )
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD000             BEQ.N    ??xQueueCreateCountingSemaphore_4
    724          		{
    725          			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
   \       0x38   0x6384             STR      R4,[R0, #+56]
    726          
    727          			traceCREATE_COUNTING_SEMAPHORE();
    728          		}
    729          		else
    730          		{
    731          			traceCREATE_COUNTING_SEMAPHORE_FAILED();
    732          		}
    733          
    734          		return xHandle;
   \                     ??xQueueCreateCountingSemaphore_4: (+1)
   \       0x3A   0xBD10             POP      {R4,PC}
    735          	}
    736          
    737          #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
    738          /*-----------------------------------------------------------*/
    739          

   \                                 In section .text, align 2, keep-with-next
    740          BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
    741          {
   \                     xQueueGenericSend: (+1)
   \        0x0   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x001F             MOVS     R7,R3
    742          BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
   \        0x8   0x2400             MOVS     R4,#+0
    743          TimeOut_t xTimeOut;
    744          Queue_t * const pxQueue = xQueue;
    745          
    746          	configASSERT( pxQueue );
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD107             BNE.N    ??xQueueGenericSend_0
   \        0xE   0x2050             MOVS     R0,#+80
   \       0x10   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x14   0xF3BF 0x8F4F      DSB      SY
   \       0x18   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericSend_1: (+1)
   \       0x1C   0xE7FE             B.N      ??xQueueGenericSend_1
    747          	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueueGenericSend_0: (+1)
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD102             BNE.N    ??xQueueGenericSend_2
   \       0x22   0x6C28             LDR      R0,[R5, #+64]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD101             BNE.N    ??xQueueGenericSend_3
   \                     ??xQueueGenericSend_2: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE000             B.N      ??xQueueGenericSend_4
   \                     ??xQueueGenericSend_3: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??xQueueGenericSend_4: (+1)
   \       0x2E   0xB2C0             UXTB     R0,R0
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD107             BNE.N    ??xQueueGenericSend_5
   \       0x34   0x2050             MOVS     R0,#+80
   \       0x36   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x3A   0xF3BF 0x8F4F      DSB      SY
   \       0x3E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericSend_6: (+1)
   \       0x42   0xE7FE             B.N      ??xQueueGenericSend_6
    748          	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   \                     ??xQueueGenericSend_5: (+1)
   \       0x44   0x2F02             CMP      R7,#+2
   \       0x46   0xD102             BNE.N    ??xQueueGenericSend_7
   \       0x48   0x6BE8             LDR      R0,[R5, #+60]
   \       0x4A   0x2801             CMP      R0,#+1
   \       0x4C   0xD101             BNE.N    ??xQueueGenericSend_8
   \                     ??xQueueGenericSend_7: (+1)
   \       0x4E   0x2001             MOVS     R0,#+1
   \       0x50   0xE000             B.N      ??xQueueGenericSend_9
   \                     ??xQueueGenericSend_8: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \                     ??xQueueGenericSend_9: (+1)
   \       0x54   0xB2C0             UXTB     R0,R0
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD107             BNE.N    ??xQueueGenericSend_10
   \       0x5A   0x2050             MOVS     R0,#+80
   \       0x5C   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x60   0xF3BF 0x8F4F      DSB      SY
   \       0x64   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericSend_11: (+1)
   \       0x68   0xE7FE             B.N      ??xQueueGenericSend_11
    749          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    750          	{
    751          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??xQueueGenericSend_10: (+1)
   \       0x6A   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD102             BNE.N    ??xQueueGenericSend_12
   \       0x72   0x9802             LDR      R0,[SP, #+8]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD101             BNE.N    ??xQueueGenericSend_13
   \                     ??xQueueGenericSend_12: (+1)
   \       0x78   0x2001             MOVS     R0,#+1
   \       0x7A   0xE000             B.N      ??xQueueGenericSend_14
   \                     ??xQueueGenericSend_13: (+1)
   \       0x7C   0x2000             MOVS     R0,#+0
   \                     ??xQueueGenericSend_14: (+1)
   \       0x7E   0xB2C0             UXTB     R0,R0
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD138             BNE.N    ??xQueueGenericSend_15
   \       0x84   0x2050             MOVS     R0,#+80
   \       0x86   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x8A   0xF3BF 0x8F4F      DSB      SY
   \       0x8E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericSend_16: (+1)
   \       0x92   0xE7FE             B.N      ??xQueueGenericSend_16
    752          	}
    753          	#endif
    754          
    755          
    756          	/*lint -save -e904 This function relaxes the coding standard somewhat to
    757          	allow return statements within the function itself.  This is done in the
    758          	interest of execution time efficiency. */
    759          	for( ;; )
    760          	{
    761          		taskENTER_CRITICAL();
    762          		{
    763          			/* Is there room on the queue now?  The running task must be the
    764          			highest priority task wanting to access the queue.  If the head item
    765          			in the queue is to be overwritten then it does not matter if the
    766          			queue is full. */
    767          			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    768          			{
    769          				traceQUEUE_SEND( pxQueue );
    770          
    771          				#if ( configUSE_QUEUE_SETS == 1 )
    772          				{
    773          				const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    774          
    775          					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    776          
    777          					if( pxQueue->pxQueueSetContainer != NULL )
    778          					{
    779          						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
    780          						{
    781          							/* Do not notify the queue set as an existing item
    782          							was overwritten in the queue so the number of items
    783          							in the queue has not changed. */
    784          							mtCOVERAGE_TEST_MARKER();
    785          						}
    786          						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
    787          						{
    788          							/* The queue is a member of a queue set, and posting
    789          							to the queue set caused a higher priority task to
    790          							unblock. A context switch is required. */
    791          							queueYIELD_IF_USING_PREEMPTION();
    792          						}
    793          						else
    794          						{
    795          							mtCOVERAGE_TEST_MARKER();
    796          						}
    797          					}
    798          					else
    799          					{
    800          						/* If there was a task waiting for data to arrive on the
    801          						queue then unblock it now. */
    802          						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    803          						{
    804          							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    805          							{
    806          								/* The unblocked task has a priority higher than
    807          								our own so yield immediately.  Yes it is ok to
    808          								do this from within the critical section - the
    809          								kernel takes care of that. */
    810          								queueYIELD_IF_USING_PREEMPTION();
    811          							}
    812          							else
    813          							{
    814          								mtCOVERAGE_TEST_MARKER();
    815          							}
    816          						}
    817          						else if( xYieldRequired != pdFALSE )
    818          						{
    819          							/* This path is a special case that will only get
    820          							executed if the task was holding multiple mutexes
    821          							and the mutexes were given back in an order that is
    822          							different to that in which they were taken. */
    823          							queueYIELD_IF_USING_PREEMPTION();
    824          						}
    825          						else
    826          						{
    827          							mtCOVERAGE_TEST_MARKER();
    828          						}
    829          					}
    830          				}
    831          				#else /* configUSE_QUEUE_SETS */
    832          				{
    833          					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    834          
    835          					/* If there was a task waiting for data to arrive on the
    836          					queue then unblock it now. */
    837          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    838          					{
    839          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    840          						{
    841          							/* The unblocked task has a priority higher than
    842          							our own so yield immediately.  Yes it is ok to do
    843          							this from within the critical section - the kernel
    844          							takes care of that. */
    845          							queueYIELD_IF_USING_PREEMPTION();
    846          						}
    847          						else
    848          						{
    849          							mtCOVERAGE_TEST_MARKER();
    850          						}
    851          					}
    852          					else if( xYieldRequired != pdFALSE )
    853          					{
    854          						/* This path is a special case that will only get
    855          						executed if the task was holding multiple mutexes and
    856          						the mutexes were given back in an order that is
    857          						different to that in which they were taken. */
    858          						queueYIELD_IF_USING_PREEMPTION();
    859          					}
    860          					else
    861          					{
    862          						mtCOVERAGE_TEST_MARKER();
    863          					}
    864          				}
    865          				#endif /* configUSE_QUEUE_SETS */
    866          
    867          				taskEXIT_CRITICAL();
    868          				return pdPASS;
    869          			}
    870          			else
    871          			{
    872          				if( xTicksToWait == ( TickType_t ) 0 )
   \                     ??xQueueGenericSend_17: (+1)
   \       0x94   0x9802             LDR      R0,[SP, #+8]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD05C             BEQ.N    ??xQueueGenericSend_18
    873          				{
    874          					/* The queue was full and no block time is specified (or
    875          					the block time has expired) so leave now. */
    876          					taskEXIT_CRITICAL();
    877          
    878          					/* Return to the original privilege level before exiting
    879          					the function. */
    880          					traceQUEUE_SEND_FAILED( pxQueue );
    881          					return errQUEUE_FULL;
    882          				}
    883          				else if( xEntryTimeSet == pdFALSE )
   \                     ??xQueueGenericSend_19: (+1)
   \       0x9A   0x2C00             CMP      R4,#+0
   \       0x9C   0xD103             BNE.N    ??xQueueGenericSend_20
    884          				{
    885          					/* The queue was full and a block time was specified so
    886          					configure the timeout structure. */
    887          					vTaskInternalSetTimeOutState( &xTimeOut );
   \       0x9E   0x4668             MOV      R0,SP
   \       0xA0   0x.... 0x....      BL       vTaskInternalSetTimeOutState
    888          					xEntryTimeSet = pdTRUE;
   \       0xA4   0x2401             MOVS     R4,#+1
    889          				}
    890          				else
    891          				{
    892          					/* Entry time was already set. */
    893          					mtCOVERAGE_TEST_MARKER();
    894          				}
    895          			}
    896          		}
    897          		taskEXIT_CRITICAL();
   \                     ??xQueueGenericSend_20: (+1)
   \       0xA6   0x.... 0x....      BL       vPortExitCritical
    898          
    899          		/* Interrupts and other tasks can send to and receive from the queue
    900          		now the critical section has been exited. */
    901          
    902          		vTaskSuspendAll();
   \       0xAA   0x.... 0x....      BL       vTaskSuspendAll
    903          		prvLockQueue( pxQueue );
   \       0xAE   0x.... 0x....      BL       vPortEnterCritical
   \       0xB2   0xF995 0x0044      LDRSB    R0,[R5, #+68]
   \       0xB6   0xF110 0x0F01      CMN      R0,#+1
   \       0xBA   0xD102             BNE.N    ??xQueueGenericSend_21
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0xF885 0x0044      STRB     R0,[R5, #+68]
   \                     ??xQueueGenericSend_21: (+1)
   \       0xC2   0xF995 0x0045      LDRSB    R0,[R5, #+69]
   \       0xC6   0xF110 0x0F01      CMN      R0,#+1
   \       0xCA   0xD102             BNE.N    ??xQueueGenericSend_22
   \       0xCC   0x2000             MOVS     R0,#+0
   \       0xCE   0xF885 0x0045      STRB     R0,[R5, #+69]
   \                     ??xQueueGenericSend_22: (+1)
   \       0xD2   0x.... 0x....      BL       vPortExitCritical
    904          
    905          		/* Update the timeout state to see if it has expired yet. */
    906          		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   \       0xD6   0xA902             ADD      R1,SP,#+8
   \       0xD8   0x4668             MOV      R0,SP
   \       0xDA   0x.... 0x....      BL       xTaskCheckForTimeOut
   \       0xDE   0x2800             CMP      R0,#+0
   \       0xE0   0xD152             BNE.N    ??xQueueGenericSend_23
    907          		{
    908          			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   \       0xE2   0x0028             MOVS     R0,R5
   \       0xE4   0x.... 0x....      BL       prvIsQueueFull
   \       0xE8   0x2800             CMP      R0,#+0
   \       0xEA   0xD137             BNE.N    ??xQueueGenericSend_24
    909          			{
    910          				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
    911          				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    912          
    913          				/* Unlocking the queue means queue events can effect the
    914          				event list.  It is possible that interrupts occurring now
    915          				remove this task from the event list again - but as the
    916          				scheduler is suspended the task will go onto the pending
    917          				ready last instead of the actual ready list. */
    918          				prvUnlockQueue( pxQueue );
    919          
    920          				/* Resuming the scheduler will move tasks from the pending
    921          				ready list into the ready list - so it is feasible that this
    922          				task is already in a ready list before it yields - in which
    923          				case the yield will not cause a context switch unless there
    924          				is also a higher priority task in the pending ready list. */
    925          				if( xTaskResumeAll() == pdFALSE )
    926          				{
    927          					portYIELD_WITHIN_API();
    928          				}
    929          			}
    930          			else
    931          			{
    932          				/* Try again. */
    933          				prvUnlockQueue( pxQueue );
   \                     ??xQueueGenericSend_25: (+1)
   \       0xEC   0x0028             MOVS     R0,R5
   \       0xEE   0x.... 0x....      BL       prvUnlockQueue
    934          				( void ) xTaskResumeAll();
   \       0xF2   0x.... 0x....      BL       xTaskResumeAll
    935          			}
   \                     ??xQueueGenericSend_15: (+1)
   \       0xF6   0x.... 0x....      BL       vPortEnterCritical
   \       0xFA   0x6BA8             LDR      R0,[R5, #+56]
   \       0xFC   0x6BE9             LDR      R1,[R5, #+60]
   \       0xFE   0x4288             CMP      R0,R1
   \      0x100   0xD301             BCC.N    ??xQueueGenericSend_26
   \      0x102   0x2F02             CMP      R7,#+2
   \      0x104   0xD1C6             BNE.N    ??xQueueGenericSend_17
   \                     ??xQueueGenericSend_26: (+1)
   \      0x106   0x003A             MOVS     R2,R7
   \      0x108   0x0031             MOVS     R1,R6
   \      0x10A   0x0028             MOVS     R0,R5
   \      0x10C   0x.... 0x....      BL       prvCopyDataToQueue
   \      0x110   0x6A69             LDR      R1,[R5, #+36]
   \      0x112   0x2900             CMP      R1,#+0
   \      0x114   0xD00F             BEQ.N    ??xQueueGenericSend_27
   \      0x116   0xF115 0x0024      ADDS     R0,R5,#+36
   \      0x11A   0x.... 0x....      BL       xTaskRemoveFromEventList
   \      0x11E   0x2800             CMP      R0,#+0
   \      0x120   0xD014             BEQ.N    ??xQueueGenericSend_28
   \      0x122   0xF05F 0x5080      MOVS     R0,#+268435456
   \      0x126   0x.... 0x....      LDR.W    R1,??DataTable4
   \      0x12A   0x6008             STR      R0,[R1, #+0]
   \      0x12C   0xF3BF 0x8F4F      DSB      SY
   \      0x130   0xF3BF 0x8F6F      ISB      SY
   \      0x134   0xE00A             B.N      ??xQueueGenericSend_28
   \                     ??xQueueGenericSend_27: (+1)
   \      0x136   0x2800             CMP      R0,#+0
   \      0x138   0xD008             BEQ.N    ??xQueueGenericSend_28
   \      0x13A   0xF05F 0x5080      MOVS     R0,#+268435456
   \      0x13E   0x.... 0x....      LDR.W    R1,??DataTable4
   \      0x142   0x6008             STR      R0,[R1, #+0]
   \      0x144   0xF3BF 0x8F4F      DSB      SY
   \      0x148   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericSend_28: (+1)
   \      0x14C   0x.... 0x....      BL       vPortExitCritical
   \      0x150   0x2001             MOVS     R0,#+1
   \      0x152   0xE01F             B.N      ??xQueueGenericSend_29
   \                     ??xQueueGenericSend_18: (+1)
   \      0x154   0x.... 0x....      BL       vPortExitCritical
   \      0x158   0x2000             MOVS     R0,#+0
   \      0x15A   0xE01B             B.N      ??xQueueGenericSend_29
   \                     ??xQueueGenericSend_24: (+1)
   \      0x15C   0x9902             LDR      R1,[SP, #+8]
   \      0x15E   0xF115 0x0010      ADDS     R0,R5,#+16
   \      0x162   0x.... 0x....      BL       vTaskPlaceOnEventList
   \      0x166   0x0028             MOVS     R0,R5
   \      0x168   0x.... 0x....      BL       prvUnlockQueue
   \      0x16C   0x.... 0x....      BL       xTaskResumeAll
   \      0x170   0x2800             CMP      R0,#+0
   \      0x172   0xD1C0             BNE.N    ??xQueueGenericSend_15
   \      0x174   0xF05F 0x5080      MOVS     R0,#+268435456
   \      0x178   0x.... 0x....      LDR.W    R1,??DataTable4
   \      0x17C   0x6008             STR      R0,[R1, #+0]
   \      0x17E   0xF3BF 0x8F4F      DSB      SY
   \      0x182   0xF3BF 0x8F6F      ISB      SY
   \      0x186   0xE7B6             B.N      ??xQueueGenericSend_15
    936          		}
    937          		else
    938          		{
    939          			/* The timeout has expired. */
    940          			prvUnlockQueue( pxQueue );
   \                     ??xQueueGenericSend_23: (+1)
   \      0x188   0x0028             MOVS     R0,R5
   \      0x18A   0x.... 0x....      BL       prvUnlockQueue
    941          			( void ) xTaskResumeAll();
   \      0x18E   0x.... 0x....      BL       xTaskResumeAll
    942          
    943          			traceQUEUE_SEND_FAILED( pxQueue );
    944          			return errQUEUE_FULL;
   \      0x192   0x2000             MOVS     R0,#+0
   \                     ??xQueueGenericSend_29: (+1)
   \      0x194   0xBDFE             POP      {R1-R7,PC}
    945          		}
    946          	} /*lint -restore */
    947          }
    948          /*-----------------------------------------------------------*/
    949          

   \                                 In section .text, align 2, keep-with-next
    950          BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
    951          {
   \                     xQueueGenericSendFromISR: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x4698             MOV      R8,R3
    952          BaseType_t xReturn;
    953          UBaseType_t uxSavedInterruptStatus;
    954          Queue_t * const pxQueue = xQueue;
    955          
    956          	configASSERT( pxQueue );
   \        0xC   0x2D00             CMP      R5,#+0
   \        0xE   0xD107             BNE.N    ??xQueueGenericSendFromISR_0
   \       0x10   0x2050             MOVS     R0,#+80
   \       0x12   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x16   0xF3BF 0x8F4F      DSB      SY
   \       0x1A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericSendFromISR_1: (+1)
   \       0x1E   0xE7FE             B.N      ??xQueueGenericSendFromISR_1
    957          	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueueGenericSendFromISR_0: (+1)
   \       0x20   0x2E00             CMP      R6,#+0
   \       0x22   0xD102             BNE.N    ??xQueueGenericSendFromISR_2
   \       0x24   0x6C28             LDR      R0,[R5, #+64]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD101             BNE.N    ??xQueueGenericSendFromISR_3
   \                     ??xQueueGenericSendFromISR_2: (+1)
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE000             B.N      ??xQueueGenericSendFromISR_4
   \                     ??xQueueGenericSendFromISR_3: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \                     ??xQueueGenericSendFromISR_4: (+1)
   \       0x30   0xB2C0             UXTB     R0,R0
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD107             BNE.N    ??xQueueGenericSendFromISR_5
   \       0x36   0x2050             MOVS     R0,#+80
   \       0x38   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x3C   0xF3BF 0x8F4F      DSB      SY
   \       0x40   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericSendFromISR_6: (+1)
   \       0x44   0xE7FE             B.N      ??xQueueGenericSendFromISR_6
    958          	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   \                     ??xQueueGenericSendFromISR_5: (+1)
   \       0x46   0xF1B8 0x0F02      CMP      R8,#+2
   \       0x4A   0xD102             BNE.N    ??xQueueGenericSendFromISR_7
   \       0x4C   0x6BE8             LDR      R0,[R5, #+60]
   \       0x4E   0x2801             CMP      R0,#+1
   \       0x50   0xD101             BNE.N    ??xQueueGenericSendFromISR_8
   \                     ??xQueueGenericSendFromISR_7: (+1)
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0xE000             B.N      ??xQueueGenericSendFromISR_9
   \                     ??xQueueGenericSendFromISR_8: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \                     ??xQueueGenericSendFromISR_9: (+1)
   \       0x58   0xB2C0             UXTB     R0,R0
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD107             BNE.N    ??xQueueGenericSendFromISR_10
   \       0x5E   0x2050             MOVS     R0,#+80
   \       0x60   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x64   0xF3BF 0x8F4F      DSB      SY
   \       0x68   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGenericSendFromISR_11: (+1)
   \       0x6C   0xE7FE             B.N      ??xQueueGenericSendFromISR_11
    959          
    960          	/* RTOS ports that support interrupt nesting have the concept of a maximum
    961          	system call (or maximum API call) interrupt priority.  Interrupts that are
    962          	above the maximum system call priority are kept permanently enabled, even
    963          	when the RTOS kernel is in a critical section, but cannot make any calls to
    964          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
    965          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
    966          	failure if a FreeRTOS API function is called from an interrupt that has been
    967          	assigned a priority above the configured maximum system call priority.
    968          	Only FreeRTOS functions that end in FromISR can be called from interrupts
    969          	that have been assigned a priority at or (logically) below the maximum
    970          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
    971          	safe API to ensure interrupt entry is as fast and as simple as possible.
    972          	More information (albeit Cortex-M specific) is provided on the following
    973          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
    974          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   \                     ??xQueueGenericSendFromISR_10: (+1)
   \       0x6E   0x.... 0x....      BL       vPortValidateInterruptPriority
    975          
    976          	/* Similar to xQueueGenericSend, except without blocking if there is no room
    977          	in the queue.  Also don't directly wake a task that was blocked on a queue
    978          	read, instead return a flag to say whether a context switch is required or
    979          	not (i.e. has a task with a higher priority than us been woken by this
    980          	post). */
    981          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \       0x72   0xF3EF 0x8711      MRS      R7,BASEPRI
   \       0x76   0x2050             MOVS     R0,#+80
   \       0x78   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x7C   0xF3BF 0x8F4F      DSB      SY
   \       0x80   0xF3BF 0x8F6F      ISB      SY
    982          	{
    983          		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   \       0x84   0x6BA8             LDR      R0,[R5, #+56]
   \       0x86   0x6BE9             LDR      R1,[R5, #+60]
   \       0x88   0x4288             CMP      R0,R1
   \       0x8A   0xD302             BCC.N    ??xQueueGenericSendFromISR_12
   \       0x8C   0xF1B8 0x0F02      CMP      R8,#+2
   \       0x90   0xD121             BNE.N    ??xQueueGenericSendFromISR_13
    984          		{
    985          			const int8_t cTxLock = pxQueue->cTxLock;
   \                     ??xQueueGenericSendFromISR_12: (+1)
   \       0x92   0xF995 0x9045      LDRSB    R9,[R5, #+69]
    986          			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
   \       0x96   0x6BA8             LDR      R0,[R5, #+56]
    987          
    988          			traceQUEUE_SEND_FROM_ISR( pxQueue );
    989          
    990          			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
    991          			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
    992          			in a task disinheriting a priority and prvCopyDataToQueue() can be
    993          			called here even though the disinherit function does not check if
    994          			the scheduler is suspended before accessing the ready lists. */
    995          			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   \       0x98   0x4642             MOV      R2,R8
   \       0x9A   0x0031             MOVS     R1,R6
   \       0x9C   0x0028             MOVS     R0,R5
   \       0x9E   0x.... 0x....      BL       prvCopyDataToQueue
    996          
    997          			/* The event list is not altered if the queue is locked.  This will
    998          			be done when the queue is unlocked later. */
    999          			if( cTxLock == queueUNLOCKED )
   \       0xA2   0x4648             MOV      R0,R9
   \       0xA4   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \       0xA8   0xB240             SXTB     R0,R0
   \       0xAA   0x4288             CMP      R0,R1
   \       0xAC   0xD10D             BNE.N    ??xQueueGenericSendFromISR_14
   1000          			{
   1001          				#if ( configUSE_QUEUE_SETS == 1 )
   1002          				{
   1003          					if( pxQueue->pxQueueSetContainer != NULL )
   1004          					{
   1005          						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
   1006          						{
   1007          							/* Do not notify the queue set as an existing item
   1008          							was overwritten in the queue so the number of items
   1009          							in the queue has not changed. */
   1010          							mtCOVERAGE_TEST_MARKER();
   1011          						}
   1012          						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
   1013          						{
   1014          							/* The queue is a member of a queue set, and posting
   1015          							to the queue set caused a higher priority task to
   1016          							unblock.  A context switch is required. */
   1017          							if( pxHigherPriorityTaskWoken != NULL )
   1018          							{
   1019          								*pxHigherPriorityTaskWoken = pdTRUE;
   1020          							}
   1021          							else
   1022          							{
   1023          								mtCOVERAGE_TEST_MARKER();
   1024          							}
   1025          						}
   1026          						else
   1027          						{
   1028          							mtCOVERAGE_TEST_MARKER();
   1029          						}
   1030          					}
   1031          					else
   1032          					{
   1033          						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1034          						{
   1035          							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1036          							{
   1037          								/* The task waiting has a higher priority so
   1038          								record that a context switch is required. */
   1039          								if( pxHigherPriorityTaskWoken != NULL )
   1040          								{
   1041          									*pxHigherPriorityTaskWoken = pdTRUE;
   1042          								}
   1043          								else
   1044          								{
   1045          									mtCOVERAGE_TEST_MARKER();
   1046          								}
   1047          							}
   1048          							else
   1049          							{
   1050          								mtCOVERAGE_TEST_MARKER();
   1051          							}
   1052          						}
   1053          						else
   1054          						{
   1055          							mtCOVERAGE_TEST_MARKER();
   1056          						}
   1057          					}
   1058          				}
   1059          				#else /* configUSE_QUEUE_SETS */
   1060          				{
   1061          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   \       0xAE   0x6A68             LDR      R0,[R5, #+36]
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD009             BEQ.N    ??xQueueGenericSendFromISR_15
   1062          					{
   1063          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   \       0xB4   0xF115 0x0024      ADDS     R0,R5,#+36
   \       0xB8   0x.... 0x....      BL       xTaskRemoveFromEventList
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xD003             BEQ.N    ??xQueueGenericSendFromISR_15
   1064          						{
   1065          							/* The task waiting has a higher priority so record that a
   1066          							context	switch is required. */
   1067          							if( pxHigherPriorityTaskWoken != NULL )
   \       0xC0   0x2C00             CMP      R4,#+0
   \       0xC2   0xD001             BEQ.N    ??xQueueGenericSendFromISR_15
   1068          							{
   1069          								*pxHigherPriorityTaskWoken = pdTRUE;
   \       0xC4   0x2001             MOVS     R0,#+1
   \       0xC6   0x6020             STR      R0,[R4, #+0]
   1070          							}
   1071          							else
   1072          							{
   1073          								mtCOVERAGE_TEST_MARKER();
   1074          							}
   1075          						}
   1076          						else
   1077          						{
   1078          							mtCOVERAGE_TEST_MARKER();
   1079          						}
   1080          					}
   1081          					else
   1082          					{
   1083          						mtCOVERAGE_TEST_MARKER();
   1084          					}
   1085          					
   1086          					/* Not used in this path. */
   1087          					( void ) uxPreviousMessagesWaiting;
   \                     ??xQueueGenericSendFromISR_15: (+1)
   \       0xC8   0xE003             B.N      ??xQueueGenericSendFromISR_16
   1088          				}
   1089          				#endif /* configUSE_QUEUE_SETS */
   1090          			}
   1091          			else
   1092          			{
   1093          				/* Increment the lock count so the task that unlocks the queue
   1094          				knows that data was posted while it was locked. */
   1095          				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   \                     ??xQueueGenericSendFromISR_14: (+1)
   \       0xCA   0xF119 0x0901      ADDS     R9,R9,#+1
   \       0xCE   0xF885 0x9045      STRB     R9,[R5, #+69]
   1096          			}
   1097          
   1098          			xReturn = pdPASS;
   \                     ??xQueueGenericSendFromISR_16: (+1)
   \       0xD2   0x2001             MOVS     R0,#+1
   \       0xD4   0xE000             B.N      ??xQueueGenericSendFromISR_17
   1099          		}
   1100          		else
   1101          		{
   1102          			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
   1103          			xReturn = errQUEUE_FULL;
   \                     ??xQueueGenericSendFromISR_13: (+1)
   \       0xD6   0x2000             MOVS     R0,#+0
   1104          		}
   1105          	}
   1106          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueueGenericSendFromISR_17: (+1)
   \       0xD8   0xF387 0x8811      MSR      BASEPRI,R7
   1107          
   1108          	return xReturn;
   \       0xDC   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1109          }
   1110          /*-----------------------------------------------------------*/
   1111          

   \                                 In section .text, align 2, keep-with-next
   1112          BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
   1113          {
   \                     xQueueGiveFromISR: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1114          BaseType_t xReturn;
   1115          UBaseType_t uxSavedInterruptStatus;
   1116          Queue_t * const pxQueue = xQueue;
   1117          
   1118          	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
   1119          	item size is 0.  Don't directly wake a task that was blocked on a queue
   1120          	read, instead return a flag to say whether a context switch is required or
   1121          	not (i.e. has a task with a higher priority than us been woken by this
   1122          	post). */
   1123          
   1124          	configASSERT( pxQueue );
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD107             BNE.N    ??xQueueGiveFromISR_0
   \        0xA   0x2050             MOVS     R0,#+80
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGiveFromISR_1: (+1)
   \       0x18   0xE7FE             B.N      ??xQueueGiveFromISR_1
   1125          
   1126          	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
   1127          	if the item size is not 0. */
   1128          	configASSERT( pxQueue->uxItemSize == 0 );
   \                     ??xQueueGiveFromISR_0: (+1)
   \       0x1A   0x6C28             LDR      R0,[R5, #+64]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD007             BEQ.N    ??xQueueGiveFromISR_2
   \       0x20   0x2050             MOVS     R0,#+80
   \       0x22   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x26   0xF3BF 0x8F4F      DSB      SY
   \       0x2A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGiveFromISR_3: (+1)
   \       0x2E   0xE7FE             B.N      ??xQueueGiveFromISR_3
   1129          
   1130          	/* Normally a mutex would not be given from an interrupt, especially if
   1131          	there is a mutex holder, as priority inheritance makes no sense for an
   1132          	interrupts, only tasks. */
   1133          	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
   \                     ??xQueueGiveFromISR_2: (+1)
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD102             BNE.N    ??xQueueGiveFromISR_4
   \       0x36   0x68A8             LDR      R0,[R5, #+8]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD101             BNE.N    ??xQueueGiveFromISR_5
   \                     ??xQueueGiveFromISR_4: (+1)
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xE000             B.N      ??xQueueGiveFromISR_6
   \                     ??xQueueGiveFromISR_5: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \                     ??xQueueGiveFromISR_6: (+1)
   \       0x42   0xB2C0             UXTB     R0,R0
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD107             BNE.N    ??xQueueGiveFromISR_7
   \       0x48   0x2050             MOVS     R0,#+80
   \       0x4A   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x4E   0xF3BF 0x8F4F      DSB      SY
   \       0x52   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueGiveFromISR_8: (+1)
   \       0x56   0xE7FE             B.N      ??xQueueGiveFromISR_8
   1134          
   1135          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1136          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1137          	above the maximum system call priority are kept permanently enabled, even
   1138          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1139          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1140          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1141          	failure if a FreeRTOS API function is called from an interrupt that has been
   1142          	assigned a priority above the configured maximum system call priority.
   1143          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1144          	that have been assigned a priority at or (logically) below the maximum
   1145          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1146          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1147          	More information (albeit Cortex-M specific) is provided on the following
   1148          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1149          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   \                     ??xQueueGiveFromISR_7: (+1)
   \       0x58   0x.... 0x....      BL       vPortValidateInterruptPriority
   1150          
   1151          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \       0x5C   0xF3EF 0x8611      MRS      R6,BASEPRI
   \       0x60   0x2050             MOVS     R0,#+80
   \       0x62   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x66   0xF3BF 0x8F4F      DSB      SY
   \       0x6A   0xF3BF 0x8F6F      ISB      SY
   1152          	{
   1153          		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   \       0x6E   0x6BA8             LDR      R0,[R5, #+56]
   1154          
   1155          		/* When the queue is used to implement a semaphore no data is ever
   1156          		moved through the queue but it is still valid to see if the queue 'has
   1157          		space'. */
   1158          		if( uxMessagesWaiting < pxQueue->uxLength )
   \       0x70   0x6BE9             LDR      R1,[R5, #+60]
   \       0x72   0x4288             CMP      R0,R1
   \       0x74   0xD21C             BCS.N    ??xQueueGiveFromISR_9
   1159          		{
   1160          			const int8_t cTxLock = pxQueue->cTxLock;
   \       0x76   0xF995 0x1045      LDRSB    R1,[R5, #+69]
   1161          
   1162          			traceQUEUE_SEND_FROM_ISR( pxQueue );
   1163          
   1164          			/* A task can only have an inherited priority if it is a mutex
   1165          			holder - and if there is a mutex holder then the mutex cannot be
   1166          			given from an ISR.  As this is the ISR version of the function it
   1167          			can be assumed there is no mutex holder and no need to determine if
   1168          			priority disinheritance is needed.  Simply increase the count of
   1169          			messages (semaphores) available. */
   1170          			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   \       0x7A   0x1C40             ADDS     R0,R0,#+1
   \       0x7C   0x63A8             STR      R0,[R5, #+56]
   1171          
   1172          			/* The event list is not altered if the queue is locked.  This will
   1173          			be done when the queue is unlocked later. */
   1174          			if( cTxLock == queueUNLOCKED )
   \       0x7E   0x0008             MOVS     R0,R1
   \       0x80   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x84   0xB240             SXTB     R0,R0
   \       0x86   0x4290             CMP      R0,R2
   \       0x88   0xD10D             BNE.N    ??xQueueGiveFromISR_10
   1175          			{
   1176          				#if ( configUSE_QUEUE_SETS == 1 )
   1177          				{
   1178          					if( pxQueue->pxQueueSetContainer != NULL )
   1179          					{
   1180          						if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
   1181          						{
   1182          							/* The semaphore is a member of a queue set, and
   1183          							posting	to the queue set caused a higher priority
   1184          							task to	unblock.  A context switch is required. */
   1185          							if( pxHigherPriorityTaskWoken != NULL )
   1186          							{
   1187          								*pxHigherPriorityTaskWoken = pdTRUE;
   1188          							}
   1189          							else
   1190          							{
   1191          								mtCOVERAGE_TEST_MARKER();
   1192          							}
   1193          						}
   1194          						else
   1195          						{
   1196          							mtCOVERAGE_TEST_MARKER();
   1197          						}
   1198          					}
   1199          					else
   1200          					{
   1201          						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1202          						{
   1203          							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1204          							{
   1205          								/* The task waiting has a higher priority so
   1206          								record that a context switch is required. */
   1207          								if( pxHigherPriorityTaskWoken != NULL )
   1208          								{
   1209          									*pxHigherPriorityTaskWoken = pdTRUE;
   1210          								}
   1211          								else
   1212          								{
   1213          									mtCOVERAGE_TEST_MARKER();
   1214          								}
   1215          							}
   1216          							else
   1217          							{
   1218          								mtCOVERAGE_TEST_MARKER();
   1219          							}
   1220          						}
   1221          						else
   1222          						{
   1223          							mtCOVERAGE_TEST_MARKER();
   1224          						}
   1225          					}
   1226          				}
   1227          				#else /* configUSE_QUEUE_SETS */
   1228          				{
   1229          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   \       0x8A   0x6A68             LDR      R0,[R5, #+36]
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD00D             BEQ.N    ??xQueueGiveFromISR_11
   1230          					{
   1231          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   \       0x90   0xF115 0x0024      ADDS     R0,R5,#+36
   \       0x94   0x.... 0x....      BL       xTaskRemoveFromEventList
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD007             BEQ.N    ??xQueueGiveFromISR_11
   1232          						{
   1233          							/* The task waiting has a higher priority so record that a
   1234          							context	switch is required. */
   1235          							if( pxHigherPriorityTaskWoken != NULL )
   \       0x9C   0x2C00             CMP      R4,#+0
   \       0x9E   0xD005             BEQ.N    ??xQueueGiveFromISR_11
   1236          							{
   1237          								*pxHigherPriorityTaskWoken = pdTRUE;
   \       0xA0   0x2001             MOVS     R0,#+1
   \       0xA2   0x6020             STR      R0,[R4, #+0]
   \       0xA4   0xE002             B.N      ??xQueueGiveFromISR_11
   1238          							}
   1239          							else
   1240          							{
   1241          								mtCOVERAGE_TEST_MARKER();
   1242          							}
   1243          						}
   1244          						else
   1245          						{
   1246          							mtCOVERAGE_TEST_MARKER();
   1247          						}
   1248          					}
   1249          					else
   1250          					{
   1251          						mtCOVERAGE_TEST_MARKER();
   1252          					}
   1253          				}
   1254          				#endif /* configUSE_QUEUE_SETS */
   1255          			}
   1256          			else
   1257          			{
   1258          				/* Increment the lock count so the task that unlocks the queue
   1259          				knows that data was posted while it was locked. */
   1260          				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   \                     ??xQueueGiveFromISR_10: (+1)
   \       0xA6   0x1C49             ADDS     R1,R1,#+1
   \       0xA8   0xF885 0x1045      STRB     R1,[R5, #+69]
   1261          			}
   1262          
   1263          			xReturn = pdPASS;
   \                     ??xQueueGiveFromISR_11: (+1)
   \       0xAC   0x2001             MOVS     R0,#+1
   \       0xAE   0xE000             B.N      ??xQueueGiveFromISR_12
   1264          		}
   1265          		else
   1266          		{
   1267          			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
   1268          			xReturn = errQUEUE_FULL;
   \                     ??xQueueGiveFromISR_9: (+1)
   \       0xB0   0x2000             MOVS     R0,#+0
   1269          		}
   1270          	}
   1271          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueueGiveFromISR_12: (+1)
   \       0xB2   0xF386 0x8811      MSR      BASEPRI,R6
   1272          
   1273          	return xReturn;
   \       0xB6   0xBD70             POP      {R4-R6,PC}
   1274          }
   1275          /*-----------------------------------------------------------*/
   1276          

   \                                 In section .text, align 2, keep-with-next
   1277          BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
   1278          {
   \                     xQueueReceive: (+1)
   \        0x0   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000F             MOVS     R7,R1
   1279          BaseType_t xEntryTimeSet = pdFALSE;
   \        0x6   0x2400             MOVS     R4,#+0
   1280          TimeOut_t xTimeOut;
   1281          Queue_t * const pxQueue = xQueue;
   1282          
   1283          	/* Check the pointer is not NULL. */
   1284          	configASSERT( ( pxQueue ) );
   \        0x8   0x2E00             CMP      R6,#+0
   \        0xA   0xD107             BNE.N    ??xQueueReceive_0
   \        0xC   0x2050             MOVS     R0,#+80
   \        0xE   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x12   0xF3BF 0x8F4F      DSB      SY
   \       0x16   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueReceive_1: (+1)
   \       0x1A   0xE7FE             B.N      ??xQueueReceive_1
   1285          
   1286          	/* The buffer into which data is received can only be NULL if the data size
   1287          	is zero (so no data is copied into the buffer. */
   1288          	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueueReceive_0: (+1)
   \       0x1C   0x2F00             CMP      R7,#+0
   \       0x1E   0xD102             BNE.N    ??xQueueReceive_2
   \       0x20   0x6C30             LDR      R0,[R6, #+64]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD101             BNE.N    ??xQueueReceive_3
   \                     ??xQueueReceive_2: (+1)
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xE000             B.N      ??xQueueReceive_4
   \                     ??xQueueReceive_3: (+1)
   \       0x2A   0x2000             MOVS     R0,#+0
   \                     ??xQueueReceive_4: (+1)
   \       0x2C   0xB2C0             UXTB     R0,R0
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD107             BNE.N    ??xQueueReceive_5
   \       0x32   0x2050             MOVS     R0,#+80
   \       0x34   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x38   0xF3BF 0x8F4F      DSB      SY
   \       0x3C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueReceive_6: (+1)
   \       0x40   0xE7FE             B.N      ??xQueueReceive_6
   1289          
   1290          	/* Cannot block if the scheduler is suspended. */
   1291          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   1292          	{
   1293          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??xQueueReceive_5: (+1)
   \       0x42   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD102             BNE.N    ??xQueueReceive_7
   \       0x4A   0x9802             LDR      R0,[SP, #+8]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD101             BNE.N    ??xQueueReceive_8
   \                     ??xQueueReceive_7: (+1)
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0xE000             B.N      ??xQueueReceive_9
   \                     ??xQueueReceive_8: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \                     ??xQueueReceive_9: (+1)
   \       0x56   0xB2C0             UXTB     R0,R0
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD10C             BNE.N    ??xQueueReceive_10
   \       0x5C   0x2050             MOVS     R0,#+80
   \       0x5E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x62   0xF3BF 0x8F4F      DSB      SY
   \       0x66   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueReceive_11: (+1)
   \       0x6A   0xE7FE             B.N      ??xQueueReceive_11
   1294          	}
   1295          	#endif
   1296          
   1297          
   1298          	/*lint -save -e904  This function relaxes the coding standard somewhat to
   1299          	allow return statements within the function itself.  This is done in the
   1300          	interest of execution time efficiency. */
   1301          	for( ;; )
   1302          	{
   1303          		taskENTER_CRITICAL();
   1304          		{
   1305          			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   1306          
   1307          			/* Is there data in the queue now?  To be running the calling task
   1308          			must be the highest priority task wanting to access the queue. */
   1309          			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   1310          			{
   1311          				/* Data available, remove one item. */
   1312          				prvCopyDataFromQueue( pxQueue, pvBuffer );
   1313          				traceQUEUE_RECEIVE( pxQueue );
   1314          				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
   1315          
   1316          				/* There is now space in the queue, were any tasks waiting to
   1317          				post to the queue?  If so, unblock the highest priority waiting
   1318          				task. */
   1319          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1320          				{
   1321          					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1322          					{
   1323          						queueYIELD_IF_USING_PREEMPTION();
   1324          					}
   1325          					else
   1326          					{
   1327          						mtCOVERAGE_TEST_MARKER();
   1328          					}
   1329          				}
   1330          				else
   1331          				{
   1332          					mtCOVERAGE_TEST_MARKER();
   1333          				}
   1334          
   1335          				taskEXIT_CRITICAL();
   1336          				return pdPASS;
   1337          			}
   1338          			else
   1339          			{
   1340          				if( xTicksToWait == ( TickType_t ) 0 )
   1341          				{
   1342          					/* The queue was empty and no block time is specified (or
   1343          					the block time has expired) so leave now. */
   1344          					taskEXIT_CRITICAL();
   1345          					traceQUEUE_RECEIVE_FAILED( pxQueue );
   1346          					return errQUEUE_EMPTY;
   1347          				}
   1348          				else if( xEntryTimeSet == pdFALSE )
   1349          				{
   1350          					/* The queue was empty and a block time was specified so
   1351          					configure the timeout structure. */
   1352          					vTaskInternalSetTimeOutState( &xTimeOut );
   1353          					xEntryTimeSet = pdTRUE;
   1354          				}
   1355          				else
   1356          				{
   1357          					/* Entry time was already set. */
   1358          					mtCOVERAGE_TEST_MARKER();
   1359          				}
   1360          			}
   1361          		}
   1362          		taskEXIT_CRITICAL();
   1363          
   1364          		/* Interrupts and other tasks can send to and receive from the queue
   1365          		now the critical section has been exited. */
   1366          
   1367          		vTaskSuspendAll();
   1368          		prvLockQueue( pxQueue );
   1369          
   1370          		/* Update the timeout state to see if it has expired yet. */
   1371          		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1372          		{
   1373          			/* The timeout has not expired.  If the queue is still empty place
   1374          			the task on the list of tasks waiting to receive from the queue. */
   1375          			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   1376          			{
   1377          				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
   1378          				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   1379          				prvUnlockQueue( pxQueue );
   1380          				if( xTaskResumeAll() == pdFALSE )
   1381          				{
   1382          					portYIELD_WITHIN_API();
   1383          				}
   1384          				else
   1385          				{
   1386          					mtCOVERAGE_TEST_MARKER();
   1387          				}
   1388          			}
   1389          			else
   1390          			{
   1391          				/* The queue contains data again.  Loop back to try and read the
   1392          				data. */
   1393          				prvUnlockQueue( pxQueue );
   \                     ??xQueueReceive_12: (+1)
   \       0x6C   0x0030             MOVS     R0,R6
   \       0x6E   0x.... 0x....      BL       prvUnlockQueue
   1394          				( void ) xTaskResumeAll();
   \       0x72   0x.... 0x....      BL       xTaskResumeAll
   1395          			}
   \                     ??xQueueReceive_10: (+1)
   \       0x76   0x.... 0x....      BL       vPortEnterCritical
   \       0x7A   0x6BB5             LDR      R5,[R6, #+56]
   \       0x7C   0x2D00             CMP      R5,#+0
   \       0x7E   0xD141             BNE.N    ??xQueueReceive_13
   \                     ??xQueueReceive_14: (+1)
   \       0x80   0x9802             LDR      R0,[SP, #+8]
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD05A             BEQ.N    ??xQueueReceive_15
   \                     ??xQueueReceive_16: (+1)
   \       0x86   0x2C00             CMP      R4,#+0
   \       0x88   0xD103             BNE.N    ??xQueueReceive_17
   \       0x8A   0x4668             MOV      R0,SP
   \       0x8C   0x.... 0x....      BL       vTaskInternalSetTimeOutState
   \       0x90   0x2401             MOVS     R4,#+1
   \                     ??xQueueReceive_17: (+1)
   \       0x92   0x.... 0x....      BL       vPortExitCritical
   \       0x96   0x.... 0x....      BL       vTaskSuspendAll
   \       0x9A   0x.... 0x....      BL       vPortEnterCritical
   \       0x9E   0xF996 0x0044      LDRSB    R0,[R6, #+68]
   \       0xA2   0xF110 0x0F01      CMN      R0,#+1
   \       0xA6   0xD102             BNE.N    ??xQueueReceive_18
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0xF886 0x0044      STRB     R0,[R6, #+68]
   \                     ??xQueueReceive_18: (+1)
   \       0xAE   0xF996 0x0045      LDRSB    R0,[R6, #+69]
   \       0xB2   0xF110 0x0F01      CMN      R0,#+1
   \       0xB6   0xD102             BNE.N    ??xQueueReceive_19
   \       0xB8   0x2000             MOVS     R0,#+0
   \       0xBA   0xF886 0x0045      STRB     R0,[R6, #+69]
   \                     ??xQueueReceive_19: (+1)
   \       0xBE   0x.... 0x....      BL       vPortExitCritical
   \       0xC2   0xA902             ADD      R1,SP,#+8
   \       0xC4   0x4668             MOV      R0,SP
   \       0xC6   0x.... 0x....      BL       xTaskCheckForTimeOut
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0xD13A             BNE.N    ??xQueueReceive_20
   \       0xCE   0x0030             MOVS     R0,R6
   \       0xD0   0x.... 0x....      BL       prvIsQueueEmpty
   \       0xD4   0x2800             CMP      R0,#+0
   \       0xD6   0xD0C9             BEQ.N    ??xQueueReceive_12
   \       0xD8   0x9902             LDR      R1,[SP, #+8]
   \       0xDA   0xF116 0x0024      ADDS     R0,R6,#+36
   \       0xDE   0x.... 0x....      BL       vTaskPlaceOnEventList
   \       0xE2   0x0030             MOVS     R0,R6
   \       0xE4   0x.... 0x....      BL       prvUnlockQueue
   \       0xE8   0x.... 0x....      BL       xTaskResumeAll
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD1C2             BNE.N    ??xQueueReceive_10
   \       0xF0   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0xF4   0x.... 0x....      LDR.W    R1,??DataTable4
   \       0xF8   0x6008             STR      R0,[R1, #+0]
   \       0xFA   0xF3BF 0x8F4F      DSB      SY
   \       0xFE   0xF3BF 0x8F6F      ISB      SY
   \      0x102   0xE7B8             B.N      ??xQueueReceive_10
   \                     ??xQueueReceive_13: (+1)
   \      0x104   0x0039             MOVS     R1,R7
   \      0x106   0x0030             MOVS     R0,R6
   \      0x108   0x.... 0x....      BL       prvCopyDataFromQueue
   \      0x10C   0x1E6D             SUBS     R5,R5,#+1
   \      0x10E   0x63B5             STR      R5,[R6, #+56]
   \      0x110   0x6930             LDR      R0,[R6, #+16]
   \      0x112   0x2800             CMP      R0,#+0
   \      0x114   0xD00E             BEQ.N    ??xQueueReceive_21
   \      0x116   0xF116 0x0010      ADDS     R0,R6,#+16
   \      0x11A   0x.... 0x....      BL       xTaskRemoveFromEventList
   \      0x11E   0x2800             CMP      R0,#+0
   \      0x120   0xD008             BEQ.N    ??xQueueReceive_21
   \      0x122   0xF05F 0x5080      MOVS     R0,#+268435456
   \      0x126   0x.... 0x....      LDR.W    R1,??DataTable4
   \      0x12A   0x6008             STR      R0,[R1, #+0]
   \      0x12C   0xF3BF 0x8F4F      DSB      SY
   \      0x130   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueReceive_21: (+1)
   \      0x134   0x.... 0x....      BL       vPortExitCritical
   \      0x138   0x2001             MOVS     R0,#+1
   \      0x13A   0xE00E             B.N      ??xQueueReceive_22
   \                     ??xQueueReceive_15: (+1)
   \      0x13C   0x.... 0x....      BL       vPortExitCritical
   \      0x140   0x2000             MOVS     R0,#+0
   \      0x142   0xE00A             B.N      ??xQueueReceive_22
   1396          		}
   1397          		else
   1398          		{
   1399          			/* Timed out.  If there is no data in the queue exit, otherwise loop
   1400          			back and attempt to read the data. */
   1401          			prvUnlockQueue( pxQueue );
   \                     ??xQueueReceive_20: (+1)
   \      0x144   0x0030             MOVS     R0,R6
   \      0x146   0x.... 0x....      BL       prvUnlockQueue
   1402          			( void ) xTaskResumeAll();
   \      0x14A   0x.... 0x....      BL       xTaskResumeAll
   1403          
   1404          			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   \      0x14E   0x0030             MOVS     R0,R6
   \      0x150   0x.... 0x....      BL       prvIsQueueEmpty
   \      0x154   0x2800             CMP      R0,#+0
   \      0x156   0xD08E             BEQ.N    ??xQueueReceive_10
   1405          			{
   1406          				traceQUEUE_RECEIVE_FAILED( pxQueue );
   1407          				return errQUEUE_EMPTY;
   \      0x158   0x2000             MOVS     R0,#+0
   \                     ??xQueueReceive_22: (+1)
   \      0x15A   0xBDFE             POP      {R1-R7,PC}
   1408          			}
   1409          			else
   1410          			{
   1411          				mtCOVERAGE_TEST_MARKER();
   1412          			}
   1413          		}
   1414          	} /*lint -restore */
   1415          }
   1416          /*-----------------------------------------------------------*/
   1417          

   \                                 In section .text, align 2, keep-with-next
   1418          BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
   1419          {
   \                     xQueueSemaphoreTake: (+1)
   \        0x0   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
   \        0x4   0x0006             MOVS     R6,R0
   1420          BaseType_t xEntryTimeSet = pdFALSE;
   \        0x6   0x2400             MOVS     R4,#+0
   1421          TimeOut_t xTimeOut;
   1422          Queue_t * const pxQueue = xQueue;
   1423          
   1424          #if( configUSE_MUTEXES == 1 )
   1425          	BaseType_t xInheritanceOccurred = pdFALSE;
   \        0x8   0x2500             MOVS     R5,#+0
   1426          #endif
   1427          
   1428          	/* Check the queue pointer is not NULL. */
   1429          	configASSERT( ( pxQueue ) );
   \        0xA   0x2E00             CMP      R6,#+0
   \        0xC   0xD107             BNE.N    ??xQueueSemaphoreTake_0
   \        0xE   0x2050             MOVS     R0,#+80
   \       0x10   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x14   0xF3BF 0x8F4F      DSB      SY
   \       0x18   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueSemaphoreTake_1: (+1)
   \       0x1C   0xE7FE             B.N      ??xQueueSemaphoreTake_1
   1430          
   1431          	/* Check this really is a semaphore, in which case the item size will be
   1432          	0. */
   1433          	configASSERT( pxQueue->uxItemSize == 0 );
   \                     ??xQueueSemaphoreTake_0: (+1)
   \       0x1E   0x6C30             LDR      R0,[R6, #+64]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD007             BEQ.N    ??xQueueSemaphoreTake_2
   \       0x24   0x2050             MOVS     R0,#+80
   \       0x26   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2A   0xF3BF 0x8F4F      DSB      SY
   \       0x2E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueSemaphoreTake_3: (+1)
   \       0x32   0xE7FE             B.N      ??xQueueSemaphoreTake_3
   1434          
   1435          	/* Cannot block if the scheduler is suspended. */
   1436          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   1437          	{
   1438          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??xQueueSemaphoreTake_2: (+1)
   \       0x34   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD102             BNE.N    ??xQueueSemaphoreTake_4
   \       0x3C   0x9803             LDR      R0,[SP, #+12]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD101             BNE.N    ??xQueueSemaphoreTake_5
   \                     ??xQueueSemaphoreTake_4: (+1)
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0xE000             B.N      ??xQueueSemaphoreTake_6
   \                     ??xQueueSemaphoreTake_5: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \                     ??xQueueSemaphoreTake_6: (+1)
   \       0x48   0xB2C0             UXTB     R0,R0
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD10C             BNE.N    ??xQueueSemaphoreTake_7
   \       0x4E   0x2050             MOVS     R0,#+80
   \       0x50   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x54   0xF3BF 0x8F4F      DSB      SY
   \       0x58   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueSemaphoreTake_8: (+1)
   \       0x5C   0xE7FE             B.N      ??xQueueSemaphoreTake_8
   1439          	}
   1440          	#endif
   1441          
   1442          
   1443          	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
   1444          	statements within the function itself.  This is done in the interest
   1445          	of execution time efficiency. */
   1446          	for( ;; )
   1447          	{
   1448          		taskENTER_CRITICAL();
   1449          		{
   1450          			/* Semaphores are queues with an item size of 0, and where the
   1451          			number of messages in the queue is the semaphore's count value. */
   1452          			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
   1453          
   1454          			/* Is there data in the queue now?  To be running the calling task
   1455          			must be the highest priority task wanting to access the queue. */
   1456          			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
   1457          			{
   1458          				traceQUEUE_RECEIVE( pxQueue );
   1459          
   1460          				/* Semaphores are queues with a data size of zero and where the
   1461          				messages waiting is the semaphore's count.  Reduce the count. */
   1462          				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
   1463          
   1464          				#if ( configUSE_MUTEXES == 1 )
   1465          				{
   1466          					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   1467          					{
   1468          						/* Record the information required to implement
   1469          						priority inheritance should it become necessary. */
   1470          						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
   1471          					}
   1472          					else
   1473          					{
   1474          						mtCOVERAGE_TEST_MARKER();
   1475          					}
   1476          				}
   1477          				#endif /* configUSE_MUTEXES */
   1478          
   1479          				/* Check to see if other tasks are blocked waiting to give the
   1480          				semaphore, and if so, unblock the highest priority such task. */
   1481          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1482          				{
   1483          					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1484          					{
   1485          						queueYIELD_IF_USING_PREEMPTION();
   1486          					}
   1487          					else
   1488          					{
   1489          						mtCOVERAGE_TEST_MARKER();
   1490          					}
   1491          				}
   1492          				else
   1493          				{
   1494          					mtCOVERAGE_TEST_MARKER();
   1495          				}
   1496          
   1497          				taskEXIT_CRITICAL();
   1498          				return pdPASS;
   1499          			}
   1500          			else
   1501          			{
   1502          				if( xTicksToWait == ( TickType_t ) 0 )
   1503          				{
   1504          					/* For inheritance to have occurred there must have been an
   1505          					initial timeout, and an adjusted timeout cannot become 0, as
   1506          					if it were 0 the function would have exited. */
   1507          					#if( configUSE_MUTEXES == 1 )
   1508          					{
   1509          						configASSERT( xInheritanceOccurred == pdFALSE );
   1510          					}
   1511          					#endif /* configUSE_MUTEXES */
   1512          
   1513          					/* The semaphore count was 0 and no block time is specified
   1514          					(or the block time has expired) so exit now. */
   1515          					taskEXIT_CRITICAL();
   1516          					traceQUEUE_RECEIVE_FAILED( pxQueue );
   1517          					return errQUEUE_EMPTY;
   1518          				}
   1519          				else if( xEntryTimeSet == pdFALSE )
   1520          				{
   1521          					/* The semaphore count was 0 and a block time was specified
   1522          					so configure the timeout structure ready to block. */
   1523          					vTaskInternalSetTimeOutState( &xTimeOut );
   1524          					xEntryTimeSet = pdTRUE;
   1525          				}
   1526          				else
   1527          				{
   1528          					/* Entry time was already set. */
   1529          					mtCOVERAGE_TEST_MARKER();
   1530          				}
   1531          			}
   1532          		}
   1533          		taskEXIT_CRITICAL();
   1534          
   1535          		/* Interrupts and other tasks can give to and take from the semaphore
   1536          		now the critical section has been exited. */
   1537          
   1538          		vTaskSuspendAll();
   1539          		prvLockQueue( pxQueue );
   1540          
   1541          		/* Update the timeout state to see if it has expired yet. */
   1542          		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1543          		{
   1544          			/* A block time is specified and not expired.  If the semaphore
   1545          			count is 0 then enter the Blocked state to wait for a semaphore to
   1546          			become available.  As semaphores are implemented with queues the
   1547          			queue being empty is equivalent to the semaphore count being 0. */
   1548          			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   1549          			{
   1550          				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
   1551          
   1552          				#if ( configUSE_MUTEXES == 1 )
   1553          				{
   1554          					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   1555          					{
   1556          						taskENTER_CRITICAL();
   1557          						{
   1558          							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
   1559          						}
   1560          						taskEXIT_CRITICAL();
   1561          					}
   1562          					else
   1563          					{
   1564          						mtCOVERAGE_TEST_MARKER();
   1565          					}
   1566          				}
   1567          				#endif
   1568          
   1569          				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   1570          				prvUnlockQueue( pxQueue );
   1571          				if( xTaskResumeAll() == pdFALSE )
   1572          				{
   1573          					portYIELD_WITHIN_API();
   1574          				}
   1575          				else
   1576          				{
   1577          					mtCOVERAGE_TEST_MARKER();
   1578          				}
   1579          			}
   1580          			else
   1581          			{
   1582          				/* There was no timeout and the semaphore count was not 0, so
   1583          				attempt to take the semaphore again. */
   1584          				prvUnlockQueue( pxQueue );
   \                     ??xQueueSemaphoreTake_9: (+1)
   \       0x5E   0x0030             MOVS     R0,R6
   \       0x60   0x.... 0x....      BL       prvUnlockQueue
   1585          				( void ) xTaskResumeAll();
   \       0x64   0x.... 0x....      BL       xTaskResumeAll
   1586          			}
   \                     ??xQueueSemaphoreTake_7: (+1)
   \       0x68   0x.... 0x....      BL       vPortEnterCritical
   \       0x6C   0x6BB0             LDR      R0,[R6, #+56]
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD14B             BNE.N    ??xQueueSemaphoreTake_10
   \                     ??xQueueSemaphoreTake_11: (+1)
   \       0x72   0x9803             LDR      R0,[SP, #+12]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD065             BEQ.N    ??xQueueSemaphoreTake_12
   \                     ??xQueueSemaphoreTake_13: (+1)
   \       0x78   0x2C00             CMP      R4,#+0
   \       0x7A   0xD103             BNE.N    ??xQueueSemaphoreTake_14
   \       0x7C   0x4668             MOV      R0,SP
   \       0x7E   0x.... 0x....      BL       vTaskInternalSetTimeOutState
   \       0x82   0x2401             MOVS     R4,#+1
   \                     ??xQueueSemaphoreTake_14: (+1)
   \       0x84   0x.... 0x....      BL       vPortExitCritical
   \       0x88   0x.... 0x....      BL       vTaskSuspendAll
   \       0x8C   0x.... 0x....      BL       vPortEnterCritical
   \       0x90   0xF996 0x0044      LDRSB    R0,[R6, #+68]
   \       0x94   0xF110 0x0F01      CMN      R0,#+1
   \       0x98   0xD102             BNE.N    ??xQueueSemaphoreTake_15
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0xF886 0x0044      STRB     R0,[R6, #+68]
   \                     ??xQueueSemaphoreTake_15: (+1)
   \       0xA0   0xF996 0x0045      LDRSB    R0,[R6, #+69]
   \       0xA4   0xF110 0x0F01      CMN      R0,#+1
   \       0xA8   0xD102             BNE.N    ??xQueueSemaphoreTake_16
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0xF886 0x0045      STRB     R0,[R6, #+69]
   \                     ??xQueueSemaphoreTake_16: (+1)
   \       0xB0   0x.... 0x....      BL       vPortExitCritical
   \       0xB4   0xA903             ADD      R1,SP,#+12
   \       0xB6   0x4668             MOV      R0,SP
   \       0xB8   0x.... 0x....      BL       xTaskCheckForTimeOut
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xD14F             BNE.N    ??xQueueSemaphoreTake_17
   \       0xC0   0x0030             MOVS     R0,R6
   \       0xC2   0x.... 0x....      BL       prvIsQueueEmpty
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD0C9             BEQ.N    ??xQueueSemaphoreTake_9
   \       0xCA   0x6830             LDR      R0,[R6, #+0]
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD107             BNE.N    ??xQueueSemaphoreTake_18
   \       0xD0   0x.... 0x....      BL       vPortEnterCritical
   \       0xD4   0x68B0             LDR      R0,[R6, #+8]
   \       0xD6   0x.... 0x....      BL       xTaskPriorityInherit
   \       0xDA   0x0005             MOVS     R5,R0
   \       0xDC   0x.... 0x....      BL       vPortExitCritical
   \                     ??xQueueSemaphoreTake_18: (+1)
   \       0xE0   0x9903             LDR      R1,[SP, #+12]
   \       0xE2   0xF116 0x0024      ADDS     R0,R6,#+36
   \       0xE6   0x.... 0x....      BL       vTaskPlaceOnEventList
   \       0xEA   0x0030             MOVS     R0,R6
   \       0xEC   0x.... 0x....      BL       prvUnlockQueue
   \       0xF0   0x.... 0x....      BL       xTaskResumeAll
   \       0xF4   0x2800             CMP      R0,#+0
   \       0xF6   0xD1B7             BNE.N    ??xQueueSemaphoreTake_7
   \       0xF8   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0xFC   0x....             LDR.N    R1,??DataTable4
   \       0xFE   0x6008             STR      R0,[R1, #+0]
   \      0x100   0xF3BF 0x8F4F      DSB      SY
   \      0x104   0xF3BF 0x8F6F      ISB      SY
   \      0x108   0xE7AE             B.N      ??xQueueSemaphoreTake_7
   \                     ??xQueueSemaphoreTake_10: (+1)
   \      0x10A   0x1E40             SUBS     R0,R0,#+1
   \      0x10C   0x63B0             STR      R0,[R6, #+56]
   \      0x10E   0x6830             LDR      R0,[R6, #+0]
   \      0x110   0x2800             CMP      R0,#+0
   \      0x112   0xD102             BNE.N    ??xQueueSemaphoreTake_19
   \      0x114   0x.... 0x....      BL       pvTaskIncrementMutexHeldCount
   \      0x118   0x60B0             STR      R0,[R6, #+8]
   \                     ??xQueueSemaphoreTake_19: (+1)
   \      0x11A   0x6930             LDR      R0,[R6, #+16]
   \      0x11C   0x2800             CMP      R0,#+0
   \      0x11E   0xD00D             BEQ.N    ??xQueueSemaphoreTake_20
   \      0x120   0xF116 0x0010      ADDS     R0,R6,#+16
   \      0x124   0x.... 0x....      BL       xTaskRemoveFromEventList
   \      0x128   0x2800             CMP      R0,#+0
   \      0x12A   0xD007             BEQ.N    ??xQueueSemaphoreTake_20
   \      0x12C   0xF05F 0x5080      MOVS     R0,#+268435456
   \      0x130   0x....             LDR.N    R1,??DataTable4
   \      0x132   0x6008             STR      R0,[R1, #+0]
   \      0x134   0xF3BF 0x8F4F      DSB      SY
   \      0x138   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueSemaphoreTake_20: (+1)
   \      0x13C   0x.... 0x....      BL       vPortExitCritical
   \      0x140   0x2001             MOVS     R0,#+1
   \      0x142   0xE026             B.N      ??xQueueSemaphoreTake_21
   \                     ??xQueueSemaphoreTake_12: (+1)
   \      0x144   0x2D00             CMP      R5,#+0
   \      0x146   0xD007             BEQ.N    ??xQueueSemaphoreTake_22
   \      0x148   0x2050             MOVS     R0,#+80
   \      0x14A   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x14E   0xF3BF 0x8F4F      DSB      SY
   \      0x152   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueSemaphoreTake_23: (+1)
   \      0x156   0xE7FE             B.N      ??xQueueSemaphoreTake_23
   \                     ??xQueueSemaphoreTake_22: (+1)
   \      0x158   0x.... 0x....      BL       vPortExitCritical
   \      0x15C   0x2000             MOVS     R0,#+0
   \      0x15E   0xE018             B.N      ??xQueueSemaphoreTake_21
   1587          		}
   1588          		else
   1589          		{
   1590          			/* Timed out. */
   1591          			prvUnlockQueue( pxQueue );
   \                     ??xQueueSemaphoreTake_17: (+1)
   \      0x160   0x0030             MOVS     R0,R6
   \      0x162   0x.... 0x....      BL       prvUnlockQueue
   1592          			( void ) xTaskResumeAll();
   \      0x166   0x.... 0x....      BL       xTaskResumeAll
   1593          
   1594          			/* If the semaphore count is 0 exit now as the timeout has
   1595          			expired.  Otherwise return to attempt to take the semaphore that is
   1596          			known to be available.  As semaphores are implemented by queues the
   1597          			queue being empty is equivalent to the semaphore count being 0. */
   1598          			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   \      0x16A   0x0030             MOVS     R0,R6
   \      0x16C   0x.... 0x....      BL       prvIsQueueEmpty
   \      0x170   0x2800             CMP      R0,#+0
   \      0x172   0xF43F 0xAF79      BEQ.W    ??xQueueSemaphoreTake_7
   1599          			{
   1600          				#if ( configUSE_MUTEXES == 1 )
   1601          				{
   1602          					/* xInheritanceOccurred could only have be set if
   1603          					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
   1604          					test the mutex type again to check it is actually a mutex. */
   1605          					if( xInheritanceOccurred != pdFALSE )
   \      0x176   0x2D00             CMP      R5,#+0
   \      0x178   0xD00A             BEQ.N    ??xQueueSemaphoreTake_24
   1606          					{
   1607          						taskENTER_CRITICAL();
   \      0x17A   0x.... 0x....      BL       vPortEnterCritical
   1608          						{
   1609          							UBaseType_t uxHighestWaitingPriority;
   1610          
   1611          							/* This task blocking on the mutex caused another
   1612          							task to inherit this task's priority.  Now this task
   1613          							has timed out the priority should be disinherited
   1614          							again, but only as low as the next highest priority
   1615          							task that is waiting for the same mutex. */
   1616          							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
   \      0x17E   0x0030             MOVS     R0,R6
   \      0x180   0x.... 0x....      BL       prvGetDisinheritPriorityAfterTimeout
   1617          							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
   \      0x184   0x0001             MOVS     R1,R0
   \      0x186   0x68B0             LDR      R0,[R6, #+8]
   \      0x188   0x.... 0x....      BL       vTaskPriorityDisinheritAfterTimeout
   1618          						}
   1619          						taskEXIT_CRITICAL();
   \      0x18C   0x.... 0x....      BL       vPortExitCritical
   1620          					}
   1621          				}
   1622          				#endif /* configUSE_MUTEXES */
   1623          
   1624          				traceQUEUE_RECEIVE_FAILED( pxQueue );
   1625          				return errQUEUE_EMPTY;
   \                     ??xQueueSemaphoreTake_24: (+1)
   \      0x190   0x2000             MOVS     R0,#+0
   \                     ??xQueueSemaphoreTake_21: (+1)
   \      0x192   0xB004             ADD      SP,SP,#+16
   \      0x194   0xBD70             POP      {R4-R6,PC}
   1626          			}
   1627          			else
   1628          			{
   1629          				mtCOVERAGE_TEST_MARKER();
   1630          			}
   1631          		}
   1632          	} /*lint -restore */
   1633          }
   1634          /*-----------------------------------------------------------*/
   1635          

   \                                 In section .text, align 2, keep-with-next
   1636          BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
   1637          {
   \                     xQueuePeek: (+1)
   \        0x0   0xB576             PUSH     {R1,R2,R4-R6,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   1638          BaseType_t xEntryTimeSet = pdFALSE;
   \        0x8   0x2400             MOVS     R4,#+0
   1639          TimeOut_t xTimeOut;
   1640          int8_t *pcOriginalReadPosition;
   1641          Queue_t * const pxQueue = xQueue;
   1642          
   1643          	/* Check the pointer is not NULL. */
   1644          	configASSERT( ( pxQueue ) );
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD107             BNE.N    ??xQueuePeek_0
   \        0xE   0x2050             MOVS     R0,#+80
   \       0x10   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x14   0xF3BF 0x8F4F      DSB      SY
   \       0x18   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueuePeek_1: (+1)
   \       0x1C   0xE7FE             B.N      ??xQueuePeek_1
   1645          
   1646          	/* The buffer into which data is received can only be NULL if the data size
   1647          	is zero (so no data is copied into the buffer. */
   1648          	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueuePeek_0: (+1)
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD102             BNE.N    ??xQueuePeek_2
   \       0x22   0x6C28             LDR      R0,[R5, #+64]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD101             BNE.N    ??xQueuePeek_3
   \                     ??xQueuePeek_2: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE000             B.N      ??xQueuePeek_4
   \                     ??xQueuePeek_3: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??xQueuePeek_4: (+1)
   \       0x2E   0xB2C0             UXTB     R0,R0
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD107             BNE.N    ??xQueuePeek_5
   \       0x34   0x2050             MOVS     R0,#+80
   \       0x36   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x3A   0xF3BF 0x8F4F      DSB      SY
   \       0x3E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueuePeek_6: (+1)
   \       0x42   0xE7FE             B.N      ??xQueuePeek_6
   1649          
   1650          	/* Cannot block if the scheduler is suspended. */
   1651          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   1652          	{
   1653          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??xQueuePeek_5: (+1)
   \       0x44   0x.... 0x....      BL       xTaskGetSchedulerState
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD102             BNE.N    ??xQueuePeek_7
   \       0x4C   0x9803             LDR      R0,[SP, #+12]
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD101             BNE.N    ??xQueuePeek_8
   \                     ??xQueuePeek_7: (+1)
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0xE000             B.N      ??xQueuePeek_9
   \                     ??xQueuePeek_8: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \                     ??xQueuePeek_9: (+1)
   \       0x58   0xB2C0             UXTB     R0,R0
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD10C             BNE.N    ??xQueuePeek_10
   \       0x5E   0x2050             MOVS     R0,#+80
   \       0x60   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x64   0xF3BF 0x8F4F      DSB      SY
   \       0x68   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueuePeek_11: (+1)
   \       0x6C   0xE7FE             B.N      ??xQueuePeek_11
   1654          	}
   1655          	#endif
   1656          
   1657          
   1658          	/*lint -save -e904  This function relaxes the coding standard somewhat to
   1659          	allow return statements within the function itself.  This is done in the
   1660          	interest of execution time efficiency. */
   1661          	for( ;; )
   1662          	{
   1663          		taskENTER_CRITICAL();
   1664          		{
   1665          			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   1666          
   1667          			/* Is there data in the queue now?  To be running the calling task
   1668          			must be the highest priority task wanting to access the queue. */
   1669          			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   1670          			{
   1671          				/* Remember the read position so it can be reset after the data
   1672          				is read from the queue as this function is only peeking the
   1673          				data, not removing it. */
   1674          				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
   1675          
   1676          				prvCopyDataFromQueue( pxQueue, pvBuffer );
   1677          				traceQUEUE_PEEK( pxQueue );
   1678          
   1679          				/* The data is not being removed, so reset the read pointer. */
   1680          				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
   1681          
   1682          				/* The data is being left in the queue, so see if there are
   1683          				any other tasks waiting for the data. */
   1684          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1685          				{
   1686          					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1687          					{
   1688          						/* The task waiting has a higher priority than this task. */
   1689          						queueYIELD_IF_USING_PREEMPTION();
   1690          					}
   1691          					else
   1692          					{
   1693          						mtCOVERAGE_TEST_MARKER();
   1694          					}
   1695          				}
   1696          				else
   1697          				{
   1698          					mtCOVERAGE_TEST_MARKER();
   1699          				}
   1700          
   1701          				taskEXIT_CRITICAL();
   1702          				return pdPASS;
   1703          			}
   1704          			else
   1705          			{
   1706          				if( xTicksToWait == ( TickType_t ) 0 )
   1707          				{
   1708          					/* The queue was empty and no block time is specified (or
   1709          					the block time has expired) so leave now. */
   1710          					taskEXIT_CRITICAL();
   1711          					traceQUEUE_PEEK_FAILED( pxQueue );
   1712          					return errQUEUE_EMPTY;
   1713          				}
   1714          				else if( xEntryTimeSet == pdFALSE )
   1715          				{
   1716          					/* The queue was empty and a block time was specified so
   1717          					configure the timeout structure ready to enter the blocked
   1718          					state. */
   1719          					vTaskInternalSetTimeOutState( &xTimeOut );
   1720          					xEntryTimeSet = pdTRUE;
   1721          				}
   1722          				else
   1723          				{
   1724          					/* Entry time was already set. */
   1725          					mtCOVERAGE_TEST_MARKER();
   1726          				}
   1727          			}
   1728          		}
   1729          		taskEXIT_CRITICAL();
   1730          
   1731          		/* Interrupts and other tasks can send to and receive from the queue
   1732          		now the critical section has been exited. */
   1733          
   1734          		vTaskSuspendAll();
   1735          		prvLockQueue( pxQueue );
   1736          
   1737          		/* Update the timeout state to see if it has expired yet. */
   1738          		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1739          		{
   1740          			/* Timeout has not expired yet, check to see if there is data in the
   1741          			queue now, and if not enter the Blocked state to wait for data. */
   1742          			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   1743          			{
   1744          				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
   1745          				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   1746          				prvUnlockQueue( pxQueue );
   1747          				if( xTaskResumeAll() == pdFALSE )
   1748          				{
   1749          					portYIELD_WITHIN_API();
   1750          				}
   1751          				else
   1752          				{
   1753          					mtCOVERAGE_TEST_MARKER();
   1754          				}
   1755          			}
   1756          			else
   1757          			{
   1758          				/* There is data in the queue now, so don't enter the blocked
   1759          				state, instead return to try and obtain the data. */
   1760          				prvUnlockQueue( pxQueue );
   \                     ??xQueuePeek_12: (+1)
   \       0x6E   0x0028             MOVS     R0,R5
   \       0x70   0x.... 0x....      BL       prvUnlockQueue
   1761          				( void ) xTaskResumeAll();
   \       0x74   0x.... 0x....      BL       xTaskResumeAll
   1762          			}
   \                     ??xQueuePeek_10: (+1)
   \       0x78   0x.... 0x....      BL       vPortEnterCritical
   \       0x7C   0x6BA8             LDR      R0,[R5, #+56]
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD140             BNE.N    ??xQueuePeek_13
   \                     ??xQueuePeek_14: (+1)
   \       0x82   0x9803             LDR      R0,[SP, #+12]
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD058             BEQ.N    ??xQueuePeek_15
   \                     ??xQueuePeek_16: (+1)
   \       0x88   0x2C00             CMP      R4,#+0
   \       0x8A   0xD103             BNE.N    ??xQueuePeek_17
   \       0x8C   0x4668             MOV      R0,SP
   \       0x8E   0x.... 0x....      BL       vTaskInternalSetTimeOutState
   \       0x92   0x2401             MOVS     R4,#+1
   \                     ??xQueuePeek_17: (+1)
   \       0x94   0x.... 0x....      BL       vPortExitCritical
   \       0x98   0x.... 0x....      BL       vTaskSuspendAll
   \       0x9C   0x.... 0x....      BL       vPortEnterCritical
   \       0xA0   0xF995 0x0044      LDRSB    R0,[R5, #+68]
   \       0xA4   0xF110 0x0F01      CMN      R0,#+1
   \       0xA8   0xD102             BNE.N    ??xQueuePeek_18
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0xF885 0x0044      STRB     R0,[R5, #+68]
   \                     ??xQueuePeek_18: (+1)
   \       0xB0   0xF995 0x0045      LDRSB    R0,[R5, #+69]
   \       0xB4   0xF110 0x0F01      CMN      R0,#+1
   \       0xB8   0xD102             BNE.N    ??xQueuePeek_19
   \       0xBA   0x2000             MOVS     R0,#+0
   \       0xBC   0xF885 0x0045      STRB     R0,[R5, #+69]
   \                     ??xQueuePeek_19: (+1)
   \       0xC0   0x.... 0x....      BL       vPortExitCritical
   \       0xC4   0xA903             ADD      R1,SP,#+12
   \       0xC6   0x4668             MOV      R0,SP
   \       0xC8   0x.... 0x....      BL       xTaskCheckForTimeOut
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD138             BNE.N    ??xQueuePeek_20
   \       0xD0   0x0028             MOVS     R0,R5
   \       0xD2   0x.... 0x....      BL       prvIsQueueEmpty
   \       0xD6   0x2800             CMP      R0,#+0
   \       0xD8   0xD0C9             BEQ.N    ??xQueuePeek_12
   \       0xDA   0x9903             LDR      R1,[SP, #+12]
   \       0xDC   0xF115 0x0024      ADDS     R0,R5,#+36
   \       0xE0   0x.... 0x....      BL       vTaskPlaceOnEventList
   \       0xE4   0x0028             MOVS     R0,R5
   \       0xE6   0x.... 0x....      BL       prvUnlockQueue
   \       0xEA   0x.... 0x....      BL       xTaskResumeAll
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD1C2             BNE.N    ??xQueuePeek_10
   \       0xF2   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0xF6   0x....             LDR.N    R1,??DataTable4
   \       0xF8   0x6008             STR      R0,[R1, #+0]
   \       0xFA   0xF3BF 0x8F4F      DSB      SY
   \       0xFE   0xF3BF 0x8F6F      ISB      SY
   \      0x102   0xE7B9             B.N      ??xQueuePeek_10
   \                     ??xQueuePeek_13: (+1)
   \      0x104   0x68EC             LDR      R4,[R5, #+12]
   \      0x106   0x0031             MOVS     R1,R6
   \      0x108   0x0028             MOVS     R0,R5
   \      0x10A   0x.... 0x....      BL       prvCopyDataFromQueue
   \      0x10E   0x60EC             STR      R4,[R5, #+12]
   \      0x110   0x6A68             LDR      R0,[R5, #+36]
   \      0x112   0x2800             CMP      R0,#+0
   \      0x114   0xD00D             BEQ.N    ??xQueuePeek_21
   \      0x116   0xF115 0x0024      ADDS     R0,R5,#+36
   \      0x11A   0x.... 0x....      BL       xTaskRemoveFromEventList
   \      0x11E   0x2800             CMP      R0,#+0
   \      0x120   0xD007             BEQ.N    ??xQueuePeek_21
   \      0x122   0xF05F 0x5080      MOVS     R0,#+268435456
   \      0x126   0x....             LDR.N    R1,??DataTable4
   \      0x128   0x6008             STR      R0,[R1, #+0]
   \      0x12A   0xF3BF 0x8F4F      DSB      SY
   \      0x12E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueuePeek_21: (+1)
   \      0x132   0x.... 0x....      BL       vPortExitCritical
   \      0x136   0x2001             MOVS     R0,#+1
   \      0x138   0xE00E             B.N      ??xQueuePeek_22
   \                     ??xQueuePeek_15: (+1)
   \      0x13A   0x.... 0x....      BL       vPortExitCritical
   \      0x13E   0x2000             MOVS     R0,#+0
   \      0x140   0xE00A             B.N      ??xQueuePeek_22
   1763          		}
   1764          		else
   1765          		{
   1766          			/* The timeout has expired.  If there is still no data in the queue
   1767          			exit, otherwise go back and try to read the data again. */
   1768          			prvUnlockQueue( pxQueue );
   \                     ??xQueuePeek_20: (+1)
   \      0x142   0x0028             MOVS     R0,R5
   \      0x144   0x.... 0x....      BL       prvUnlockQueue
   1769          			( void ) xTaskResumeAll();
   \      0x148   0x.... 0x....      BL       xTaskResumeAll
   1770          
   1771          			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   \      0x14C   0x0028             MOVS     R0,R5
   \      0x14E   0x.... 0x....      BL       prvIsQueueEmpty
   \      0x152   0x2800             CMP      R0,#+0
   \      0x154   0xD090             BEQ.N    ??xQueuePeek_10
   1772          			{
   1773          				traceQUEUE_PEEK_FAILED( pxQueue );
   1774          				return errQUEUE_EMPTY;
   \      0x156   0x2000             MOVS     R0,#+0
   \                     ??xQueuePeek_22: (+1)
   \      0x158   0xB004             ADD      SP,SP,#+16
   \      0x15A   0xBD70             POP      {R4-R6,PC}
   1775          			}
   1776          			else
   1777          			{
   1778          				mtCOVERAGE_TEST_MARKER();
   1779          			}
   1780          		}
   1781          	} /*lint -restore */
   1782          }
   1783          /*-----------------------------------------------------------*/
   1784          

   \                                 In section .text, align 2, keep-with-next
   1785          BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
   1786          {
   \                     xQueueReceiveFromISR: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
   1787          BaseType_t xReturn;
   1788          UBaseType_t uxSavedInterruptStatus;
   1789          Queue_t * const pxQueue = xQueue;
   1790          
   1791          	configASSERT( pxQueue );
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD107             BNE.N    ??xQueueReceiveFromISR_0
   \        0xE   0x2050             MOVS     R0,#+80
   \       0x10   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x14   0xF3BF 0x8F4F      DSB      SY
   \       0x18   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueReceiveFromISR_1: (+1)
   \       0x1C   0xE7FE             B.N      ??xQueueReceiveFromISR_1
   1792          	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueueReceiveFromISR_0: (+1)
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD102             BNE.N    ??xQueueReceiveFromISR_2
   \       0x22   0x6C28             LDR      R0,[R5, #+64]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD101             BNE.N    ??xQueueReceiveFromISR_3
   \                     ??xQueueReceiveFromISR_2: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE000             B.N      ??xQueueReceiveFromISR_4
   \                     ??xQueueReceiveFromISR_3: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??xQueueReceiveFromISR_4: (+1)
   \       0x2E   0xB2C0             UXTB     R0,R0
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD107             BNE.N    ??xQueueReceiveFromISR_5
   \       0x34   0x2050             MOVS     R0,#+80
   \       0x36   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x3A   0xF3BF 0x8F4F      DSB      SY
   \       0x3E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueReceiveFromISR_6: (+1)
   \       0x42   0xE7FE             B.N      ??xQueueReceiveFromISR_6
   1793          
   1794          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1795          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1796          	above the maximum system call priority are kept permanently enabled, even
   1797          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1798          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1799          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1800          	failure if a FreeRTOS API function is called from an interrupt that has been
   1801          	assigned a priority above the configured maximum system call priority.
   1802          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1803          	that have been assigned a priority at or (logically) below the maximum
   1804          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1805          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1806          	More information (albeit Cortex-M specific) is provided on the following
   1807          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1808          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   \                     ??xQueueReceiveFromISR_5: (+1)
   \       0x44   0x.... 0x....      BL       vPortValidateInterruptPriority
   1809          
   1810          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \       0x48   0xF3EF 0x8811      MRS      R8,BASEPRI
   \       0x4C   0x2050             MOVS     R0,#+80
   \       0x4E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x52   0xF3BF 0x8F4F      DSB      SY
   \       0x56   0xF3BF 0x8F6F      ISB      SY
   1811          	{
   1812          		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   \       0x5A   0x6BAF             LDR      R7,[R5, #+56]
   1813          
   1814          		/* Cannot block in an ISR, so check there is data available. */
   1815          		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   \       0x5C   0x2F00             CMP      R7,#+0
   \       0x5E   0xD021             BEQ.N    ??xQueueReceiveFromISR_7
   1816          		{
   1817          			const int8_t cRxLock = pxQueue->cRxLock;
   \       0x60   0xF995 0x9044      LDRSB    R9,[R5, #+68]
   1818          
   1819          			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
   1820          
   1821          			prvCopyDataFromQueue( pxQueue, pvBuffer );
   \       0x64   0x0031             MOVS     R1,R6
   \       0x66   0x0028             MOVS     R0,R5
   \       0x68   0x.... 0x....      BL       prvCopyDataFromQueue
   1822          			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
   \       0x6C   0x1E7F             SUBS     R7,R7,#+1
   \       0x6E   0x63AF             STR      R7,[R5, #+56]
   1823          
   1824          			/* If the queue is locked the event list will not be modified.
   1825          			Instead update the lock count so the task that unlocks the queue
   1826          			will know that an ISR has removed data while the queue was
   1827          			locked. */
   1828          			if( cRxLock == queueUNLOCKED )
   \       0x70   0x4648             MOV      R0,R9
   \       0x72   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \       0x76   0xB240             SXTB     R0,R0
   \       0x78   0x4288             CMP      R0,R1
   \       0x7A   0xD10D             BNE.N    ??xQueueReceiveFromISR_8
   1829          			{
   1830          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   \       0x7C   0x6928             LDR      R0,[R5, #+16]
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD00E             BEQ.N    ??xQueueReceiveFromISR_9
   1831          				{
   1832          					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   \       0x82   0xF115 0x0010      ADDS     R0,R5,#+16
   \       0x86   0x.... 0x....      BL       xTaskRemoveFromEventList
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD008             BEQ.N    ??xQueueReceiveFromISR_9
   1833          					{
   1834          						/* The task waiting has a higher priority than us so
   1835          						force a context switch. */
   1836          						if( pxHigherPriorityTaskWoken != NULL )
   \       0x8E   0x2C00             CMP      R4,#+0
   \       0x90   0xD006             BEQ.N    ??xQueueReceiveFromISR_9
   1837          						{
   1838          							*pxHigherPriorityTaskWoken = pdTRUE;
   \       0x92   0x2001             MOVS     R0,#+1
   \       0x94   0x6020             STR      R0,[R4, #+0]
   \       0x96   0xE003             B.N      ??xQueueReceiveFromISR_9
   1839          						}
   1840          						else
   1841          						{
   1842          							mtCOVERAGE_TEST_MARKER();
   1843          						}
   1844          					}
   1845          					else
   1846          					{
   1847          						mtCOVERAGE_TEST_MARKER();
   1848          					}
   1849          				}
   1850          				else
   1851          				{
   1852          					mtCOVERAGE_TEST_MARKER();
   1853          				}
   1854          			}
   1855          			else
   1856          			{
   1857          				/* Increment the lock count so the task that unlocks the queue
   1858          				knows that data was removed while it was locked. */
   1859          				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
   \                     ??xQueueReceiveFromISR_8: (+1)
   \       0x98   0xF119 0x0901      ADDS     R9,R9,#+1
   \       0x9C   0xF885 0x9044      STRB     R9,[R5, #+68]
   1860          			}
   1861          
   1862          			xReturn = pdPASS;
   \                     ??xQueueReceiveFromISR_9: (+1)
   \       0xA0   0x2001             MOVS     R0,#+1
   \       0xA2   0xE000             B.N      ??xQueueReceiveFromISR_10
   1863          		}
   1864          		else
   1865          		{
   1866          			xReturn = pdFAIL;
   \                     ??xQueueReceiveFromISR_7: (+1)
   \       0xA4   0x2000             MOVS     R0,#+0
   1867          			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
   1868          		}
   1869          	}
   1870          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueueReceiveFromISR_10: (+1)
   \       0xA6   0xF388 0x8811      MSR      BASEPRI,R8
   1871          
   1872          	return xReturn;
   \       0xAA   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1873          }
   1874          /*-----------------------------------------------------------*/
   1875          

   \                                 In section .text, align 2, keep-with-next
   1876          BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
   1877          {
   \                     xQueuePeekFromISR: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1878          BaseType_t xReturn;
   1879          UBaseType_t uxSavedInterruptStatus;
   1880          int8_t *pcOriginalReadPosition;
   1881          Queue_t * const pxQueue = xQueue;
   1882          
   1883          	configASSERT( pxQueue );
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD107             BNE.N    ??xQueuePeekFromISR_0
   \        0xA   0x2050             MOVS     R0,#+80
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueuePeekFromISR_1: (+1)
   \       0x18   0xE7FE             B.N      ??xQueuePeekFromISR_1
   1884          	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueuePeekFromISR_0: (+1)
   \       0x1A   0x2D00             CMP      R5,#+0
   \       0x1C   0xD102             BNE.N    ??xQueuePeekFromISR_2
   \       0x1E   0x6C20             LDR      R0,[R4, #+64]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD101             BNE.N    ??xQueuePeekFromISR_3
   \                     ??xQueuePeekFromISR_2: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xE000             B.N      ??xQueuePeekFromISR_4
   \                     ??xQueuePeekFromISR_3: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \                     ??xQueuePeekFromISR_4: (+1)
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD107             BNE.N    ??xQueuePeekFromISR_5
   \       0x30   0x2050             MOVS     R0,#+80
   \       0x32   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x36   0xF3BF 0x8F4F      DSB      SY
   \       0x3A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueuePeekFromISR_6: (+1)
   \       0x3E   0xE7FE             B.N      ??xQueuePeekFromISR_6
   1885          	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
   \                     ??xQueuePeekFromISR_5: (+1)
   \       0x40   0x6C20             LDR      R0,[R4, #+64]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD107             BNE.N    ??xQueuePeekFromISR_7
   \       0x46   0x2050             MOVS     R0,#+80
   \       0x48   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x4C   0xF3BF 0x8F4F      DSB      SY
   \       0x50   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueuePeekFromISR_8: (+1)
   \       0x54   0xE7FE             B.N      ??xQueuePeekFromISR_8
   1886          
   1887          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1888          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1889          	above the maximum system call priority are kept permanently enabled, even
   1890          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1891          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1892          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1893          	failure if a FreeRTOS API function is called from an interrupt that has been
   1894          	assigned a priority above the configured maximum system call priority.
   1895          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1896          	that have been assigned a priority at or (logically) below the maximum
   1897          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1898          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1899          	More information (albeit Cortex-M specific) is provided on the following
   1900          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1901          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   \                     ??xQueuePeekFromISR_7: (+1)
   \       0x56   0x.... 0x....      BL       vPortValidateInterruptPriority
   1902          
   1903          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \       0x5A   0xF3EF 0x8611      MRS      R6,BASEPRI
   \       0x5E   0x2050             MOVS     R0,#+80
   \       0x60   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x64   0xF3BF 0x8F4F      DSB      SY
   \       0x68   0xF3BF 0x8F6F      ISB      SY
   1904          	{
   1905          		/* Cannot block in an ISR, so check there is data available. */
   1906          		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   \       0x6C   0x6BA0             LDR      R0,[R4, #+56]
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD007             BEQ.N    ??xQueuePeekFromISR_9
   1907          		{
   1908          			traceQUEUE_PEEK_FROM_ISR( pxQueue );
   1909          
   1910          			/* Remember the read position so it can be reset as nothing is
   1911          			actually being removed from the queue. */
   1912          			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
   \       0x72   0x68E7             LDR      R7,[R4, #+12]
   1913          			prvCopyDataFromQueue( pxQueue, pvBuffer );
   \       0x74   0x0029             MOVS     R1,R5
   \       0x76   0x0020             MOVS     R0,R4
   \       0x78   0x.... 0x....      BL       prvCopyDataFromQueue
   1914          			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
   \       0x7C   0x60E7             STR      R7,[R4, #+12]
   1915          
   1916          			xReturn = pdPASS;
   \       0x7E   0x2001             MOVS     R0,#+1
   \       0x80   0xE000             B.N      ??xQueuePeekFromISR_10
   1917          		}
   1918          		else
   1919          		{
   1920          			xReturn = pdFAIL;
   \                     ??xQueuePeekFromISR_9: (+1)
   \       0x82   0x2000             MOVS     R0,#+0
   1921          			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
   1922          		}
   1923          	}
   1924          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueuePeekFromISR_10: (+1)
   \       0x84   0xF386 0x8811      MSR      BASEPRI,R6
   1925          
   1926          	return xReturn;
   \       0x88   0xBDF2             POP      {R1,R4-R7,PC}
   1927          }
   1928          /*-----------------------------------------------------------*/
   1929          

   \                                 In section .text, align 2, keep-with-next
   1930          UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
   1931          {
   \                     uxQueueMessagesWaiting: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1932          UBaseType_t uxReturn;
   1933          
   1934          	configASSERT( xQueue );
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD107             BNE.N    ??uxQueueMessagesWaiting_0
   \        0x8   0x2050             MOVS     R0,#+80
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??uxQueueMessagesWaiting_1: (+1)
   \       0x16   0xE7FE             B.N      ??uxQueueMessagesWaiting_1
   1935          
   1936          	taskENTER_CRITICAL();
   \                     ??uxQueueMessagesWaiting_0: (+1)
   \       0x18   0x.... 0x....      BL       vPortEnterCritical
   1937          	{
   1938          		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
   \       0x1C   0x6BA4             LDR      R4,[R4, #+56]
   1939          	}
   1940          	taskEXIT_CRITICAL();
   \       0x1E   0x.... 0x....      BL       vPortExitCritical
   1941          
   1942          	return uxReturn;
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0xBD10             POP      {R4,PC}
   1943          } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   1944          /*-----------------------------------------------------------*/
   1945          

   \                                 In section .text, align 2, keep-with-next
   1946          UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
   1947          {
   \                     uxQueueSpacesAvailable: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1948          UBaseType_t uxReturn;
   1949          Queue_t * const pxQueue = xQueue;
   1950          
   1951          	configASSERT( pxQueue );
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD107             BNE.N    ??uxQueueSpacesAvailable_0
   \        0x8   0x2050             MOVS     R0,#+80
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??uxQueueSpacesAvailable_1: (+1)
   \       0x16   0xE7FE             B.N      ??uxQueueSpacesAvailable_1
   1952          
   1953          	taskENTER_CRITICAL();
   \                     ??uxQueueSpacesAvailable_0: (+1)
   \       0x18   0x.... 0x....      BL       vPortEnterCritical
   1954          	{
   1955          		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
   \       0x1C   0x6BE0             LDR      R0,[R4, #+60]
   \       0x1E   0x6BA4             LDR      R4,[R4, #+56]
   \       0x20   0x1B04             SUBS     R4,R0,R4
   1956          	}
   1957          	taskEXIT_CRITICAL();
   \       0x22   0x.... 0x....      BL       vPortExitCritical
   1958          
   1959          	return uxReturn;
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0xBD10             POP      {R4,PC}
   1960          } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   1961          /*-----------------------------------------------------------*/
   1962          

   \                                 In section .text, align 2, keep-with-next
   1963          UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
   1964          {
   1965          UBaseType_t uxReturn;
   1966          Queue_t * const pxQueue = xQueue;
   1967          
   1968          	configASSERT( pxQueue );
   \                     uxQueueMessagesWaitingFromISR: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD107             BNE.N    ??uxQueueMessagesWaitingFromISR_0
   \        0x4   0x2050             MOVS     R0,#+80
   \        0x6   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
   \                     ??uxQueueMessagesWaitingFromISR_1: (+1)
   \       0x12   0xE7FE             B.N      ??uxQueueMessagesWaitingFromISR_1
   1969          	uxReturn = pxQueue->uxMessagesWaiting;
   \                     ??uxQueueMessagesWaitingFromISR_0: (+1)
   \       0x14   0x6B80             LDR      R0,[R0, #+56]
   1970          
   1971          	return uxReturn;
   \       0x16   0x4770             BX       LR
   1972          } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   1973          /*-----------------------------------------------------------*/
   1974          

   \                                 In section .text, align 2, keep-with-next
   1975          void vQueueDelete( QueueHandle_t xQueue )
   1976          {
   \                     vQueueDelete: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1977          Queue_t * const pxQueue = xQueue;
   1978          
   1979          	configASSERT( pxQueue );
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD107             BNE.N    ??vQueueDelete_0
   \        0x8   0x2050             MOVS     R0,#+80
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??vQueueDelete_1: (+1)
   \       0x16   0xE7FE             B.N      ??vQueueDelete_1
   1980          	traceQUEUE_DELETE( pxQueue );
   1981          
   1982          	#if ( configQUEUE_REGISTRY_SIZE > 0 )
   1983          	{
   1984          		vQueueUnregisterQueue( pxQueue );
   \                     ??vQueueDelete_0: (+1)
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0x.... 0x....      BL       vQueueUnregisterQueue
   1985          	}
   1986          	#endif
   1987          
   1988          	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
   1989          	{
   1990          		/* The queue can only have been allocated dynamically - free it
   1991          		again. */
   1992          		vPortFree( pxQueue );
   1993          	}
   1994          	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
   1995          	{
   1996          		/* The queue could have been allocated statically or dynamically, so
   1997          		check before attempting to free the memory. */
   1998          		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
   \       0x1E   0xF894 0x0046      LDRB     R0,[R4, #+70]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD102             BNE.N    ??vQueueDelete_2
   1999          		{
   2000          			vPortFree( pxQueue );
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       vPortFree
   2001          		}
   2002          		else
   2003          		{
   2004          			mtCOVERAGE_TEST_MARKER();
   2005          		}
   2006          	}
   2007          	#else
   2008          	{
   2009          		/* The queue must have been statically allocated, so is not going to be
   2010          		deleted.  Avoid compiler warnings about the unused parameter. */
   2011          		( void ) pxQueue;
   2012          	}
   2013          	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
   2014          }
   \                     ??vQueueDelete_2: (+1)
   \       0x2C   0xBD10             POP      {R4,PC}
   2015          /*-----------------------------------------------------------*/
   2016          
   2017          #if ( configUSE_TRACE_FACILITY == 1 )
   2018          

   \                                 In section .text, align 2, keep-with-next
   2019          	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
   2020          	{
   2021          		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
   \                     uxQueueGetQueueNumber: (+1)
   \        0x0   0x6C80             LDR      R0,[R0, #+72]
   \        0x2   0x4770             BX       LR
   2022          	}
   2023          
   2024          #endif /* configUSE_TRACE_FACILITY */
   2025          /*-----------------------------------------------------------*/
   2026          
   2027          #if ( configUSE_TRACE_FACILITY == 1 )
   2028          

   \                                 In section .text, align 2, keep-with-next
   2029          	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
   2030          	{
   2031          		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
   \                     vQueueSetQueueNumber: (+1)
   \        0x0   0x6481             STR      R1,[R0, #+72]
   2032          	}
   \        0x2   0x4770             BX       LR
   2033          
   2034          #endif /* configUSE_TRACE_FACILITY */
   2035          /*-----------------------------------------------------------*/
   2036          
   2037          #if ( configUSE_TRACE_FACILITY == 1 )
   2038          

   \                                 In section .text, align 2, keep-with-next
   2039          	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
   2040          	{
   2041          		return ( ( Queue_t * ) xQueue )->ucQueueType;
   \                     ucQueueGetQueueType: (+1)
   \        0x0   0xF890 0x004C      LDRB     R0,[R0, #+76]
   \        0x4   0x4770             BX       LR
   2042          	}
   2043          
   2044          #endif /* configUSE_TRACE_FACILITY */
   2045          /*-----------------------------------------------------------*/
   2046          
   2047          #if( configUSE_MUTEXES == 1 )
   2048          

   \                                 In section .text, align 2, keep-with-next
   2049          	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
   2050          	{
   2051          	UBaseType_t uxHighestPriorityOfWaitingTasks;
   2052          
   2053          		/* If a task waiting for a mutex causes the mutex holder to inherit a
   2054          		priority, but the waiting task times out, then the holder should
   2055          		disinherit the priority - but only down to the highest priority of any
   2056          		other tasks that are waiting for the same mutex.  For this purpose,
   2057          		return the priority of the highest priority task that is waiting for the
   2058          		mutex. */
   2059          		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
   \                     prvGetDisinheritPriorityAfterTimeout: (+1)
   \        0x0   0x6A41             LDR      R1,[R0, #+36]
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD004             BEQ.N    ??prvGetDisinheritPriorityAfterTimeout_0
   2060          		{
   2061          			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
   \        0x6   0x6B00             LDR      R0,[R0, #+48]
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0xF1D0 0x0038      RSBS     R0,R0,#+56
   \        0xE   0xE000             B.N      ??prvGetDisinheritPriorityAfterTimeout_1
   2062          		}
   2063          		else
   2064          		{
   2065          			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
   \                     ??prvGetDisinheritPriorityAfterTimeout_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   2066          		}
   2067          
   2068          		return uxHighestPriorityOfWaitingTasks;
   \                     ??prvGetDisinheritPriorityAfterTimeout_1: (+1)
   \       0x12   0x4770             BX       LR
   2069          	}
   2070          
   2071          #endif /* configUSE_MUTEXES */
   2072          /*-----------------------------------------------------------*/
   2073          

   \                                 In section .text, align 2, keep-with-next
   2074          static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
   2075          {
   \                     prvCopyDataToQueue: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x0015             MOVS     R5,R2
   2076          BaseType_t xReturn = pdFALSE;
   \        0x8   0x2700             MOVS     R7,#+0
   2077          UBaseType_t uxMessagesWaiting;
   2078          
   2079          	/* This function is called from a critical section. */
   2080          
   2081          	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   \        0xA   0x6BB4             LDR      R4,[R6, #+56]
   2082          
   2083          	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   \        0xC   0x6C30             LDR      R0,[R6, #+64]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD109             BNE.N    ??prvCopyDataToQueue_0
   2084          	{
   2085          		#if ( configUSE_MUTEXES == 1 )
   2086          		{
   2087          			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   \       0x12   0x6830             LDR      R0,[R6, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD131             BNE.N    ??prvCopyDataToQueue_1
   2088          			{
   2089          				/* The mutex is no longer being held. */
   2090          				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
   \       0x18   0x68B0             LDR      R0,[R6, #+8]
   \       0x1A   0x.... 0x....      BL       xTaskPriorityDisinherit
   \       0x1E   0x0007             MOVS     R7,R0
   2091          				pxQueue->u.xSemaphore.xMutexHolder = NULL;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x60B0             STR      R0,[R6, #+8]
   \       0x24   0xE02A             B.N      ??prvCopyDataToQueue_1
   2092          			}
   2093          			else
   2094          			{
   2095          				mtCOVERAGE_TEST_MARKER();
   2096          			}
   2097          		}
   2098          		#endif /* configUSE_MUTEXES */
   2099          	}
   2100          	else if( xPosition == queueSEND_TO_BACK )
   \                     ??prvCopyDataToQueue_0: (+1)
   \       0x26   0x2D00             CMP      R5,#+0
   \       0x28   0xD10F             BNE.N    ??prvCopyDataToQueue_2
   2101          	{
   2102          		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
   \       0x2A   0x6C32             LDR      R2,[R6, #+64]
   \       0x2C   0x6875             LDR      R5,[R6, #+4]
   \       0x2E   0x0028             MOVS     R0,R5
   \       0x30   0x.... 0x....      BL       __aeabi_memcpy
   2103          		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
   \       0x34   0x6870             LDR      R0,[R6, #+4]
   \       0x36   0x6C31             LDR      R1,[R6, #+64]
   \       0x38   0x4408             ADD      R0,R0,R1
   \       0x3A   0x6070             STR      R0,[R6, #+4]
   2104          		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   \       0x3C   0x6870             LDR      R0,[R6, #+4]
   \       0x3E   0x68B1             LDR      R1,[R6, #+8]
   \       0x40   0x4288             CMP      R0,R1
   \       0x42   0xD31B             BCC.N    ??prvCopyDataToQueue_1
   2105          		{
   2106          			pxQueue->pcWriteTo = pxQueue->pcHead;
   \       0x44   0x6830             LDR      R0,[R6, #+0]
   \       0x46   0x6070             STR      R0,[R6, #+4]
   \       0x48   0xE018             B.N      ??prvCopyDataToQueue_1
   2107          		}
   2108          		else
   2109          		{
   2110          			mtCOVERAGE_TEST_MARKER();
   2111          		}
   2112          	}
   2113          	else
   2114          	{
   2115          		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
   \                     ??prvCopyDataToQueue_2: (+1)
   \       0x4A   0x6C32             LDR      R2,[R6, #+64]
   \       0x4C   0xF8D6 0x800C      LDR      R8,[R6, #+12]
   \       0x50   0x4640             MOV      R0,R8
   \       0x52   0x.... 0x....      BL       __aeabi_memcpy
   2116          		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
   \       0x56   0x68F0             LDR      R0,[R6, #+12]
   \       0x58   0x6C31             LDR      R1,[R6, #+64]
   \       0x5A   0x4249             RSBS     R1,R1,#+0
   \       0x5C   0x4408             ADD      R0,R0,R1
   \       0x5E   0x60F0             STR      R0,[R6, #+12]
   2117          		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   \       0x60   0x68F0             LDR      R0,[R6, #+12]
   \       0x62   0x6831             LDR      R1,[R6, #+0]
   \       0x64   0x4288             CMP      R0,R1
   \       0x66   0xD204             BCS.N    ??prvCopyDataToQueue_3
   2118          		{
   2119          			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
   \       0x68   0x68B0             LDR      R0,[R6, #+8]
   \       0x6A   0x6C31             LDR      R1,[R6, #+64]
   \       0x6C   0x4249             RSBS     R1,R1,#+0
   \       0x6E   0x4408             ADD      R0,R0,R1
   \       0x70   0x60F0             STR      R0,[R6, #+12]
   2120          		}
   2121          		else
   2122          		{
   2123          			mtCOVERAGE_TEST_MARKER();
   2124          		}
   2125          
   2126          		if( xPosition == queueOVERWRITE )
   \                     ??prvCopyDataToQueue_3: (+1)
   \       0x72   0x2D02             CMP      R5,#+2
   \       0x74   0xD102             BNE.N    ??prvCopyDataToQueue_1
   2127          		{
   2128          			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   \       0x76   0x2C00             CMP      R4,#+0
   \       0x78   0xD000             BEQ.N    ??prvCopyDataToQueue_1
   2129          			{
   2130          				/* An item is not being added but overwritten, so subtract
   2131          				one from the recorded number of items in the queue so when
   2132          				one is added again below the number of recorded items remains
   2133          				correct. */
   2134          				--uxMessagesWaiting;
   \       0x7A   0x1E64             SUBS     R4,R4,#+1
   2135          			}
   2136          			else
   2137          			{
   2138          				mtCOVERAGE_TEST_MARKER();
   2139          			}
   2140          		}
   2141          		else
   2142          		{
   2143          			mtCOVERAGE_TEST_MARKER();
   2144          		}
   2145          	}
   2146          
   2147          	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   \                     ??prvCopyDataToQueue_1: (+1)
   \       0x7C   0x1C64             ADDS     R4,R4,#+1
   \       0x7E   0x63B4             STR      R4,[R6, #+56]
   2148          
   2149          	return xReturn;
   \       0x80   0x0038             MOVS     R0,R7
   \       0x82   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2150          }
   2151          /*-----------------------------------------------------------*/
   2152          

   \                                 In section .text, align 2, keep-with-next
   2153          static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
   2154          {
   \                     prvCopyDataFromQueue: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x000C             MOVS     R4,R1
   2155          	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
   \        0x4   0x6C01             LDR      R1,[R0, #+64]
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD00E             BEQ.N    ??prvCopyDataFromQueue_0
   2156          	{
   2157          		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
   \        0xA   0x68C1             LDR      R1,[R0, #+12]
   \        0xC   0x6C02             LDR      R2,[R0, #+64]
   \        0xE   0x4411             ADD      R1,R1,R2
   \       0x10   0x60C1             STR      R1,[R0, #+12]
   2158          		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   \       0x12   0x68C1             LDR      R1,[R0, #+12]
   \       0x14   0x6882             LDR      R2,[R0, #+8]
   \       0x16   0x4291             CMP      R1,R2
   \       0x18   0xD301             BCC.N    ??prvCopyDataFromQueue_1
   2159          		{
   2160          			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
   \       0x1A   0x6801             LDR      R1,[R0, #+0]
   \       0x1C   0x60C1             STR      R1,[R0, #+12]
   2161          		}
   2162          		else
   2163          		{
   2164          			mtCOVERAGE_TEST_MARKER();
   2165          		}
   2166          		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
   \                     ??prvCopyDataFromQueue_1: (+1)
   \       0x1E   0x6C02             LDR      R2,[R0, #+64]
   \       0x20   0x68C1             LDR      R1,[R0, #+12]
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       __aeabi_memcpy
   2167          	}
   2168          }
   \                     ??prvCopyDataFromQueue_0: (+1)
   \       0x28   0xBD10             POP      {R4,PC}
   2169          /*-----------------------------------------------------------*/
   2170          

   \                                 In section .text, align 2, keep-with-next
   2171          static void prvUnlockQueue( Queue_t * const pxQueue )
   2172          {
   \                     prvUnlockQueue: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2173          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
   2174          
   2175          	/* The lock counts contains the number of extra data items placed or
   2176          	removed from the queue while the queue was locked.  When a queue is
   2177          	locked items can be added or removed, but the event lists cannot be
   2178          	updated. */
   2179          	taskENTER_CRITICAL();
   \        0x4   0x.... 0x....      BL       vPortEnterCritical
   2180          	{
   2181          		int8_t cTxLock = pxQueue->cTxLock;
   \        0x8   0xF994 0x5045      LDRSB    R5,[R4, #+69]
   \        0xC   0xE008             B.N      ??prvUnlockQueue_0
   2182          
   2183          		/* See if data was added to the queue while it was locked. */
   2184          		while( cTxLock > queueLOCKED_UNMODIFIED )
   2185          		{
   2186          			/* Data was posted while the queue was locked.  Are any tasks
   2187          			blocked waiting for data to become available? */
   2188          			#if ( configUSE_QUEUE_SETS == 1 )
   2189          			{
   2190          				if( pxQueue->pxQueueSetContainer != NULL )
   2191          				{
   2192          					if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
   2193          					{
   2194          						/* The queue is a member of a queue set, and posting to
   2195          						the queue set caused a higher priority task to unblock.
   2196          						A context switch is required. */
   2197          						vTaskMissedYield();
   2198          					}
   2199          					else
   2200          					{
   2201          						mtCOVERAGE_TEST_MARKER();
   2202          					}
   2203          				}
   2204          				else
   2205          				{
   2206          					/* Tasks that are removed from the event list will get
   2207          					added to the pending ready list as the scheduler is still
   2208          					suspended. */
   2209          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2210          					{
   2211          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   2212          						{
   2213          							/* The task waiting has a higher priority so record that a
   2214          							context	switch is required. */
   2215          							vTaskMissedYield();
   2216          						}
   2217          						else
   2218          						{
   2219          							mtCOVERAGE_TEST_MARKER();
   2220          						}
   2221          					}
   2222          					else
   2223          					{
   2224          						break;
   2225          					}
   2226          				}
   2227          			}
   2228          			#else /* configUSE_QUEUE_SETS */
   2229          			{
   2230          				/* Tasks that are removed from the event list will get added to
   2231          				the pending ready list as the scheduler is still suspended. */
   2232          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2233          				{
   2234          					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   \                     ??prvUnlockQueue_1: (+1)
   \        0xE   0xF114 0x0024      ADDS     R0,R4,#+36
   \       0x12   0x.... 0x....      BL       xTaskRemoveFromEventList
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ.N    ??prvUnlockQueue_2
   2235          					{
   2236          						/* The task waiting has a higher priority so record that
   2237          						a context switch is required. */
   2238          						vTaskMissedYield();
   \       0x1A   0x.... 0x....      BL       vTaskMissedYield
   2239          					}
   2240          					else
   2241          					{
   2242          						mtCOVERAGE_TEST_MARKER();
   2243          					}
   2244          				}
   2245          				else
   2246          				{
   2247          					break;
   2248          				}
   2249          			}
   2250          			#endif /* configUSE_QUEUE_SETS */
   2251          
   2252          			--cTxLock;
   \                     ??prvUnlockQueue_2: (+1)
   \       0x1E   0x1E6D             SUBS     R5,R5,#+1
   \                     ??prvUnlockQueue_0: (+1)
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0xB240             SXTB     R0,R0
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xDB02             BLT.N    ??prvUnlockQueue_3
   \       0x28   0x6A60             LDR      R0,[R4, #+36]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD1EF             BNE.N    ??prvUnlockQueue_1
   2253          		}
   2254          
   2255          		pxQueue->cTxLock = queueUNLOCKED;
   \                     ??prvUnlockQueue_3: (+1)
   \       0x2E   0xF05F 0x35FF      MOVS     R5,#+4294967295
   \       0x32   0xF884 0x5045      STRB     R5,[R4, #+69]
   2256          	}
   2257          	taskEXIT_CRITICAL();
   \       0x36   0x.... 0x....      BL       vPortExitCritical
   2258          
   2259          	/* Do the same for the Rx lock. */
   2260          	taskENTER_CRITICAL();
   \       0x3A   0x.... 0x....      BL       vPortEnterCritical
   2261          	{
   2262          		int8_t cRxLock = pxQueue->cRxLock;
   \       0x3E   0xF994 0x6044      LDRSB    R6,[R4, #+68]
   \       0x42   0xE008             B.N      ??prvUnlockQueue_4
   2263          
   2264          		while( cRxLock > queueLOCKED_UNMODIFIED )
   2265          		{
   2266          			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   2267          			{
   2268          				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   \                     ??prvUnlockQueue_5: (+1)
   \       0x44   0xF114 0x0010      ADDS     R0,R4,#+16
   \       0x48   0x.... 0x....      BL       xTaskRemoveFromEventList
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD001             BEQ.N    ??prvUnlockQueue_6
   2269          				{
   2270          					vTaskMissedYield();
   \       0x50   0x.... 0x....      BL       vTaskMissedYield
   2271          				}
   2272          				else
   2273          				{
   2274          					mtCOVERAGE_TEST_MARKER();
   2275          				}
   2276          
   2277          				--cRxLock;
   \                     ??prvUnlockQueue_6: (+1)
   \       0x54   0x1E76             SUBS     R6,R6,#+1
   2278          			}
   \                     ??prvUnlockQueue_4: (+1)
   \       0x56   0x0030             MOVS     R0,R6
   \       0x58   0xB240             SXTB     R0,R0
   \       0x5A   0x2801             CMP      R0,#+1
   \       0x5C   0xDB02             BLT.N    ??prvUnlockQueue_7
   \       0x5E   0x6920             LDR      R0,[R4, #+16]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD1EF             BNE.N    ??prvUnlockQueue_5
   2279          			else
   2280          			{
   2281          				break;
   2282          			}
   2283          		}
   2284          
   2285          		pxQueue->cRxLock = queueUNLOCKED;
   \                     ??prvUnlockQueue_7: (+1)
   \       0x64   0xF884 0x5044      STRB     R5,[R4, #+68]
   2286          	}
   2287          	taskEXIT_CRITICAL();
   \       0x68   0x.... 0x....      BL       vPortExitCritical
   2288          }
   \       0x6C   0xBD70             POP      {R4-R6,PC}
   2289          /*-----------------------------------------------------------*/
   2290          

   \                                 In section .text, align 2, keep-with-next
   2291          static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
   2292          {
   \                     prvIsQueueEmpty: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2293          BaseType_t xReturn;
   2294          
   2295          	taskENTER_CRITICAL();
   \        0x4   0x.... 0x....      BL       vPortEnterCritical
   2296          	{
   2297          		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   \        0x8   0x6BA0             LDR      R0,[R4, #+56]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD101             BNE.N    ??prvIsQueueEmpty_0
   2298          		{
   2299          			xReturn = pdTRUE;
   \        0xE   0x2401             MOVS     R4,#+1
   \       0x10   0xE000             B.N      ??prvIsQueueEmpty_1
   2300          		}
   2301          		else
   2302          		{
   2303          			xReturn = pdFALSE;
   \                     ??prvIsQueueEmpty_0: (+1)
   \       0x12   0x2400             MOVS     R4,#+0
   2304          		}
   2305          	}
   2306          	taskEXIT_CRITICAL();
   \                     ??prvIsQueueEmpty_1: (+1)
   \       0x14   0x.... 0x....      BL       vPortExitCritical
   2307          
   2308          	return xReturn;
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0xBD10             POP      {R4,PC}
   2309          }
   2310          /*-----------------------------------------------------------*/
   2311          

   \                                 In section .text, align 2, keep-with-next
   2312          BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
   2313          {
   2314          BaseType_t xReturn;
   2315          Queue_t * const pxQueue = xQueue;
   2316          
   2317          	configASSERT( pxQueue );
   \                     xQueueIsQueueEmptyFromISR: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD107             BNE.N    ??xQueueIsQueueEmptyFromISR_0
   \        0x4   0x2050             MOVS     R0,#+80
   \        0x6   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueIsQueueEmptyFromISR_1: (+1)
   \       0x12   0xE7FE             B.N      ??xQueueIsQueueEmptyFromISR_1
   2318          	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
   \                     ??xQueueIsQueueEmptyFromISR_0: (+1)
   \       0x14   0x6B80             LDR      R0,[R0, #+56]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??xQueueIsQueueEmptyFromISR_2
   2319          	{
   2320          		xReturn = pdTRUE;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE000             B.N      ??xQueueIsQueueEmptyFromISR_3
   2321          	}
   2322          	else
   2323          	{
   2324          		xReturn = pdFALSE;
   \                     ??xQueueIsQueueEmptyFromISR_2: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   2325          	}
   2326          
   2327          	return xReturn;
   \                     ??xQueueIsQueueEmptyFromISR_3: (+1)
   \       0x20   0x4770             BX       LR
   2328          } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   2329          /*-----------------------------------------------------------*/
   2330          

   \                                 In section .text, align 2, keep-with-next
   2331          static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
   2332          {
   \                     prvIsQueueFull: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2333          BaseType_t xReturn;
   2334          
   2335          	taskENTER_CRITICAL();
   \        0x4   0x.... 0x....      BL       vPortEnterCritical
   2336          	{
   2337          		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   \        0x8   0x6BA0             LDR      R0,[R4, #+56]
   \        0xA   0x6BE1             LDR      R1,[R4, #+60]
   \        0xC   0x4288             CMP      R0,R1
   \        0xE   0xD101             BNE.N    ??prvIsQueueFull_0
   2338          		{
   2339          			xReturn = pdTRUE;
   \       0x10   0x2401             MOVS     R4,#+1
   \       0x12   0xE000             B.N      ??prvIsQueueFull_1
   2340          		}
   2341          		else
   2342          		{
   2343          			xReturn = pdFALSE;
   \                     ??prvIsQueueFull_0: (+1)
   \       0x14   0x2400             MOVS     R4,#+0
   2344          		}
   2345          	}
   2346          	taskEXIT_CRITICAL();
   \                     ??prvIsQueueFull_1: (+1)
   \       0x16   0x.... 0x....      BL       vPortExitCritical
   2347          
   2348          	return xReturn;
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0xBD10             POP      {R4,PC}
   2349          }
   2350          /*-----------------------------------------------------------*/
   2351          

   \                                 In section .text, align 2, keep-with-next
   2352          BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
   2353          {
   2354          BaseType_t xReturn;
   2355          Queue_t * const pxQueue = xQueue;
   2356          
   2357          	configASSERT( pxQueue );
   \                     xQueueIsQueueFullFromISR: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD107             BNE.N    ??xQueueIsQueueFullFromISR_0
   \        0x4   0x2050             MOVS     R0,#+80
   \        0x6   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
   \                     ??xQueueIsQueueFullFromISR_1: (+1)
   \       0x12   0xE7FE             B.N      ??xQueueIsQueueFullFromISR_1
   2358          	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   \                     ??xQueueIsQueueFullFromISR_0: (+1)
   \       0x14   0x6B81             LDR      R1,[R0, #+56]
   \       0x16   0x6BC0             LDR      R0,[R0, #+60]
   \       0x18   0x4281             CMP      R1,R0
   \       0x1A   0xD101             BNE.N    ??xQueueIsQueueFullFromISR_2
   2359          	{
   2360          		xReturn = pdTRUE;
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE000             B.N      ??xQueueIsQueueFullFromISR_3
   2361          	}
   2362          	else
   2363          	{
   2364          		xReturn = pdFALSE;
   \                     ??xQueueIsQueueFullFromISR_2: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   2365          	}
   2366          
   2367          	return xReturn;
   \                     ??xQueueIsQueueFullFromISR_3: (+1)
   \       0x22   0x4770             BX       LR
   2368          } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   2369          /*-----------------------------------------------------------*/
   2370          
   2371          #if ( configUSE_CO_ROUTINES == 1 )
   2372          
   2373          	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
   2374          	{
   2375          	BaseType_t xReturn;
   2376          	Queue_t * const pxQueue = xQueue;
   2377          
   2378          		/* If the queue is already full we may have to block.  A critical section
   2379          		is required to prevent an interrupt removing something from the queue
   2380          		between the check to see if the queue is full and blocking on the queue. */
   2381          		portDISABLE_INTERRUPTS();
   2382          		{
   2383          			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   2384          			{
   2385          				/* The queue is full - do we want to block or just leave without
   2386          				posting? */
   2387          				if( xTicksToWait > ( TickType_t ) 0 )
   2388          				{
   2389          					/* As this is called from a coroutine we cannot block directly, but
   2390          					return indicating that we need to block. */
   2391          					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
   2392          					portENABLE_INTERRUPTS();
   2393          					return errQUEUE_BLOCKED;
   2394          				}
   2395          				else
   2396          				{
   2397          					portENABLE_INTERRUPTS();
   2398          					return errQUEUE_FULL;
   2399          				}
   2400          			}
   2401          		}
   2402          		portENABLE_INTERRUPTS();
   2403          
   2404          		portDISABLE_INTERRUPTS();
   2405          		{
   2406          			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   2407          			{
   2408          				/* There is room in the queue, copy the data into the queue. */
   2409          				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
   2410          				xReturn = pdPASS;
   2411          
   2412          				/* Were any co-routines waiting for data to become available? */
   2413          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2414          				{
   2415          					/* In this instance the co-routine could be placed directly
   2416          					into the ready list as we are within a critical section.
   2417          					Instead the same pending ready list mechanism is used as if
   2418          					the event were caused from within an interrupt. */
   2419          					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   2420          					{
   2421          						/* The co-routine waiting has a higher priority so record
   2422          						that a yield might be appropriate. */
   2423          						xReturn = errQUEUE_YIELD;
   2424          					}
   2425          					else
   2426          					{
   2427          						mtCOVERAGE_TEST_MARKER();
   2428          					}
   2429          				}
   2430          				else
   2431          				{
   2432          					mtCOVERAGE_TEST_MARKER();
   2433          				}
   2434          			}
   2435          			else
   2436          			{
   2437          				xReturn = errQUEUE_FULL;
   2438          			}
   2439          		}
   2440          		portENABLE_INTERRUPTS();
   2441          
   2442          		return xReturn;
   2443          	}
   2444          
   2445          #endif /* configUSE_CO_ROUTINES */
   2446          /*-----------------------------------------------------------*/
   2447          
   2448          #if ( configUSE_CO_ROUTINES == 1 )
   2449          
   2450          	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
   2451          	{
   2452          	BaseType_t xReturn;
   2453          	Queue_t * const pxQueue = xQueue;
   2454          
   2455          		/* If the queue is already empty we may have to block.  A critical section
   2456          		is required to prevent an interrupt adding something to the queue
   2457          		between the check to see if the queue is empty and blocking on the queue. */
   2458          		portDISABLE_INTERRUPTS();
   2459          		{
   2460          			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
   2461          			{
   2462          				/* There are no messages in the queue, do we want to block or just
   2463          				leave with nothing? */
   2464          				if( xTicksToWait > ( TickType_t ) 0 )
   2465          				{
   2466          					/* As this is a co-routine we cannot block directly, but return
   2467          					indicating that we need to block. */
   2468          					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
   2469          					portENABLE_INTERRUPTS();
   2470          					return errQUEUE_BLOCKED;
   2471          				}
   2472          				else
   2473          				{
   2474          					portENABLE_INTERRUPTS();
   2475          					return errQUEUE_FULL;
   2476          				}
   2477          			}
   2478          			else
   2479          			{
   2480          				mtCOVERAGE_TEST_MARKER();
   2481          			}
   2482          		}
   2483          		portENABLE_INTERRUPTS();
   2484          
   2485          		portDISABLE_INTERRUPTS();
   2486          		{
   2487          			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   2488          			{
   2489          				/* Data is available from the queue. */
   2490          				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
   2491          				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
   2492          				{
   2493          					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
   2494          				}
   2495          				else
   2496          				{
   2497          					mtCOVERAGE_TEST_MARKER();
   2498          				}
   2499          				--( pxQueue->uxMessagesWaiting );
   2500          				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
   2501          
   2502          				xReturn = pdPASS;
   2503          
   2504          				/* Were any co-routines waiting for space to become available? */
   2505          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   2506          				{
   2507          					/* In this instance the co-routine could be placed directly
   2508          					into the ready list as we are within a critical section.
   2509          					Instead the same pending ready list mechanism is used as if
   2510          					the event were caused from within an interrupt. */
   2511          					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   2512          					{
   2513          						xReturn = errQUEUE_YIELD;
   2514          					}
   2515          					else
   2516          					{
   2517          						mtCOVERAGE_TEST_MARKER();
   2518          					}
   2519          				}
   2520          				else
   2521          				{
   2522          					mtCOVERAGE_TEST_MARKER();
   2523          				}
   2524          			}
   2525          			else
   2526          			{
   2527          				xReturn = pdFAIL;
   2528          			}
   2529          		}
   2530          		portENABLE_INTERRUPTS();
   2531          
   2532          		return xReturn;
   2533          	}
   2534          
   2535          #endif /* configUSE_CO_ROUTINES */
   2536          /*-----------------------------------------------------------*/
   2537          
   2538          #if ( configUSE_CO_ROUTINES == 1 )
   2539          
   2540          	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
   2541          	{
   2542          	Queue_t * const pxQueue = xQueue;
   2543          
   2544          		/* Cannot block within an ISR so if there is no space on the queue then
   2545          		exit without doing anything. */
   2546          		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   2547          		{
   2548          			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
   2549          
   2550          			/* We only want to wake one co-routine per ISR, so check that a
   2551          			co-routine has not already been woken. */
   2552          			if( xCoRoutinePreviouslyWoken == pdFALSE )
   2553          			{
   2554          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2555          				{
   2556          					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   2557          					{
   2558          						return pdTRUE;
   2559          					}
   2560          					else
   2561          					{
   2562          						mtCOVERAGE_TEST_MARKER();
   2563          					}
   2564          				}
   2565          				else
   2566          				{
   2567          					mtCOVERAGE_TEST_MARKER();
   2568          				}
   2569          			}
   2570          			else
   2571          			{
   2572          				mtCOVERAGE_TEST_MARKER();
   2573          			}
   2574          		}
   2575          		else
   2576          		{
   2577          			mtCOVERAGE_TEST_MARKER();
   2578          		}
   2579          
   2580          		return xCoRoutinePreviouslyWoken;
   2581          	}
   2582          
   2583          #endif /* configUSE_CO_ROUTINES */
   2584          /*-----------------------------------------------------------*/
   2585          
   2586          #if ( configUSE_CO_ROUTINES == 1 )
   2587          
   2588          	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
   2589          	{
   2590          	BaseType_t xReturn;
   2591          	Queue_t * const pxQueue = xQueue;
   2592          
   2593          		/* We cannot block from an ISR, so check there is data available. If
   2594          		not then just leave without doing anything. */
   2595          		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   2596          		{
   2597          			/* Copy the data from the queue. */
   2598          			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
   2599          			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
   2600          			{
   2601          				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
   2602          			}
   2603          			else
   2604          			{
   2605          				mtCOVERAGE_TEST_MARKER();
   2606          			}
   2607          			--( pxQueue->uxMessagesWaiting );
   2608          			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
   2609          
   2610          			if( ( *pxCoRoutineWoken ) == pdFALSE )
   2611          			{
   2612          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   2613          				{
   2614          					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   2615          					{
   2616          						*pxCoRoutineWoken = pdTRUE;
   2617          					}
   2618          					else
   2619          					{
   2620          						mtCOVERAGE_TEST_MARKER();
   2621          					}
   2622          				}
   2623          				else
   2624          				{
   2625          					mtCOVERAGE_TEST_MARKER();
   2626          				}
   2627          			}
   2628          			else
   2629          			{
   2630          				mtCOVERAGE_TEST_MARKER();
   2631          			}
   2632          
   2633          			xReturn = pdPASS;
   2634          		}
   2635          		else
   2636          		{
   2637          			xReturn = pdFAIL;
   2638          		}
   2639          
   2640          		return xReturn;
   2641          	}
   2642          
   2643          #endif /* configUSE_CO_ROUTINES */
   2644          /*-----------------------------------------------------------*/
   2645          
   2646          #if ( configQUEUE_REGISTRY_SIZE > 0 )
   2647          

   \                                 In section .text, align 2, keep-with-next
   2648          	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2649          	{
   \                     vQueueAddToRegistry: (+1)
   \        0x0   0xB410             PUSH     {R4}
   2650          	UBaseType_t ux;
   2651          
   2652          		/* See if there is an empty space in the registry.  A NULL name denotes
   2653          		a free slot. */
   2654          		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0xE000             B.N      ??vQueueAddToRegistry_0
   \                     ??vQueueAddToRegistry_1: (+1)
   \        0x6   0x1C5B             ADDS     R3,R3,#+1
   \                     ??vQueueAddToRegistry_0: (+1)
   \        0x8   0x2B08             CMP      R3,#+8
   \        0xA   0xD209             BCS.N    ??vQueueAddToRegistry_2
   2655          		{
   2656          			if( xQueueRegistry[ ux ].pcQueueName == NULL )
   \        0xC   0x....             LDR.N    R4,??DataTable7
   \        0xE   0xF854 0x2033      LDR      R2,[R4, R3, LSL #+3]
   \       0x12   0x2A00             CMP      R2,#+0
   \       0x14   0xD1F7             BNE.N    ??vQueueAddToRegistry_1
   2657          			{
   2658          				/* Store the information on this queue. */
   2659          				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
   \       0x16   0xF844 0x1033      STR      R1,[R4, R3, LSL #+3]
   2660          				xQueueRegistry[ ux ].xHandle = xQueue;
   \       0x1A   0xEB04 0x01C3      ADD      R1,R4,R3, LSL #+3
   \       0x1E   0x6048             STR      R0,[R1, #+4]
   2661          
   2662          				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
   2663          				break;
   2664          			}
   2665          			else
   2666          			{
   2667          				mtCOVERAGE_TEST_MARKER();
   2668          			}
   2669          		}
   2670          	}
   \                     ??vQueueAddToRegistry_2: (+1)
   \       0x20   0xBC10             POP      {R4}
   \       0x22   0x4770             BX       LR
   2671          
   2672          #endif /* configQUEUE_REGISTRY_SIZE */
   2673          /*-----------------------------------------------------------*/
   2674          
   2675          #if ( configQUEUE_REGISTRY_SIZE > 0 )
   2676          

   \                                 In section .text, align 2, keep-with-next
   2677          	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2678          	{
   \                     pcQueueGetName: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0001             MOVS     R1,R0
   2679          	UBaseType_t ux;
   2680          	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   \        0x4   0x2000             MOVS     R0,#+0
   2681          
   2682          		/* Note there is nothing here to protect against another task adding or
   2683          		removing entries from the registry while it is being searched. */
   2684          		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0xE000             B.N      ??pcQueueGetName_0
   \                     ??pcQueueGetName_1: (+1)
   \        0xA   0x1C52             ADDS     R2,R2,#+1
   \                     ??pcQueueGetName_0: (+1)
   \        0xC   0x2A08             CMP      R2,#+8
   \        0xE   0xD207             BCS.N    ??pcQueueGetName_2
   2685          		{
   2686          			if( xQueueRegistry[ ux ].xHandle == xQueue )
   \       0x10   0x....             LDR.N    R3,??DataTable7
   \       0x12   0xEB03 0x04C2      ADD      R4,R3,R2, LSL #+3
   \       0x16   0x6864             LDR      R4,[R4, #+4]
   \       0x18   0x428C             CMP      R4,R1
   \       0x1A   0xD1F6             BNE.N    ??pcQueueGetName_1
   2687          			{
   2688          				pcReturn = xQueueRegistry[ ux ].pcQueueName;
   \       0x1C   0xF853 0x0032      LDR      R0,[R3, R2, LSL #+3]
   2689          				break;
   2690          			}
   2691          			else
   2692          			{
   2693          				mtCOVERAGE_TEST_MARKER();
   2694          			}
   2695          		}
   2696          
   2697          		return pcReturn;
   \                     ??pcQueueGetName_2: (+1)
   \       0x20   0xBC10             POP      {R4}
   \       0x22   0x4770             BX       LR
   2698          	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
   2699          
   2700          #endif /* configQUEUE_REGISTRY_SIZE */
   2701          /*-----------------------------------------------------------*/
   2702          
   2703          #if ( configQUEUE_REGISTRY_SIZE > 0 )
   2704          

   \                                 In section .text, align 2, keep-with-next
   2705          	void vQueueUnregisterQueue( QueueHandle_t xQueue )
   2706          	{
   2707          	UBaseType_t ux;
   2708          
   2709          		/* See if the handle of the queue being unregistered in actually in the
   2710          		registry. */
   2711          		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
   \                     vQueueUnregisterQueue: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0xE000             B.N      ??vQueueUnregisterQueue_0
   \                     ??vQueueUnregisterQueue_1: (+1)
   \        0x4   0x1C49             ADDS     R1,R1,#+1
   \                     ??vQueueUnregisterQueue_0: (+1)
   \        0x6   0x2908             CMP      R1,#+8
   \        0x8   0xD20C             BCS.N    ??vQueueUnregisterQueue_2
   2712          		{
   2713          			if( xQueueRegistry[ ux ].xHandle == xQueue )
   \        0xA   0x....             LDR.N    R2,??DataTable7
   \        0xC   0xEB02 0x03C1      ADD      R3,R2,R1, LSL #+3
   \       0x10   0x685B             LDR      R3,[R3, #+4]
   \       0x12   0x4283             CMP      R3,R0
   \       0x14   0xD1F6             BNE.N    ??vQueueUnregisterQueue_1
   2714          			{
   2715          				/* Set the name to NULL to show that this slot if free again. */
   2716          				xQueueRegistry[ ux ].pcQueueName = NULL;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xF842 0x0031      STR      R0,[R2, R1, LSL #+3]
   2717          
   2718          				/* Set the handle to NULL to ensure the same queue handle cannot
   2719          				appear in the registry twice if it is added, removed, then
   2720          				added again. */
   2721          				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xEB02 0x01C1      ADD      R1,R2,R1, LSL #+3
   \       0x22   0x6048             STR      R0,[R1, #+4]
   2722          				break;
   2723          			}
   2724          			else
   2725          			{
   2726          				mtCOVERAGE_TEST_MARKER();
   2727          			}
   2728          		}
   2729          
   2730          	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   \                     ??vQueueUnregisterQueue_2: (+1)
   \       0x24   0x4770             BX       LR
   2731          
   2732          #endif /* configQUEUE_REGISTRY_SIZE */
   2733          /*-----------------------------------------------------------*/
   2734          
   2735          #if ( configUSE_TIMERS == 1 )
   2736          

   \                                 In section .text, align 2, keep-with-next
   2737          	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
   2738          	{
   \                     vQueueWaitForMessageRestricted: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   2739          	Queue_t * const pxQueue = xQueue;
   2740          
   2741          		/* This function should not be called by application code hence the
   2742          		'Restricted' in its name.  It is not part of the public API.  It is
   2743          		designed for use by kernel code, and has special calling requirements.
   2744          		It can result in vListInsert() being called on a list that can only
   2745          		possibly ever have one item in it, so the list will be fast, but even
   2746          		so it should be called with the scheduler locked and not from a critical
   2747          		section. */
   2748          
   2749          		/* Only do anything if there are no messages in the queue.  This function
   2750          		will not actually cause the task to block, just place it on a blocked
   2751          		list.  It will not block until the scheduler is unlocked - at which
   2752          		time a yield will be performed.  If an item is added to the queue while
   2753          		the queue is locked, and the calling task blocks on the queue, then the
   2754          		calling task will be immediately unblocked when the queue is unlocked. */
   2755          		prvLockQueue( pxQueue );
   \        0x8   0x.... 0x....      BL       vPortEnterCritical
   \        0xC   0xF994 0x0044      LDRSB    R0,[R4, #+68]
   \       0x10   0xF110 0x0F01      CMN      R0,#+1
   \       0x14   0xD102             BNE.N    ??vQueueWaitForMessageRestricted_0
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xF884 0x0044      STRB     R0,[R4, #+68]
   \                     ??vQueueWaitForMessageRestricted_0: (+1)
   \       0x1C   0xF994 0x0045      LDRSB    R0,[R4, #+69]
   \       0x20   0xF110 0x0F01      CMN      R0,#+1
   \       0x24   0xD102             BNE.N    ??vQueueWaitForMessageRestricted_1
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xF884 0x0045      STRB     R0,[R4, #+69]
   \                     ??vQueueWaitForMessageRestricted_1: (+1)
   \       0x2C   0x.... 0x....      BL       vPortExitCritical
   2756          		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
   \       0x30   0x6BA0             LDR      R0,[R4, #+56]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD105             BNE.N    ??vQueueWaitForMessageRestricted_2
   2757          		{
   2758          			/* There is nothing in the queue, block for the specified period. */
   2759          			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
   \       0x36   0x0032             MOVS     R2,R6
   \       0x38   0x0029             MOVS     R1,R5
   \       0x3A   0xF114 0x0024      ADDS     R0,R4,#+36
   \       0x3E   0x.... 0x....      BL       vTaskPlaceOnEventListRestricted
   2760          		}
   2761          		else
   2762          		{
   2763          			mtCOVERAGE_TEST_MARKER();
   2764          		}
   2765          		prvUnlockQueue( pxQueue );
   \                     ??vQueueWaitForMessageRestricted_2: (+1)
   \       0x42   0x0020             MOVS     R0,R4
   \       0x44   0x.... 0x....      BL       prvUnlockQueue
   2766          	}
   \       0x48   0xBD70             POP      {R4-R6,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0xE000'ED04        DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x....'....        DC32     xQueueRegistry
   2767          
   2768          #endif /* configUSE_TIMERS */
   2769          /*-----------------------------------------------------------*/
   2770          
   2771          #if( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
   2772          
   2773          	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
   2774          	{
   2775          	QueueSetHandle_t pxQueue;
   2776          
   2777          		pxQueue = xQueueGenericCreate( uxEventQueueLength, ( UBaseType_t ) sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
   2778          
   2779          		return pxQueue;
   2780          	}
   2781          
   2782          #endif /* configUSE_QUEUE_SETS */
   2783          /*-----------------------------------------------------------*/
   2784          
   2785          #if ( configUSE_QUEUE_SETS == 1 )
   2786          
   2787          	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
   2788          	{
   2789          	BaseType_t xReturn;
   2790          
   2791          		taskENTER_CRITICAL();
   2792          		{
   2793          			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
   2794          			{
   2795          				/* Cannot add a queue/semaphore to more than one queue set. */
   2796          				xReturn = pdFAIL;
   2797          			}
   2798          			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
   2799          			{
   2800          				/* Cannot add a queue/semaphore to a queue set if there are already
   2801          				items in the queue/semaphore. */
   2802          				xReturn = pdFAIL;
   2803          			}
   2804          			else
   2805          			{
   2806          				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
   2807          				xReturn = pdPASS;
   2808          			}
   2809          		}
   2810          		taskEXIT_CRITICAL();
   2811          
   2812          		return xReturn;
   2813          	}
   2814          
   2815          #endif /* configUSE_QUEUE_SETS */
   2816          /*-----------------------------------------------------------*/
   2817          
   2818          #if ( configUSE_QUEUE_SETS == 1 )
   2819          
   2820          	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
   2821          	{
   2822          	BaseType_t xReturn;
   2823          	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
   2824          
   2825          		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
   2826          		{
   2827          			/* The queue was not a member of the set. */
   2828          			xReturn = pdFAIL;
   2829          		}
   2830          		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
   2831          		{
   2832          			/* It is dangerous to remove a queue from a set when the queue is
   2833          			not empty because the queue set will still hold pending events for
   2834          			the queue. */
   2835          			xReturn = pdFAIL;
   2836          		}
   2837          		else
   2838          		{
   2839          			taskENTER_CRITICAL();
   2840          			{
   2841          				/* The queue is no longer contained in the set. */
   2842          				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
   2843          			}
   2844          			taskEXIT_CRITICAL();
   2845          			xReturn = pdPASS;
   2846          		}
   2847          
   2848          		return xReturn;
   2849          	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
   2850          
   2851          #endif /* configUSE_QUEUE_SETS */
   2852          /*-----------------------------------------------------------*/
   2853          
   2854          #if ( configUSE_QUEUE_SETS == 1 )
   2855          
   2856          	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
   2857          	{
   2858          	QueueSetMemberHandle_t xReturn = NULL;
   2859          
   2860          		( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait ); /*lint !e961 Casting from one typedef to another is not redundant. */
   2861          		return xReturn;
   2862          	}
   2863          
   2864          #endif /* configUSE_QUEUE_SETS */
   2865          /*-----------------------------------------------------------*/
   2866          
   2867          #if ( configUSE_QUEUE_SETS == 1 )
   2868          
   2869          	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
   2870          	{
   2871          	QueueSetMemberHandle_t xReturn = NULL;
   2872          
   2873          		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
   2874          		return xReturn;
   2875          	}
   2876          
   2877          #endif /* configUSE_QUEUE_SETS */
   2878          /*-----------------------------------------------------------*/
   2879          
   2880          #if ( configUSE_QUEUE_SETS == 1 )
   2881          
   2882          	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )
   2883          	{
   2884          	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
   2885          	BaseType_t xReturn = pdFALSE;
   2886          
   2887          		/* This function must be called form a critical section. */
   2888          
   2889          		configASSERT( pxQueueSetContainer );
   2890          		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
   2891          
   2892          		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
   2893          		{
   2894          			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
   2895          
   2896          			traceQUEUE_SEND( pxQueueSetContainer );
   2897          
   2898          			/* The data copied is the handle of the queue that contains data. */
   2899          			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
   2900          
   2901          			if( cTxLock == queueUNLOCKED )
   2902          			{
   2903          				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
   2904          				{
   2905          					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
   2906          					{
   2907          						/* The task waiting has a higher priority. */
   2908          						xReturn = pdTRUE;
   2909          					}
   2910          					else
   2911          					{
   2912          						mtCOVERAGE_TEST_MARKER();
   2913          					}
   2914          				}
   2915          				else
   2916          				{
   2917          					mtCOVERAGE_TEST_MARKER();
   2918          				}
   2919          			}
   2920          			else
   2921          			{
   2922          				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
   2923          			}
   2924          		}
   2925          		else
   2926          		{
   2927          			mtCOVERAGE_TEST_MARKER();
   2928          		}
   2929          
   2930          		return xReturn;
   2931          	}
   2932          
   2933          #endif /* configUSE_QUEUE_SETS */
   2934          
   2935          
   2936          
   2937          
   2938          
   2939          
   2940          
   2941          
   2942          
   2943          
   2944          
   2945          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   pcQueueGetName
       8   prvCopyDataFromQueue
         8   -> __aeabi_memcpy
      24   prvCopyDataToQueue
        24   -> __aeabi_memcpy
        24   -> xTaskPriorityDisinherit
       0   prvGetDisinheritPriorityAfterTimeout
       8   prvInitialiseMutex
         8   -> xQueueGenericSend
      16   prvInitialiseNewQueue
        16   -> xQueueGenericReset
       8   prvIsQueueEmpty
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   prvIsQueueFull
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
      16   prvUnlockQueue
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vTaskMissedYield
        16   -> xTaskRemoveFromEventList
       0   ucQueueGetQueueType
       0   uxQueueGetQueueNumber
       8   uxQueueMessagesWaiting
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       0   uxQueueMessagesWaitingFromISR
       8   uxQueueSpacesAvailable
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       4   vQueueAddToRegistry
       8   vQueueDelete
         8   -> vPortFree
         8   -> vQueueUnregisterQueue
       0   vQueueSetQueueNumber
       0   vQueueUnregisterQueue
      16   vQueueWaitForMessageRestricted
        16   -> prvUnlockQueue
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vTaskPlaceOnEventListRestricted
       8   xQueueCreateCountingSemaphore
         8   -> xQueueGenericCreate
      16   xQueueCreateCountingSemaphoreStatic
        16   -> xQueueGenericCreateStatic
       8   xQueueCreateMutex
         8   -> prvInitialiseMutex
         8   -> xQueueGenericCreate
      16   xQueueCreateMutexStatic
        16   -> prvInitialiseMutex
        16   -> xQueueGenericCreateStatic
      24   xQueueGenericCreate
        24   -> prvInitialiseNewQueue
        24   -> pvPortMalloc
      16   xQueueGenericCreateStatic
        16   -> prvInitialiseNewQueue
      16   xQueueGenericReset
        16   -> vListInitialise
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> xTaskRemoveFromEventList
      32   xQueueGenericSend
        32   -> prvCopyDataToQueue
        32   -> prvIsQueueFull
        32   -> prvUnlockQueue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vTaskInternalSetTimeOutState
        32   -> vTaskPlaceOnEventList
        32   -> vTaskSuspendAll
        32   -> xTaskCheckForTimeOut
        32   -> xTaskGetSchedulerState
        32   -> xTaskRemoveFromEventList
        32   -> xTaskResumeAll
      32   xQueueGenericSendFromISR
        32   -> prvCopyDataToQueue
        32   -> vPortValidateInterruptPriority
        32   -> xTaskRemoveFromEventList
       8   xQueueGetMutexHolder
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       0   xQueueGetMutexHolderFromISR
      16   xQueueGiveFromISR
        16   -> vPortValidateInterruptPriority
        16   -> xTaskRemoveFromEventList
       8   xQueueGiveMutexRecursive
         8   -> xQueueGenericSend
         8   -> xTaskGetCurrentTaskHandle
       0   xQueueIsQueueEmptyFromISR
       0   xQueueIsQueueFullFromISR
      32   xQueuePeek
        32   -> prvCopyDataFromQueue
        32   -> prvIsQueueEmpty
        32   -> prvUnlockQueue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vTaskInternalSetTimeOutState
        32   -> vTaskPlaceOnEventList
        32   -> vTaskSuspendAll
        32   -> xTaskCheckForTimeOut
        32   -> xTaskGetSchedulerState
        32   -> xTaskRemoveFromEventList
        32   -> xTaskResumeAll
      24   xQueuePeekFromISR
        24   -> prvCopyDataFromQueue
        24   -> vPortValidateInterruptPriority
      32   xQueueReceive
        32   -> prvCopyDataFromQueue
        32   -> prvIsQueueEmpty
        32   -> prvUnlockQueue
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vTaskInternalSetTimeOutState
        32   -> vTaskPlaceOnEventList
        32   -> vTaskSuspendAll
        32   -> xTaskCheckForTimeOut
        32   -> xTaskGetSchedulerState
        32   -> xTaskRemoveFromEventList
        32   -> xTaskResumeAll
      32   xQueueReceiveFromISR
        32   -> prvCopyDataFromQueue
        32   -> vPortValidateInterruptPriority
        32   -> xTaskRemoveFromEventList
      32   xQueueSemaphoreTake
        32   -> prvGetDisinheritPriorityAfterTimeout
        32   -> prvIsQueueEmpty
        32   -> prvUnlockQueue
        32   -> pvTaskIncrementMutexHeldCount
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vTaskInternalSetTimeOutState
        32   -> vTaskPlaceOnEventList
        32   -> vTaskPriorityDisinheritAfterTimeout
        32   -> vTaskSuspendAll
        32   -> xTaskCheckForTimeOut
        32   -> xTaskGetSchedulerState
        32   -> xTaskPriorityInherit
        32   -> xTaskRemoveFromEventList
        32   -> xTaskResumeAll
      16   xQueueTakeMutexRecursive
        16   -> xQueueSemaphoreTake
        16   -> xTaskGetCurrentTaskHandle


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable7
      36  pcQueueGetName
      42  prvCopyDataFromQueue
     134  prvCopyDataToQueue
      20  prvGetDisinheritPriorityAfterTimeout
      30  prvInitialiseMutex
      34  prvInitialiseNewQueue
      28  prvIsQueueEmpty
      30  prvIsQueueFull
     110  prvUnlockQueue
       6  ucQueueGetQueueType
       4  uxQueueGetQueueNumber
      38  uxQueueMessagesWaiting
      24  uxQueueMessagesWaitingFromISR
      42  uxQueueSpacesAvailable
      36  vQueueAddToRegistry
      46  vQueueDelete
       4  vQueueSetQueueNumber
      38  vQueueUnregisterQueue
      74  vQueueWaitForMessageRestricted
      60  xQueueCreateCountingSemaphore
      66  xQueueCreateCountingSemaphoreStatic
      26  xQueueCreateMutex
      32  xQueueCreateMutexStatic
      74  xQueueGenericCreate
     168  xQueueGenericCreateStatic
     146  xQueueGenericReset
     406  xQueueGenericSend
     224  xQueueGenericSendFromISR
      28  xQueueGetMutexHolder
      34  xQueueGetMutexHolderFromISR
     184  xQueueGiveFromISR
      66  xQueueGiveMutexRecursive
      34  xQueueIsQueueEmptyFromISR
      36  xQueueIsQueueFullFromISR
     348  xQueuePeek
     138  xQueuePeekFromISR
     348  xQueueReceive
     174  xQueueReceiveFromISR
      64  xQueueRegistry
     406  xQueueSemaphoreTake
      66  xQueueTakeMutexRecursive

 
    64 bytes in section .bss
 3'848 bytes in section .text
 
 3'848 bytes of CODE memory
    64 bytes of DATA memory

Errors: none
Warnings: none
