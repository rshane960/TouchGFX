###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         05/Feb/2022  17:09:40
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\Middlewares\Third_Party\FreeRTOS\Source\stream_buffer.c
#        [UTF-8]
#    Command line      =
#        -f
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS\stream_buffer.o.rsp
#        (D:\99_Project\GitHub\TouchGFX\MyApplication\Middlewares\Third_Party\FreeRTOS\Source\stream_buffer.c
#        -D USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Middlewares\FreeRTOS
#        -lA
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Middlewares\FreeRTOS
#        -o
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Core/Inc\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/App\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS\stream_buffer.o.d
#    Locale            =  C
#    List file         =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Middlewares\FreeRTOS\stream_buffer.lst
#    Object file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Middlewares\FreeRTOS\stream_buffer.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\99_Project\GitHub\TouchGFX\MyApplication\Middlewares\Third_Party\FreeRTOS\Source\stream_buffer.c
      1          /*
      2           * FreeRTOS Kernel V10.3.1
      3           * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
      4           *
      5           * Permission is hereby granted, free of charge, to any person obtaining a copy of
      6           * this software and associated documentation files (the "Software"), to deal in
      7           * the Software without restriction, including without limitation the rights to
      8           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
      9           * the Software, and to permit persons to whom the Software is furnished to do so,
     10           * subject to the following conditions:
     11           *
     12           * The above copyright notice and this permission notice shall be included in all
     13           * copies or substantial portions of the Software.
     14           *
     15           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     16           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     17           * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     18           * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     19           * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     20           * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     21           *
     22           * http://www.FreeRTOS.org
     23           * http://aws.amazon.com/freertos
     24           *
     25           * 1 tab == 4 spaces!
     26           */
     27          
     28          /* Standard includes. */
     29          #include <stdint.h>
     30          #include <string.h>
     31          
     32          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     33          all the API functions to use the MPU wrappers.  That should only be done when
     34          task.h is included from an application file. */
     35          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     36          
     37          /* FreeRTOS includes. */
     38          #include "FreeRTOS.h"
     39          #include "task.h"
     40          #include "stream_buffer.h"
     41          
     42          #if( configUSE_TASK_NOTIFICATIONS != 1 )
     43          	#error configUSE_TASK_NOTIFICATIONS must be set to 1 to build stream_buffer.c
     44          #endif
     45          
     46          /* Lint e961, e9021 and e750 are suppressed as a MISRA exception justified
     47          because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
     48          for the header files above, but not in this file, in order to generate the
     49          correct privileged Vs unprivileged linkage and placement. */
     50          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
     51          
     52          /* If the user has not provided application specific Rx notification macros,
     53          or #defined the notification macros away, them provide default implementations
     54          that uses task notifications. */
     55          /*lint -save -e9026 Function like macros allowed and needed here so they can be overidden. */
     56          #ifndef sbRECEIVE_COMPLETED
     57          	#define sbRECEIVE_COMPLETED( pxStreamBuffer )										\
     58          		vTaskSuspendAll();																\
     59          		{																				\
     60          			if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )						\
     61          			{																			\
     62          				( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToSend,			\
     63          									  ( uint32_t ) 0,									\
     64          									  eNoAction );										\
     65          				( pxStreamBuffer )->xTaskWaitingToSend = NULL;							\
     66          			}																			\
     67          		}																				\
     68          		( void ) xTaskResumeAll();
     69          #endif /* sbRECEIVE_COMPLETED */
     70          
     71          #ifndef sbRECEIVE_COMPLETED_FROM_ISR
     72          	#define sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer,								\
     73          										  pxHigherPriorityTaskWoken )					\
     74          	{																					\
     75          	UBaseType_t uxSavedInterruptStatus;													\
     76          																						\
     77          		uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();		\
     78          		{																				\
     79          			if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )						\
     80          			{																			\
     81          				( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,	\
     82          											 ( uint32_t ) 0,							\
     83          											 eNoAction,									\
     84          											 pxHigherPriorityTaskWoken );				\
     85          				( pxStreamBuffer )->xTaskWaitingToSend = NULL;							\
     86          			}																			\
     87          		}																				\
     88          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );					\
     89          	}
     90          #endif /* sbRECEIVE_COMPLETED_FROM_ISR */
     91          
     92          /* If the user has not provided an application specific Tx notification macro,
     93          or #defined the notification macro away, them provide a default implementation
     94          that uses task notifications. */
     95          #ifndef sbSEND_COMPLETED
     96          	#define sbSEND_COMPLETED( pxStreamBuffer )											\
     97          		vTaskSuspendAll();																\
     98          		{																				\
     99          			if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )						\
    100          			{																			\
    101          				( void ) xTaskNotify( ( pxStreamBuffer )->xTaskWaitingToReceive,		\
    102          									  ( uint32_t ) 0,									\
    103          									  eNoAction );										\
    104          				( pxStreamBuffer )->xTaskWaitingToReceive = NULL;						\
    105          			}																			\
    106          		}																				\
    107          		( void ) xTaskResumeAll();
    108          #endif /* sbSEND_COMPLETED */
    109          
    110          #ifndef sbSEND_COMPLETE_FROM_ISR
    111          	#define sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken )		\
    112          	{																					\
    113          	UBaseType_t uxSavedInterruptStatus;													\
    114          																						\
    115          		uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();		\
    116          		{																				\
    117          			if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )						\
    118          			{																			\
    119          				( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,	\
    120          											 ( uint32_t ) 0,							\
    121          											 eNoAction,									\
    122          											 pxHigherPriorityTaskWoken );				\
    123          				( pxStreamBuffer )->xTaskWaitingToReceive = NULL;						\
    124          			}																			\
    125          		}																				\
    126          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );					\
    127          	}
    128          #endif /* sbSEND_COMPLETE_FROM_ISR */
    129          /*lint -restore (9026) */
    130          
    131          /* The number of bytes used to hold the length of a message in the buffer. */
    132          #define sbBYTES_TO_STORE_MESSAGE_LENGTH ( sizeof( configMESSAGE_BUFFER_LENGTH_TYPE ) )
    133          
    134          /* Bits stored in the ucFlags field of the stream buffer. */
    135          #define sbFLAGS_IS_MESSAGE_BUFFER		( ( uint8_t ) 1 ) /* Set if the stream buffer was created as a message buffer, in which case it holds discrete messages rather than a stream. */
    136          #define sbFLAGS_IS_STATICALLY_ALLOCATED ( ( uint8_t ) 2 ) /* Set if the stream buffer was created using statically allocated memory. */
    137          
    138          /*-----------------------------------------------------------*/
    139          
    140          /* Structure that hold state information on the buffer. */
    141          typedef struct StreamBufferDef_t /*lint !e9058 Style convention uses tag. */
    142          {
    143          	volatile size_t xTail;				/* Index to the next item to read within the buffer. */
    144          	volatile size_t xHead;				/* Index to the next item to write within the buffer. */
    145          	size_t xLength;						/* The length of the buffer pointed to by pucBuffer. */
    146          	size_t xTriggerLevelBytes;			/* The number of bytes that must be in the stream buffer before a task that is waiting for data is unblocked. */
    147          	volatile TaskHandle_t xTaskWaitingToReceive; /* Holds the handle of a task waiting for data, or NULL if no tasks are waiting. */
    148          	volatile TaskHandle_t xTaskWaitingToSend;	/* Holds the handle of a task waiting to send data to a message buffer that is full. */
    149          	uint8_t *pucBuffer;					/* Points to the buffer itself - that is - the RAM that stores the data passed through the buffer. */
    150          	uint8_t ucFlags;
    151          
    152          	#if ( configUSE_TRACE_FACILITY == 1 )
    153          		UBaseType_t uxStreamBufferNumber;		/* Used for tracing purposes. */
    154          	#endif
    155          } StreamBuffer_t;
    156          
    157          /*
    158           * The number of bytes available to be read from the buffer.
    159           */
    160          static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer ) PRIVILEGED_FUNCTION;
    161          
    162          /*
    163           * Add xCount bytes from pucData into the pxStreamBuffer message buffer.
    164           * Returns the number of bytes written, which will either equal xCount in the
    165           * success case, or 0 if there was not enough space in the buffer (in which case
    166           * no data is written into the buffer).
    167           */
    168          static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount ) PRIVILEGED_FUNCTION;
    169          
    170          /*
    171           * If the stream buffer is being used as a message buffer, then reads an entire
    172           * message out of the buffer.  If the stream buffer is being used as a stream
    173           * buffer then read as many bytes as possible from the buffer.
    174           * prvReadBytesFromBuffer() is called to actually extract the bytes from the
    175           * buffer's data storage area.
    176           */
    177          static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
    178          										void *pvRxData,
    179          										size_t xBufferLengthBytes,
    180          										size_t xBytesAvailable,
    181          										size_t xBytesToStoreMessageLength ) PRIVILEGED_FUNCTION;
    182          
    183          /*
    184           * If the stream buffer is being used as a message buffer, then writes an entire
    185           * message to the buffer.  If the stream buffer is being used as a stream
    186           * buffer then write as many bytes as possible to the buffer.
    187           * prvWriteBytestoBuffer() is called to actually send the bytes to the buffer's
    188           * data storage area.
    189           */
    190          static size_t prvWriteMessageToBuffer(  StreamBuffer_t * const pxStreamBuffer,
    191          										const void * pvTxData,
    192          										size_t xDataLengthBytes,
    193          										size_t xSpace,
    194          										size_t xRequiredSpace ) PRIVILEGED_FUNCTION;
    195          
    196          /*
    197           * Read xMaxCount bytes from the pxStreamBuffer message buffer and write them
    198           * to pucData.
    199           */
    200          static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer,
    201          									  uint8_t *pucData,
    202          									  size_t xMaxCount,
    203          									  size_t xBytesAvailable ) PRIVILEGED_FUNCTION;
    204          
    205          /*
    206           * Called by both pxStreamBufferCreate() and pxStreamBufferCreateStatic() to
    207           * initialise the members of the newly created stream buffer structure.
    208           */
    209          static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
    210          										  uint8_t * const pucBuffer,
    211          										  size_t xBufferSizeBytes,
    212          										  size_t xTriggerLevelBytes,
    213          										  uint8_t ucFlags ) PRIVILEGED_FUNCTION;
    214          
    215          /*-----------------------------------------------------------*/
    216          
    217          #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    218          

   \                                 In section .text, align 2, keep-with-next
    219          	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
    220          	{
   \                     xStreamBufferGenericCreate: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000D             MOVS     R5,R1
    221          	uint8_t *pucAllocatedMemory;
    222          	uint8_t ucFlags;
    223          
    224          		/* In case the stream buffer is going to be used as a message buffer
    225          		(that is, it will hold discrete messages with a little meta data that
    226          		says how big the next message is) check the buffer will be large enough
    227          		to hold at least one message. */
    228          		if( xIsMessageBuffer == pdTRUE )
   \        0x6   0x2A01             CMP      R2,#+1
   \        0x8   0xD10A             BNE.N    ??xStreamBufferGenericCreate_0
    229          		{
    230          			/* Is a message buffer but not statically allocated. */
    231          			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
   \        0xA   0x2701             MOVS     R7,#+1
    232          			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
   \        0xC   0x2E05             CMP      R6,#+5
   \        0xE   0xD212             BCS.N    ??xStreamBufferGenericCreate_1
   \       0x10   0x2050             MOVS     R0,#+80
   \       0x12   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x16   0xF3BF 0x8F4F      DSB      SY
   \       0x1A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferGenericCreate_2: (+1)
   \       0x1E   0xE7FE             B.N      ??xStreamBufferGenericCreate_2
    233          		}
    234          		else
    235          		{
    236          			/* Not a message buffer and not statically allocated. */
    237          			ucFlags = 0;
   \                     ??xStreamBufferGenericCreate_0: (+1)
   \       0x20   0x2700             MOVS     R7,#+0
    238          			configASSERT( xBufferSizeBytes > 0 );
   \       0x22   0x2E00             CMP      R6,#+0
   \       0x24   0xD107             BNE.N    ??xStreamBufferGenericCreate_1
   \       0x26   0x2050             MOVS     R0,#+80
   \       0x28   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2C   0xF3BF 0x8F4F      DSB      SY
   \       0x30   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferGenericCreate_3: (+1)
   \       0x34   0xE7FE             B.N      ??xStreamBufferGenericCreate_3
    239          		}
    240          		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
   \                     ??xStreamBufferGenericCreate_1: (+1)
   \       0x36   0x42AE             CMP      R6,R5
   \       0x38   0xD207             BCS.N    ??xStreamBufferGenericCreate_4
   \       0x3A   0x2050             MOVS     R0,#+80
   \       0x3C   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x40   0xF3BF 0x8F4F      DSB      SY
   \       0x44   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferGenericCreate_5: (+1)
   \       0x48   0xE7FE             B.N      ??xStreamBufferGenericCreate_5
    241          
    242          		/* A trigger level of 0 would cause a waiting task to unblock even when
    243          		the buffer was empty. */
    244          		if( xTriggerLevelBytes == ( size_t ) 0 )
   \                     ??xStreamBufferGenericCreate_4: (+1)
   \       0x4A   0x2D00             CMP      R5,#+0
   \       0x4C   0xD100             BNE.N    ??xStreamBufferGenericCreate_6
    245          		{
    246          			xTriggerLevelBytes = ( size_t ) 1;
   \       0x4E   0x2501             MOVS     R5,#+1
    247          		}
    248          
    249          		/* A stream buffer requires a StreamBuffer_t structure and a buffer.
    250          		Both are allocated in a single call to pvPortMalloc().  The
    251          		StreamBuffer_t structure is placed at the start of the allocated memory
    252          		and the buffer follows immediately after.  The requested size is
    253          		incremented so the free space is returned as the user would expect -
    254          		this is a quirk of the implementation that means otherwise the free
    255          		space would be reported as one byte smaller than would be logically
    256          		expected. */
    257          		xBufferSizeBytes++;
   \                     ??xStreamBufferGenericCreate_6: (+1)
   \       0x50   0x1C76             ADDS     R6,R6,#+1
    258          		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
   \       0x52   0xF116 0x0024      ADDS     R0,R6,#+36
   \       0x56   0x.... 0x....      BL       pvPortMalloc
   \       0x5A   0x0004             MOVS     R4,R0
    259          
    260          		if( pucAllocatedMemory != NULL )
   \       0x5C   0x2C00             CMP      R4,#+0
   \       0x5E   0xD008             BEQ.N    ??xStreamBufferGenericCreate_7
    261          		{
    262          			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    263          										   pucAllocatedMemory + sizeof( StreamBuffer_t ),  /* Storage area follows. */ /*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */
    264          										   xBufferSizeBytes,
    265          										   xTriggerLevelBytes,
    266          										   ucFlags );
   \       0x60   0xB2FF             UXTB     R7,R7
   \       0x62   0x9700             STR      R7,[SP, #+0]
   \       0x64   0x002B             MOVS     R3,R5
   \       0x66   0x0032             MOVS     R2,R6
   \       0x68   0xF114 0x0124      ADDS     R1,R4,#+36
   \       0x6C   0x0020             MOVS     R0,R4
   \       0x6E   0x.... 0x....      BL       prvInitialiseNewStreamBuffer
    267          
    268          			traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );
    269          		}
    270          		else
    271          		{
    272          			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
    273          		}
    274          
    275          		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
   \                     ??xStreamBufferGenericCreate_7: (+1)
   \       0x72   0x0020             MOVS     R0,R4
   \       0x74   0xBDF2             POP      {R1,R4-R7,PC}
    276          	}
    277          
    278          #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    279          /*-----------------------------------------------------------*/
    280          
    281          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    282          

   \                                 In section .text, align 2, keep-with-next
    283          	StreamBufferHandle_t xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,
    284          														   size_t xTriggerLevelBytes,
    285          														   BaseType_t xIsMessageBuffer,
    286          														   uint8_t * const pucStreamBufferStorageArea,
    287          														   StaticStreamBuffer_t * const pxStaticStreamBuffer )
    288          	{
   \                     xStreamBufferGenericCreateStatic: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x0008             MOVS     R0,R1
   \        0x6   0x0019             MOVS     R1,R3
   \        0x8   0x9C06             LDR      R4,[SP, #+24]
    289          	StreamBuffer_t * const pxStreamBuffer = ( StreamBuffer_t * ) pxStaticStreamBuffer; /*lint !e740 !e9087 Safe cast as StaticStreamBuffer_t is opaque Streambuffer_t. */
   \        0xA   0x0026             MOVS     R6,R4
    290          	StreamBufferHandle_t xReturn;
    291          	uint8_t ucFlags;
    292          
    293          		configASSERT( pucStreamBufferStorageArea );
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD107             BNE.N    ??xStreamBufferGenericCreateStatic_0
   \       0x10   0x2050             MOVS     R0,#+80
   \       0x12   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x16   0xF3BF 0x8F4F      DSB      SY
   \       0x1A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferGenericCreateStatic_1: (+1)
   \       0x1E   0xE7FE             B.N      ??xStreamBufferGenericCreateStatic_1
    294          		configASSERT( pxStaticStreamBuffer );
   \                     ??xStreamBufferGenericCreateStatic_0: (+1)
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD107             BNE.N    ??xStreamBufferGenericCreateStatic_2
   \       0x24   0x2050             MOVS     R0,#+80
   \       0x26   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2A   0xF3BF 0x8F4F      DSB      SY
   \       0x2E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferGenericCreateStatic_3: (+1)
   \       0x32   0xE7FE             B.N      ??xStreamBufferGenericCreateStatic_3
    295          		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
   \                     ??xStreamBufferGenericCreateStatic_2: (+1)
   \       0x34   0x4285             CMP      R5,R0
   \       0x36   0xD207             BCS.N    ??xStreamBufferGenericCreateStatic_4
   \       0x38   0x2050             MOVS     R0,#+80
   \       0x3A   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x3E   0xF3BF 0x8F4F      DSB      SY
   \       0x42   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferGenericCreateStatic_5: (+1)
   \       0x46   0xE7FE             B.N      ??xStreamBufferGenericCreateStatic_5
    296          
    297          		/* A trigger level of 0 would cause a waiting task to unblock even when
    298          		the buffer was empty. */
    299          		if( xTriggerLevelBytes == ( size_t ) 0 )
   \                     ??xStreamBufferGenericCreateStatic_4: (+1)
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD100             BNE.N    ??xStreamBufferGenericCreateStatic_6
    300          		{
    301          			xTriggerLevelBytes = ( size_t ) 1;
   \       0x4C   0x2001             MOVS     R0,#+1
    302          		}
    303          
    304          		if( xIsMessageBuffer != pdFALSE )
   \                     ??xStreamBufferGenericCreateStatic_6: (+1)
   \       0x4E   0x2A00             CMP      R2,#+0
   \       0x50   0xD001             BEQ.N    ??xStreamBufferGenericCreateStatic_7
    305          		{
    306          			/* Statically allocated message buffer. */
    307          			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER | sbFLAGS_IS_STATICALLY_ALLOCATED;
   \       0x52   0x2203             MOVS     R2,#+3
   \       0x54   0xE000             B.N      ??xStreamBufferGenericCreateStatic_8
    308          		}
    309          		else
    310          		{
    311          			/* Statically allocated stream buffer. */
    312          			ucFlags = sbFLAGS_IS_STATICALLY_ALLOCATED;
   \                     ??xStreamBufferGenericCreateStatic_7: (+1)
   \       0x56   0x2202             MOVS     R2,#+2
    313          		}
    314          
    315          		/* In case the stream buffer is going to be used as a message buffer
    316          		(that is, it will hold discrete messages with a little meta data that
    317          		says how big the next message is) check the buffer will be large enough
    318          		to hold at least one message. */
    319          		configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
   \                     ??xStreamBufferGenericCreateStatic_8: (+1)
   \       0x58   0x2D05             CMP      R5,#+5
   \       0x5A   0xD207             BCS.N    ??xStreamBufferGenericCreateStatic_9
   \       0x5C   0x2050             MOVS     R0,#+80
   \       0x5E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x62   0xF3BF 0x8F4F      DSB      SY
   \       0x66   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferGenericCreateStatic_10: (+1)
   \       0x6A   0xE7FE             B.N      ??xStreamBufferGenericCreateStatic_10
    320          
    321          		#if( configASSERT_DEFINED == 1 )
    322          		{
    323          			/* Sanity check that the size of the structure used to declare a
    324          			variable of type StaticStreamBuffer_t equals the size of the real
    325          			message buffer structure. */
    326          			volatile size_t xSize = sizeof( StaticStreamBuffer_t );
   \                     ??xStreamBufferGenericCreateStatic_9: (+1)
   \       0x6C   0x2324             MOVS     R3,#+36
   \       0x6E   0x9300             STR      R3,[SP, #+0]
    327          			configASSERT( xSize == sizeof( StreamBuffer_t ) );
   \       0x70   0x9B00             LDR      R3,[SP, #+0]
   \       0x72   0x2B24             CMP      R3,#+36
   \       0x74   0xD007             BEQ.N    ??xStreamBufferGenericCreateStatic_11
   \       0x76   0x2050             MOVS     R0,#+80
   \       0x78   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x7C   0xF3BF 0x8F4F      DSB      SY
   \       0x80   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferGenericCreateStatic_12: (+1)
   \       0x84   0xE7FE             B.N      ??xStreamBufferGenericCreateStatic_12
    328          		} /*lint !e529 xSize is referenced is configASSERT() is defined. */
    329          		#endif /* configASSERT_DEFINED */
    330          
    331          		if( ( pucStreamBufferStorageArea != NULL ) && ( pxStaticStreamBuffer != NULL ) )
   \                     ??xStreamBufferGenericCreateStatic_11: (+1)
   \       0x86   0x2900             CMP      R1,#+0
   \       0x88   0xD00D             BEQ.N    ??xStreamBufferGenericCreateStatic_13
   \       0x8A   0x2C00             CMP      R4,#+0
   \       0x8C   0xD00B             BEQ.N    ??xStreamBufferGenericCreateStatic_13
    332          		{
    333          			prvInitialiseNewStreamBuffer( pxStreamBuffer,
    334          										  pucStreamBufferStorageArea,
    335          										  xBufferSizeBytes,
    336          										  xTriggerLevelBytes,
    337          										  ucFlags );
   \       0x8E   0xB2D2             UXTB     R2,R2
   \       0x90   0x9200             STR      R2,[SP, #+0]
   \       0x92   0x0003             MOVS     R3,R0
   \       0x94   0x002A             MOVS     R2,R5
   \       0x96   0x0030             MOVS     R0,R6
   \       0x98   0x.... 0x....      BL       prvInitialiseNewStreamBuffer
    338          
    339          			/* Remember this was statically allocated in case it is ever deleted
    340          			again. */
    341          			pxStreamBuffer->ucFlags |= sbFLAGS_IS_STATICALLY_ALLOCATED;
   \       0x9C   0x7F30             LDRB     R0,[R6, #+28]
   \       0x9E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0xA2   0x7730             STRB     R0,[R6, #+28]
    342          
    343          			traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer );
    344          
    345          			xReturn = ( StreamBufferHandle_t ) pxStaticStreamBuffer; /*lint !e9087 Data hiding requires cast to opaque type. */
   \       0xA4   0xE000             B.N      ??xStreamBufferGenericCreateStatic_14
    346          		}
    347          		else
    348          		{
    349          			xReturn = NULL;
   \                     ??xStreamBufferGenericCreateStatic_13: (+1)
   \       0xA6   0x2400             MOVS     R4,#+0
    350          			traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer );
    351          		}
    352          
    353          		return xReturn;
   \                     ??xStreamBufferGenericCreateStatic_14: (+1)
   \       0xA8   0x0020             MOVS     R0,R4
   \       0xAA   0xBD76             POP      {R1,R2,R4-R6,PC}
    354          	}
    355          
    356          #endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    357          /*-----------------------------------------------------------*/
    358          

   \                                 In section .text, align 2, keep-with-next
    359          void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
    360          {
   \                     vStreamBufferDelete: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    361          StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    362          
    363          	configASSERT( pxStreamBuffer );
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD107             BNE.N    ??vStreamBufferDelete_0
   \        0x8   0x2050             MOVS     R0,#+80
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??vStreamBufferDelete_1: (+1)
   \       0x16   0xE7FE             B.N      ??vStreamBufferDelete_1
    364          
    365          	traceSTREAM_BUFFER_DELETE( xStreamBuffer );
    366          
    367          	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
   \                     ??vStreamBufferDelete_0: (+1)
   \       0x18   0x7F20             LDRB     R0,[R4, #+28]
   \       0x1A   0x0780             LSLS     R0,R0,#+30
   \       0x1C   0xD403             BMI.N    ??vStreamBufferDelete_2
    368          	{
    369          		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    370          		{
    371          			/* Both the structure and the buffer were allocated using a single call
    372          			to pvPortMalloc(), hence only one call to vPortFree() is required. */
    373          			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       vPortFree
   \       0x24   0xE004             B.N      ??vStreamBufferDelete_3
    374          		}
    375          		#else
    376          		{
    377          			/* Should not be possible to get here, ucFlags must be corrupt.
    378          			Force an assert. */
    379          			configASSERT( xStreamBuffer == ( StreamBufferHandle_t ) ~0 );
    380          		}
    381          		#endif
    382          	}
    383          	else
    384          	{
    385          		/* The structure and buffer were not allocated dynamically and cannot be
    386          		freed - just scrub the structure so future use will assert. */
    387          		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
   \                     ??vStreamBufferDelete_2: (+1)
   \       0x26   0x2124             MOVS     R1,#+36
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0x.... 0x....      BL       __aeabi_memset
    388          	}
    389          }
   \                     ??vStreamBufferDelete_3: (+1)
   \       0x30   0xBD10             POP      {R4,PC}
    390          /*-----------------------------------------------------------*/
    391          

   \                                 In section .text, align 2, keep-with-next
    392          BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
    393          {
   \                     xStreamBufferReset: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    394          StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    395          BaseType_t xReturn = pdFAIL;
   \        0x4   0x2500             MOVS     R5,#+0
    396          
    397          #if( configUSE_TRACE_FACILITY == 1 )
    398          	UBaseType_t uxStreamBufferNumber;
    399          #endif
    400          
    401          	configASSERT( pxStreamBuffer );
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD107             BNE.N    ??xStreamBufferReset_0
   \        0xA   0x2050             MOVS     R0,#+80
   \        0xC   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferReset_1: (+1)
   \       0x18   0xE7FE             B.N      ??xStreamBufferReset_1
    402          
    403          	#if( configUSE_TRACE_FACILITY == 1 )
    404          	{
    405          		/* Store the stream buffer number so it can be restored after the
    406          		reset. */
    407          		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
   \                     ??xStreamBufferReset_0: (+1)
   \       0x1A   0x6A26             LDR      R6,[R4, #+32]
    408          	}
    409          	#endif
    410          
    411          	/* Can only reset a message buffer if there are no tasks blocked on it. */
    412          	taskENTER_CRITICAL();
   \       0x1C   0x.... 0x....      BL       vPortEnterCritical
    413          	{
    414          		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
   \       0x20   0x6920             LDR      R0,[R4, #+16]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD10C             BNE.N    ??xStreamBufferReset_2
    415          		{
    416          			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
   \       0x26   0x6960             LDR      R0,[R4, #+20]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD109             BNE.N    ??xStreamBufferReset_2
    417          			{
    418          				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    419          											  pxStreamBuffer->pucBuffer,
    420          											  pxStreamBuffer->xLength,
    421          											  pxStreamBuffer->xTriggerLevelBytes,
    422          											  pxStreamBuffer->ucFlags );
   \       0x2C   0x7F20             LDRB     R0,[R4, #+28]
   \       0x2E   0x9000             STR      R0,[SP, #+0]
   \       0x30   0x68E3             LDR      R3,[R4, #+12]
   \       0x32   0x68A2             LDR      R2,[R4, #+8]
   \       0x34   0x69A1             LDR      R1,[R4, #+24]
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x.... 0x....      BL       prvInitialiseNewStreamBuffer
    423          				xReturn = pdPASS;
   \       0x3C   0x2501             MOVS     R5,#+1
    424          
    425          				#if( configUSE_TRACE_FACILITY == 1 )
    426          				{
    427          					pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
   \       0x3E   0x6226             STR      R6,[R4, #+32]
    428          				}
    429          				#endif
    430          
    431          				traceSTREAM_BUFFER_RESET( xStreamBuffer );
    432          			}
    433          		}
    434          	}
    435          	taskEXIT_CRITICAL();
   \                     ??xStreamBufferReset_2: (+1)
   \       0x40   0x.... 0x....      BL       vPortExitCritical
    436          
    437          	return xReturn;
   \       0x44   0x0028             MOVS     R0,R5
   \       0x46   0xBD76             POP      {R1,R2,R4-R6,PC}
    438          }
    439          /*-----------------------------------------------------------*/
    440          

   \                                 In section .text, align 2, keep-with-next
    441          BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
    442          {
    443          StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    444          BaseType_t xReturn;
    445          
    446          	configASSERT( pxStreamBuffer );
   \                     xStreamBufferSetTriggerLevel: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD107             BNE.N    ??xStreamBufferSetTriggerLevel_0
   \        0x4   0x2050             MOVS     R0,#+80
   \        0x6   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferSetTriggerLevel_1: (+1)
   \       0x12   0xE7FE             B.N      ??xStreamBufferSetTriggerLevel_1
    447          
    448          	/* It is not valid for the trigger level to be 0. */
    449          	if( xTriggerLevel == ( size_t ) 0 )
   \                     ??xStreamBufferSetTriggerLevel_0: (+1)
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD100             BNE.N    ??xStreamBufferSetTriggerLevel_2
    450          	{
    451          		xTriggerLevel = ( size_t ) 1;
   \       0x18   0x2101             MOVS     R1,#+1
    452          	}
    453          
    454          	/* The trigger level is the number of bytes that must be in the stream
    455          	buffer before a task that is waiting for data is unblocked. */
    456          	if( xTriggerLevel <= pxStreamBuffer->xLength )
   \                     ??xStreamBufferSetTriggerLevel_2: (+1)
   \       0x1A   0x6882             LDR      R2,[R0, #+8]
   \       0x1C   0x428A             CMP      R2,R1
   \       0x1E   0xD302             BCC.N    ??xStreamBufferSetTriggerLevel_3
    457          	{
    458          		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
   \       0x20   0x60C1             STR      R1,[R0, #+12]
    459          		xReturn = pdPASS;
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xE000             B.N      ??xStreamBufferSetTriggerLevel_4
    460          	}
    461          	else
    462          	{
    463          		xReturn = pdFALSE;
   \                     ??xStreamBufferSetTriggerLevel_3: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
    464          	}
    465          
    466          	return xReturn;
   \                     ??xStreamBufferSetTriggerLevel_4: (+1)
   \       0x28   0x4770             BX       LR
    467          }
    468          /*-----------------------------------------------------------*/
    469          

   \                                 In section .text, align 2, keep-with-next
    470          size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
    471          {
   \                     xStreamBufferSpacesAvailable: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    472          const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    473          size_t xSpace;
    474          
    475          	configASSERT( pxStreamBuffer );
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD107             BNE.N    ??xStreamBufferSpacesAvailable_0
   \        0x6   0x2050             MOVS     R0,#+80
   \        0x8   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \       0x10   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferSpacesAvailable_1: (+1)
   \       0x14   0xE7FE             B.N      ??xStreamBufferSpacesAvailable_1
    476          
    477          	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
   \                     ??xStreamBufferSpacesAvailable_0: (+1)
   \       0x16   0x6888             LDR      R0,[R1, #+8]
   \       0x18   0x680A             LDR      R2,[R1, #+0]
   \       0x1A   0x1810             ADDS     R0,R2,R0
    478          	xSpace -= pxStreamBuffer->xHead;
   \       0x1C   0x684A             LDR      R2,[R1, #+4]
   \       0x1E   0x1A80             SUBS     R0,R0,R2
    479          	xSpace -= ( size_t ) 1;
   \       0x20   0x1E40             SUBS     R0,R0,#+1
    480          
    481          	if( xSpace >= pxStreamBuffer->xLength )
   \       0x22   0x688A             LDR      R2,[R1, #+8]
   \       0x24   0x4290             CMP      R0,R2
   \       0x26   0xD301             BCC.N    ??xStreamBufferSpacesAvailable_2
    482          	{
    483          		xSpace -= pxStreamBuffer->xLength;
   \       0x28   0x6889             LDR      R1,[R1, #+8]
   \       0x2A   0x1A40             SUBS     R0,R0,R1
    484          	}
    485          	else
    486          	{
    487          		mtCOVERAGE_TEST_MARKER();
    488          	}
    489          
    490          	return xSpace;
   \                     ??xStreamBufferSpacesAvailable_2: (+1)
   \       0x2C   0x4770             BX       LR
    491          }
    492          /*-----------------------------------------------------------*/
    493          

   \                                 In section .text, align 2, keep-with-next
    494          size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
    495          {
   \                     xStreamBufferBytesAvailable: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    496          const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    497          size_t xReturn;
    498          
    499          	configASSERT( pxStreamBuffer );
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD107             BNE.N    ??xStreamBufferBytesAvailable_0
   \        0x6   0x2050             MOVS     R0,#+80
   \        0x8   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \       0x10   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferBytesAvailable_1: (+1)
   \       0x14   0xE7FE             B.N      ??xStreamBufferBytesAvailable_1
    500          
    501          	xReturn = prvBytesInBuffer( pxStreamBuffer );
   \                     ??xStreamBufferBytesAvailable_0: (+1)
   \       0x16   0x.... 0x....      BL       prvBytesInBuffer
    502          	return xReturn;
   \       0x1A   0xBD02             POP      {R1,PC}
    503          }
    504          /*-----------------------------------------------------------*/
    505          

   \                                 In section .text, align 2, keep-with-next
    506          size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
    507          						  const void *pvTxData,
    508          						  size_t xDataLengthBytes,
    509          						  TickType_t xTicksToWait )
    510          {
   \                     xStreamBufferSend: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0017             MOVS     R7,R2
    511          StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    512          size_t xReturn, xSpace = 0;
   \        0xA   0x2600             MOVS     R6,#+0
    513          size_t xRequiredSpace = xDataLengthBytes;
   \        0xC   0x46B8             MOV      R8,R7
    514          TimeOut_t xTimeOut;
    515          
    516          	configASSERT( pvTxData );
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD107             BNE.N    ??xStreamBufferSend_0
   \       0x12   0x2050             MOVS     R0,#+80
   \       0x14   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x18   0xF3BF 0x8F4F      DSB      SY
   \       0x1C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferSend_1: (+1)
   \       0x20   0xE7FE             B.N      ??xStreamBufferSend_1
    517          	configASSERT( pxStreamBuffer );
   \                     ??xStreamBufferSend_0: (+1)
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD107             BNE.N    ??xStreamBufferSend_2
   \       0x26   0x2050             MOVS     R0,#+80
   \       0x28   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2C   0xF3BF 0x8F4F      DSB      SY
   \       0x30   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferSend_3: (+1)
   \       0x34   0xE7FE             B.N      ??xStreamBufferSend_3
    518          
    519          	/* This send function is used to write to both message buffers and stream
    520          	buffers.  If this is a message buffer then the space needed must be
    521          	increased by the amount of bytes needed to store the length of the
    522          	message. */
    523          	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
   \                     ??xStreamBufferSend_2: (+1)
   \       0x36   0x7F20             LDRB     R0,[R4, #+28]
   \       0x38   0x07C0             LSLS     R0,R0,#+31
   \       0x3A   0xD50B             BPL.N    ??xStreamBufferSend_4
    524          	{
    525          		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
   \       0x3C   0xF118 0x0804      ADDS     R8,R8,#+4
    526          
    527          		/* Overflow? */
    528          		configASSERT( xRequiredSpace > xDataLengthBytes );
   \       0x40   0x4547             CMP      R7,R8
   \       0x42   0xD307             BCC.N    ??xStreamBufferSend_4
   \       0x44   0x2050             MOVS     R0,#+80
   \       0x46   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x4A   0xF3BF 0x8F4F      DSB      SY
   \       0x4E   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferSend_5: (+1)
   \       0x52   0xE7FE             B.N      ??xStreamBufferSend_5
    529          	}
    530          	else
    531          	{
    532          		mtCOVERAGE_TEST_MARKER();
    533          	}
    534          
    535          	if( xTicksToWait != ( TickType_t ) 0 )
   \                     ??xStreamBufferSend_4: (+1)
   \       0x54   0x9803             LDR      R0,[SP, #+12]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD02E             BEQ.N    ??xStreamBufferSend_6
    536          	{
    537          		vTaskSetTimeOutState( &xTimeOut );
   \       0x5A   0xA801             ADD      R0,SP,#+4
   \       0x5C   0x.... 0x....      BL       vTaskSetTimeOutState
    538          
    539          		do
    540          		{
    541          			/* Wait until the required number of bytes are free in the message
    542          			buffer. */
    543          			taskENTER_CRITICAL();
   \                     ??xStreamBufferSend_7: (+1)
   \       0x60   0x.... 0x....      BL       vPortEnterCritical
    544          			{
    545          				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
   \       0x64   0x0020             MOVS     R0,R4
   \       0x66   0x.... 0x....      BL       xStreamBufferSpacesAvailable
   \       0x6A   0x0006             MOVS     R6,R0
    546          
    547          				if( xSpace < xRequiredSpace )
   \       0x6C   0x4546             CMP      R6,R8
   \       0x6E   0xD221             BCS.N    ??xStreamBufferSend_8
    548          				{
    549          					/* Clear notification state as going to wait for space. */
    550          					( void ) xTaskNotifyStateClear( NULL );
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x.... 0x....      BL       xTaskNotifyStateClear
    551          
    552          					/* Should only be one writer. */
    553          					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
   \       0x76   0x6960             LDR      R0,[R4, #+20]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD113             BNE.N    ??xStreamBufferSend_9
    554          					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
   \                     ??xStreamBufferSend_10: (+1)
   \       0x7C   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \       0x80   0x6160             STR      R0,[R4, #+20]
    555          				}
    556          				else
    557          				{
    558          					taskEXIT_CRITICAL();
    559          					break;
    560          				}
    561          			}
    562          			taskEXIT_CRITICAL();
   \       0x82   0x.... 0x....      BL       vPortExitCritical
    563          
    564          			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
    565          			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
   \       0x86   0x9B03             LDR      R3,[SP, #+12]
   \       0x88   0x2200             MOVS     R2,#+0
   \       0x8A   0x2100             MOVS     R1,#+0
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0x.... 0x....      BL       xTaskNotifyWait
    566          			pxStreamBuffer->xTaskWaitingToSend = NULL;
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0x6160             STR      R0,[R4, #+20]
    567          
    568          		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
   \       0x96   0xA903             ADD      R1,SP,#+12
   \       0x98   0xA801             ADD      R0,SP,#+4
   \       0x9A   0x.... 0x....      BL       xTaskCheckForTimeOut
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD10A             BNE.N    ??xStreamBufferSend_6
   \       0xA2   0xE7DD             B.N      ??xStreamBufferSend_7
   \                     ??xStreamBufferSend_9: (+1)
   \       0xA4   0x2050             MOVS     R0,#+80
   \       0xA6   0xF380 0x8811      MSR      BASEPRI,R0
   \       0xAA   0xF3BF 0x8F4F      DSB      SY
   \       0xAE   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferSend_11: (+1)
   \       0xB2   0xE7FE             B.N      ??xStreamBufferSend_11
   \                     ??xStreamBufferSend_8: (+1)
   \       0xB4   0x.... 0x....      BL       vPortExitCritical
    569          	}
    570          	else
    571          	{
    572          		mtCOVERAGE_TEST_MARKER();
    573          	}
    574          
    575          	if( xSpace == ( size_t ) 0 )
   \                     ??xStreamBufferSend_6: (+1)
   \       0xB8   0x2E00             CMP      R6,#+0
   \       0xBA   0xD103             BNE.N    ??xStreamBufferSend_12
    576          	{
    577          		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
   \       0xBC   0x0020             MOVS     R0,R4
   \       0xBE   0x.... 0x....      BL       xStreamBufferSpacesAvailable
   \       0xC2   0x0006             MOVS     R6,R0
    578          	}
    579          	else
    580          	{
    581          		mtCOVERAGE_TEST_MARKER();
    582          	}
    583          
    584          	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
   \                     ??xStreamBufferSend_12: (+1)
   \       0xC4   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0xC8   0x0033             MOVS     R3,R6
   \       0xCA   0x003A             MOVS     R2,R7
   \       0xCC   0x0029             MOVS     R1,R5
   \       0xCE   0x0020             MOVS     R0,R4
   \       0xD0   0x.... 0x....      BL       prvWriteMessageToBuffer
   \       0xD4   0x0005             MOVS     R5,R0
    585          
    586          	if( xReturn > ( size_t ) 0 )
   \       0xD6   0x2D00             CMP      R5,#+0
   \       0xD8   0xD014             BEQ.N    ??xStreamBufferSend_13
    587          	{
    588          		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );
    589          
    590          		/* Was a task waiting for the data? */
    591          		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
   \       0xDA   0x0020             MOVS     R0,R4
   \       0xDC   0x.... 0x....      BL       prvBytesInBuffer
   \       0xE0   0x68E1             LDR      R1,[R4, #+12]
   \       0xE2   0x4288             CMP      R0,R1
   \       0xE4   0xD30E             BCC.N    ??xStreamBufferSend_13
    592          		{
    593          			sbSEND_COMPLETED( pxStreamBuffer );
   \       0xE6   0x.... 0x....      BL       vTaskSuspendAll
   \       0xEA   0x6920             LDR      R0,[R4, #+16]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD007             BEQ.N    ??xStreamBufferSend_14
   \       0xF0   0x2300             MOVS     R3,#+0
   \       0xF2   0x2200             MOVS     R2,#+0
   \       0xF4   0x2100             MOVS     R1,#+0
   \       0xF6   0x6920             LDR      R0,[R4, #+16]
   \       0xF8   0x.... 0x....      BL       xTaskGenericNotify
   \       0xFC   0x2000             MOVS     R0,#+0
   \       0xFE   0x6120             STR      R0,[R4, #+16]
   \                     ??xStreamBufferSend_14: (+1)
   \      0x100   0x.... 0x....      BL       xTaskResumeAll
    594          		}
    595          		else
    596          		{
    597          			mtCOVERAGE_TEST_MARKER();
    598          		}
    599          	}
    600          	else
    601          	{
    602          		mtCOVERAGE_TEST_MARKER();
    603          		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    604          	}
    605          
    606          	return xReturn;
   \                     ??xStreamBufferSend_13: (+1)
   \      0x104   0x0028             MOVS     R0,R5
   \      0x106   0xB004             ADD      SP,SP,#+16
   \      0x108   0xE8BD 0x81F0      POP      {R4-R8,PC}
    607          }
    608          /*-----------------------------------------------------------*/
    609          

   \                                 In section .text, align 2, keep-with-next
    610          size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
    611          								 const void *pvTxData,
    612          								 size_t xDataLengthBytes,
    613          								 BaseType_t * const pxHigherPriorityTaskWoken )
    614          {
   \                     xStreamBufferSendFromISR: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x001E             MOVS     R6,R3
    615          StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    616          size_t xReturn, xSpace;
    617          size_t xRequiredSpace = xDataLengthBytes;
   \        0xC   0x46B8             MOV      R8,R7
    618          
    619          	configASSERT( pvTxData );
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD107             BNE.N    ??xStreamBufferSendFromISR_0
   \       0x12   0x2050             MOVS     R0,#+80
   \       0x14   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x18   0xF3BF 0x8F4F      DSB      SY
   \       0x1C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferSendFromISR_1: (+1)
   \       0x20   0xE7FE             B.N      ??xStreamBufferSendFromISR_1
    620          	configASSERT( pxStreamBuffer );
   \                     ??xStreamBufferSendFromISR_0: (+1)
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD107             BNE.N    ??xStreamBufferSendFromISR_2
   \       0x26   0x2050             MOVS     R0,#+80
   \       0x28   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2C   0xF3BF 0x8F4F      DSB      SY
   \       0x30   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferSendFromISR_3: (+1)
   \       0x34   0xE7FE             B.N      ??xStreamBufferSendFromISR_3
    621          
    622          	/* This send function is used to write to both message buffers and stream
    623          	buffers.  If this is a message buffer then the space needed must be
    624          	increased by the amount of bytes needed to store the length of the
    625          	message. */
    626          	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
   \                     ??xStreamBufferSendFromISR_2: (+1)
   \       0x36   0x7F20             LDRB     R0,[R4, #+28]
   \       0x38   0x07C0             LSLS     R0,R0,#+31
   \       0x3A   0xD501             BPL.N    ??xStreamBufferSendFromISR_4
    627          	{
    628          		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
   \       0x3C   0xF118 0x0804      ADDS     R8,R8,#+4
    629          	}
    630          	else
    631          	{
    632          		mtCOVERAGE_TEST_MARKER();
    633          	}
    634          
    635          	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
   \                     ??xStreamBufferSendFromISR_4: (+1)
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x.... 0x....      BL       xStreamBufferSpacesAvailable
    636          	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
   \       0x46   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x4A   0x0003             MOVS     R3,R0
   \       0x4C   0x003A             MOVS     R2,R7
   \       0x4E   0x0029             MOVS     R1,R5
   \       0x50   0x0020             MOVS     R0,R4
   \       0x52   0x.... 0x....      BL       prvWriteMessageToBuffer
   \       0x56   0x0005             MOVS     R5,R0
    637          
    638          	if( xReturn > ( size_t ) 0 )
   \       0x58   0x2D00             CMP      R5,#+0
   \       0x5A   0xD01C             BEQ.N    ??xStreamBufferSendFromISR_5
    639          	{
    640          		/* Was a task waiting for the data? */
    641          		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0x.... 0x....      BL       prvBytesInBuffer
   \       0x62   0x68E1             LDR      R1,[R4, #+12]
   \       0x64   0x4288             CMP      R0,R1
   \       0x66   0xD316             BCC.N    ??xStreamBufferSendFromISR_5
    642          		{
    643          			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
   \       0x68   0xF3EF 0x8711      MRS      R7,BASEPRI
   \       0x6C   0x2050             MOVS     R0,#+80
   \       0x6E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x72   0xF3BF 0x8F4F      DSB      SY
   \       0x76   0xF3BF 0x8F6F      ISB      SY
   \       0x7A   0x6920             LDR      R0,[R4, #+16]
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD008             BEQ.N    ??xStreamBufferSendFromISR_6
   \       0x80   0x9600             STR      R6,[SP, #+0]
   \       0x82   0x2300             MOVS     R3,#+0
   \       0x84   0x2200             MOVS     R2,#+0
   \       0x86   0x2100             MOVS     R1,#+0
   \       0x88   0x6920             LDR      R0,[R4, #+16]
   \       0x8A   0x.... 0x....      BL       xTaskGenericNotifyFromISR
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0x6120             STR      R0,[R4, #+16]
   \                     ??xStreamBufferSendFromISR_6: (+1)
   \       0x92   0xF387 0x8811      MSR      BASEPRI,R7
    644          		}
    645          		else
    646          		{
    647          			mtCOVERAGE_TEST_MARKER();
    648          		}
    649          	}
    650          	else
    651          	{
    652          		mtCOVERAGE_TEST_MARKER();
    653          	}
    654          
    655          	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );
    656          
    657          	return xReturn;
   \                     ??xStreamBufferSendFromISR_5: (+1)
   \       0x96   0x0028             MOVS     R0,R5
   \       0x98   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
    658          }
    659          /*-----------------------------------------------------------*/
    660          

   \                                 In section .text, align 2, keep-with-next
    661          static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
    662          									   const void * pvTxData,
    663          									   size_t xDataLengthBytes,
    664          									   size_t xSpace,
    665          									   size_t xRequiredSpace )
    666          {
   \                     prvWriteMessageToBuffer: (+1)
   \        0x0   0xB576             PUSH     {R1,R2,R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
    667          	BaseType_t xShouldWrite;
    668          	size_t xReturn;
    669          
    670          	if( xSpace == ( size_t ) 0 )
   \        0x6   0x2B00             CMP      R3,#+0
   \        0x8   0xD101             BNE.N    ??prvWriteMessageToBuffer_0
    671          	{
    672          		/* Doesn't matter if this is a stream buffer or a message buffer, there
    673          		is no space to write. */
    674          		xShouldWrite = pdFALSE;
   \        0xA   0x2400             MOVS     R4,#+0
   \        0xC   0xE013             B.N      ??prvWriteMessageToBuffer_1
    675          	}
    676          	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
   \                     ??prvWriteMessageToBuffer_0: (+1)
   \        0xE   0x7F28             LDRB     R0,[R5, #+28]
   \       0x10   0x07C0             LSLS     R0,R0,#+31
   \       0x12   0xD405             BMI.N    ??prvWriteMessageToBuffer_2
    677          	{
    678          		/* This is a stream buffer, as opposed to a message buffer, so writing a
    679          		stream of bytes rather than discrete messages.  Write as many bytes as
    680          		possible. */
    681          		xShouldWrite = pdTRUE;
   \       0x14   0x2401             MOVS     R4,#+1
    682          		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
   \       0x16   0x9801             LDR      R0,[SP, #+4]
   \       0x18   0x4298             CMP      R0,R3
   \       0x1A   0xD30C             BCC.N    ??prvWriteMessageToBuffer_1
   \                     ??prvWriteMessageToBuffer_3: (+1)
   \       0x1C   0x9301             STR      R3,[SP, #+4]
   \       0x1E   0xE00A             B.N      ??prvWriteMessageToBuffer_1
    683          	}
   \                     ??prvWriteMessageToBuffer_2: (+1)
   \       0x20   0x9806             LDR      R0,[SP, #+24]
    684          	else if( xSpace >= xRequiredSpace )
   \       0x22   0x4283             CMP      R3,R0
   \       0x24   0xD306             BCC.N    ??prvWriteMessageToBuffer_4
    685          	{
    686          		/* This is a message buffer, as opposed to a stream buffer, and there
    687          		is enough space to write both the message length and the message itself
    688          		into the buffer.  Start by writing the length of the data, the data
    689          		itself will be written later in this function. */
    690          		xShouldWrite = pdTRUE;
   \       0x26   0x2401             MOVS     R4,#+1
    691          		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
   \       0x28   0x2204             MOVS     R2,#+4
   \       0x2A   0xA901             ADD      R1,SP,#+4
   \       0x2C   0x0028             MOVS     R0,R5
   \       0x2E   0x.... 0x....      BL       prvWriteBytesToBuffer
   \       0x32   0xE000             B.N      ??prvWriteMessageToBuffer_1
    692          	}
    693          	else
    694          	{
    695          		/* There is space available, but not enough space. */
    696          		xShouldWrite = pdFALSE;
   \                     ??prvWriteMessageToBuffer_4: (+1)
   \       0x34   0x2400             MOVS     R4,#+0
    697          	}
    698          
    699          	if( xShouldWrite != pdFALSE )
   \                     ??prvWriteMessageToBuffer_1: (+1)
   \       0x36   0x2C00             CMP      R4,#+0
   \       0x38   0xD005             BEQ.N    ??prvWriteMessageToBuffer_5
    700          	{
    701          		/* Writes the data itself. */
    702          		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
   \       0x3A   0x9A01             LDR      R2,[SP, #+4]
   \       0x3C   0x0031             MOVS     R1,R6
   \       0x3E   0x0028             MOVS     R0,R5
   \       0x40   0x.... 0x....      BL       prvWriteBytesToBuffer
   \       0x44   0xE000             B.N      ??prvWriteMessageToBuffer_6
    703          	}
    704          	else
    705          	{
    706          		xReturn = 0;
   \                     ??prvWriteMessageToBuffer_5: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
    707          	}
    708          
    709          	return xReturn;
   \                     ??prvWriteMessageToBuffer_6: (+1)
   \       0x48   0xBD76             POP      {R1,R2,R4-R6,PC}
    710          }
    711          /*-----------------------------------------------------------*/
    712          

   \                                 In section .text, align 2, keep-with-next
    713          size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
    714          							 void *pvRxData,
    715          							 size_t xBufferLengthBytes,
    716          							 TickType_t xTicksToWait )
    717          {
   \                     xStreamBufferReceive: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001F             MOVS     R7,R3
    718          StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    719          size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
   \        0xC   0x2400             MOVS     R4,#+0
    720          
    721          	configASSERT( pvRxData );
   \        0xE   0x2E00             CMP      R6,#+0
   \       0x10   0xD107             BNE.N    ??xStreamBufferReceive_0
   \       0x12   0x2050             MOVS     R0,#+80
   \       0x14   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x18   0xF3BF 0x8F4F      DSB      SY
   \       0x1C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferReceive_1: (+1)
   \       0x20   0xE7FE             B.N      ??xStreamBufferReceive_1
    722          	configASSERT( pxStreamBuffer );
   \                     ??xStreamBufferReceive_0: (+1)
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD107             BNE.N    ??xStreamBufferReceive_2
   \       0x26   0x2050             MOVS     R0,#+80
   \       0x28   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2C   0xF3BF 0x8F4F      DSB      SY
   \       0x30   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferReceive_3: (+1)
   \       0x34   0xE7FE             B.N      ??xStreamBufferReceive_3
    723          
    724          	/* This receive function is used by both message buffers, which store
    725          	discrete messages, and stream buffers, which store a continuous stream of
    726          	bytes.  Discrete messages include an additional
    727          	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
    728          	message. */
    729          	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
   \                     ??xStreamBufferReceive_2: (+1)
   \       0x36   0x7F28             LDRB     R0,[R5, #+28]
   \       0x38   0x07C0             LSLS     R0,R0,#+31
   \       0x3A   0xD502             BPL.N    ??xStreamBufferReceive_4
    730          	{
    731          		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
   \       0x3C   0xF05F 0x0904      MOVS     R9,#+4
   \       0x40   0xE001             B.N      ??xStreamBufferReceive_5
    732          	}
    733          	else
    734          	{
    735          		xBytesToStoreMessageLength = 0;
   \                     ??xStreamBufferReceive_4: (+1)
   \       0x42   0xF05F 0x0900      MOVS     R9,#+0
    736          	}
    737          
    738          	if( xTicksToWait != ( TickType_t ) 0 )
   \                     ??xStreamBufferReceive_5: (+1)
   \       0x46   0x2F00             CMP      R7,#+0
   \       0x48   0xD029             BEQ.N    ??xStreamBufferReceive_6
    739          	{
    740          		/* Checking if there is data and clearing the notification state must be
    741          		performed atomically. */
    742          		taskENTER_CRITICAL();
   \       0x4A   0x.... 0x....      BL       vPortEnterCritical
    743          		{
    744          			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
   \       0x4E   0x0028             MOVS     R0,R5
   \       0x50   0x.... 0x....      BL       prvBytesInBuffer
   \       0x54   0x4682             MOV      R10,R0
    745          
    746          			/* If this function was invoked by a message buffer read then
    747          			xBytesToStoreMessageLength holds the number of bytes used to hold
    748          			the length of the next discrete message.  If this function was
    749          			invoked by a stream buffer read then xBytesToStoreMessageLength will
    750          			be 0. */
    751          			if( xBytesAvailable <= xBytesToStoreMessageLength )
   \       0x56   0x45D1             CMP      R9,R10
   \       0x58   0xD310             BCC.N    ??xStreamBufferReceive_7
    752          			{
    753          				/* Clear notification state as going to wait for data. */
    754          				( void ) xTaskNotifyStateClear( NULL );
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x.... 0x....      BL       xTaskNotifyStateClear
    755          
    756          				/* Should only be one reader. */
    757          				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
   \       0x60   0x6928             LDR      R0,[R5, #+16]
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD007             BEQ.N    ??xStreamBufferReceive_8
   \       0x66   0x2050             MOVS     R0,#+80
   \       0x68   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x6C   0xF3BF 0x8F4F      DSB      SY
   \       0x70   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferReceive_9: (+1)
   \       0x74   0xE7FE             B.N      ??xStreamBufferReceive_9
    758          				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
   \                     ??xStreamBufferReceive_8: (+1)
   \       0x76   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \       0x7A   0x6128             STR      R0,[R5, #+16]
    759          			}
    760          			else
    761          			{
    762          				mtCOVERAGE_TEST_MARKER();
    763          			}
    764          		}
    765          		taskEXIT_CRITICAL();
   \                     ??xStreamBufferReceive_7: (+1)
   \       0x7C   0x.... 0x....      BL       vPortExitCritical
    766          
    767          		if( xBytesAvailable <= xBytesToStoreMessageLength )
   \       0x80   0x45D1             CMP      R9,R10
   \       0x82   0xD310             BCC.N    ??xStreamBufferReceive_10
    768          		{
    769          			/* Wait for data to be available. */
    770          			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
    771          			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
   \       0x84   0x003B             MOVS     R3,R7
   \       0x86   0x2200             MOVS     R2,#+0
   \       0x88   0x2100             MOVS     R1,#+0
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0x.... 0x....      BL       xTaskNotifyWait
    772          			pxStreamBuffer->xTaskWaitingToReceive = NULL;
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0x6128             STR      R0,[R5, #+16]
    773          
    774          			/* Recheck the data available after blocking. */
    775          			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
   \       0x94   0x0028             MOVS     R0,R5
   \       0x96   0x.... 0x....      BL       prvBytesInBuffer
   \       0x9A   0x4682             MOV      R10,R0
   \       0x9C   0xE003             B.N      ??xStreamBufferReceive_10
    776          		}
    777          		else
    778          		{
    779          			mtCOVERAGE_TEST_MARKER();
    780          		}
    781          	}
    782          	else
    783          	{
    784          		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
   \                     ??xStreamBufferReceive_6: (+1)
   \       0x9E   0x0028             MOVS     R0,R5
   \       0xA0   0x.... 0x....      BL       prvBytesInBuffer
   \       0xA4   0x4682             MOV      R10,R0
    785          	}
    786          
    787          	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
    788          	holds the number of bytes used to store the message length) or a stream of
    789          	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
    790          	available must be greater than xBytesToStoreMessageLength to be able to
    791          	read bytes from the buffer. */
    792          	if( xBytesAvailable > xBytesToStoreMessageLength )
   \                     ??xStreamBufferReceive_10: (+1)
   \       0xA6   0x45D1             CMP      R9,R10
   \       0xA8   0xD219             BCS.N    ??xStreamBufferReceive_11
    793          	{
    794          		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
   \       0xAA   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0xAE   0x4653             MOV      R3,R10
   \       0xB0   0x4642             MOV      R2,R8
   \       0xB2   0x0031             MOVS     R1,R6
   \       0xB4   0x0028             MOVS     R0,R5
   \       0xB6   0x.... 0x....      BL       prvReadMessageFromBuffer
   \       0xBA   0x0004             MOVS     R4,R0
    795          
    796          		/* Was a task waiting for space in the buffer? */
    797          		if( xReceivedLength != ( size_t ) 0 )
   \       0xBC   0x2C00             CMP      R4,#+0
   \       0xBE   0xD00E             BEQ.N    ??xStreamBufferReceive_11
    798          		{
    799          			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
    800          			sbRECEIVE_COMPLETED( pxStreamBuffer );
   \       0xC0   0x.... 0x....      BL       vTaskSuspendAll
   \       0xC4   0x6968             LDR      R0,[R5, #+20]
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD007             BEQ.N    ??xStreamBufferReceive_12
   \       0xCA   0x2300             MOVS     R3,#+0
   \       0xCC   0x2200             MOVS     R2,#+0
   \       0xCE   0x2100             MOVS     R1,#+0
   \       0xD0   0x6968             LDR      R0,[R5, #+20]
   \       0xD2   0x.... 0x....      BL       xTaskGenericNotify
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0x6168             STR      R0,[R5, #+20]
   \                     ??xStreamBufferReceive_12: (+1)
   \       0xDA   0x.... 0x....      BL       xTaskResumeAll
    801          		}
    802          		else
    803          		{
    804          			mtCOVERAGE_TEST_MARKER();
    805          		}
    806          	}
    807          	else
    808          	{
    809          		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
    810          		mtCOVERAGE_TEST_MARKER();
    811          	}
    812          
    813          	return xReceivedLength;
   \                     ??xStreamBufferReceive_11: (+1)
   \       0xDE   0x0020             MOVS     R0,R4
   \       0xE0   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
    814          }
    815          /*-----------------------------------------------------------*/
    816          

   \                                 In section .text, align 2, keep-with-next
    817          size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
    818          {
   \                     xStreamBufferNextMessageLengthBytes: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    819          StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    820          size_t xReturn, xBytesAvailable, xOriginalTail;
    821          configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;
    822          
    823          	configASSERT( pxStreamBuffer );
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD107             BNE.N    ??xStreamBufferNextMessageLengthBytes_0
   \        0x8   0x2050             MOVS     R0,#+80
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferNextMessageLengthBytes_1: (+1)
   \       0x16   0xE7FE             B.N      ??xStreamBufferNextMessageLengthBytes_1
    824          
    825          	/* Ensure the stream buffer is being used as a message buffer. */
    826          	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
   \                     ??xStreamBufferNextMessageLengthBytes_0: (+1)
   \       0x18   0x7F20             LDRB     R0,[R4, #+28]
   \       0x1A   0x07C0             LSLS     R0,R0,#+31
   \       0x1C   0xD51A             BPL.N    ??xStreamBufferNextMessageLengthBytes_2
    827          	{
    828          		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       prvBytesInBuffer
   \       0x24   0x0003             MOVS     R3,R0
    829          		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
   \       0x26   0x2B05             CMP      R3,#+5
   \       0x28   0xD308             BCC.N    ??xStreamBufferNextMessageLengthBytes_3
    830          		{
    831          			/* The number of bytes available is greater than the number of bytes
    832          			required to hold the length of the next message, so another message
    833          			is available.  Return its length without removing the length bytes
    834          			from the buffer.  A copy of the tail is stored so the buffer can be
    835          			returned to its prior state as the message is not actually being
    836          			removed from the buffer. */
    837          			xOriginalTail = pxStreamBuffer->xTail;
   \       0x2A   0x6825             LDR      R5,[R4, #+0]
    838          			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
   \       0x2C   0x2204             MOVS     R2,#+4
   \       0x2E   0x4669             MOV      R1,SP
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       prvReadBytesFromBuffer
    839          			xReturn = ( size_t ) xTempReturn;
   \       0x36   0x9800             LDR      R0,[SP, #+0]
    840          			pxStreamBuffer->xTail = xOriginalTail;
   \       0x38   0x6025             STR      R5,[R4, #+0]
   \       0x3A   0xE00C             B.N      ??xStreamBufferNextMessageLengthBytes_4
    841          		}
    842          		else
    843          		{
    844          			/* The minimum amount of bytes in a message buffer is
    845          			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
    846          			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
    847          			value is 0. */
    848          			configASSERT( xBytesAvailable == 0 );
   \                     ??xStreamBufferNextMessageLengthBytes_3: (+1)
   \       0x3C   0x2B00             CMP      R3,#+0
   \       0x3E   0xD007             BEQ.N    ??xStreamBufferNextMessageLengthBytes_5
   \       0x40   0x2050             MOVS     R0,#+80
   \       0x42   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x46   0xF3BF 0x8F4F      DSB      SY
   \       0x4A   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferNextMessageLengthBytes_6: (+1)
   \       0x4E   0xE7FE             B.N      ??xStreamBufferNextMessageLengthBytes_6
    849          			xReturn = 0;
   \                     ??xStreamBufferNextMessageLengthBytes_5: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xE000             B.N      ??xStreamBufferNextMessageLengthBytes_4
    850          		}
    851          	}
    852          	else
    853          	{
    854          		xReturn = 0;
   \                     ??xStreamBufferNextMessageLengthBytes_2: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
    855          	}
    856          
    857          	return xReturn;
   \                     ??xStreamBufferNextMessageLengthBytes_4: (+1)
   \       0x56   0xBD32             POP      {R1,R4,R5,PC}
    858          }
    859          /*-----------------------------------------------------------*/
    860          

   \                                 In section .text, align 2, keep-with-next
    861          size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
    862          									void *pvRxData,
    863          									size_t xBufferLengthBytes,
    864          									BaseType_t * const pxHigherPriorityTaskWoken )
    865          {
   \                     xStreamBufferReceiveFromISR: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001F             MOVS     R7,R3
    866          StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    867          size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
   \        0xC   0x2400             MOVS     R4,#+0
    868          
    869          	configASSERT( pvRxData );
   \        0xE   0x2E00             CMP      R6,#+0
   \       0x10   0xD107             BNE.N    ??xStreamBufferReceiveFromISR_0
   \       0x12   0x2050             MOVS     R0,#+80
   \       0x14   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x18   0xF3BF 0x8F4F      DSB      SY
   \       0x1C   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferReceiveFromISR_1: (+1)
   \       0x20   0xE7FE             B.N      ??xStreamBufferReceiveFromISR_1
    870          	configASSERT( pxStreamBuffer );
   \                     ??xStreamBufferReceiveFromISR_0: (+1)
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD107             BNE.N    ??xStreamBufferReceiveFromISR_2
   \       0x26   0x2050             MOVS     R0,#+80
   \       0x28   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2C   0xF3BF 0x8F4F      DSB      SY
   \       0x30   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferReceiveFromISR_3: (+1)
   \       0x34   0xE7FE             B.N      ??xStreamBufferReceiveFromISR_3
    871          
    872          	/* This receive function is used by both message buffers, which store
    873          	discrete messages, and stream buffers, which store a continuous stream of
    874          	bytes.  Discrete messages include an additional
    875          	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
    876          	message. */
    877          	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
   \                     ??xStreamBufferReceiveFromISR_2: (+1)
   \       0x36   0x7F28             LDRB     R0,[R5, #+28]
   \       0x38   0x07C0             LSLS     R0,R0,#+31
   \       0x3A   0xD502             BPL.N    ??xStreamBufferReceiveFromISR_4
    878          	{
    879          		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
   \       0x3C   0xF05F 0x0904      MOVS     R9,#+4
   \       0x40   0xE001             B.N      ??xStreamBufferReceiveFromISR_5
    880          	}
    881          	else
    882          	{
    883          		xBytesToStoreMessageLength = 0;
   \                     ??xStreamBufferReceiveFromISR_4: (+1)
   \       0x42   0xF05F 0x0900      MOVS     R9,#+0
    884          	}
    885          
    886          	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
   \                     ??xStreamBufferReceiveFromISR_5: (+1)
   \       0x46   0x0028             MOVS     R0,R5
   \       0x48   0x.... 0x....      BL       prvBytesInBuffer
    887          
    888          	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
    889          	holds the number of bytes used to store the message length) or a stream of
    890          	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
    891          	available must be greater than xBytesToStoreMessageLength to be able to
    892          	read bytes from the buffer. */
    893          	if( xBytesAvailable > xBytesToStoreMessageLength )
   \       0x4C   0x4581             CMP      R9,R0
   \       0x4E   0xD221             BCS.N    ??xStreamBufferReceiveFromISR_6
    894          	{
    895          		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
   \       0x50   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0x54   0x0003             MOVS     R3,R0
   \       0x56   0x4642             MOV      R2,R8
   \       0x58   0x0031             MOVS     R1,R6
   \       0x5A   0x0028             MOVS     R0,R5
   \       0x5C   0x.... 0x....      BL       prvReadMessageFromBuffer
   \       0x60   0x0004             MOVS     R4,R0
    896          
    897          		/* Was a task waiting for space in the buffer? */
    898          		if( xReceivedLength != ( size_t ) 0 )
   \       0x62   0x2C00             CMP      R4,#+0
   \       0x64   0xD016             BEQ.N    ??xStreamBufferReceiveFromISR_6
    899          		{
    900          			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
   \       0x66   0xF3EF 0x8611      MRS      R6,BASEPRI
   \       0x6A   0x2050             MOVS     R0,#+80
   \       0x6C   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x70   0xF3BF 0x8F4F      DSB      SY
   \       0x74   0xF3BF 0x8F6F      ISB      SY
   \       0x78   0x6968             LDR      R0,[R5, #+20]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD008             BEQ.N    ??xStreamBufferReceiveFromISR_7
   \       0x7E   0x9700             STR      R7,[SP, #+0]
   \       0x80   0x2300             MOVS     R3,#+0
   \       0x82   0x2200             MOVS     R2,#+0
   \       0x84   0x2100             MOVS     R1,#+0
   \       0x86   0x6968             LDR      R0,[R5, #+20]
   \       0x88   0x.... 0x....      BL       xTaskGenericNotifyFromISR
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0x6168             STR      R0,[R5, #+20]
   \                     ??xStreamBufferReceiveFromISR_7: (+1)
   \       0x90   0xF386 0x8811      MSR      BASEPRI,R6
    901          		}
    902          		else
    903          		{
    904          			mtCOVERAGE_TEST_MARKER();
    905          		}
    906          	}
    907          	else
    908          	{
    909          		mtCOVERAGE_TEST_MARKER();
    910          	}
    911          
    912          	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );
    913          
    914          	return xReceivedLength;
   \                     ??xStreamBufferReceiveFromISR_6: (+1)
   \       0x94   0x0020             MOVS     R0,R4
   \       0x96   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    915          }
    916          /*-----------------------------------------------------------*/
    917          

   \                                 In section .text, align 2, keep-with-next
    918          static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
    919          										void *pvRxData,
    920          										size_t xBufferLengthBytes,
    921          										size_t xBytesAvailable,
    922          										size_t xBytesToStoreMessageLength )
    923          {
   \                     prvReadMessageFromBuffer: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   \        0xC   0x9C08             LDR      R4,[SP, #+32]
    924          size_t xOriginalTail, xReceivedLength, xNextMessageLength;
    925          configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    926          
    927          	if( xBytesToStoreMessageLength != ( size_t ) 0 )
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD010             BEQ.N    ??prvReadMessageFromBuffer_0
    928          	{
    929          		/* A discrete message is being received.  First receive the length
    930          		of the message.  A copy of the tail is stored so the buffer can be
    931          		returned to its prior state if the length of the message is too
    932          		large for the provided buffer. */
    933          		xOriginalTail = pxStreamBuffer->xTail;
   \       0x12   0xF8D5 0x9000      LDR      R9,[R5, #+0]
    934          		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
   \       0x16   0x4643             MOV      R3,R8
   \       0x18   0x0022             MOVS     R2,R4
   \       0x1A   0x4669             MOV      R1,SP
   \       0x1C   0x0028             MOVS     R0,R5
   \       0x1E   0x.... 0x....      BL       prvReadBytesFromBuffer
    935          		xNextMessageLength = ( size_t ) xTempNextMessageLength;
   \       0x22   0x9A00             LDR      R2,[SP, #+0]
    936          
    937          		/* Reduce the number of bytes available by the number of bytes just
    938          		read out. */
    939          		xBytesAvailable -= xBytesToStoreMessageLength;
   \       0x24   0xEBB8 0x0804      SUBS     R8,R8,R4
    940          
    941          		/* Check there is enough space in the buffer provided by the
    942          		user. */
    943          		if( xNextMessageLength > xBufferLengthBytes )
   \       0x28   0x4297             CMP      R7,R2
   \       0x2A   0xD204             BCS.N    ??prvReadMessageFromBuffer_1
    944          		{
    945          			/* The user has provided insufficient space to read the message
    946          			so return the buffer to its previous state (so the length of
    947          			the message is in the buffer again). */
    948          			pxStreamBuffer->xTail = xOriginalTail;
   \       0x2C   0xF8C5 0x9000      STR      R9,[R5, #+0]
    949          			xNextMessageLength = 0;
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0xE000             B.N      ??prvReadMessageFromBuffer_1
    950          		}
    951          		else
    952          		{
    953          			mtCOVERAGE_TEST_MARKER();
    954          		}
    955          	}
    956          	else
    957          	{
    958          		/* A stream of bytes is being received (as opposed to a discrete
    959          		message), so read as many bytes as possible. */
    960          		xNextMessageLength = xBufferLengthBytes;
   \                     ??prvReadMessageFromBuffer_0: (+1)
   \       0x34   0x003A             MOVS     R2,R7
    961          	}
    962          
    963          	/* Read the actual data. */
    964          	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
   \                     ??prvReadMessageFromBuffer_1: (+1)
   \       0x36   0x4643             MOV      R3,R8
   \       0x38   0x0031             MOVS     R1,R6
   \       0x3A   0x0028             MOVS     R0,R5
   \       0x3C   0x.... 0x....      BL       prvReadBytesFromBuffer
    965          
    966          	return xReceivedLength;
   \       0x40   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    967          }
    968          /*-----------------------------------------------------------*/
    969          

   \                                 In section .text, align 2, keep-with-next
    970          BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
    971          {
    972          const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    973          BaseType_t xReturn;
    974          size_t xTail;
    975          
    976          	configASSERT( pxStreamBuffer );
   \                     xStreamBufferIsEmpty: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD107             BNE.N    ??xStreamBufferIsEmpty_0
   \        0x4   0x2050             MOVS     R0,#+80
   \        0x6   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xA   0xF3BF 0x8F4F      DSB      SY
   \        0xE   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferIsEmpty_1: (+1)
   \       0x12   0xE7FE             B.N      ??xStreamBufferIsEmpty_1
    977          
    978          	/* True if no bytes are available. */
    979          	xTail = pxStreamBuffer->xTail;
   \                     ??xStreamBufferIsEmpty_0: (+1)
   \       0x14   0x6801             LDR      R1,[R0, #+0]
    980          	if( pxStreamBuffer->xHead == xTail )
   \       0x16   0x6840             LDR      R0,[R0, #+4]
   \       0x18   0x4288             CMP      R0,R1
   \       0x1A   0xD101             BNE.N    ??xStreamBufferIsEmpty_2
    981          	{
    982          		xReturn = pdTRUE;
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE000             B.N      ??xStreamBufferIsEmpty_3
    983          	}
    984          	else
    985          	{
    986          		xReturn = pdFALSE;
   \                     ??xStreamBufferIsEmpty_2: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
    987          	}
    988          
    989          	return xReturn;
   \                     ??xStreamBufferIsEmpty_3: (+1)
   \       0x22   0x4770             BX       LR
    990          }
    991          /*-----------------------------------------------------------*/
    992          

   \                                 In section .text, align 2, keep-with-next
    993          BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
    994          {
   \                     xStreamBufferIsFull: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    995          BaseType_t xReturn;
    996          size_t xBytesToStoreMessageLength;
    997          const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
   \        0x2   0x0001             MOVS     R1,R0
    998          
    999          	configASSERT( pxStreamBuffer );
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD107             BNE.N    ??xStreamBufferIsFull_0
   \        0x8   0x2050             MOVS     R0,#+80
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferIsFull_1: (+1)
   \       0x16   0xE7FE             B.N      ??xStreamBufferIsFull_1
   1000          
   1001          	/* This generic version of the receive function is used by both message
   1002          	buffers, which store discrete messages, and stream buffers, which store a
   1003          	continuous stream of bytes.  Discrete messages include an additional
   1004          	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
   1005          	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
   \                     ??xStreamBufferIsFull_0: (+1)
   \       0x18   0x7F09             LDRB     R1,[R1, #+28]
   \       0x1A   0x07C9             LSLS     R1,R1,#+31
   \       0x1C   0xD501             BPL.N    ??xStreamBufferIsFull_2
   1006          	{
   1007          		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
   \       0x1E   0x2404             MOVS     R4,#+4
   \       0x20   0xE000             B.N      ??xStreamBufferIsFull_3
   1008          	}
   1009          	else
   1010          	{
   1011          		xBytesToStoreMessageLength = 0;
   \                     ??xStreamBufferIsFull_2: (+1)
   \       0x22   0x2400             MOVS     R4,#+0
   1012          	}
   1013          
   1014          	/* True if the available space equals zero. */
   1015          	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
   \                     ??xStreamBufferIsFull_3: (+1)
   \       0x24   0x.... 0x....      BL       xStreamBufferSpacesAvailable
   \       0x28   0x4284             CMP      R4,R0
   \       0x2A   0xD301             BCC.N    ??xStreamBufferIsFull_4
   1016          	{
   1017          		xReturn = pdTRUE;
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xE000             B.N      ??xStreamBufferIsFull_5
   1018          	}
   1019          	else
   1020          	{
   1021          		xReturn = pdFALSE;
   \                     ??xStreamBufferIsFull_4: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   1022          	}
   1023          
   1024          	return xReturn;
   \                     ??xStreamBufferIsFull_5: (+1)
   \       0x32   0xBD10             POP      {R4,PC}
   1025          }
   1026          /*-----------------------------------------------------------*/
   1027          

   \                                 In section .text, align 2, keep-with-next
   1028          BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
   1029          {
   \                     xStreamBufferSendCompletedFromISR: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1030          StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
   1031          BaseType_t xReturn;
   1032          UBaseType_t uxSavedInterruptStatus;
   1033          
   1034          	configASSERT( pxStreamBuffer );
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD107             BNE.N    ??xStreamBufferSendCompletedFromISR_0
   \        0x8   0x2050             MOVS     R0,#+80
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferSendCompletedFromISR_1: (+1)
   \       0x16   0xE7FE             B.N      ??xStreamBufferSendCompletedFromISR_1
   1035          
   1036          	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
   \                     ??xStreamBufferSendCompletedFromISR_0: (+1)
   \       0x18   0xF3EF 0x8511      MRS      R5,BASEPRI
   \       0x1C   0x2050             MOVS     R0,#+80
   \       0x1E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x22   0xF3BF 0x8F4F      DSB      SY
   \       0x26   0xF3BF 0x8F6F      ISB      SY
   1037          	{
   1038          		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
   \       0x2A   0x6920             LDR      R0,[R4, #+16]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD00A             BEQ.N    ??xStreamBufferSendCompletedFromISR_2
   1039          		{
   1040          			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
   1041          										 ( uint32_t ) 0,
   1042          										 eNoAction,
   1043          										 pxHigherPriorityTaskWoken );
   \       0x30   0x9100             STR      R1,[SP, #+0]
   \       0x32   0x2300             MOVS     R3,#+0
   \       0x34   0x2200             MOVS     R2,#+0
   \       0x36   0x2100             MOVS     R1,#+0
   \       0x38   0x6920             LDR      R0,[R4, #+16]
   \       0x3A   0x.... 0x....      BL       xTaskGenericNotifyFromISR
   1044          			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x6120             STR      R0,[R4, #+16]
   1045          			xReturn = pdTRUE;
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0xE000             B.N      ??xStreamBufferSendCompletedFromISR_3
   1046          		}
   1047          		else
   1048          		{
   1049          			xReturn = pdFALSE;
   \                     ??xStreamBufferSendCompletedFromISR_2: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   1050          		}
   1051          	}
   1052          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xStreamBufferSendCompletedFromISR_3: (+1)
   \       0x48   0xF385 0x8811      MSR      BASEPRI,R5
   1053          
   1054          	return xReturn;
   \       0x4C   0xBD32             POP      {R1,R4,R5,PC}
   1055          }
   1056          /*-----------------------------------------------------------*/
   1057          

   \                                 In section .text, align 2, keep-with-next
   1058          BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
   1059          {
   \                     xStreamBufferReceiveCompletedFromISR: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1060          StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
   1061          BaseType_t xReturn;
   1062          UBaseType_t uxSavedInterruptStatus;
   1063          
   1064          	configASSERT( pxStreamBuffer );
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD107             BNE.N    ??xStreamBufferReceiveCompletedFromISR_0
   \        0x8   0x2050             MOVS     R0,#+80
   \        0xA   0xF380 0x8811      MSR      BASEPRI,R0
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
   \                     ??xStreamBufferReceiveCompletedFromISR_1: (+1)
   \       0x16   0xE7FE             B.N      ??xStreamBufferReceiveCompletedFromISR_1
   1065          
   1066          	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
   \                     ??xStreamBufferReceiveCompletedFromISR_0: (+1)
   \       0x18   0xF3EF 0x8511      MRS      R5,BASEPRI
   \       0x1C   0x2050             MOVS     R0,#+80
   \       0x1E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x22   0xF3BF 0x8F4F      DSB      SY
   \       0x26   0xF3BF 0x8F6F      ISB      SY
   1067          	{
   1068          		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
   \       0x2A   0x6960             LDR      R0,[R4, #+20]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD00A             BEQ.N    ??xStreamBufferReceiveCompletedFromISR_2
   1069          		{
   1070          			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
   1071          										 ( uint32_t ) 0,
   1072          										 eNoAction,
   1073          										 pxHigherPriorityTaskWoken );
   \       0x30   0x9100             STR      R1,[SP, #+0]
   \       0x32   0x2300             MOVS     R3,#+0
   \       0x34   0x2200             MOVS     R2,#+0
   \       0x36   0x2100             MOVS     R1,#+0
   \       0x38   0x6960             LDR      R0,[R4, #+20]
   \       0x3A   0x.... 0x....      BL       xTaskGenericNotifyFromISR
   1074          			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x6160             STR      R0,[R4, #+20]
   1075          			xReturn = pdTRUE;
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0xE000             B.N      ??xStreamBufferReceiveCompletedFromISR_3
   1076          		}
   1077          		else
   1078          		{
   1079          			xReturn = pdFALSE;
   \                     ??xStreamBufferReceiveCompletedFromISR_2: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   1080          		}
   1081          	}
   1082          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xStreamBufferReceiveCompletedFromISR_3: (+1)
   \       0x48   0xF385 0x8811      MSR      BASEPRI,R5
   1083          
   1084          	return xReturn;
   \       0x4C   0xBD32             POP      {R1,R4,R5,PC}
   1085          }
   1086          /*-----------------------------------------------------------*/
   1087          

   \                                 In section .text, align 2, keep-with-next
   1088          static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
   1089          {
   \                     prvWriteBytesToBuffer: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x0014             MOVS     R4,R2
   1090          size_t xNextHead, xFirstLength;
   1091          
   1092          	configASSERT( xCount > ( size_t ) 0 );
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD107             BNE.N    ??prvWriteBytesToBuffer_0
   \        0xE   0x2050             MOVS     R0,#+80
   \       0x10   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x14   0xF3BF 0x8F4F      DSB      SY
   \       0x18   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvWriteBytesToBuffer_1: (+1)
   \       0x1C   0xE7FE             B.N      ??prvWriteBytesToBuffer_1
   1093          
   1094          	xNextHead = pxStreamBuffer->xHead;
   \                     ??prvWriteBytesToBuffer_0: (+1)
   \       0x1E   0x6875             LDR      R5,[R6, #+4]
   1095          
   1096          	/* Calculate the number of bytes that can be added in the first write -
   1097          	which may be less than the total number of bytes that need to be added if
   1098          	the buffer will wrap back to the beginning. */
   1099          	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
   \       0x20   0x68B0             LDR      R0,[R6, #+8]
   \       0x22   0x1B40             SUBS     R0,R0,R5
   \       0x24   0x42A0             CMP      R0,R4
   \       0x26   0xD202             BCS.N    ??prvWriteBytesToBuffer_2
   \       0x28   0x68B7             LDR      R7,[R6, #+8]
   \       0x2A   0x1B7F             SUBS     R7,R7,R5
   \       0x2C   0xE000             B.N      ??prvWriteBytesToBuffer_3
   \                     ??prvWriteBytesToBuffer_2: (+1)
   \       0x2E   0x0027             MOVS     R7,R4
   1100          
   1101          	/* Write as many bytes as can be written in the first write. */
   1102          	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
   \                     ??prvWriteBytesToBuffer_3: (+1)
   \       0x30   0x68B0             LDR      R0,[R6, #+8]
   \       0x32   0x1979             ADDS     R1,R7,R5
   \       0x34   0x4288             CMP      R0,R1
   \       0x36   0xD207             BCS.N    ??prvWriteBytesToBuffer_4
   \       0x38   0x2050             MOVS     R0,#+80
   \       0x3A   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x3E   0xF3BF 0x8F4F      DSB      SY
   \       0x42   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvWriteBytesToBuffer_5: (+1)
   \       0x46   0xE7FE             B.N      ??prvWriteBytesToBuffer_5
   1103          	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
   \                     ??prvWriteBytesToBuffer_4: (+1)
   \       0x48   0x003A             MOVS     R2,R7
   \       0x4A   0x4641             MOV      R1,R8
   \       0x4C   0x69B0             LDR      R0,[R6, #+24]
   \       0x4E   0xEB00 0x0905      ADD      R9,R0,R5
   \       0x52   0x4648             MOV      R0,R9
   \       0x54   0x.... 0x....      BL       __aeabi_memcpy
   1104          
   1105          	/* If the number of bytes written was less than the number that could be
   1106          	written in the first write... */
   1107          	if( xCount > xFirstLength )
   \       0x58   0x42A7             CMP      R7,R4
   \       0x5A   0xD212             BCS.N    ??prvWriteBytesToBuffer_6
   1108          	{
   1109          		/* ...then write the remaining bytes to the start of the buffer. */
   1110          		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
   \       0x5C   0x68B0             LDR      R0,[R6, #+8]
   \       0x5E   0x1BE1             SUBS     R1,R4,R7
   \       0x60   0x4288             CMP      R0,R1
   \       0x62   0xD207             BCS.N    ??prvWriteBytesToBuffer_7
   \       0x64   0x2050             MOVS     R0,#+80
   \       0x66   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x6A   0xF3BF 0x8F4F      DSB      SY
   \       0x6E   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvWriteBytesToBuffer_8: (+1)
   \       0x72   0xE7FE             B.N      ??prvWriteBytesToBuffer_8
   1111          		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
   \                     ??prvWriteBytesToBuffer_7: (+1)
   \       0x74   0x1BE2             SUBS     R2,R4,R7
   \       0x76   0xEB08 0x0107      ADD      R1,R8,R7
   \       0x7A   0x69B7             LDR      R7,[R6, #+24]
   \       0x7C   0x0038             MOVS     R0,R7
   \       0x7E   0x.... 0x....      BL       __aeabi_memcpy
   1112          	}
   1113          	else
   1114          	{
   1115          		mtCOVERAGE_TEST_MARKER();
   1116          	}
   1117          
   1118          	xNextHead += xCount;
   \                     ??prvWriteBytesToBuffer_6: (+1)
   \       0x82   0x1965             ADDS     R5,R4,R5
   1119          	if( xNextHead >= pxStreamBuffer->xLength )
   \       0x84   0x68B0             LDR      R0,[R6, #+8]
   \       0x86   0x4285             CMP      R5,R0
   \       0x88   0xD301             BCC.N    ??prvWriteBytesToBuffer_9
   1120          	{
   1121          		xNextHead -= pxStreamBuffer->xLength;
   \       0x8A   0x68B0             LDR      R0,[R6, #+8]
   \       0x8C   0x1A2D             SUBS     R5,R5,R0
   1122          	}
   1123          	else
   1124          	{
   1125          		mtCOVERAGE_TEST_MARKER();
   1126          	}
   1127          
   1128          	pxStreamBuffer->xHead = xNextHead;
   \                     ??prvWriteBytesToBuffer_9: (+1)
   \       0x8E   0x6075             STR      R5,[R6, #+4]
   1129          
   1130          	return xCount;
   \       0x90   0x0020             MOVS     R0,R4
   \       0x92   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1131          }
   1132          /*-----------------------------------------------------------*/
   1133          

   \                                 In section .text, align 2, keep-with-next
   1134          static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
   1135          {
   \                     prvReadBytesFromBuffer: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x468A             MOV      R10,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001C             MOVS     R4,R3
   1136          size_t xCount, xFirstLength, xNextTail;
   1137          
   1138          	/* Use the minimum of the wanted bytes and the available bytes. */
   1139          	xCount = configMIN( xBytesAvailable, xMaxCount );
   \        0xC   0x42AC             CMP      R4,R5
   \        0xE   0xD300             BCC.N    ??prvReadBytesFromBuffer_0
   \                     ??prvReadBytesFromBuffer_1: (+1)
   \       0x10   0x002C             MOVS     R4,R5
   1140          
   1141          	if( xCount > ( size_t ) 0 )
   \                     ??prvReadBytesFromBuffer_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD049             BEQ.N    ??prvReadBytesFromBuffer_2
   1142          	{
   1143          		xNextTail = pxStreamBuffer->xTail;
   \       0x16   0xF8D9 0x7000      LDR      R7,[R9, #+0]
   1144          
   1145          		/* Calculate the number of bytes that can be read - which may be
   1146          		less than the number wanted if the data wraps around to the start of
   1147          		the buffer. */
   1148          		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
   \       0x1A   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0x1E   0x1BC0             SUBS     R0,R0,R7
   \       0x20   0x42A0             CMP      R0,R4
   \       0x22   0xD203             BCS.N    ??prvReadBytesFromBuffer_3
   \       0x24   0xF8D9 0x6008      LDR      R6,[R9, #+8]
   \       0x28   0x1BF6             SUBS     R6,R6,R7
   \       0x2A   0xE000             B.N      ??prvReadBytesFromBuffer_4
   \                     ??prvReadBytesFromBuffer_3: (+1)
   \       0x2C   0x0026             MOVS     R6,R4
   1149          
   1150          		/* Obtain the number of bytes it is possible to obtain in the first
   1151          		read.  Asserts check bounds of read and write. */
   1152          		configASSERT( xFirstLength <= xMaxCount );
   \                     ??prvReadBytesFromBuffer_4: (+1)
   \       0x2E   0x42B5             CMP      R5,R6
   \       0x30   0xD207             BCS.N    ??prvReadBytesFromBuffer_5
   \       0x32   0x2050             MOVS     R0,#+80
   \       0x34   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x38   0xF3BF 0x8F4F      DSB      SY
   \       0x3C   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvReadBytesFromBuffer_6: (+1)
   \       0x40   0xE7FE             B.N      ??prvReadBytesFromBuffer_6
   1153          		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
   \                     ??prvReadBytesFromBuffer_5: (+1)
   \       0x42   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0x46   0x19F1             ADDS     R1,R6,R7
   \       0x48   0x4288             CMP      R0,R1
   \       0x4A   0xD207             BCS.N    ??prvReadBytesFromBuffer_7
   \       0x4C   0x2050             MOVS     R0,#+80
   \       0x4E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x52   0xF3BF 0x8F4F      DSB      SY
   \       0x56   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvReadBytesFromBuffer_8: (+1)
   \       0x5A   0xE7FE             B.N      ??prvReadBytesFromBuffer_8
   1154          		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
   \                     ??prvReadBytesFromBuffer_7: (+1)
   \       0x5C   0x0032             MOVS     R2,R6
   \       0x5E   0xF8D9 0x0018      LDR      R0,[R9, #+24]
   \       0x62   0xEB00 0x0107      ADD      R1,R0,R7
   \       0x66   0x46D0             MOV      R8,R10
   \       0x68   0x4640             MOV      R0,R8
   \       0x6A   0x.... 0x....      BL       __aeabi_memcpy
   1155          
   1156          		/* If the total number of wanted bytes is greater than the number
   1157          		that could be read in the first read... */
   1158          		if( xCount > xFirstLength )
   \       0x6E   0x42A6             CMP      R6,R4
   \       0x70   0xD211             BCS.N    ??prvReadBytesFromBuffer_9
   1159          		{
   1160          			/*...then read the remaining bytes from the start of the buffer. */
   1161          			configASSERT( xCount <= xMaxCount );
   \       0x72   0x42A5             CMP      R5,R4
   \       0x74   0xD207             BCS.N    ??prvReadBytesFromBuffer_10
   \       0x76   0x2050             MOVS     R0,#+80
   \       0x78   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x7C   0xF3BF 0x8F4F      DSB      SY
   \       0x80   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvReadBytesFromBuffer_11: (+1)
   \       0x84   0xE7FE             B.N      ??prvReadBytesFromBuffer_11
   1162          			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
   \                     ??prvReadBytesFromBuffer_10: (+1)
   \       0x86   0x1BA2             SUBS     R2,R4,R6
   \       0x88   0xF8D9 0x1018      LDR      R1,[R9, #+24]
   \       0x8C   0xEB0A 0x0506      ADD      R5,R10,R6
   \       0x90   0x0028             MOVS     R0,R5
   \       0x92   0x.... 0x....      BL       __aeabi_memcpy
   1163          		}
   1164          		else
   1165          		{
   1166          			mtCOVERAGE_TEST_MARKER();
   1167          		}
   1168          
   1169          		/* Move the tail pointer to effectively remove the data read from
   1170          		the buffer. */
   1171          		xNextTail += xCount;
   \                     ??prvReadBytesFromBuffer_9: (+1)
   \       0x96   0x19E7             ADDS     R7,R4,R7
   1172          
   1173          		if( xNextTail >= pxStreamBuffer->xLength )
   \       0x98   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0x9C   0x4287             CMP      R7,R0
   \       0x9E   0xD302             BCC.N    ??prvReadBytesFromBuffer_12
   1174          		{
   1175          			xNextTail -= pxStreamBuffer->xLength;
   \       0xA0   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0xA4   0x1A3F             SUBS     R7,R7,R0
   1176          		}
   1177          
   1178          		pxStreamBuffer->xTail = xNextTail;
   \                     ??prvReadBytesFromBuffer_12: (+1)
   \       0xA6   0xF8C9 0x7000      STR      R7,[R9, #+0]
   1179          	}
   1180          	else
   1181          	{
   1182          		mtCOVERAGE_TEST_MARKER();
   1183          	}
   1184          
   1185          	return xCount;
   \                     ??prvReadBytesFromBuffer_2: (+1)
   \       0xAA   0x0020             MOVS     R0,R4
   \       0xAC   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1186          }
   1187          /*-----------------------------------------------------------*/
   1188          

   \                                 In section .text, align 2, keep-with-next
   1189          static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
   1190          {
   \                     prvBytesInBuffer: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   1191          /* Returns the distance between xTail and xHead. */
   1192          size_t xCount;
   1193          
   1194          	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
   \        0x2   0x6888             LDR      R0,[R1, #+8]
   \        0x4   0x684A             LDR      R2,[R1, #+4]
   \        0x6   0x1810             ADDS     R0,R2,R0
   1195          	xCount -= pxStreamBuffer->xTail;
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0x1A80             SUBS     R0,R0,R2
   1196          	if ( xCount >= pxStreamBuffer->xLength )
   \        0xC   0x688A             LDR      R2,[R1, #+8]
   \        0xE   0x4290             CMP      R0,R2
   \       0x10   0xD301             BCC.N    ??prvBytesInBuffer_0
   1197          	{
   1198          		xCount -= pxStreamBuffer->xLength;
   \       0x12   0x6889             LDR      R1,[R1, #+8]
   \       0x14   0x1A40             SUBS     R0,R0,R1
   1199          	}
   1200          	else
   1201          	{
   1202          		mtCOVERAGE_TEST_MARKER();
   1203          	}
   1204          
   1205          	return xCount;
   \                     ??prvBytesInBuffer_0: (+1)
   \       0x16   0x4770             BX       LR
   1206          }
   1207          /*-----------------------------------------------------------*/
   1208          

   \                                 In section .text, align 2, keep-with-next
   1209          static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
   1210          										  uint8_t * const pucBuffer,
   1211          										  size_t xBufferSizeBytes,
   1212          										  size_t xTriggerLevelBytes,
   1213          										  uint8_t ucFlags )
   1214          {
   \                     prvInitialiseNewStreamBuffer: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   1215          	/* Assert here is deliberately writing to the entire buffer to ensure it can
   1216          	be written to without generating exceptions, and is setting the buffer to a
   1217          	known value to assist in development/debugging. */
   1218          	#if( configASSERT_DEFINED == 1 )
   1219          	{
   1220          		/* The value written just has to be identifiable when looking at the
   1221          		memory.  Don't use 0xA5 as that is the stack fill value and could
   1222          		result in confusion as to what is actually being observed. */
   1223          		const BaseType_t xWriteValue = 0x55;
   \        0xC   0x2255             MOVS     R2,#+85
   1224          		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
   \        0xE   0x0039             MOVS     R1,R7
   \       0x10   0x0034             MOVS     R4,R6
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0x.... 0x....      BL       __aeabi_memset
   \       0x18   0x42B4             CMP      R4,R6
   \       0x1A   0xD007             BEQ.N    ??prvInitialiseNewStreamBuffer_0
   \       0x1C   0x2050             MOVS     R0,#+80
   \       0x1E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x22   0xF3BF 0x8F4F      DSB      SY
   \       0x26   0xF3BF 0x8F6F      ISB      SY
   \                     ??prvInitialiseNewStreamBuffer_1: (+1)
   \       0x2A   0xE7FE             B.N      ??prvInitialiseNewStreamBuffer_1
   1225          	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
   \                     ??prvInitialiseNewStreamBuffer_0: (+1)
   \       0x2C   0x9C08             LDR      R4,[SP, #+32]
   1226          	#endif
   1227          
   1228          	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
   \       0x2E   0x2124             MOVS     R1,#+36
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0x46A9             MOV      R9,R5
   \       0x34   0x4648             MOV      R0,R9
   \       0x36   0x.... 0x....      BL       __aeabi_memset
   1229          	pxStreamBuffer->pucBuffer = pucBuffer;
   \       0x3A   0x61AE             STR      R6,[R5, #+24]
   1230          	pxStreamBuffer->xLength = xBufferSizeBytes;
   \       0x3C   0x60AF             STR      R7,[R5, #+8]
   1231          	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
   \       0x3E   0xF8C5 0x800C      STR      R8,[R5, #+12]
   1232          	pxStreamBuffer->ucFlags = ucFlags;
   \       0x42   0x772C             STRB     R4,[R5, #+28]
   1233          }
   \       0x44   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}
   1234          
   1235          #if ( configUSE_TRACE_FACILITY == 1 )
   1236          

   \                                 In section .text, align 2, keep-with-next
   1237          	UBaseType_t uxStreamBufferGetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer )
   1238          	{
   1239          		return xStreamBuffer->uxStreamBufferNumber;
   \                     uxStreamBufferGetStreamBufferNumber: (+1)
   \        0x0   0x6A00             LDR      R0,[R0, #+32]
   \        0x2   0x4770             BX       LR
   1240          	}
   1241          
   1242          #endif /* configUSE_TRACE_FACILITY */
   1243          /*-----------------------------------------------------------*/
   1244          
   1245          #if ( configUSE_TRACE_FACILITY == 1 )
   1246          

   \                                 In section .text, align 2, keep-with-next
   1247          	void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer, UBaseType_t uxStreamBufferNumber )
   1248          	{
   1249          		xStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
   \                     vStreamBufferSetStreamBufferNumber: (+1)
   \        0x0   0x6201             STR      R1,[R0, #+32]
   1250          	}
   \        0x2   0x4770             BX       LR
   1251          
   1252          #endif /* configUSE_TRACE_FACILITY */
   1253          /*-----------------------------------------------------------*/
   1254          
   1255          #if ( configUSE_TRACE_FACILITY == 1 )
   1256          

   \                                 In section .text, align 2, keep-with-next
   1257          	uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer )
   1258          	{
   1259          		return ( xStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER );
   \                     ucStreamBufferGetStreamBufferType: (+1)
   \        0x0   0x7F00             LDRB     R0,[R0, #+28]
   \        0x2   0xF010 0x0001      ANDS     R0,R0,#0x1
   \        0x6   0x4770             BX       LR
   1260          	}
   1261          
   1262          #endif /* configUSE_TRACE_FACILITY */
   1263          /*-----------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   prvBytesInBuffer
      32   prvInitialiseNewStreamBuffer
        32   -> __aeabi_memset
      32   prvReadBytesFromBuffer
        32   -> __aeabi_memcpy
      32   prvReadMessageFromBuffer
        32   -> prvReadBytesFromBuffer
      32   prvWriteBytesToBuffer
        32   -> __aeabi_memcpy
      24   prvWriteMessageToBuffer
        24   -> prvWriteBytesToBuffer
       0   ucStreamBufferGetStreamBufferType
       0   uxStreamBufferGetStreamBufferNumber
       8   vStreamBufferDelete
         8   -> __aeabi_memset
         8   -> vPortFree
       0   vStreamBufferSetStreamBufferNumber
       8   xStreamBufferBytesAvailable
         8   -> prvBytesInBuffer
      24   xStreamBufferGenericCreate
        24   -> prvInitialiseNewStreamBuffer
        24   -> pvPortMalloc
      24   xStreamBufferGenericCreateStatic
        24   -> prvInitialiseNewStreamBuffer
       0   xStreamBufferIsEmpty
       8   xStreamBufferIsFull
         8   -> xStreamBufferSpacesAvailable
      16   xStreamBufferNextMessageLengthBytes
        16   -> prvBytesInBuffer
        16   -> prvReadBytesFromBuffer
      40   xStreamBufferReceive
        40   -> prvBytesInBuffer
        40   -> prvReadMessageFromBuffer
        40   -> vPortEnterCritical
        40   -> vPortExitCritical
        40   -> vTaskSuspendAll
        40   -> xTaskGenericNotify
        40   -> xTaskGetCurrentTaskHandle
        40   -> xTaskNotifyStateClear
        40   -> xTaskNotifyWait
        40   -> xTaskResumeAll
      16   xStreamBufferReceiveCompletedFromISR
        16   -> xTaskGenericNotifyFromISR
      32   xStreamBufferReceiveFromISR
        32   -> prvBytesInBuffer
        32   -> prvReadMessageFromBuffer
        32   -> xTaskGenericNotifyFromISR
      24   xStreamBufferReset
        24   -> prvInitialiseNewStreamBuffer
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
      40   xStreamBufferSend
        40   -> prvBytesInBuffer
        40   -> prvWriteMessageToBuffer
        40   -> vPortEnterCritical
        40   -> vPortExitCritical
        40   -> vTaskSetTimeOutState
        40   -> vTaskSuspendAll
        40   -> xStreamBufferSpacesAvailable
        40   -> xTaskCheckForTimeOut
        40   -> xTaskGenericNotify
        40   -> xTaskGetCurrentTaskHandle
        40   -> xTaskNotifyStateClear
        40   -> xTaskNotifyWait
        40   -> xTaskResumeAll
      16   xStreamBufferSendCompletedFromISR
        16   -> xTaskGenericNotifyFromISR
      32   xStreamBufferSendFromISR
        32   -> prvBytesInBuffer
        32   -> prvWriteMessageToBuffer
        32   -> xStreamBufferSpacesAvailable
        32   -> xTaskGenericNotifyFromISR
       0   xStreamBufferSetTriggerLevel
       0   xStreamBufferSpacesAvailable


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  prvBytesInBuffer
      72  prvInitialiseNewStreamBuffer
     176  prvReadBytesFromBuffer
      68  prvReadMessageFromBuffer
     150  prvWriteBytesToBuffer
      74  prvWriteMessageToBuffer
       8  ucStreamBufferGetStreamBufferType
       4  uxStreamBufferGetStreamBufferNumber
      50  vStreamBufferDelete
       4  vStreamBufferSetStreamBufferNumber
      28  xStreamBufferBytesAvailable
     118  xStreamBufferGenericCreate
     172  xStreamBufferGenericCreateStatic
      36  xStreamBufferIsEmpty
      52  xStreamBufferIsFull
      88  xStreamBufferNextMessageLengthBytes
     228  xStreamBufferReceive
      78  xStreamBufferReceiveCompletedFromISR
     154  xStreamBufferReceiveFromISR
      72  xStreamBufferReset
     268  xStreamBufferSend
      78  xStreamBufferSendCompletedFromISR
     156  xStreamBufferSendFromISR
      42  xStreamBufferSetTriggerLevel
      46  xStreamBufferSpacesAvailable

 
 2'246 bytes in section .text
 
 2'246 bytes of CODE memory

Errors: none
Warnings: none
