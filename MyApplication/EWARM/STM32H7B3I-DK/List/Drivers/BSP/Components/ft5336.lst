###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         07/Feb/2022  20:39:40
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\BSP\Components\ft5336\ft5336.c
#        [UTF-8]
#    Command line      =
#        -f
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\BSP\Components\ft5336.o.rsp
#        (D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\BSP\Components\ft5336\ft5336.c
#        -D USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\BSP\Components
#        -lA
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\BSP\Components
#        -o
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\BSP\Components
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Core/Inc\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/App\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\BSP\Components\ft5336.o.d
#    Locale            =  C
#    List file         =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\BSP\Components\ft5336.lst
#    Object file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\BSP\Components\ft5336.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\BSP\Components\ft5336\ft5336.c
      1          /**
      2            ******************************************************************************
      3            * @file    ft5336.c
      4            * @author  MCD Application Team
      5            * @brief   This file provides a set of functions needed to manage the FT5336
      6            *          IO Expander devices.
      7            ******************************************************************************
      8            * @attention
      9            *
     10            * <h2><center>&copy; Copyright (c) 2015 STMicroelectronics.
     11            * All rights reserved.</center></h2>
     12            *
     13            * This software component is licensed by ST under BSD 3-Clause license,
     14            * the "License"; You may not use this file except in compliance with the
     15            * License. You may obtain a copy of the License at:
     16            *                        opensource.org/licenses/BSD-3-Clause
     17            *
     18            ******************************************************************************
     19            */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "ft5336.h"
     23          
     24          /** @addtogroup BSP
     25            * @{
     26            */
     27          
     28          /** @addtogroup Component
     29            * @{
     30            */
     31          
     32          /** @defgroup FT5336 FT5336
     33            * @{
     34            */
     35          
     36          /* Private typedef -----------------------------------------------------------*/
     37          /* Private macro -------------------------------------------------------------*/
     38          /** @defgroup FT5336_Exported_Variables FT5336 Exported Variables
     39            * @{
     40            */
     41          
     42          /* Touch screen driver structure initialization */

   \                                 In section .data, align 4
     43          FT5336_TS_Drv_t FT5336_TS_Driver =
   \                     FT5336_TS_Driver:
   \        0x0   0x....'....        DC32 FT5336_Init, FT5336_DeInit, FT5336_GestureConfig, FT5336_ReadID

   \              0x....'....  

   \              0x....'....  

   \              0x....'....
   \       0x10   0x....'....        DC32 FT5336_GetState, FT5336_GetMultiTouchState, FT5336_GetGesture

   \              0x....'....  

   \              0x....'....
   \       0x1C   0x....'....        DC32 FT5336_GetCapabilities, FT5336_EnableIT, FT5336_DisableIT

   \              0x....'....  

   \              0x....'....
   \       0x28   0x....'....        DC32 FT5336_ClearIT, FT5336_ITStatus

   \              0x....'....
     44          {
     45            FT5336_Init,
     46            FT5336_DeInit,
     47            FT5336_GestureConfig,
     48            FT5336_ReadID,
     49            FT5336_GetState,
     50            FT5336_GetMultiTouchState,
     51            FT5336_GetGesture,
     52            FT5336_GetCapabilities,
     53            FT5336_EnableIT,
     54            FT5336_DisableIT,
     55            FT5336_ClearIT,
     56            FT5336_ITStatus
     57          };
     58          /**
     59            * @}
     60            */
     61          
     62          /** @defgroup FT5336_Private_Function_Prototypes FT5336 Private Function Prototypes
     63            * @{
     64            */
     65          #if (FT5336_AUTO_CALIBRATION_ENABLED == 1)
     66          static int32_t FT5336_TS_Calibration(FT5336_Object_t *pObj);
     67          static int32_t FT5336_Delay(FT5336_Object_t *pObj, uint32_t Delay);
     68          #endif /* FT5336_AUTO_CALIBRATION_ENABLED == 1 */
     69          static int32_t FT5336_DetectTouch(FT5336_Object_t *pObj);
     70          static int32_t ReadRegWrap(void *handle, uint8_t Reg, uint8_t* Data, uint16_t Length);
     71          static int32_t WriteRegWrap(void *handle, uint8_t Reg, uint8_t* Data, uint16_t Length);
     72          
     73          /**
     74            * @}
     75            */
     76          
     77          /** @defgroup FT5336_Exported_Functions FT5336 Exported Functions
     78            * @{
     79            */
     80          
     81          /**
     82            * @brief  Register IO bus to component object
     83            * @param  Component object pointer
     84            * @retval error status
     85            */

   \                                 In section .text, align 2, keep-with-next
     86          int32_t FT5336_RegisterBusIO (FT5336_Object_t *pObj, FT5336_IO_t *pIO)
     87          {
   \                     FT5336_RegisterBusIO: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     88            int32_t ret;
     89          
     90            if (pObj == NULL)
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD102             BNE.N    ??FT5336_RegisterBusIO_0
     91            {
     92              ret = FT5336_ERROR;
   \        0x6   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \        0xA   0xE01A             B.N      ??FT5336_RegisterBusIO_1
     93            }
     94            else
     95            {
     96              pObj->IO.Init      = pIO->Init;
   \                     ??FT5336_RegisterBusIO_0: (+1)
   \        0xC   0x680A             LDR      R2,[R1, #+0]
   \        0xE   0x6002             STR      R2,[R0, #+0]
     97              pObj->IO.DeInit    = pIO->DeInit;
   \       0x10   0x684A             LDR      R2,[R1, #+4]
   \       0x12   0x6042             STR      R2,[R0, #+4]
     98              pObj->IO.Address   = pIO->Address;
   \       0x14   0x890A             LDRH     R2,[R1, #+8]
   \       0x16   0x8102             STRH     R2,[R0, #+8]
     99              pObj->IO.WriteReg  = pIO->WriteReg;
   \       0x18   0x68CA             LDR      R2,[R1, #+12]
   \       0x1A   0x60C2             STR      R2,[R0, #+12]
    100              pObj->IO.ReadReg   = pIO->ReadReg;
   \       0x1C   0x690A             LDR      R2,[R1, #+16]
   \       0x1E   0x6102             STR      R2,[R0, #+16]
    101              pObj->IO.GetTick   = pIO->GetTick;
   \       0x20   0x6949             LDR      R1,[R1, #+20]
   \       0x22   0x6141             STR      R1,[R0, #+20]
    102          
    103              pObj->Ctx.ReadReg  = ReadRegWrap;
   \       0x24   0x.... 0x....      ADR.W    R1,ReadRegWrap
   \       0x28   0x61C1             STR      R1,[R0, #+28]
    104              pObj->Ctx.WriteReg = WriteRegWrap;
   \       0x2A   0x.... 0x....      ADR.W    R1,WriteRegWrap
   \       0x2E   0x6181             STR      R1,[R0, #+24]
    105              pObj->Ctx.handle   = pObj;
   \       0x30   0x6200             STR      R0,[R0, #+32]
    106          
    107              if(pObj->IO.Init != NULL)
   \       0x32   0x6801             LDR      R1,[R0, #+0]
   \       0x34   0x2900             CMP      R1,#+0
   \       0x36   0xD002             BEQ.N    ??FT5336_RegisterBusIO_2
    108              {
    109                ret = pObj->IO.Init();
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0x4780             BLX      R0
   \       0x3C   0xE001             B.N      ??FT5336_RegisterBusIO_1
    110              }
    111              else
    112              {
    113                ret = FT5336_ERROR;
   \                     ??FT5336_RegisterBusIO_2: (+1)
   \       0x3E   0xF05F 0x30FF      MOVS     R0,#+4294967295
    114              }
    115            }
    116          
    117            return ret;
   \                     ??FT5336_RegisterBusIO_1: (+1)
   \       0x42   0xBD02             POP      {R1,PC}
    118          }
    119          
    120          /**
    121            * @brief  Get FT5336 sensor capabilities
    122            * @param  pObj Component object pointer
    123            * @param  Capabilities pointer to FT5336 sensor capabilities
    124            * @retval Component status
    125            */

   \                                 In section .text, align 2, keep-with-next
    126          int32_t FT5336_GetCapabilities(FT5336_Object_t *pObj, FT5336_Capabilities_t *Capabilities)
    127          {
    128            /* Prevent unused argument(s) compilation warning */
    129            (void)(pObj);
    130          
    131            /* Store component's capabilities */
    132            Capabilities->MultiTouch = 1;
   \                     FT5336_GetCapabilities: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x7008             STRB     R0,[R1, #+0]
    133            Capabilities->Gesture    = 1;
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x7048             STRB     R0,[R1, #+1]
    134            Capabilities->MaxTouch   = FT5336_MAX_NB_TOUCH;
   \        0x8   0x2005             MOVS     R0,#+5
   \        0xA   0x7088             STRB     R0,[R1, #+2]
    135            Capabilities->MaxXl      = FT5336_MAX_X_LENGTH;
   \        0xC   0xF44F 0x70F0      MOV      R0,#+480
   \       0x10   0x6048             STR      R0,[R1, #+4]
    136            Capabilities->MaxYl      = FT5336_MAX_Y_LENGTH;
   \       0x12   0xF44F 0x7088      MOV      R0,#+272
   \       0x16   0x6088             STR      R0,[R1, #+8]
    137          
    138            return FT5336_OK;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x4770             BX       LR
    139          }
    140          
    141          /**
    142            * @brief  Initialize the FT5336 communication bus
    143            *         from MCU to FT5336 : ie I2C channel initialization (if required).
    144            * @param  pObj Component object pointer
    145            * @param  GestureInit: Gesture init structure
    146            * @retval FT5336_OK
    147            */

   \                                 In section .text, align 2, keep-with-next
    148          int32_t FT5336_Init(FT5336_Object_t *pObj)
    149          {
   \                     FT5336_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
    150            int32_t ret = FT5336_OK;
   \        0x4   0x2400             MOVS     R4,#+0
    151          
    152            if(pObj->IsInitialized == 0U)
   \        0x6   0xF895 0x0024      LDRB     R0,[R5, #+36]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD108             BNE.N    ??FT5336_Init_0
    153            {
    154              /* Initialize IO BUS layer */
    155              pObj->IO.Init();
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x4780             BLX      R0
    156          
    157          #if (FT5336_AUTO_CALIBRATION_ENABLED == 1)
    158              /* Hw Calibration sequence start : should be done once after each power up */
    159              /* This is called internal calibration of the touch screen                 */
    160              ret += FT5336_TS_Calibration(pObj);
    161          #endif /* (FT5336_AUTO_CALIBRATION_ENABLED == 1) */
    162              /* By default set FT5336 IC in Polling mode : no INT generation on FT5336 for new touch available */
    163              /* Note TS_INT is active low                                                                      */
    164              ret += FT5336_DisableIT(pObj);
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0x.... 0x....      BL       FT5336_DisableIT
   \       0x18   0x1904             ADDS     R4,R0,R4
    165          
    166              pObj->IsInitialized = 1;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xF885 0x0024      STRB     R0,[R5, #+36]
    167            }
    168          
    169            if(ret != FT5336_OK)
   \                     ??FT5336_Init_0: (+1)
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD001             BEQ.N    ??FT5336_Init_1
    170            {
    171              ret = FT5336_ERROR;
   \       0x24   0xF05F 0x34FF      MOVS     R4,#+4294967295
    172            }
    173          
    174            return ret;
   \                     ??FT5336_Init_1: (+1)
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0xBD32             POP      {R1,R4,R5,PC}
    175          }
    176          
    177          /**
    178            * @brief  De-Initialize the FT5336 communication bus
    179            *         from MCU to FT5336 : ie I2C channel initialization (if required).
    180            * @param  pObj Component object pointer
    181            * @retval FT5336_OK
    182            */

   \                                 In section .text, align 2, keep-with-next
    183          int32_t FT5336_DeInit(FT5336_Object_t *pObj)
    184          {
   \                     FT5336_DeInit: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    185            int32_t ret = FT5336_OK;
   \        0x2   0x2000             MOVS     R0,#+0
    186          
    187            if(pObj->IsInitialized == 1U)
   \        0x4   0xF891 0x2024      LDRB     R2,[R1, #+36]
   \        0x8   0x2A01             CMP      R2,#+1
   \        0xA   0xD102             BNE.N    ??FT5336_DeInit_0
    188            {
    189              pObj->IsInitialized = 0;
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0xF881 0x2024      STRB     R2,[R1, #+36]
    190            }
    191          
    192            return ret;
   \                     ??FT5336_DeInit_0: (+1)
   \       0x12   0x4770             BX       LR
    193          }
    194          
    195          /**
    196            * @brief  Configure the FT5336 gesture
    197            * @param  pObj  Component object pointer
    198            * @param  GestureInit Gesture init structure
    199            * @retval FT5336_OK
    200            */

   \                                 In section .text, align 2, keep-with-next
    201          int32_t FT5336_GestureConfig(FT5336_Object_t *pObj, FT5336_Gesture_Init_t *GestureInit)
    202          {
   \                     FT5336_GestureConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
    203            int32_t ret;
    204          
    205            ret = ft5336_radian_value(&pObj->Ctx, (uint8_t)GestureInit->Radian);
   \        0x6   0x6831             LDR      R1,[R6, #+0]
   \        0x8   0xB2C9             UXTB     R1,R1
   \        0xA   0xF115 0x0018      ADDS     R0,R5,#+24
   \        0xE   0x.... 0x....      BL       ft5336_radian_value
   \       0x12   0x0004             MOVS     R4,R0
    206            ret += ft5336_offset_left_right(&pObj->Ctx, (uint8_t)GestureInit->OffsetLeftRight);
   \       0x14   0x6871             LDR      R1,[R6, #+4]
   \       0x16   0xB2C9             UXTB     R1,R1
   \       0x18   0xF115 0x0018      ADDS     R0,R5,#+24
   \       0x1C   0x.... 0x....      BL       ft5336_offset_left_right
   \       0x20   0x1904             ADDS     R4,R0,R4
    207            ret += ft5336_offset_up_down(&pObj->Ctx, (uint8_t)GestureInit->OffsetUpDown);
   \       0x22   0x68B1             LDR      R1,[R6, #+8]
   \       0x24   0xB2C9             UXTB     R1,R1
   \       0x26   0xF115 0x0018      ADDS     R0,R5,#+24
   \       0x2A   0x.... 0x....      BL       ft5336_offset_up_down
   \       0x2E   0x1904             ADDS     R4,R0,R4
    208            ret += ft5336_disatnce_left_right(&pObj->Ctx, (uint8_t)GestureInit->DistanceLeftRight);
   \       0x30   0x68F1             LDR      R1,[R6, #+12]
   \       0x32   0xB2C9             UXTB     R1,R1
   \       0x34   0xF115 0x0018      ADDS     R0,R5,#+24
   \       0x38   0x.... 0x....      BL       ft5336_disatnce_left_right
   \       0x3C   0x1904             ADDS     R4,R0,R4
    209            ret += ft5336_distance_up_down(&pObj->Ctx, (uint8_t)GestureInit->DistanceUpDown);
   \       0x3E   0x6931             LDR      R1,[R6, #+16]
   \       0x40   0xB2C9             UXTB     R1,R1
   \       0x42   0xF115 0x0018      ADDS     R0,R5,#+24
   \       0x46   0x.... 0x....      BL       ft5336_distance_up_down
   \       0x4A   0x1904             ADDS     R4,R0,R4
    210            ret += ft5336_distance_zoom(&pObj->Ctx, (uint8_t)GestureInit->DistanceZoom);
   \       0x4C   0x6971             LDR      R1,[R6, #+20]
   \       0x4E   0xB2C9             UXTB     R1,R1
   \       0x50   0xF115 0x0018      ADDS     R0,R5,#+24
   \       0x54   0x.... 0x....      BL       ft5336_distance_zoom
   \       0x58   0x1904             ADDS     R4,R0,R4
    211          
    212            if(ret != FT5336_OK)
   \       0x5A   0x2C00             CMP      R4,#+0
   \       0x5C   0xD001             BEQ.N    ??FT5336_GestureConfig_0
    213            {
    214              ret = FT5336_ERROR;
   \       0x5E   0xF05F 0x34FF      MOVS     R4,#+4294967295
    215            }
    216          
    217            return ret;
   \                     ??FT5336_GestureConfig_0: (+1)
   \       0x62   0x0020             MOVS     R0,R4
   \       0x64   0xBD70             POP      {R4-R6,PC}
    218          }
    219          
    220          /**
    221            * @brief  Read the FT5336 device ID, pre initialize I2C in case of need to be
    222            *         able to read the FT5336 device ID, and verify this is a FT5336.
    223            * @param  pObj Component object pointer
    224            * @retval The Device ID (two bytes).
    225            */

   \                                 In section .text, align 2, keep-with-next
    226          int32_t FT5336_ReadID(FT5336_Object_t *pObj, uint32_t *Id)
    227          {
   \                     FT5336_ReadID: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    228            return ft5336_chip_id(&pObj->Ctx, (uint8_t *)Id);
   \        0x2   0x3018             ADDS     R0,R0,#+24
   \        0x4   0x.... 0x....      BL       ft5336_chip_id
   \        0x8   0xBD02             POP      {R1,PC}
    229          }
    230          
    231          /**
    232            * @brief  Get the touch screen X and Y positions values
    233            * @param  pObj Component object pointer
    234            * @param  State: Single Touch stucture pointer
    235            * @retval FT5336_OK.
    236            */

   \                                 In section .text, align 2, keep-with-next
    237          int32_t FT5336_GetState(FT5336_Object_t *pObj, FT5336_State_t *State)
    238          {
   \                     FT5336_GetState: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    239            int32_t ret = FT5336_OK;
   \        0x6   0x2600             MOVS     R6,#+0
    240            uint8_t  data[4];
    241          
    242            State->TouchDetected = (uint32_t)FT5336_DetectTouch(pObj);
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       FT5336_DetectTouch
   \        0xE   0x6028             STR      R0,[R5, #+0]
    243            if(ft5336_read_reg(&pObj->Ctx, FT5336_P1_XH_REG, data, (uint16_t)sizeof(data)) != FT5336_OK)
   \       0x10   0x2304             MOVS     R3,#+4
   \       0x12   0x466A             MOV      R2,SP
   \       0x14   0x2103             MOVS     R1,#+3
   \       0x16   0xF114 0x0018      ADDS     R0,R4,#+24
   \       0x1A   0x.... 0x....      BL       ft5336_read_reg
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD002             BEQ.N    ??FT5336_GetState_0
    244            {
    245              ret = FT5336_ERROR;
   \       0x22   0xF05F 0x36FF      MOVS     R6,#+4294967295
   \       0x26   0xE011             B.N      ??FT5336_GetState_1
    246            }
    247            else
    248            {
    249              /* Send back first ready X position to caller */
    250              State->TouchX = (((uint32_t)data[0] & FT5336_P1_XH_TP_BIT_MASK) << 8) | ((uint32_t)data[1] & FT5336_P1_XL_TP_BIT_MASK);
   \                     ??FT5336_GetState_0: (+1)
   \       0x28   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x2C   0x0209             LSLS     R1,R1,#+8
   \       0x2E   0xF411 0x6170      ANDS     R1,R1,#0xF00
   \       0x32   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x36   0x4301             ORRS     R1,R0,R1
   \       0x38   0x6069             STR      R1,[R5, #+4]
    251              /* Send back first ready Y position to caller */
    252              State->TouchY = (((uint32_t)data[2] & FT5336_P1_YH_TP_BIT_MASK) << 8) | ((uint32_t)data[3] & FT5336_P1_YL_TP_BIT_MASK);
   \       0x3A   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \       0x3E   0x0209             LSLS     R1,R1,#+8
   \       0x40   0xF411 0x6170      ANDS     R1,R1,#0xF00
   \       0x44   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \       0x48   0x4301             ORRS     R1,R0,R1
   \       0x4A   0x60A9             STR      R1,[R5, #+8]
    253            }
    254          
    255            return ret;
   \                     ??FT5336_GetState_1: (+1)
   \       0x4C   0x0030             MOVS     R0,R6
   \       0x4E   0xBD76             POP      {R1,R2,R4-R6,PC}
    256          }
    257          
    258          /**
    259            * @brief  Get the touch screen Xn and Yn positions values in multi-touch mode
    260            * @param  pObj Component object pointer
    261            * @param  State Multi Touch structure pointer
    262            * @retval FT5336_OK.
    263            */

   \                                 In section .text, align 2, keep-with-next
    264          int32_t FT5336_GetMultiTouchState(FT5336_Object_t *pObj, FT5336_MultiTouch_State_t *State)
    265          {
   \                     FT5336_GetMultiTouchState: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000D             MOVS     R5,R1
    266            int32_t ret = FT5336_OK;
   \        0x8   0x2400             MOVS     R4,#+0
    267            uint8_t  data[30];
    268            uint32_t i;
    269          
    270            State->TouchDetected = (uint32_t)FT5336_DetectTouch(pObj);
   \        0xA   0x0030             MOVS     R0,R6
   \        0xC   0x.... 0x....      BL       FT5336_DetectTouch
   \       0x10   0x6028             STR      R0,[R5, #+0]
    271          
    272            if(ft5336_read_reg(&pObj->Ctx, FT5336_P1_XH_REG, data, (uint16_t)sizeof(data)) != FT5336_OK)
   \       0x12   0x231E             MOVS     R3,#+30
   \       0x14   0x466A             MOV      R2,SP
   \       0x16   0x2103             MOVS     R1,#+3
   \       0x18   0xF116 0x0018      ADDS     R0,R6,#+24
   \       0x1C   0x.... 0x....      BL       ft5336_read_reg
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD002             BEQ.N    ??FT5336_GetMultiTouchState_0
    273            {
    274              ret = FT5336_ERROR;
   \       0x24   0xF05F 0x34FF      MOVS     R4,#+4294967295
   \       0x28   0xE03E             B.N      ??FT5336_GetMultiTouchState_1
    275            }
    276            else
    277            {
    278              for(i = 0; i < FT5336_MAX_NB_TOUCH; i++)
   \                     ??FT5336_GetMultiTouchState_0: (+1)
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0xE03A             B.N      ??FT5336_GetMultiTouchState_2
    279              {
    280              /* Send back first ready X position to caller */
    281              State->TouchX[i] = (((uint32_t)data[i*6U] & FT5336_P1_XH_TP_BIT_MASK) << 8U) | ((uint32_t)data[(i*6U) + 1U] & FT5336_P1_XL_TP_BIT_MASK);
   \                     ??FT5336_GetMultiTouchState_3: (+1)
   \       0x2E   0x2206             MOVS     R2,#+6
   \       0x30   0x466B             MOV      R3,SP
   \       0x32   0xFB02 0xF001      MUL      R0,R2,R1
   \       0x36   0x5C1E             LDRB     R6,[R3, R0]
   \       0x38   0x0236             LSLS     R6,R6,#+8
   \       0x3A   0xF416 0x6670      ANDS     R6,R6,#0xF00
   \       0x3E   0x4668             MOV      R0,SP
   \       0x40   0xFB02 0xF701      MUL      R7,R2,R1
   \       0x44   0x4438             ADD      R0,R0,R7
   \       0x46   0x7840             LDRB     R0,[R0, #+1]
   \       0x48   0x4306             ORRS     R6,R0,R6
   \       0x4A   0xEB05 0x0081      ADD      R0,R5,R1, LSL #+2
   \       0x4E   0x6046             STR      R6,[R0, #+4]
    282              /* Send back first ready Y position to caller */
    283              State->TouchY[i] = (((uint32_t)data[(i*6U) + 2U] & FT5336_P1_YH_TP_BIT_MASK) << 8U) | ((uint32_t)data[(i*6U) + 3U] & FT5336_P1_YL_TP_BIT_MASK);
   \       0x50   0x4668             MOV      R0,SP
   \       0x52   0xFB02 0xF601      MUL      R6,R2,R1
   \       0x56   0x4430             ADD      R0,R0,R6
   \       0x58   0x7886             LDRB     R6,[R0, #+2]
   \       0x5A   0x0236             LSLS     R6,R6,#+8
   \       0x5C   0xF416 0x6670      ANDS     R6,R6,#0xF00
   \       0x60   0x4668             MOV      R0,SP
   \       0x62   0xFB02 0xF701      MUL      R7,R2,R1
   \       0x66   0x4438             ADD      R0,R0,R7
   \       0x68   0x78C0             LDRB     R0,[R0, #+3]
   \       0x6A   0x4306             ORRS     R6,R0,R6
   \       0x6C   0xEB05 0x0081      ADD      R0,R5,R1, LSL #+2
   \       0x70   0x6186             STR      R6,[R0, #+24]
    284              /* Send back first ready Event to caller */
    285              State->TouchEvent[i] = (((uint32_t)data[i*6U] & FT5336_P1_XH_EF_BIT_MASK) >> FT5336_P1_XH_EF_BIT_POSITION);
   \       0x72   0xFB02 0xF001      MUL      R0,R2,R1
   \       0x76   0x5C18             LDRB     R0,[R3, R0]
   \       0x78   0x0980             LSRS     R0,R0,#+6
   \       0x7A   0xEB05 0x0381      ADD      R3,R5,R1, LSL #+2
   \       0x7E   0x6418             STR      R0,[R3, #+64]
    286              /* Send back first ready Weight to caller */
    287              State->TouchWeight[i] = ((uint32_t)data[(i*6U) + 4U] & FT5336_P1_WEIGHT_BIT_MASK);
   \       0x80   0x4668             MOV      R0,SP
   \       0x82   0xFB02 0xF301      MUL      R3,R2,R1
   \       0x86   0x4418             ADD      R0,R0,R3
   \       0x88   0x7900             LDRB     R0,[R0, #+4]
   \       0x8A   0xEB05 0x0381      ADD      R3,R5,R1, LSL #+2
   \       0x8E   0x62D8             STR      R0,[R3, #+44]
    288              /* Send back first ready Area to caller */
    289              State->TouchArea[i] = ((uint32_t)data[(i*6U) + 5U] & FT5336_P1_MISC_BIT_MASK) >> FT5336_P1_MISC_BIT_POSITION;
   \       0x90   0x4668             MOV      R0,SP
   \       0x92   0xFB02 0xF201      MUL      R2,R2,R1
   \       0x96   0x4410             ADD      R0,R0,R2
   \       0x98   0x7940             LDRB     R0,[R0, #+5]
   \       0x9A   0x0900             LSRS     R0,R0,#+4
   \       0x9C   0xEB05 0x0281      ADD      R2,R5,R1, LSL #+2
   \       0xA0   0x6550             STR      R0,[R2, #+84]
    290              }
   \       0xA2   0x1C49             ADDS     R1,R1,#+1
   \                     ??FT5336_GetMultiTouchState_2: (+1)
   \       0xA4   0x2905             CMP      R1,#+5
   \       0xA6   0xD3C2             BCC.N    ??FT5336_GetMultiTouchState_3
    291            }
    292          
    293            return ret;
   \                     ??FT5336_GetMultiTouchState_1: (+1)
   \       0xA8   0x0020             MOVS     R0,R4
   \       0xAA   0xB009             ADD      SP,SP,#+36
   \       0xAC   0xBDF0             POP      {R4-R7,PC}
    294          }
    295          
    296          /**
    297            * @brief  Get Gesture ID
    298            * @param  pObj Component object pointer
    299            * @param  GestureId: gesture ID
    300            * @retval Gesture ID.
    301            */

   \                                 In section .text, align 2, keep-with-next
    302          int32_t FT5336_GetGesture(FT5336_Object_t *pObj, uint8_t *GestureId)
    303          {
   \                     FT5336_GetGesture: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    304            return ft5336_gest_id(&pObj->Ctx, GestureId);
   \        0x2   0x3018             ADDS     R0,R0,#+24
   \        0x4   0x.... 0x....      BL       ft5336_gest_id
   \        0x8   0xBD02             POP      {R1,PC}
    305          }
    306          
    307          /**
    308            * @brief  Configure the FT5336 device to generate IT on given INT pin
    309            *         connected to MCU as EXTI.
    310            * @param  pObj Component object pointer
    311            * @retval None
    312            */

   \                                 In section .text, align 2, keep-with-next
    313          int32_t FT5336_EnableIT(FT5336_Object_t *pObj)
    314          {
   \                     FT5336_EnableIT: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    315            return ft5336_g_mode(&pObj->Ctx, FT5336_G_MODE_INTERRUPT_TRIGGER);
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x3018             ADDS     R0,R0,#+24
   \        0x6   0x.... 0x....      BL       ft5336_g_mode
   \        0xA   0xBD02             POP      {R1,PC}
    316          }
    317          
    318          /**
    319            * @brief  Configure the FT5336 device to stop generating IT on the given INT pin
    320            *         connected to MCU as EXTI.
    321            * @param  pObj Component object pointer
    322            * @retval None
    323            */

   \                                 In section .text, align 2, keep-with-next
    324          int32_t FT5336_DisableIT(FT5336_Object_t *pObj)
    325          {
   \                     FT5336_DisableIT: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    326            return ft5336_g_mode(&pObj->Ctx, FT5336_G_MODE_INTERRUPT_POLLING);
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x3018             ADDS     R0,R0,#+24
   \        0x6   0x.... 0x....      BL       ft5336_g_mode
   \        0xA   0xBD02             POP      {R1,PC}
    327          }
    328          
    329          /**
    330            * @brief  Get IT status from FT5336 interrupt status registers
    331            *         Should be called Following an EXTI coming to the MCU to know the detailed
    332            *         reason of the interrupt.
    333            *         @note : This feature is not applicable to FT5336.
    334            * @param  pObj Component object pointer
    335            * @retval TS interrupts status : always return 0 here
    336            */

   \                                 In section .text, align 2, keep-with-next
    337          int32_t FT5336_ITStatus(FT5336_Object_t *pObj)
    338          {
    339            /* Prevent unused argument(s) compilation warning */
    340            (void)(pObj);
    341          
    342            /* Always return FT5336_OK as feature not applicable to FT5336 */
    343            return FT5336_OK;
   \                     FT5336_ITStatus: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR
    344          }
    345          
    346          /**
    347            * @brief  Clear IT status in FT5336 interrupt status clear registers
    348            *         Should be called Following an EXTI coming to the MCU.
    349            *         @note : This feature is not applicable to FT5336.
    350            * @param  pObj Component object pointer
    351            * @retval None
    352            */

   \                                 In section .text, align 2, keep-with-next
    353          int32_t FT5336_ClearIT(FT5336_Object_t *pObj)
    354          {
    355            /* Prevent unused argument(s) compilation warning */
    356            (void)(pObj);
    357          
    358            /* Always return FT5336_OK as feature not applicable to FT5336 */
    359            return FT5336_OK;
   \                     FT5336_ClearIT: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR
    360          }
    361          
    362          /******************** Static functions ****************************************/
    363          #if (FT5336_AUTO_CALIBRATION_ENABLED == 1)
    364          /**
    365            * @brief This function provides accurate delay (in milliseconds)
    366            * @param pObj pointer to component object
    367            * @param Delay: specifies the delay time length, in milliseconds
    368            * @retval WM8994_OK
    369            */
    370          static int32_t FT5336_Delay(FT5336_Object_t *pObj, uint32_t Delay)
    371          {
    372            uint32_t tickstart;
    373            tickstart = pObj->IO.GetTick();
    374            while((pObj->IO.GetTick() - tickstart) < Delay)
    375            {
    376            }
    377            return FT5336_OK;
    378          }
    379          
    380          /**
    381            * @brief  Start TouchScreen calibration phase
    382            * @param  DeviceAddr: FT5336 Device address for communication on I2C Bus.
    383            * @retval Status FT5336_OK or FT5336_ERROR.
    384            */
    385          static int32_t FT5336_TS_Calibration(FT5336_Object_t *pObj)
    386          {
    387            int32_t ret = FT5336_OK;
    388            uint32_t nbr_attempt;
    389            uint8_t read_data;
    390            uint8_t end_calibration = 0;
    391          
    392            /* Switch FT5336 back to factory mode to calibrate */
    393            if(ft5336_dev_mode_w(&pObj->Ctx, FT5336_DEV_MODE_FACTORY) != FT5336_OK)
    394            {
    395              ret = FT5336_ERROR;
    396            }/* Read back the same register FT5336_DEV_MODE_REG */
    397            else if(ft5336_dev_mode_r(&pObj->Ctx, &read_data) != FT5336_OK)
    398            {
    399              ret = FT5336_ERROR;
    400            }
    401            else
    402            {
    403              (void)FT5336_Delay(pObj, 300); /* Wait 300 ms */
    404          
    405              if(read_data != FT5336_DEV_MODE_FACTORY )
    406              {
    407                /* Return error to caller */
    408                ret = FT5336_ERROR;
    409              }
    410              else
    411              {
    412                /* Start calibration command */
    413                read_data= 0x04;
    414                if(ft5336_write_reg(&pObj->Ctx, FT5336_TD_STAT_REG, &read_data, 1) != FT5336_OK)
    415                {
    416                  ret = FT5336_ERROR;
    417                }
    418                else
    419                {
    420                  (void)FT5336_Delay(pObj, 300); /* Wait 300 ms */
    421          
    422                  /* 100 attempts to wait switch from factory mode (calibration) to working mode */
    423                  for (nbr_attempt=0; ((nbr_attempt < 100U) && (end_calibration == 0U)) ; nbr_attempt++)
    424                  {
    425                    if(ft5336_dev_mode_r(&pObj->Ctx, &read_data) != FT5336_OK)
    426                    {
    427                      ret = FT5336_ERROR;
    428                      break;
    429                    }
    430                    if(read_data == FT5336_DEV_MODE_WORKING)
    431                    {
    432                      /* Auto Switch to FT5336_DEV_MODE_WORKING : means calibration have ended */
    433                      end_calibration = 1; /* exit for loop */
    434                    }
    435          
    436                    (void)FT5336_Delay(pObj, 200); /* Wait 200 ms */
    437                  }
    438                }
    439              }
    440            }
    441          
    442            return ret;
    443          }
    444          #endif /* FT5336_AUTO_CALIBRATION_ENABLED == 1 */
    445          
    446          /**
    447            * @brief  Return if there is touches detected or not.
    448            *         Try to detect new touches and forget the old ones (reset internal global
    449            *         variables).
    450            * @param  pObj Component object pointer
    451            * @retval Number of active touches detected (can be 0, 1 or 2) or FT5336_ERROR
    452            *         in case of error
    453            */

   \                                 In section .text, align 2, keep-with-next
    454          static int32_t FT5336_DetectTouch(FT5336_Object_t *pObj)
    455          {
   \                     FT5336_DetectTouch: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    456            int32_t ret;
    457            uint8_t nb_touch;
    458          
    459            /* Read register FT5336_TD_STAT_REG to check number of touches detection */
    460            if(ft5336_td_status(&pObj->Ctx, &nb_touch) != FT5336_OK)
   \        0x2   0x4669             MOV      R1,SP
   \        0x4   0x3018             ADDS     R0,R0,#+24
   \        0x6   0x.... 0x....      BL       ft5336_td_status
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD002             BEQ.N    ??FT5336_DetectTouch_0
    461            {
    462              ret = FT5336_ERROR;
   \        0xE   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x12   0xE007             B.N      ??FT5336_DetectTouch_1
    463            }
    464            else
    465            {
    466              if(nb_touch > FT5336_MAX_NB_TOUCH)
   \                     ??FT5336_DetectTouch_0: (+1)
   \       0x14   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x18   0x2806             CMP      R0,#+6
   \       0x1A   0xD301             BCC.N    ??FT5336_DetectTouch_2
    467              {
    468                /* If invalid number of touch detected, set it to zero */
    469                ret = 0;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xE001             B.N      ??FT5336_DetectTouch_1
    470              }
    471              else
    472              {
    473                ret = (int32_t)nb_touch;
   \                     ??FT5336_DetectTouch_2: (+1)
   \       0x20   0xF89D 0x0000      LDRB     R0,[SP, #+0]
    474              }
    475            }
    476            return ret;
   \                     ??FT5336_DetectTouch_1: (+1)
   \       0x24   0xBD02             POP      {R1,PC}
    477          }
    478          
    479          /**
    480            * @brief  Function
    481            * @param  handle: Component object handle
    482            * @param  Reg: The target register address to write
    483            * @param  pData: The target register value to be written
    484            * @param  Length: buffer size to be written
    485            * @retval error status
    486            */

   \                                 In section .text, align 4, keep-with-next
    487          static int32_t ReadRegWrap(void *handle, uint8_t Reg, uint8_t* pData, uint16_t Length)
    488          {
   \                     ReadRegWrap: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    489            FT5336_Object_t *pObj = (FT5336_Object_t *)handle;
    490          
    491            return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
   \        0x4   0xB29B             UXTH     R3,R3
   \        0x6   0xB2C9             UXTB     R1,R1
   \        0x8   0xB289             UXTH     R1,R1
   \        0xA   0x8920             LDRH     R0,[R4, #+8]
   \        0xC   0x6924             LDR      R4,[R4, #+16]
   \        0xE   0x47A0             BLX      R4
   \       0x10   0xBD10             POP      {R4,PC}
    492          }
    493          
    494          /**
    495            * @brief  Function
    496            * @param  handle: Component object handle
    497            * @param  Reg: The target register address to write
    498            * @param  pData: The target register value to be written
    499            * @param  Length: buffer size to be written
    500            * @retval error status
    501            */

   \                                 In section .text, align 4, keep-with-next
    502          static int32_t WriteRegWrap(void *handle, uint8_t Reg, uint8_t* pData, uint16_t Length)
    503          {
   \                     WriteRegWrap: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    504            FT5336_Object_t *pObj = (FT5336_Object_t *)handle;
    505          
    506            return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
   \        0x4   0xB29B             UXTH     R3,R3
   \        0x6   0xB2C9             UXTB     R1,R1
   \        0x8   0xB289             UXTH     R1,R1
   \        0xA   0x8920             LDRH     R0,[R4, #+8]
   \        0xC   0x68E4             LDR      R4,[R4, #+12]
   \        0xE   0x47A0             BLX      R4
   \       0x10   0xBD10             POP      {R4,PC}
    507          }
    508          
    509          /**
    510            * @}
    511            */
    512          
    513          /**
    514            * @}
    515            */
    516          
    517          /**
    518            * @}
    519            */
    520          
    521          /**
    522            * @}
    523            */
    524          
    525          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FT5336_ClearIT
       0   FT5336_DeInit
       8   FT5336_DetectTouch
         8   -> ft5336_td_status
       8   FT5336_DisableIT
         8   -> ft5336_g_mode
       8   FT5336_EnableIT
         8   -> ft5336_g_mode
      16   FT5336_GestureConfig
        16   -> ft5336_disatnce_left_right
        16   -> ft5336_distance_up_down
        16   -> ft5336_distance_zoom
        16   -> ft5336_offset_left_right
        16   -> ft5336_offset_up_down
        16   -> ft5336_radian_value
       0   FT5336_GetCapabilities
       8   FT5336_GetGesture
         8   -> ft5336_gest_id
      56   FT5336_GetMultiTouchState
        56   -> FT5336_DetectTouch
        56   -> ft5336_read_reg
      24   FT5336_GetState
        24   -> FT5336_DetectTouch
        24   -> ft5336_read_reg
       0   FT5336_ITStatus
      16   FT5336_Init
        16   -- Indirect call
        16   -> FT5336_DisableIT
       8   FT5336_ReadID
         8   -> ft5336_chip_id
       8   FT5336_RegisterBusIO
         8   -- Indirect call
       8   ReadRegWrap
         8   -- Indirect call
       8   WriteRegWrap
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  FT5336_ClearIT
      20  FT5336_DeInit
      38  FT5336_DetectTouch
      12  FT5336_DisableIT
      12  FT5336_EnableIT
     102  FT5336_GestureConfig
      28  FT5336_GetCapabilities
      10  FT5336_GetGesture
     174  FT5336_GetMultiTouchState
      80  FT5336_GetState
       4  FT5336_ITStatus
      44  FT5336_Init
      10  FT5336_ReadID
      68  FT5336_RegisterBusIO
      48  FT5336_TS_Driver
      18  ReadRegWrap
      18  WriteRegWrap

 
  48 bytes in section .data
 642 bytes in section .text
 
 642 bytes of CODE memory
  48 bytes of DATA memory

Errors: none
Warnings: none
