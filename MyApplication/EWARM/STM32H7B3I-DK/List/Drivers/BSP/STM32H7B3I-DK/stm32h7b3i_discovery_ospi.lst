###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         08/Feb/2022  20:54:08
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\BSP\STM32H7B3I-DK\stm32h7b3i_discovery_ospi.c
#        [UTF-8]
#    Command line      =
#        -f
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\BSP\STM32H7B3I-DK\stm32h7b3i_discovery_ospi.o.rsp
#        (D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\BSP\STM32H7B3I-DK\stm32h7b3i_discovery_ospi.c
#        -D USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\BSP\STM32H7B3I-DK
#        -lA
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\BSP\STM32H7B3I-DK
#        -o
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\BSP\STM32H7B3I-DK
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Core/Inc\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/App\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\BSP\STM32H7B3I-DK\stm32h7b3i_discovery_ospi.o.d
#    Locale            =  C
#    List file         =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\BSP\STM32H7B3I-DK\stm32h7b3i_discovery_ospi.lst
#    Object file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\BSP\STM32H7B3I-DK\stm32h7b3i_discovery_ospi.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\BSP\STM32H7B3I-DK\stm32h7b3i_discovery_ospi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32h7b3i_discovery_ospi.c
      4            * @author  MCD Application Team
      5            * @brief   This file includes a standard driver for the MX25LM51245G OSPI
      6            *          memory mounted on STM32H7B3I-EVAL board.
      7            @verbatim
      8            ==============================================================================
      9                               ##### How to use this driver #####
     10            ==============================================================================
     11            [..]
     12             (#) This driver is used to drive the MX25LM51245G Octal NOR and the ISS66WVH8M8 HyperRAM
     13                 external memories mounted on STM32H7B3I-EVAL evaluation board.
     14          
     15             (#) This driver need specific component driver (MX25LM51245G and ISS66WVH8M8) to be included with.
     16          
     17             (#) MX25LM51245G Initialization steps:
     18                 (++) Initialize the OPSI external memory using the BSP_OSPI_NOR_Init() function. This
     19                      function includes the MSP layer hardware resources initialization and the
     20                      OSPI interface with the external memory.
     21          
     22             (#) MX25LM51245G Octal NOR memory operations
     23                 (++) OSPI memory can be accessed with read/write operations once it is
     24                      initialized.
     25                      Read/write operation can be performed with AHB access using the functions
     26                      BSP_OSPI_NOR_Read()/BSP_OSPI_NOR_Write().
     27                 (++) The function BSP_OSPI_NOR_GetInfo() returns the configuration of the OSPI memory.
     28                      (see the OSPI memory data sheet)
     29                 (++) Perform erase block operation using the function BSP_OSPI_NOR_Erase_Block() and by
     30                      specifying the block address. You can perform an erase operation of the whole
     31                      chip by calling the function BSP_OSPI_NOR_Erase_Chip().
     32                 (++) The function BSP_OSPI_NOR_GetStatus() returns the current status of the OSPI memory.
     33                      (see the OSPI memory data sheet)
     34                 (++) The memory access can be configured in memory-mapped mode with the call of
     35                      function BSP_OSPI_NOR_EnableMemoryMapped(). To go back in indirect mode, the
     36                      function BSP_OSPI_NOR_DisableMemoryMapped() should be used.
     37                 (++) The erase operation can be suspend and resume with using functions
     38                      BSP_OSPI_NOR_SuspendErase() and BSP_OSPI_NOR_ResumeErase()
     39                 (++) It is possible to put the memory in deep power-down mode to reduce its consumption.
     40                      For this, the function BSP_OSPI_NOR_EnterDeepPowerDown() should be called. To leave
     41                      the deep power-down mode, the function BSP_OSPI_NOR_LeaveDeepPowerDown() should be called.
     42                 (++) The function BSP_OSPI_NOR_ReadID() returns the identifier of the memory
     43                      (see the OSPI memory data sheet)
     44                 (++) The configuration of the interface between peripheral and memory is done by
     45                      the function BSP_OSPI_NOR_ConfigFlash(), three modes are possible :
     46                      - SPI : instruction, address and data on one line
     47                      - STR OPI : instruction, address and data on eight lines with sampling on one edge of clock
     48                      - DTR OPI : instruction, address and data on eight lines with sampling on both edgaes of clock
     49          
     50            @endverbatim
     51            ******************************************************************************
     52            * @attention
     53            *
     54            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     55            * All rights reserved.</center></h2>
     56            *
     57            * This software component is licensed by ST under BSD 3-Clause license,
     58            * the "License"; You may not use this file except in compliance with the
     59            * License. You may obtain a copy of the License at:
     60            *                        opensource.org/licenses/BSD-3-Clause
     61            *
     62            ******************************************************************************
     63            */
     64          
     65          /* Includes ------------------------------------------------------------------*/
     66          #include "stm32h7b3i_discovery_ospi.h"
     67          
     68          /** @addtogroup BSP
     69            * @{
     70            */
     71          
     72          /** @addtogroup STM32H7B3I_DK
     73            * @{
     74            */
     75          
     76          /** @defgroup STM32H7B3I_DK_OSPI OSPI
     77            * @{
     78            */
     79          
     80          /* Exported variables --------------------------------------------------------*/
     81          /** @addtogroup STM32H7B3I_DK_OSPI_NOR_Exported_Variables OSPI_NOR Exported Variables
     82            * @{
     83            */

   \                                 In section .bss, align 4
     84          OSPI_HandleTypeDef hospi_nor[OSPI_NOR_INSTANCES_NUMBER];
   \                     hospi_nor:
   \        0x0                      DS8 96

   \                                 In section .bss, align 4
     85          OSPI_NOR_Ctx_t Ospi_Nor_Ctx[OSPI_NOR_INSTANCES_NUMBER];
   \                     Ospi_Nor_Ctx:
   \        0x0                      DS8 8
     86          /**
     87            * @}
     88            */
     89          
     90          /* Private constants --------------------------------------------------------*/
     91          /* Private variables ---------------------------------------------------------*/
     92          /* Private functions ---------------------------------------------------------*/
     93          
     94          /** @defgroup STM32H7B3I_DK_OSPI_NOR_Private_FunctionsPrototypes OSPI_NOR Private Functions Prototypes
     95            * @{
     96            */
     97          static void    OSPI_NOR_MspInit      (OSPI_HandleTypeDef *hospi);
     98          static void    OSPI_NOR_MspDeInit    (OSPI_HandleTypeDef *hospi);
     99          static int32_t OSPI_NOR_ResetMemory  (uint32_t Instance);
    100          static int32_t OSPI_NOR_EnterDOPIMode(uint32_t Instance);
    101          static int32_t OSPI_NOR_EnterSOPIMode(uint32_t Instance);
    102          static int32_t OSPI_NOR_ExitOPIMode  (uint32_t Instance);
    103          /**
    104            * @}
    105            */
    106          
    107          /* Exported functions ---------------------------------------------------------*/
    108          
    109          /** @defgroup STM32H7B3I_EVAL_OSPI_NOR_Exported_Functions OSPI Exported Functions
    110            * @{
    111            */
    112          /**
    113            * @brief  Initializes the OSPI interface.
    114            * @param  Instance   OSPI Instance
    115            * @param  Init       OSPI Init structure
    116            * @retval BSP status
    117            */

   \                                 In section .text, align 2, keep-with-next
    118          int32_t BSP_OSPI_NOR_Init(uint32_t Instance, BSP_OSPI_NOR_Init_t *Init)
    119          {
   \                     BSP_OSPI_NOR_Init: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB08D             SUB      SP,SP,#+52
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000F             MOVS     R7,R1
    120            int32_t ret = BSP_ERROR_NONE;
   \        0xA   0x2500             MOVS     R5,#+0
    121            BSP_OSPI_NOR_Info_t pInfo;
    122            MX_OSPI_Config ospi_config;
    123          
    124            /* Check if the instance is supported */
    125            if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD002             BEQ.N    ??BSP_OSPI_NOR_Init_0
    126            {
    127              ret = BSP_ERROR_WRONG_PARAM;
   \       0x10   0xF07F 0x0501      MVNS     R5,#+1
   \       0x14   0xE04A             B.N      ??BSP_OSPI_NOR_Init_1
    128            }
    129            else
    130            {
    131              /* Check if the instance is already initialized */
    132              if (Ospi_Nor_Ctx[Instance].IsInitialized == OSPI_ACCESS_NONE)
   \                     ??BSP_OSPI_NOR_Init_0: (+1)
   \       0x16   0x.... 0x....      LDR.W    R6,??DataTable18
   \       0x1A   0xF816 0x0034      LDRB     R0,[R6, R4, LSL #+3]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD144             BNE.N    ??BSP_OSPI_NOR_Init_1
    133              {
    134          #if (USE_HAL_OSPI_REGISTER_CALLBACKS == 0)
    135                /* Msp OSPI initialization */
    136                OSPI_NOR_MspInit(&hospi_nor[Instance]);
   \       0x22   0xF05F 0x0860      MOVS     R8,#+96
   \       0x26   0x.... 0x....      LDR.W    R9,??DataTable18_1
   \       0x2A   0xFB08 0xF004      MUL      R0,R8,R4
   \       0x2E   0x4448             ADD      R0,R9,R0
   \       0x30   0x.... 0x....      BL       OSPI_NOR_MspInit
    137          #else
    138                /* Register the OSPI MSP Callbacks */
    139                if(Ospi_Nor_Ctx[Instance].IsMspCallbacksValid == 0UL)
    140                {
    141                  if(BSP_OSPI_NOR_RegisterDefaultMspCallbacks(Instance) != BSP_ERROR_NONE)
    142                  {
    143                    ret = BSP_ERROR_PERIPH_FAILURE;
    144                  }
    145                }
    146                if(ret == BSP_ERROR_NONE)
    147                {
    148          #endif /* USE_HAL_OSPI_REGISTER_CALLBACKS */
    149          
    150                  /* Get Flash informations of one memory */
    151                  (void)MX25LM51245G_GetFlashInfo(&pInfo);
   \       0x34   0xA804             ADD      R0,SP,#+16
   \       0x36   0x.... 0x....      BL       MX25LM51245G_GetFlashInfo
    152          
    153                  /* Fill config structure */
    154                  ospi_config.ClockPrescaler = 3U;
   \       0x3A   0x2003             MOVS     R0,#+3
   \       0x3C   0x9001             STR      R0,[SP, #+4]
    155                  ospi_config.MemorySize     = (uint32_t)POSITION_VAL((uint32_t)pInfo.FlashSize);
   \       0x3E   0x9804             LDR      R0,[SP, #+16]
   \       0x40   0xFA90 0xF0A0      RBIT     R0,R0
   \       0x44   0xFAB0 0xF080      CLZ      R0,R0
   \       0x48   0x9000             STR      R0,[SP, #+0]
    156                  ospi_config.SampleShifting = HAL_OSPI_SAMPLE_SHIFTING_NONE;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x9002             STR      R0,[SP, #+8]
    157                  ospi_config.TransferRate   = (uint32_t)Init->TransferRate;
   \       0x4E   0x7878             LDRB     R0,[R7, #+1]
   \       0x50   0x9003             STR      R0,[SP, #+12]
    158          
    159                  /* STM32 OSPI interface initialization */
    160                  if (MX_OSPI_NOR_Init(&hospi_nor[Instance], &ospi_config) != HAL_OK)
   \       0x52   0x4669             MOV      R1,SP
   \       0x54   0xFB08 0xF004      MUL      R0,R8,R4
   \       0x58   0x4448             ADD      R0,R9,R0
   \       0x5A   0x.... 0x....      BL       MX_OSPI_NOR_Init
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD002             BEQ.N    ??BSP_OSPI_NOR_Init_2
    161                  {
    162                    ret = BSP_ERROR_PERIPH_FAILURE;
   \       0x62   0xF07F 0x0503      MVNS     R5,#+3
   \       0x66   0xE021             B.N      ??BSP_OSPI_NOR_Init_1
    163                  }
    164                  /* OSPI memory reset */
    165                  else if (OSPI_NOR_ResetMemory(Instance) != BSP_ERROR_NONE)
   \                     ??BSP_OSPI_NOR_Init_2: (+1)
   \       0x68   0x0020             MOVS     R0,R4
   \       0x6A   0x.... 0x....      BL       OSPI_NOR_ResetMemory
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD002             BEQ.N    ??BSP_OSPI_NOR_Init_3
    166                  {
    167                    ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x72   0xF07F 0x0504      MVNS     R5,#+4
   \       0x76   0xE019             B.N      ??BSP_OSPI_NOR_Init_1
    168                  }
    169                  /* Check if memory is ready */
    170                  else if (MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_Init_3: (+1)
   \       0x78   0xEB06 0x00C4      ADD      R0,R6,R4, LSL #+3
   \       0x7C   0x7882             LDRB     R2,[R0, #+2]
   \       0x7E   0xEB06 0x00C4      ADD      R0,R6,R4, LSL #+3
   \       0x82   0x7841             LDRB     R1,[R0, #+1]
   \       0x84   0xFB08 0xF804      MUL      R8,R8,R4
   \       0x88   0xEB09 0x0008      ADD      R0,R9,R8
   \       0x8C   0x.... 0x....      BL       MX25LM51245G_AutoPollingMemReady
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD002             BEQ.N    ??BSP_OSPI_NOR_Init_4
    171                  {
    172                    ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x94   0xF07F 0x0504      MVNS     R5,#+4
   \       0x98   0xE008             B.N      ??BSP_OSPI_NOR_Init_1
    173                  }
    174                  else
    175                  {
    176                    /* Configure the memory */
    177                    if (BSP_OSPI_NOR_ConfigFlash(Instance, Init->InterfaceMode, Init->TransferRate) != BSP_ERROR_NONE)
   \                     ??BSP_OSPI_NOR_Init_4: (+1)
   \       0x9A   0x787A             LDRB     R2,[R7, #+1]
   \       0x9C   0x7839             LDRB     R1,[R7, #+0]
   \       0x9E   0x0020             MOVS     R0,R4
   \       0xA0   0x.... 0x....      BL       BSP_OSPI_NOR_ConfigFlash
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD001             BEQ.N    ??BSP_OSPI_NOR_Init_1
    178                    {
    179                      ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0xA8   0xF07F 0x0504      MVNS     R5,#+4
    180                    }
    181                  }
    182          #if (USE_HAL_OSPI_REGISTER_CALLBACKS == 1)
    183                }
    184          #endif
    185              }
    186            }
    187          
    188            /* Return BSP status */
    189            return ret;
   \                     ??BSP_OSPI_NOR_Init_1: (+1)
   \       0xAC   0x0028             MOVS     R0,R5
   \       0xAE   0xB00D             ADD      SP,SP,#+52
   \       0xB0   0xE8BD 0x83F0      POP      {R4-R9,PC}
    190          }
    191          
    192          /**
    193            * @brief  De-Initializes the OSPI interface.
    194            * @param  Instance   OSPI Instance
    195            * @retval BSP status
    196            */

   \                                 In section .text, align 2, keep-with-next
    197          int32_t BSP_OSPI_NOR_DeInit(uint32_t Instance)
    198          {
   \                     BSP_OSPI_NOR_DeInit: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    199            int32_t ret = BSP_ERROR_NONE;
   \        0x4   0x2500             MOVS     R5,#+0
    200          
    201            /* Check if the instance is supported */
    202            if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD002             BEQ.N    ??BSP_OSPI_NOR_DeInit_0
    203            {
    204              ret = BSP_ERROR_WRONG_PARAM;
   \        0xA   0xF07F 0x0501      MVNS     R5,#+1
   \        0xE   0xE02A             B.N      ??BSP_OSPI_NOR_DeInit_1
    205            }
    206            else
    207            {
    208              /* Disable Memory mapped mode */
    209              if(Ospi_Nor_Ctx[Instance].IsInitialized == OSPI_ACCESS_MMP)
   \                     ??BSP_OSPI_NOR_DeInit_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R6,??DataTable18
   \       0x14   0xF816 0x0034      LDRB     R0,[R6, R4, LSL #+3]
   \       0x18   0x2802             CMP      R0,#+2
   \       0x1A   0xD106             BNE.N    ??BSP_OSPI_NOR_DeInit_2
    210              {
    211                if(BSP_OSPI_NOR_DisableMemoryMappedMode(Instance) != BSP_ERROR_NONE)
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       BSP_OSPI_NOR_DisableMemoryMappedMode
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD001             BEQ.N    ??BSP_OSPI_NOR_DeInit_2
    212                {
    213                  ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x26   0xF07F 0x0504      MVNS     R5,#+4
    214                }
    215              }
    216          
    217              if(ret == BSP_ERROR_NONE)
   \                     ??BSP_OSPI_NOR_DeInit_2: (+1)
   \       0x2A   0x2D00             CMP      R5,#+0
   \       0x2C   0xD11B             BNE.N    ??BSP_OSPI_NOR_DeInit_1
    218              {
    219                /* Set default Ospi_Nor_Ctx values */
    220                Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_NONE;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xF806 0x0034      STRB     R0,[R6, R4, LSL #+3]
    221                Ospi_Nor_Ctx[Instance].InterfaceMode = BSP_OSPI_NOR_SPI_MODE;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xEB06 0x01C4      ADD      R1,R6,R4, LSL #+3
   \       0x3A   0x7048             STRB     R0,[R1, #+1]
    222                Ospi_Nor_Ctx[Instance].TransferRate  = BSP_OSPI_NOR_STR_TRANSFER;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xEB06 0x01C4      ADD      R1,R6,R4, LSL #+3
   \       0x42   0x7088             STRB     R0,[R1, #+2]
    223          
    224          #if (USE_HAL_OSPI_REGISTER_CALLBACKS == 0)
    225                OSPI_NOR_MspDeInit(&hospi_nor[Instance]);
   \       0x44   0x2660             MOVS     R6,#+96
   \       0x46   0x.... 0x....      LDR.W    R7,??DataTable18_1
   \       0x4A   0xFB06 0xF004      MUL      R0,R6,R4
   \       0x4E   0x4438             ADD      R0,R7,R0
   \       0x50   0x.... 0x....      BL       OSPI_NOR_MspDeInit
    226          #endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS == 0) */
    227          
    228                /* Call the DeInit function to reset the driver */
    229                if (HAL_OSPI_DeInit(&hospi_nor[Instance]) != HAL_OK)
   \       0x54   0x4374             MULS     R4,R6,R4
   \       0x56   0xEB07 0x0004      ADD      R0,R7,R4
   \       0x5A   0x.... 0x....      BL       HAL_OSPI_DeInit
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD001             BEQ.N    ??BSP_OSPI_NOR_DeInit_1
    230                {
    231                  ret = BSP_ERROR_PERIPH_FAILURE;
   \       0x62   0xF07F 0x0503      MVNS     R5,#+3
    232                }
    233              }
    234            }
    235          
    236            /* Return BSP status */
    237            return ret;
   \                     ??BSP_OSPI_NOR_DeInit_1: (+1)
   \       0x66   0x0028             MOVS     R0,R5
   \       0x68   0xBDF2             POP      {R1,R4-R7,PC}
    238          }
    239          
    240          /**
    241            * @brief  Initializes the OSPI interface.
    242            * @param  hospi          OSPI handle
    243            * @param  Config         OSPI config structure
    244            * @retval BSP status
    245            */

   \                                 In section .text, align 4
    246          __weak HAL_StatusTypeDef MX_OSPI_NOR_Init(OSPI_HandleTypeDef *hospi, MX_OSPI_Config *Config)
    247          {
   \                     MX_OSPI_NOR_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    248              /* OctoSPI initialization */
    249            hospi->Instance = OCTOSPI1;
   \        0x2   0x4A14             LDR.N    R2,??MX_OSPI_NOR_Init_0
   \        0x4   0x6002             STR      R2,[R0, #+0]
    250          
    251            hospi->Init.FifoThreshold      = 4;
   \        0x6   0x2204             MOVS     R2,#+4
   \        0x8   0x6042             STR      R2,[R0, #+4]
    252            hospi->Init.DualQuad           = HAL_OSPI_DUALQUAD_DISABLE;
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x6082             STR      R2,[R0, #+8]
    253            hospi->Init.DeviceSize         = Config->MemorySize; /* 512 MBits */
   \        0xE   0x680A             LDR      R2,[R1, #+0]
   \       0x10   0x6102             STR      R2,[R0, #+16]
    254            hospi->Init.ChipSelectHighTime = 2;
   \       0x12   0x2202             MOVS     R2,#+2
   \       0x14   0x6142             STR      R2,[R0, #+20]
    255            hospi->Init.FreeRunningClock   = HAL_OSPI_FREERUNCLK_DISABLE;
   \       0x16   0x2200             MOVS     R2,#+0
   \       0x18   0x6182             STR      R2,[R0, #+24]
    256            hospi->Init.ClockMode          = HAL_OSPI_CLOCK_MODE_0;
   \       0x1A   0x2200             MOVS     R2,#+0
   \       0x1C   0x61C2             STR      R2,[R0, #+28]
    257            hospi->Init.WrapSize           = HAL_OSPI_WRAP_NOT_SUPPORTED;
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0x6202             STR      R2,[R0, #+32]
    258            hospi->Init.ClockPrescaler     = Config->ClockPrescaler;
   \       0x22   0x684A             LDR      R2,[R1, #+4]
   \       0x24   0x6242             STR      R2,[R0, #+36]
    259            hospi->Init.SampleShifting     = Config->SampleShifting;
   \       0x26   0x688A             LDR      R2,[R1, #+8]
   \       0x28   0x6282             STR      R2,[R0, #+40]
    260            hospi->Init.ChipSelectBoundary = 0;
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0x6302             STR      R2,[R0, #+48]
    261            hospi->Init.DelayBlockBypass   = HAL_OSPI_DELAY_BLOCK_BYPASSED;
   \       0x2E   0x2208             MOVS     R2,#+8
   \       0x30   0x6382             STR      R2,[R0, #+56]
    262          
    263            if (Config->TransferRate == (uint32_t)BSP_OSPI_NOR_DTR_TRANSFER)
   \       0x32   0x68C9             LDR      R1,[R1, #+12]
   \       0x34   0x2901             CMP      R1,#+1
   \       0x36   0xD106             BNE.N    ??MX_OSPI_NOR_Init_1
    264            {
    265              hospi->Init.MemoryType            = HAL_OSPI_MEMTYPE_MACRONIX;
   \       0x38   0xF05F 0x7180      MOVS     R1,#+16777216
   \       0x3C   0x60C1             STR      R1,[R0, #+12]
    266              hospi->Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_ENABLE;
   \       0x3E   0xF05F 0x5180      MOVS     R1,#+268435456
   \       0x42   0x62C1             STR      R1,[R0, #+44]
   \       0x44   0xE003             B.N      ??MX_OSPI_NOR_Init_2
    267            }
    268            else
    269            {
    270              hospi->Init.MemoryType            = HAL_OSPI_MEMTYPE_MICRON;
   \                     ??MX_OSPI_NOR_Init_1: (+1)
   \       0x46   0x2100             MOVS     R1,#+0
   \       0x48   0x60C1             STR      R1,[R0, #+12]
    271              hospi->Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_DISABLE;
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0x62C1             STR      R1,[R0, #+44]
    272            }
    273          
    274            return HAL_OSPI_Init(hospi);
   \                     ??MX_OSPI_NOR_Init_2: (+1)
   \       0x4E   0x.... 0x....      BL       HAL_OSPI_Init
   \       0x52   0xBD02             POP      {R1,PC}
   \                     ??MX_OSPI_NOR_Init_0:
   \       0x54   0x5200'5000        DC32     0x52005000
    275          }
    276          
    277          #if (USE_HAL_OSPI_REGISTER_CALLBACKS == 1)
    278          /**
    279            * @brief Default BSP OSPI Msp Callbacks
    280            * @param Instance      OSPI Instance
    281            * @retval BSP status
    282            */
    283          int32_t BSP_OSPI_NOR_RegisterDefaultMspCallbacks (uint32_t Instance)
    284          {
    285            int32_t ret = BSP_ERROR_NONE;
    286          
    287            /* Check if the instance is supported */
    288            if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
    289            {
    290              ret = BSP_ERROR_WRONG_PARAM;
    291            }
    292            else
    293            {
    294              /* Register MspInit/MspDeInit Callbacks */
    295              if(HAL_OSPI_RegisterCallback(&hospi_nor[Instance], HAL_OSPI_MSPINIT_CB_ID, OSPI_NOR_MspInit) != HAL_OK)
    296              {
    297                ret = BSP_ERROR_PERIPH_FAILURE;
    298              }
    299              else if(HAL_OSPI_RegisterCallback(&hospi_nor[Instance], HAL_OSPI_MSPDEINIT_CB_ID, OSPI_NOR_MspDeInit) != HAL_OK)
    300              {
    301                ret = BSP_ERROR_PERIPH_FAILURE;
    302              }
    303              else
    304              {
    305                Ospi_Nor_Ctx[Instance].IsMspCallbacksValid = 1U;
    306              }
    307            }
    308          
    309            /* Return BSP status */
    310            return ret;
    311          }
    312          
    313          /**
    314            * @brief BSP OSPI Msp Callback registering
    315            * @param Instance     OSPI Instance
    316            * @param CallBacks    pointer to MspInit/MspDeInit callbacks functions
    317            * @retval BSP status
    318            */
    319          int32_t BSP_OSPI_NOR_RegisterMspCallbacks (uint32_t Instance, BSP_OSPI_NOR_Cb_t *CallBacks)
    320          {
    321            int32_t ret = BSP_ERROR_NONE;
    322          
    323            /* Check if the instance is supported */
    324            if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
    325            {
    326              ret = BSP_ERROR_WRONG_PARAM;
    327            }
    328            else
    329            {
    330              /* Register MspInit/MspDeInit Callbacks */
    331              if(HAL_OSPI_RegisterCallback(&hospi_nor[Instance], HAL_OSPI_MSPINIT_CB_ID, CallBacks->pMspInitCb) != HAL_OK)
    332              {
    333                ret = BSP_ERROR_PERIPH_FAILURE;
    334              }
    335              else if(HAL_OSPI_RegisterCallback(&hospi_nor[Instance], HAL_OSPI_MSPDEINIT_CB_ID, CallBacks->pMspDeInitCb) != HAL_OK)
    336              {
    337                ret = BSP_ERROR_PERIPH_FAILURE;
    338              }
    339              else
    340              {
    341                Ospi_Nor_Ctx[Instance].IsMspCallbacksValid = 1U;
    342              }
    343            }
    344          
    345            /* Return BSP status */
    346            return ret;
    347          }
    348          #endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS == 1) */
    349          
    350          /**
    351            * @brief  Reads an amount of data from the OSPI memory.
    352            * @param  Instance  OSPI instance
    353            * @param  pData     Pointer to data to be read
    354            * @param  ReadAddr  Read start address
    355            * @param  Size      Size of data to read
    356            * @retval BSP status
    357            */

   \                                 In section .text, align 2, keep-with-next
    358          int32_t BSP_OSPI_NOR_Read(uint32_t Instance, uint8_t* pData, uint32_t ReadAddr, uint32_t Size)
    359          {
   \                     BSP_OSPI_NOR_Read: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
    360            int32_t ret = BSP_ERROR_NONE;
   \        0x2   0x2500             MOVS     R5,#+0
    361          
    362            /* Check if the instance is supported */
    363            if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD002             BEQ.N    ??BSP_OSPI_NOR_Read_0
    364            {
    365              ret = BSP_ERROR_WRONG_PARAM;
   \        0x8   0xF07F 0x0501      MVNS     R5,#+1
   \        0xC   0xE024             B.N      ??BSP_OSPI_NOR_Read_1
    366            }
    367            else if(Ospi_Nor_Ctx[Instance].TransferRate == BSP_OSPI_NOR_STR_TRANSFER)
   \                     ??BSP_OSPI_NOR_Read_0: (+1)
   \        0xE   0x.... 0x....      LDR.W    R6,??DataTable18
   \       0x12   0xEB06 0x04C0      ADD      R4,R6,R0, LSL #+3
   \       0x16   0x78A4             LDRB     R4,[R4, #+2]
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD112             BNE.N    ??BSP_OSPI_NOR_Read_2
    368            {
    369              if(MX25LM51245G_ReadSTR(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, MX25LM51245G_4BYTES_SIZE, pData, ReadAddr, Size) != MX25LM51245G_OK)
   \       0x1C   0x9301             STR      R3,[SP, #+4]
   \       0x1E   0x9200             STR      R2,[SP, #+0]
   \       0x20   0x000B             MOVS     R3,R1
   \       0x22   0x2201             MOVS     R2,#+1
   \       0x24   0xEB06 0x01C0      ADD      R1,R6,R0, LSL #+3
   \       0x28   0x7849             LDRB     R1,[R1, #+1]
   \       0x2A   0x.... 0x....      LDR.W    R6,??DataTable18_1
   \       0x2E   0x2460             MOVS     R4,#+96
   \       0x30   0x4360             MULS     R0,R4,R0
   \       0x32   0x4430             ADD      R0,R6,R0
   \       0x34   0x.... 0x....      BL       MX25LM51245G_ReadSTR
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD00D             BEQ.N    ??BSP_OSPI_NOR_Read_1
    370              {
    371                ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x3C   0xF07F 0x0504      MVNS     R5,#+4
   \       0x40   0xE00A             B.N      ??BSP_OSPI_NOR_Read_1
    372              }
    373            }
    374            else
    375            {
    376              if(MX25LM51245G_ReadDTR(&hospi_nor[Instance], pData, ReadAddr, Size) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_Read_2: (+1)
   \       0x42   0x.... 0x....      LDR.W    R6,??DataTable18_1
   \       0x46   0x2460             MOVS     R4,#+96
   \       0x48   0x4360             MULS     R0,R4,R0
   \       0x4A   0x4430             ADD      R0,R6,R0
   \       0x4C   0x.... 0x....      BL       MX25LM51245G_ReadDTR
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD001             BEQ.N    ??BSP_OSPI_NOR_Read_1
    377              {
    378                ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x54   0xF07F 0x0504      MVNS     R5,#+4
    379              }
    380            }
    381          
    382            /* Return BSP status */
    383            return ret;
   \                     ??BSP_OSPI_NOR_Read_1: (+1)
   \       0x58   0x0028             MOVS     R0,R5
   \       0x5A   0xBD76             POP      {R1,R2,R4-R6,PC}
    384          }
    385          
    386          /**
    387            * @brief  Writes an amount of data to the OSPI memory.
    388            * @param  Instance  OSPI instance
    389            * @param  pData     Pointer to data to be written
    390            * @param  WriteAddr Write start address
    391            * @param  Size      Size of data to write
    392            * @retval BSP status
    393            */

   \                                 In section .text, align 2, keep-with-next
    394          int32_t BSP_OSPI_NOR_Write(uint32_t Instance, uint8_t* pData, uint32_t WriteAddr, uint32_t Size)
    395          {
   \                     BSP_OSPI_NOR_Write: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0005             MOVS     R5,R0
    396            int32_t ret = BSP_ERROR_NONE;
   \        0x6   0x2400             MOVS     R4,#+0
    397            uint32_t end_addr, current_size, current_addr;
    398            uint32_t data_addr;
    399          
    400            /* Check if the instance is supported */
    401            if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
   \        0x8   0x2D00             CMP      R5,#+0
   \        0xA   0xD002             BEQ.N    ??BSP_OSPI_NOR_Write_0
    402            {
    403              ret = BSP_ERROR_WRONG_PARAM;
   \        0xC   0xF07F 0x0401      MVNS     R4,#+1
   \       0x10   0xE078             B.N      ??BSP_OSPI_NOR_Write_1
    404            }
    405            else
    406            {
    407              /* Calculation of the size between the write address and the end of the page */
    408              current_size = MX25LM51245G_PAGE_SIZE - (WriteAddr % MX25LM51245G_PAGE_SIZE);
   \                     ??BSP_OSPI_NOR_Write_0: (+1)
   \       0x12   0xF002 0x06FF      AND      R6,R2,#0xFF
   \       0x16   0xF5D6 0x7680      RSBS     R6,R6,#+256
    409          
    410              /* Check if the size of the data is less than the remaining place in the page */
    411              if (current_size > Size)
   \       0x1A   0x42B3             CMP      R3,R6
   \       0x1C   0xD200             BCS.N    ??BSP_OSPI_NOR_Write_2
    412              {
    413                current_size = Size;
   \       0x1E   0x001E             MOVS     R6,R3
    414              }
    415          
    416              /* Initialize the address variables */
    417              current_addr = WriteAddr;
   \                     ??BSP_OSPI_NOR_Write_2: (+1)
   \       0x20   0x0017             MOVS     R7,R2
    418              end_addr = WriteAddr + Size;
   \       0x22   0x189A             ADDS     R2,R3,R2
   \       0x24   0x9202             STR      R2,[SP, #+8]
    419              data_addr = (uint32_t)pData;
   \       0x26   0x4688             MOV      R8,R1
    420          
    421              /* Perform the write page by page */
    422              do
    423              {
    424                /* Check if Flash busy ? */
    425                if(MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_Write_3: (+1)
   \       0x28   0xF05F 0x0960      MOVS     R9,#+96
   \       0x2C   0x.... 0x....      LDR.W    R10,??DataTable18_1
   \       0x30   0x.... 0x....      LDR.W    R11,??DataTable18
   \       0x34   0xEB0B 0x00C5      ADD      R0,R11,R5, LSL #+3
   \       0x38   0x7882             LDRB     R2,[R0, #+2]
   \       0x3A   0xEB0B 0x00C5      ADD      R0,R11,R5, LSL #+3
   \       0x3E   0x7841             LDRB     R1,[R0, #+1]
   \       0x40   0xFB09 0xF005      MUL      R0,R9,R5
   \       0x44   0x4450             ADD      R0,R10,R0
   \       0x46   0x.... 0x....      BL       MX25LM51245G_AutoPollingMemReady
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD002             BEQ.N    ??BSP_OSPI_NOR_Write_4
    426                {
    427                  ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x4E   0xF07F 0x0404      MVNS     R4,#+4
   \       0x52   0xE052             B.N      ??BSP_OSPI_NOR_Write_5
    428                }/* Enable write operations */
    429                else if(MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_Write_4: (+1)
   \       0x54   0xEB0B 0x00C5      ADD      R0,R11,R5, LSL #+3
   \       0x58   0x7882             LDRB     R2,[R0, #+2]
   \       0x5A   0xEB0B 0x00C5      ADD      R0,R11,R5, LSL #+3
   \       0x5E   0x7841             LDRB     R1,[R0, #+1]
   \       0x60   0xFB09 0xF005      MUL      R0,R9,R5
   \       0x64   0x4450             ADD      R0,R10,R0
   \       0x66   0x.... 0x....      BL       MX25LM51245G_WriteEnable
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD002             BEQ.N    ??BSP_OSPI_NOR_Write_6
    430                {
    431                  ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x6E   0xF07F 0x0404      MVNS     R4,#+4
   \       0x72   0xE042             B.N      ??BSP_OSPI_NOR_Write_5
    432                }
    433                else
    434                {
    435                  if(Ospi_Nor_Ctx[Instance].TransferRate == BSP_OSPI_NOR_STR_TRANSFER)
   \                     ??BSP_OSPI_NOR_Write_6: (+1)
   \       0x74   0xEB0B 0x00C5      ADD      R0,R11,R5, LSL #+3
   \       0x78   0x7880             LDRB     R0,[R0, #+2]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD110             BNE.N    ??BSP_OSPI_NOR_Write_7
    436                  {
    437                    /* Issue page program command */
    438                    if(MX25LM51245G_PageProgram(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, MX25LM51245G_4BYTES_SIZE, (uint8_t*)data_addr, current_addr, current_size) != MX25LM51245G_OK)
   \       0x7E   0x9601             STR      R6,[SP, #+4]
   \       0x80   0x9700             STR      R7,[SP, #+0]
   \       0x82   0x4643             MOV      R3,R8
   \       0x84   0x2201             MOVS     R2,#+1
   \       0x86   0xEB0B 0x00C5      ADD      R0,R11,R5, LSL #+3
   \       0x8A   0x7841             LDRB     R1,[R0, #+1]
   \       0x8C   0xFB09 0xF005      MUL      R0,R9,R5
   \       0x90   0x4450             ADD      R0,R10,R0
   \       0x92   0x.... 0x....      BL       MX25LM51245G_PageProgram
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD00E             BEQ.N    ??BSP_OSPI_NOR_Write_8
    439                    {
    440                      ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x9A   0xF07F 0x0404      MVNS     R4,#+4
   \       0x9E   0xE00B             B.N      ??BSP_OSPI_NOR_Write_8
    441                    }
    442                  }
    443                  else
    444                  {
    445                    /* Issue page program command */
    446                    if(MX25LM51245G_PageProgramDTR(&hospi_nor[Instance], (uint8_t*)data_addr, current_addr, current_size) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_Write_7: (+1)
   \       0xA0   0x0033             MOVS     R3,R6
   \       0xA2   0x003A             MOVS     R2,R7
   \       0xA4   0x4641             MOV      R1,R8
   \       0xA6   0xFB09 0xF005      MUL      R0,R9,R5
   \       0xAA   0x4450             ADD      R0,R10,R0
   \       0xAC   0x.... 0x....      BL       MX25LM51245G_PageProgramDTR
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD001             BEQ.N    ??BSP_OSPI_NOR_Write_8
    447                    {
    448                      ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0xB4   0xF07F 0x0404      MVNS     R4,#+4
    449                    }
    450                  }
    451          
    452                  if (ret == BSP_ERROR_NONE)
   \                     ??BSP_OSPI_NOR_Write_8: (+1)
   \       0xB8   0x2C00             CMP      R4,#+0
   \       0xBA   0xD11E             BNE.N    ??BSP_OSPI_NOR_Write_5
    453                  {
    454                    /* Configure automatic polling mode to wait for end of program */
    455                    if (MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
   \       0xBC   0xEB0B 0x00C5      ADD      R0,R11,R5, LSL #+3
   \       0xC0   0x7882             LDRB     R2,[R0, #+2]
   \       0xC2   0xEB0B 0x00C5      ADD      R0,R11,R5, LSL #+3
   \       0xC6   0x7841             LDRB     R1,[R0, #+1]
   \       0xC8   0xFB09 0xF905      MUL      R9,R9,R5
   \       0xCC   0xEB0A 0x0009      ADD      R0,R10,R9
   \       0xD0   0x.... 0x....      BL       MX25LM51245G_AutoPollingMemReady
   \       0xD4   0x2800             CMP      R0,#+0
   \       0xD6   0xD002             BEQ.N    ??BSP_OSPI_NOR_Write_9
    456                    {
    457                      ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0xD8   0xF07F 0x0404      MVNS     R4,#+4
   \       0xDC   0xE00D             B.N      ??BSP_OSPI_NOR_Write_5
    458                    }
    459                    else
    460                    {
    461                      /* Update the address and size variables for next page programming */
    462                      current_addr += current_size;
   \                     ??BSP_OSPI_NOR_Write_9: (+1)
   \       0xDE   0x19F7             ADDS     R7,R6,R7
    463                      data_addr += current_size;
   \       0xE0   0xEB16 0x0608      ADDS     R6,R6,R8
   \       0xE4   0x46B0             MOV      R8,R6
    464                      current_size = ((current_addr + MX25LM51245G_PAGE_SIZE) > end_addr) ? (end_addr - current_addr) : MX25LM51245G_PAGE_SIZE;
   \       0xE6   0x9802             LDR      R0,[SP, #+8]
   \       0xE8   0xF517 0x7180      ADDS     R1,R7,#+256
   \       0xEC   0x4288             CMP      R0,R1
   \       0xEE   0xD202             BCS.N    ??BSP_OSPI_NOR_Write_10
   \       0xF0   0x9E02             LDR      R6,[SP, #+8]
   \       0xF2   0x1BF6             SUBS     R6,R6,R7
   \       0xF4   0xE001             B.N      ??BSP_OSPI_NOR_Write_5
   \                     ??BSP_OSPI_NOR_Write_10: (+1)
   \       0xF6   0xF44F 0x7680      MOV      R6,#+256
    465                    }
    466                  }
    467                }
    468              } while ((current_addr < end_addr) && (ret == BSP_ERROR_NONE));
   \                     ??BSP_OSPI_NOR_Write_5: (+1)
   \       0xFA   0x9802             LDR      R0,[SP, #+8]
   \       0xFC   0x4287             CMP      R7,R0
   \       0xFE   0xD201             BCS.N    ??BSP_OSPI_NOR_Write_1
   \      0x100   0x2C00             CMP      R4,#+0
   \      0x102   0xD091             BEQ.N    ??BSP_OSPI_NOR_Write_3
    469            }
    470          
    471            /* Return BSP status */
    472            return ret;
   \                     ??BSP_OSPI_NOR_Write_1: (+1)
   \      0x104   0x0020             MOVS     R0,R4
   \      0x106   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    473          }
    474          
    475          /**
    476            * @brief  Erases the specified block of the OSPI memory.
    477            * @param  Instance     OSPI instance
    478            * @param  BlockAddress Block address to erase
    479            * @param  BlockSize    Erase Block size
    480            * @retval BSP status
    481            */

   \                                 In section .text, align 2, keep-with-next
    482          int32_t BSP_OSPI_NOR_Erase_Block(uint32_t Instance, uint32_t BlockAddress, BSP_OSPI_NOR_Erase_t BlockSize)
    483          {
   \                     BSP_OSPI_NOR_Erase_Block: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
    484            int32_t ret = BSP_ERROR_NONE;
   \        0xA   0x2500             MOVS     R5,#+0
    485          
    486            /* Check if the instance is supported */
    487            if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD002             BEQ.N    ??BSP_OSPI_NOR_Erase_Block_0
    488            {
    489              ret = BSP_ERROR_WRONG_PARAM;
   \       0x10   0xF07F 0x0501      MVNS     R5,#+1
   \       0x14   0xE039             B.N      ??BSP_OSPI_NOR_Erase_Block_1
    490            }/* Check Flash busy ? */
    491            else if(MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_Erase_Block_0: (+1)
   \       0x16   0xF05F 0x0860      MOVS     R8,#+96
   \       0x1A   0x.... 0x....      LDR.W    R9,??DataTable18_1
   \       0x1E   0x.... 0x....      LDR.W    R10,??DataTable18
   \       0x22   0xEB0A 0x00C4      ADD      R0,R10,R4, LSL #+3
   \       0x26   0x7882             LDRB     R2,[R0, #+2]
   \       0x28   0xEB0A 0x00C4      ADD      R0,R10,R4, LSL #+3
   \       0x2C   0x7841             LDRB     R1,[R0, #+1]
   \       0x2E   0xFB08 0xF004      MUL      R0,R8,R4
   \       0x32   0x4448             ADD      R0,R9,R0
   \       0x34   0x.... 0x....      BL       MX25LM51245G_AutoPollingMemReady
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD002             BEQ.N    ??BSP_OSPI_NOR_Erase_Block_2
    492            {
    493              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x3C   0xF07F 0x0504      MVNS     R5,#+4
   \       0x40   0xE023             B.N      ??BSP_OSPI_NOR_Erase_Block_1
    494            }/* Enable write operations */
    495            else if(MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_Erase_Block_2: (+1)
   \       0x42   0xEB0A 0x00C4      ADD      R0,R10,R4, LSL #+3
   \       0x46   0x7882             LDRB     R2,[R0, #+2]
   \       0x48   0xEB0A 0x00C4      ADD      R0,R10,R4, LSL #+3
   \       0x4C   0x7841             LDRB     R1,[R0, #+1]
   \       0x4E   0xFB08 0xF004      MUL      R0,R8,R4
   \       0x52   0x4448             ADD      R0,R9,R0
   \       0x54   0x.... 0x....      BL       MX25LM51245G_WriteEnable
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD002             BEQ.N    ??BSP_OSPI_NOR_Erase_Block_3
    496            {
    497              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x5C   0xF07F 0x0504      MVNS     R5,#+4
   \       0x60   0xE013             B.N      ??BSP_OSPI_NOR_Erase_Block_1
    498            }
    499            else
    500            {
    501              /* Issue Block Erase command */
    502              if(MX25LM51245G_BlockErase(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_4BYTES_SIZE, BlockAddress, BlockSize) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_Erase_Block_3: (+1)
   \       0x62   0xB2FF             UXTB     R7,R7
   \       0x64   0x9701             STR      R7,[SP, #+4]
   \       0x66   0x9600             STR      R6,[SP, #+0]
   \       0x68   0x2301             MOVS     R3,#+1
   \       0x6A   0xEB0A 0x00C4      ADD      R0,R10,R4, LSL #+3
   \       0x6E   0x7882             LDRB     R2,[R0, #+2]
   \       0x70   0xEB0A 0x00C4      ADD      R0,R10,R4, LSL #+3
   \       0x74   0x7841             LDRB     R1,[R0, #+1]
   \       0x76   0xFB08 0xF404      MUL      R4,R8,R4
   \       0x7A   0xEB09 0x0004      ADD      R0,R9,R4
   \       0x7E   0x.... 0x....      BL       MX25LM51245G_BlockErase
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD001             BEQ.N    ??BSP_OSPI_NOR_Erase_Block_1
    503              {
    504                ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x86   0xF07F 0x0504      MVNS     R5,#+4
    505              }
    506            }
    507          
    508            /* Return BSP status */
    509            return ret;
   \                     ??BSP_OSPI_NOR_Erase_Block_1: (+1)
   \       0x8A   0x0028             MOVS     R0,R5
   \       0x8C   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
    510          }
    511          
    512          /**
    513            * @brief  Erases the entire OSPI memory.
    514            * @param  Instance  QSPI instance
    515            * @retval BSP status
    516            */

   \                                 In section .text, align 2, keep-with-next
    517          int32_t BSP_OSPI_NOR_Erase_Chip(uint32_t Instance)
    518          {
   \                     BSP_OSPI_NOR_Erase_Chip: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
    519            int32_t ret = BSP_ERROR_NONE;
   \        0x6   0x2500             MOVS     R5,#+0
    520          
    521            /* Check if the instance is supported */
    522            if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD002             BEQ.N    ??BSP_OSPI_NOR_Erase_Chip_0
    523            {
    524              ret = BSP_ERROR_WRONG_PARAM;
   \        0xC   0xF07F 0x0501      MVNS     R5,#+1
   \       0x10   0xE033             B.N      ??BSP_OSPI_NOR_Erase_Chip_1
    525            }/* Check Flash busy ? */
    526            else if(MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_Erase_Chip_0: (+1)
   \       0x12   0x2660             MOVS     R6,#+96
   \       0x14   0x.... 0x....      LDR.W    R7,??DataTable18_1
   \       0x18   0x.... 0x....      LDR.W    R8,??DataTable18
   \       0x1C   0xEB08 0x00C4      ADD      R0,R8,R4, LSL #+3
   \       0x20   0x7882             LDRB     R2,[R0, #+2]
   \       0x22   0xEB08 0x00C4      ADD      R0,R8,R4, LSL #+3
   \       0x26   0x7841             LDRB     R1,[R0, #+1]
   \       0x28   0xFB06 0xF004      MUL      R0,R6,R4
   \       0x2C   0x4438             ADD      R0,R7,R0
   \       0x2E   0x.... 0x....      BL       MX25LM51245G_AutoPollingMemReady
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD002             BEQ.N    ??BSP_OSPI_NOR_Erase_Chip_2
    527            {
    528              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x36   0xF07F 0x0504      MVNS     R5,#+4
   \       0x3A   0xE01E             B.N      ??BSP_OSPI_NOR_Erase_Chip_1
    529            }/* Enable write operations */
    530            else if(MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_Erase_Chip_2: (+1)
   \       0x3C   0xEB08 0x00C4      ADD      R0,R8,R4, LSL #+3
   \       0x40   0x7882             LDRB     R2,[R0, #+2]
   \       0x42   0xEB08 0x00C4      ADD      R0,R8,R4, LSL #+3
   \       0x46   0x7841             LDRB     R1,[R0, #+1]
   \       0x48   0xFB06 0xF004      MUL      R0,R6,R4
   \       0x4C   0x4438             ADD      R0,R7,R0
   \       0x4E   0x.... 0x....      BL       MX25LM51245G_WriteEnable
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD002             BEQ.N    ??BSP_OSPI_NOR_Erase_Chip_3
    531            {
    532              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x56   0xF07F 0x0504      MVNS     R5,#+4
   \       0x5A   0xE00E             B.N      ??BSP_OSPI_NOR_Erase_Chip_1
    533            }
    534            else
    535            {
    536              /* Issue Chip erase command */
    537              if(MX25LM51245G_ChipErase(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_Erase_Chip_3: (+1)
   \       0x5C   0xEB08 0x00C4      ADD      R0,R8,R4, LSL #+3
   \       0x60   0x7882             LDRB     R2,[R0, #+2]
   \       0x62   0xEB08 0x00C4      ADD      R0,R8,R4, LSL #+3
   \       0x66   0x7841             LDRB     R1,[R0, #+1]
   \       0x68   0x4374             MULS     R4,R6,R4
   \       0x6A   0xEB07 0x0004      ADD      R0,R7,R4
   \       0x6E   0x.... 0x....      BL       MX25LM51245G_ChipErase
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD001             BEQ.N    ??BSP_OSPI_NOR_Erase_Chip_1
    538              {
    539                ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x76   0xF07F 0x0504      MVNS     R5,#+4
    540              }
    541            }
    542          
    543            /* Return BSP status */
    544            return ret;
   \                     ??BSP_OSPI_NOR_Erase_Chip_1: (+1)
   \       0x7A   0x0028             MOVS     R0,R5
   \       0x7C   0xE8BD 0x81F0      POP      {R4-R8,PC}
    545          }
    546          
    547          /**
    548            * @brief  Reads current status of the OSPI memory.
    549            * @param  Instance  QSPI instance
    550            * @retval OSPI memory status: whether busy or not
    551            */

   \                                 In section .text, align 2, keep-with-next
    552          int32_t BSP_OSPI_NOR_GetStatus(uint32_t Instance)
    553          {
   \                     BSP_OSPI_NOR_GetStatus: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
    554            static uint8_t reg[2];
    555            int32_t ret = BSP_ERROR_NONE;
   \        0x6   0x2500             MOVS     R5,#+0
    556          
    557            /* Check if the instance is supported */
    558            if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD002             BEQ.N    ??BSP_OSPI_NOR_GetStatus_0
    559            {
    560              ret = BSP_ERROR_WRONG_PARAM;
   \        0xC   0xF07F 0x0501      MVNS     R5,#+1
   \       0x10   0xE03E             B.N      ??BSP_OSPI_NOR_GetStatus_1
    561            }
    562            else if(MX25LM51245G_ReadSecurityRegister(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, reg) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_GetStatus_0: (+1)
   \       0x12   0x2660             MOVS     R6,#+96
   \       0x14   0x.... 0x....      LDR.W    R7,??DataTable18_1
   \       0x18   0x.... 0x....      LDR.W    R8,??DataTable18
   \       0x1C   0x.... 0x....      LDR.W    R9,??DataTable18_2
   \       0x20   0x464B             MOV      R3,R9
   \       0x22   0xEB08 0x00C4      ADD      R0,R8,R4, LSL #+3
   \       0x26   0x7882             LDRB     R2,[R0, #+2]
   \       0x28   0xEB08 0x00C4      ADD      R0,R8,R4, LSL #+3
   \       0x2C   0x7841             LDRB     R1,[R0, #+1]
   \       0x2E   0xFB06 0xF004      MUL      R0,R6,R4
   \       0x32   0x4438             ADD      R0,R7,R0
   \       0x34   0x.... 0x....      BL       MX25LM51245G_ReadSecurityRegister
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD002             BEQ.N    ??BSP_OSPI_NOR_GetStatus_2
    563            {
    564              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x3C   0xF07F 0x0504      MVNS     R5,#+4
   \       0x40   0xE026             B.N      ??BSP_OSPI_NOR_GetStatus_1
    565            }/* Check the value of the register */
    566            else if ((reg[0] & (MX25LM51245G_SECR_P_FAIL | MX25LM51245G_SECR_E_FAIL)) != 0U)
   \                     ??BSP_OSPI_NOR_GetStatus_2: (+1)
   \       0x42   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \       0x46   0xF010 0x0F60      TST      R0,#0x60
   \       0x4A   0xD002             BEQ.N    ??BSP_OSPI_NOR_GetStatus_3
    567            {
    568              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x4C   0xF07F 0x0504      MVNS     R5,#+4
   \       0x50   0xE01E             B.N      ??BSP_OSPI_NOR_GetStatus_1
    569            }
    570            else if ((reg[0] & (MX25LM51245G_SECR_PSB | MX25LM51245G_SECR_ESB)) != 0U)
   \                     ??BSP_OSPI_NOR_GetStatus_3: (+1)
   \       0x52   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \       0x56   0xF010 0x0F0C      TST      R0,#0xC
   \       0x5A   0xD002             BEQ.N    ??BSP_OSPI_NOR_GetStatus_4
    571            {
    572              ret = BSP_ERROR_OSPI_SUSPENDED;
   \       0x5C   0xF07F 0x0513      MVNS     R5,#+19
   \       0x60   0xE016             B.N      ??BSP_OSPI_NOR_GetStatus_1
    573            }
    574            else if(MX25LM51245G_ReadStatusRegister(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, reg) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_GetStatus_4: (+1)
   \       0x62   0x464B             MOV      R3,R9
   \       0x64   0xEB08 0x00C4      ADD      R0,R8,R4, LSL #+3
   \       0x68   0x7882             LDRB     R2,[R0, #+2]
   \       0x6A   0xEB08 0x00C4      ADD      R0,R8,R4, LSL #+3
   \       0x6E   0x7841             LDRB     R1,[R0, #+1]
   \       0x70   0x4374             MULS     R4,R6,R4
   \       0x72   0xEB07 0x0004      ADD      R0,R7,R4
   \       0x76   0x.... 0x....      BL       MX25LM51245G_ReadStatusRegister
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD002             BEQ.N    ??BSP_OSPI_NOR_GetStatus_5
    575            {
    576              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x7E   0xF07F 0x0504      MVNS     R5,#+4
   \       0x82   0xE005             B.N      ??BSP_OSPI_NOR_GetStatus_1
    577            }
    578            else
    579            {
    580              /* Check the value of the register */
    581              if ((reg[0] & MX25LM51245G_SR_WIP) != 0U)
   \                     ??BSP_OSPI_NOR_GetStatus_5: (+1)
   \       0x84   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \       0x88   0x07C0             LSLS     R0,R0,#+31
   \       0x8A   0xD501             BPL.N    ??BSP_OSPI_NOR_GetStatus_1
    582              {
    583                ret = BSP_ERROR_BUSY;
   \       0x8C   0xF07F 0x0502      MVNS     R5,#+2
    584              }
    585            }
    586          
    587            /* Return BSP status */
    588            return ret;
   \                     ??BSP_OSPI_NOR_GetStatus_1: (+1)
   \       0x90   0x0028             MOVS     R0,R5
   \       0x92   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    589          }

   \                                 In section .bss, align 2
   \                     `BSP_OSPI_NOR_GetStatus::reg`:
   \        0x0                      DS8 2
    590          
    591          /**
    592            * @brief  Return the configuration of the OSPI memory.
    593            * @param  Instance  OSPI instance
    594            * @param  pInfo     pointer on the configuration structure
    595            * @retval BSP status
    596            */

   \                                 In section .text, align 2, keep-with-next
    597          int32_t BSP_OSPI_NOR_GetInfo(uint32_t Instance, BSP_OSPI_NOR_Info_t* pInfo)
    598          {
   \                     BSP_OSPI_NOR_GetInfo: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    599            int32_t ret = BSP_ERROR_NONE;
   \        0x2   0x2400             MOVS     R4,#+0
    600          
    601            /* Check if the instance is supported */
    602            if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD002             BEQ.N    ??BSP_OSPI_NOR_GetInfo_0
    603            {
    604              ret = BSP_ERROR_WRONG_PARAM;
   \        0x8   0xF07F 0x0401      MVNS     R4,#+1
   \        0xC   0xE002             B.N      ??BSP_OSPI_NOR_GetInfo_1
    605            }
    606            else
    607            {
    608              (void)MX25LM51245G_GetFlashInfo(pInfo);
   \                     ??BSP_OSPI_NOR_GetInfo_0: (+1)
   \        0xE   0x0008             MOVS     R0,R1
   \       0x10   0x.... 0x....      BL       MX25LM51245G_GetFlashInfo
    609            }
    610          
    611            /* Return BSP status */
    612            return ret;
   \                     ??BSP_OSPI_NOR_GetInfo_1: (+1)
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0xBD10             POP      {R4,PC}
    613          }
    614          
    615          /**
    616            * @brief  Configure the OSPI in memory-mapped mode
    617            * @param  Instance  OSPI instance
    618            * @retval BSP status
    619            */

   \                                 In section .text, align 2, keep-with-next
    620          int32_t BSP_OSPI_NOR_EnableMemoryMappedMode(uint32_t Instance)
    621          {
   \                     BSP_OSPI_NOR_EnableMemoryMappedMode: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    622            int32_t ret = BSP_ERROR_NONE;
   \        0x4   0x2500             MOVS     R5,#+0
    623          
    624            /* Check if the instance is supported */
    625            if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD002             BEQ.N    ??BSP_OSPI_NOR_EnableMemoryMappedMode_0
    626            {
    627              ret = BSP_ERROR_WRONG_PARAM;
   \        0xA   0xF07F 0x0501      MVNS     R5,#+1
   \        0xE   0xE02E             B.N      ??BSP_OSPI_NOR_EnableMemoryMappedMode_1
    628            }
    629            else if(Ospi_Nor_Ctx[Instance].TransferRate == BSP_OSPI_NOR_STR_TRANSFER)
   \                     ??BSP_OSPI_NOR_EnableMemoryMappedMode_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R6,??DataTable18
   \       0x14   0xEB06 0x00C4      ADD      R0,R6,R4, LSL #+3
   \       0x18   0x7880             LDRB     R0,[R0, #+2]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD114             BNE.N    ??BSP_OSPI_NOR_EnableMemoryMappedMode_2
    630            {
    631              if(MX25LM51245G_EnableMemoryMappedModeSTR(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, MX25LM51245G_4BYTES_SIZE) != MX25LM51245G_OK)
   \       0x1E   0x2201             MOVS     R2,#+1
   \       0x20   0xEB06 0x00C4      ADD      R0,R6,R4, LSL #+3
   \       0x24   0x7841             LDRB     R1,[R0, #+1]
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \       0x2A   0x2360             MOVS     R3,#+96
   \       0x2C   0xFB03 0xF304      MUL      R3,R3,R4
   \       0x30   0x4418             ADD      R0,R0,R3
   \       0x32   0x.... 0x....      BL       MX25LM51245G_EnableMemoryMappedModeSTR
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD002             BEQ.N    ??BSP_OSPI_NOR_EnableMemoryMappedMode_3
    632              {
    633                ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x3A   0xF07F 0x0504      MVNS     R5,#+4
   \       0x3E   0xE016             B.N      ??BSP_OSPI_NOR_EnableMemoryMappedMode_1
    634              }
    635              else /* Update OSPI context if all operations are well done */
    636              {
    637                Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_MMP;
   \                     ??BSP_OSPI_NOR_EnableMemoryMappedMode_3: (+1)
   \       0x40   0x2002             MOVS     R0,#+2
   \       0x42   0xF806 0x0034      STRB     R0,[R6, R4, LSL #+3]
   \       0x46   0xE012             B.N      ??BSP_OSPI_NOR_EnableMemoryMappedMode_1
    638              }
    639            }
    640            else
    641            {
    642              if(MX25LM51245G_EnableMemoryMappedModeDTR(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_EnableMemoryMappedMode_2: (+1)
   \       0x48   0xEB06 0x00C4      ADD      R0,R6,R4, LSL #+3
   \       0x4C   0x7841             LDRB     R1,[R0, #+1]
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \       0x52   0x2260             MOVS     R2,#+96
   \       0x54   0xFB02 0xF204      MUL      R2,R2,R4
   \       0x58   0x4410             ADD      R0,R0,R2
   \       0x5A   0x.... 0x....      BL       MX25LM51245G_EnableMemoryMappedModeDTR
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD002             BEQ.N    ??BSP_OSPI_NOR_EnableMemoryMappedMode_4
    643              {
    644                ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x62   0xF07F 0x0504      MVNS     R5,#+4
   \       0x66   0xE002             B.N      ??BSP_OSPI_NOR_EnableMemoryMappedMode_1
    645              }
    646              else /* Update OSPI context if all operations are well done */
    647              {
    648                Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_MMP;
   \                     ??BSP_OSPI_NOR_EnableMemoryMappedMode_4: (+1)
   \       0x68   0x2002             MOVS     R0,#+2
   \       0x6A   0xF806 0x0034      STRB     R0,[R6, R4, LSL #+3]
    649              }
    650            }
    651          
    652            /* Return BSP status */
    653            return ret;
   \                     ??BSP_OSPI_NOR_EnableMemoryMappedMode_1: (+1)
   \       0x6E   0x0028             MOVS     R0,R5
   \       0x70   0xBD70             POP      {R4-R6,PC}
    654          }
    655          
    656          /**
    657            * @brief  Exit form memory-mapped mode
    658            *         Only 1 Instance can running MMP mode. And it will lock system at this mode.
    659            * @param  Instance  OSPI instance
    660            * @retval BSP status
    661            */

   \                                 In section .text, align 2, keep-with-next
    662          int32_t BSP_OSPI_NOR_DisableMemoryMappedMode(uint32_t Instance)
    663          {
   \                     BSP_OSPI_NOR_DisableMemoryMappedMode: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    664            int32_t ret = BSP_ERROR_NONE;
   \        0x4   0x2500             MOVS     R5,#+0
    665          
    666            /* Check if the instance is supported */
    667            if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD002             BEQ.N    ??BSP_OSPI_NOR_DisableMemoryMappedMode_0
    668            {
    669              ret = BSP_ERROR_WRONG_PARAM;
   \        0xA   0xF07F 0x0501      MVNS     R5,#+1
   \        0xE   0xE018             B.N      ??BSP_OSPI_NOR_DisableMemoryMappedMode_1
    670            }
    671            else if(Ospi_Nor_Ctx[Instance].IsInitialized != OSPI_ACCESS_MMP)
   \                     ??BSP_OSPI_NOR_DisableMemoryMappedMode_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R6,??DataTable18
   \       0x14   0xF816 0x0034      LDRB     R0,[R6, R4, LSL #+3]
   \       0x18   0x2802             CMP      R0,#+2
   \       0x1A   0xD002             BEQ.N    ??BSP_OSPI_NOR_DisableMemoryMappedMode_2
    672            {
    673              ret = BSP_ERROR_OSPI_MMP_UNLOCK_FAILURE;
   \       0x1C   0xF07F 0x051A      MVNS     R5,#+26
   \       0x20   0xE00F             B.N      ??BSP_OSPI_NOR_DisableMemoryMappedMode_1
    674            }/* Abort MMP back to indirect mode */
    675            else if(HAL_OSPI_Abort(&hospi_nor[Instance]) != HAL_OK)
   \                     ??BSP_OSPI_NOR_DisableMemoryMappedMode_2: (+1)
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \       0x26   0x2160             MOVS     R1,#+96
   \       0x28   0xFB01 0xF104      MUL      R1,R1,R4
   \       0x2C   0x4408             ADD      R0,R0,R1
   \       0x2E   0x.... 0x....      BL       HAL_OSPI_Abort
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD002             BEQ.N    ??BSP_OSPI_NOR_DisableMemoryMappedMode_3
    676            {
    677              ret = BSP_ERROR_PERIPH_FAILURE;
   \       0x36   0xF07F 0x0503      MVNS     R5,#+3
   \       0x3A   0xE002             B.N      ??BSP_OSPI_NOR_DisableMemoryMappedMode_1
    678            }
    679            else
    680            {
    681              /* Update OSPI context if all operations are well done */
    682              Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_INDIRECT;
   \                     ??BSP_OSPI_NOR_DisableMemoryMappedMode_3: (+1)
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xF806 0x0034      STRB     R0,[R6, R4, LSL #+3]
    683            }
    684          
    685            /* Return BSP status */
    686            return ret;
   \                     ??BSP_OSPI_NOR_DisableMemoryMappedMode_1: (+1)
   \       0x42   0x0028             MOVS     R0,R5
   \       0x44   0xBD70             POP      {R4-R6,PC}
    687          }
    688          
    689          /**
    690            * @brief  Get flash ID 3 Bytes:
    691            *         Manufacturer ID, Memory type, Memory density
    692            * @param  Instance  OSPI instance
    693            * @param  Id Pointer to flash ID bytes
    694            * @retval BSP status
    695            */

   \                                 In section .text, align 2, keep-with-next
    696          int32_t BSP_OSPI_NOR_ReadID(uint32_t Instance, uint8_t *Id)
    697          {
   \                     BSP_OSPI_NOR_ReadID: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x000B             MOVS     R3,R1
    698            int32_t ret = BSP_ERROR_NONE;
   \        0x4   0x2500             MOVS     R5,#+0
    699          
    700            /* Check if the instance is supported */
    701            if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD002             BEQ.N    ??BSP_OSPI_NOR_ReadID_0
    702            {
    703              ret = BSP_ERROR_WRONG_PARAM;
   \        0xA   0xF07F 0x0501      MVNS     R5,#+1
   \        0xE   0xE012             B.N      ??BSP_OSPI_NOR_ReadID_1
    704            }
    705            else
    706            {
    707              if(MX25LM51245G_ReadID(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, Id) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_ReadID_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable18
   \       0x14   0xEB01 0x02C0      ADD      R2,R1,R0, LSL #+3
   \       0x18   0x7892             LDRB     R2,[R2, #+2]
   \       0x1A   0xEB01 0x01C0      ADD      R1,R1,R0, LSL #+3
   \       0x1E   0x7849             LDRB     R1,[R1, #+1]
   \       0x20   0x.... 0x....      LDR.W    R6,??DataTable18_1
   \       0x24   0x2460             MOVS     R4,#+96
   \       0x26   0x4360             MULS     R0,R4,R0
   \       0x28   0x4430             ADD      R0,R6,R0
   \       0x2A   0x.... 0x....      BL       MX25LM51245G_ReadID
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD001             BEQ.N    ??BSP_OSPI_NOR_ReadID_1
    708              {
    709                ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x32   0xF07F 0x0504      MVNS     R5,#+4
    710              }
    711            }
    712          
    713            /* Return BSP status */
    714            return ret;
   \                     ??BSP_OSPI_NOR_ReadID_1: (+1)
   \       0x36   0x0028             MOVS     R0,R5
   \       0x38   0xBD70             POP      {R4-R6,PC}
    715          }
    716          
    717          /**
    718            * @brief  Set Flash to desired Interface mode. And this instance becomes current instance.
    719            *         If current instance running at MMP mode then this function doesn't work.
    720            *         Indirect -> Indirect
    721            * @param  Instance  OSPI instance
    722            * @param  Mode      OSPI mode
    723            * @param  Rate      OSPI transfer rate
    724            * @retval BSP status
    725            */

   \                                 In section .text, align 2, keep-with-next
    726          int32_t BSP_OSPI_NOR_ConfigFlash(uint32_t Instance, BSP_OSPI_NOR_Interface_t Mode, BSP_OSPI_NOR_Transfer_t Rate)
    727          {
   \                     BSP_OSPI_NOR_ConfigFlash: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0017             MOVS     R7,R2
    728            int32_t ret = BSP_ERROR_NONE;
   \        0x8   0x2000             MOVS     R0,#+0
    729          
    730            /* Check if the instance is supported */
    731            if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD002             BEQ.N    ??BSP_OSPI_NOR_ConfigFlash_0
    732            {
    733              ret = BSP_ERROR_WRONG_PARAM;
   \        0xE   0xF07F 0x0001      MVNS     R0,#+1
   \       0x12   0xE048             B.N      ??BSP_OSPI_NOR_ConfigFlash_1
    734            }/* Check if MMP mode locked ************************************************/
    735            else if(Ospi_Nor_Ctx[Instance].IsInitialized == OSPI_ACCESS_MMP)
   \                     ??BSP_OSPI_NOR_ConfigFlash_0: (+1)
   \       0x14   0x.... 0x....      LDR.W    R5,??DataTable18
   \       0x18   0xF815 0x1034      LDRB     R1,[R5, R4, LSL #+3]
   \       0x1C   0x2902             CMP      R1,#+2
   \       0x1E   0xD102             BNE.N    ??BSP_OSPI_NOR_ConfigFlash_2
    736            {
    737              ret = BSP_ERROR_OSPI_MMP_LOCK_FAILURE;
   \       0x20   0xF07F 0x0019      MVNS     R0,#+25
   \       0x24   0xE03F             B.N      ??BSP_OSPI_NOR_ConfigFlash_1
    738            }
    739            else
    740            {
    741              /* Setup Flash interface ***************************************************/
    742              switch(Ospi_Nor_Ctx[Instance].InterfaceMode)
   \                     ??BSP_OSPI_NOR_ConfigFlash_2: (+1)
   \       0x26   0xEB05 0x01C4      ADD      R1,R5,R4, LSL #+3
   \       0x2A   0x7849             LDRB     R1,[R1, #+1]
   \       0x2C   0x2901             CMP      R1,#+1
   \       0x2E   0xD120             BNE.N    ??BSP_OSPI_NOR_ConfigFlash_3
    743              {
    744              case BSP_OSPI_NOR_OPI_MODE :  /* 8-8-8 commands */
    745                if((Mode != BSP_OSPI_NOR_OPI_MODE) || (Rate != Ospi_Nor_Ctx[Instance].TransferRate))
   \       0x30   0x0031             MOVS     R1,R6
   \       0x32   0xB2C9             UXTB     R1,R1
   \       0x34   0x2901             CMP      R1,#+1
   \       0x36   0xD106             BNE.N    ??BSP_OSPI_NOR_ConfigFlash_4
   \       0x38   0x0039             MOVS     R1,R7
   \       0x3A   0xEB05 0x02C4      ADD      R2,R5,R4, LSL #+3
   \       0x3E   0x7892             LDRB     R2,[R2, #+2]
   \       0x40   0xB2C9             UXTB     R1,R1
   \       0x42   0x4291             CMP      R1,R2
   \       0x44   0xD014             BEQ.N    ??BSP_OSPI_NOR_ConfigFlash_5
    746                {
    747                  /* Exit OPI mode */
    748                  ret = OSPI_NOR_ExitOPIMode(Instance);
   \                     ??BSP_OSPI_NOR_ConfigFlash_4: (+1)
   \       0x46   0x0020             MOVS     R0,R4
   \       0x48   0x.... 0x....      BL       OSPI_NOR_ExitOPIMode
    749          
    750                  if ((ret == BSP_ERROR_NONE) && (Mode == BSP_OSPI_NOR_OPI_MODE))
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD10F             BNE.N    ??BSP_OSPI_NOR_ConfigFlash_5
   \       0x50   0x0031             MOVS     R1,R6
   \       0x52   0xB2C9             UXTB     R1,R1
   \       0x54   0x2901             CMP      R1,#+1
   \       0x56   0xD10B             BNE.N    ??BSP_OSPI_NOR_ConfigFlash_5
    751                  {
    752          
    753                    if (Ospi_Nor_Ctx[Instance].TransferRate == BSP_OSPI_NOR_STR_TRANSFER)
   \       0x58   0xEB05 0x00C4      ADD      R0,R5,R4, LSL #+3
   \       0x5C   0x7880             LDRB     R0,[R0, #+2]
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD103             BNE.N    ??BSP_OSPI_NOR_ConfigFlash_6
    754                    {
    755                      /* Enter DTR OPI mode */
    756                      ret = OSPI_NOR_EnterDOPIMode(Instance);
   \       0x62   0x0020             MOVS     R0,R4
   \       0x64   0x.... 0x....      BL       OSPI_NOR_EnterDOPIMode
   \       0x68   0xE002             B.N      ??BSP_OSPI_NOR_ConfigFlash_5
    757                    }
    758                    else
    759                    {
    760                      /* Enter STR OPI mode */
    761                      ret = OSPI_NOR_EnterSOPIMode(Instance);
   \                     ??BSP_OSPI_NOR_ConfigFlash_6: (+1)
   \       0x6A   0x0020             MOVS     R0,R4
   \       0x6C   0x.... 0x....      BL       OSPI_NOR_EnterSOPIMode
    762                    }
    763                  }
    764                }
    765                break;
   \                     ??BSP_OSPI_NOR_ConfigFlash_5: (+1)
   \       0x70   0xE00E             B.N      ??BSP_OSPI_NOR_ConfigFlash_7
    766          
    767              case BSP_OSPI_NOR_SPI_MODE :  /* 1-1-1 commands, Power on H/W default setting */
    768              default :
    769                if(Mode == BSP_OSPI_NOR_OPI_MODE)
   \                     ??BSP_OSPI_NOR_ConfigFlash_3: (+1)
   \       0x72   0x0031             MOVS     R1,R6
   \       0x74   0xB2C9             UXTB     R1,R1
   \       0x76   0x2901             CMP      R1,#+1
   \       0x78   0xD10A             BNE.N    ??BSP_OSPI_NOR_ConfigFlash_8
    770                {
    771                  if(Rate == BSP_OSPI_NOR_STR_TRANSFER)
   \       0x7A   0x0038             MOVS     R0,R7
   \       0x7C   0xB2C0             UXTB     R0,R0
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD103             BNE.N    ??BSP_OSPI_NOR_ConfigFlash_9
    772                  {
    773                    /* Enter STR OPI mode */
    774                    ret = OSPI_NOR_EnterSOPIMode(Instance);
   \       0x82   0x0020             MOVS     R0,R4
   \       0x84   0x.... 0x....      BL       OSPI_NOR_EnterSOPIMode
   \       0x88   0xE002             B.N      ??BSP_OSPI_NOR_ConfigFlash_8
    775                  }
    776                  else
    777                  {
    778                    /* Enter DTR OPI mode */
    779                    ret = OSPI_NOR_EnterDOPIMode(Instance);
   \                     ??BSP_OSPI_NOR_ConfigFlash_9: (+1)
   \       0x8A   0x0020             MOVS     R0,R4
   \       0x8C   0x.... 0x....      BL       OSPI_NOR_EnterDOPIMode
    780                  }
    781                }
    782                break;
    783              }
    784          
    785              /* Update OSPI context if all operations are well done */
    786              if(ret == BSP_ERROR_NONE)
   \                     ??BSP_OSPI_NOR_ConfigFlash_8: (+1)
   \                     ??BSP_OSPI_NOR_ConfigFlash_7: (+1)
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD108             BNE.N    ??BSP_OSPI_NOR_ConfigFlash_1
    787              {
    788                /* Update current status parameter *****************************************/
    789                Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_INDIRECT;
   \       0x94   0x2101             MOVS     R1,#+1
   \       0x96   0xF805 0x1034      STRB     R1,[R5, R4, LSL #+3]
    790                Ospi_Nor_Ctx[Instance].InterfaceMode = Mode;
   \       0x9A   0xEB05 0x01C4      ADD      R1,R5,R4, LSL #+3
   \       0x9E   0x704E             STRB     R6,[R1, #+1]
    791                Ospi_Nor_Ctx[Instance].TransferRate  = Rate;
   \       0xA0   0xEB05 0x01C4      ADD      R1,R5,R4, LSL #+3
   \       0xA4   0x708F             STRB     R7,[R1, #+2]
    792              }
    793            }
    794          
    795            /* Return BSP status */
    796            return ret;
   \                     ??BSP_OSPI_NOR_ConfigFlash_1: (+1)
   \       0xA6   0xBDF2             POP      {R1,R4-R7,PC}
    797          }
    798          
    799          /**
    800            * @brief  This function suspends an ongoing erase command.
    801            * @param  Instance  QSPI instance
    802            * @retval BSP status
    803            */

   \                                 In section .text, align 2, keep-with-next
    804          int32_t BSP_OSPI_NOR_SuspendErase(uint32_t Instance)
    805          {
   \                     BSP_OSPI_NOR_SuspendErase: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    806            int32_t ret = BSP_ERROR_NONE;
   \        0x4   0x2500             MOVS     R5,#+0
    807          
    808            /* Check if the instance is supported */
    809            if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD002             BEQ.N    ??BSP_OSPI_NOR_SuspendErase_0
    810            {
    811              ret = BSP_ERROR_WRONG_PARAM;
   \        0xA   0xF07F 0x0501      MVNS     R5,#+1
   \        0xE   0xE025             B.N      ??BSP_OSPI_NOR_SuspendErase_1
    812            }
    813            /* Check whether the device is busy (erase operation is in progress). */
    814            else if (BSP_OSPI_NOR_GetStatus(Instance) != BSP_ERROR_BUSY)
   \                     ??BSP_OSPI_NOR_SuspendErase_0: (+1)
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0x.... 0x....      BL       BSP_OSPI_NOR_GetStatus
   \       0x16   0xF110 0x0F03      CMN      R0,#+3
   \       0x1A   0xD002             BEQ.N    ??BSP_OSPI_NOR_SuspendErase_2
    815            {
    816              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x1C   0xF07F 0x0504      MVNS     R5,#+4
   \       0x20   0xE01C             B.N      ??BSP_OSPI_NOR_SuspendErase_1
    817            }
    818            else if(MX25LM51245G_Suspend(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_SuspendErase_2: (+1)
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable18
   \       0x26   0xEB00 0x01C4      ADD      R1,R0,R4, LSL #+3
   \       0x2A   0x788A             LDRB     R2,[R1, #+2]
   \       0x2C   0xEB00 0x00C4      ADD      R0,R0,R4, LSL #+3
   \       0x30   0x7841             LDRB     R1,[R0, #+1]
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \       0x36   0x2360             MOVS     R3,#+96
   \       0x38   0xFB03 0xF304      MUL      R3,R3,R4
   \       0x3C   0x4418             ADD      R0,R0,R3
   \       0x3E   0x.... 0x....      BL       MX25LM51245G_Suspend
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD002             BEQ.N    ??BSP_OSPI_NOR_SuspendErase_3
    819            {
    820              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x46   0xF07F 0x0504      MVNS     R5,#+4
   \       0x4A   0xE007             B.N      ??BSP_OSPI_NOR_SuspendErase_1
    821            }
    822            else
    823            {
    824              if (BSP_OSPI_NOR_GetStatus(Instance) != BSP_ERROR_OSPI_SUSPENDED)
   \                     ??BSP_OSPI_NOR_SuspendErase_3: (+1)
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x.... 0x....      BL       BSP_OSPI_NOR_GetStatus
   \       0x52   0xF110 0x0F14      CMN      R0,#+20
   \       0x56   0xD001             BEQ.N    ??BSP_OSPI_NOR_SuspendErase_1
    825              {
    826                ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x58   0xF07F 0x0504      MVNS     R5,#+4
    827              }
    828            }
    829          
    830            /* Return BSP status */
    831            return ret;
   \                     ??BSP_OSPI_NOR_SuspendErase_1: (+1)
   \       0x5C   0x0028             MOVS     R0,R5
   \       0x5E   0xBD32             POP      {R1,R4,R5,PC}
    832          }
    833          
    834          /**
    835            * @brief  This function resumes a paused erase command.
    836            * @param  Instance  QSPI instance
    837            * @retval BSP status
    838            */

   \                                 In section .text, align 2, keep-with-next
    839          int32_t BSP_OSPI_NOR_ResumeErase(uint32_t Instance)
    840          {
   \                     BSP_OSPI_NOR_ResumeErase: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    841            int32_t ret = BSP_ERROR_NONE;
   \        0x4   0x2500             MOVS     R5,#+0
    842          
    843            /* Check if the instance is supported */
    844            if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD002             BEQ.N    ??BSP_OSPI_NOR_ResumeErase_0
    845            {
    846              ret = BSP_ERROR_WRONG_PARAM;
   \        0xA   0xF07F 0x0501      MVNS     R5,#+1
   \        0xE   0xE025             B.N      ??BSP_OSPI_NOR_ResumeErase_1
    847            }
    848            /* Check whether the device is busy (erase operation is in progress). */
    849            else if (BSP_OSPI_NOR_GetStatus(Instance) != BSP_ERROR_OSPI_SUSPENDED)
   \                     ??BSP_OSPI_NOR_ResumeErase_0: (+1)
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0x.... 0x....      BL       BSP_OSPI_NOR_GetStatus
   \       0x16   0xF110 0x0F14      CMN      R0,#+20
   \       0x1A   0xD002             BEQ.N    ??BSP_OSPI_NOR_ResumeErase_2
    850            {
    851              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x1C   0xF07F 0x0504      MVNS     R5,#+4
   \       0x20   0xE01C             B.N      ??BSP_OSPI_NOR_ResumeErase_1
    852            }
    853            else if(MX25LM51245G_Resume(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
   \                     ??BSP_OSPI_NOR_ResumeErase_2: (+1)
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable18
   \       0x26   0xEB00 0x01C4      ADD      R1,R0,R4, LSL #+3
   \       0x2A   0x788A             LDRB     R2,[R1, #+2]
   \       0x2C   0xEB00 0x00C4      ADD      R0,R0,R4, LSL #+3
   \       0x30   0x7841             LDRB     R1,[R0, #+1]
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \       0x36   0x2360             MOVS     R3,#+96
   \       0x38   0xFB03 0xF304      MUL      R3,R3,R4
   \       0x3C   0x4418             ADD      R0,R0,R3
   \       0x3E   0x.... 0x....      BL       MX25LM51245G_Resume
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD002             BEQ.N    ??BSP_OSPI_NOR_ResumeErase_3
    854            {
    855              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x46   0xF07F 0x0504      MVNS     R5,#+4
   \       0x4A   0xE007             B.N      ??BSP_OSPI_NOR_ResumeErase_1
    856            }
    857            else
    858            {
    859              /* When this command is executed, the status register write in progress bit is set to 1, and
    860              the flag status register program erase controller bit is set to 0. This command is ignored
    861              if the device is not in a suspended state. */
    862              if (BSP_OSPI_NOR_GetStatus(Instance) != BSP_ERROR_BUSY)
   \                     ??BSP_OSPI_NOR_ResumeErase_3: (+1)
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x.... 0x....      BL       BSP_OSPI_NOR_GetStatus
   \       0x52   0xF110 0x0F03      CMN      R0,#+3
   \       0x56   0xD001             BEQ.N    ??BSP_OSPI_NOR_ResumeErase_1
    863              {
    864                ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x58   0xF07F 0x0504      MVNS     R5,#+4
    865              }
    866            }
    867          
    868            /* Return BSP status */
    869            return ret;
   \                     ??BSP_OSPI_NOR_ResumeErase_1: (+1)
   \       0x5C   0x0028             MOVS     R0,R5
   \       0x5E   0xBD32             POP      {R1,R4,R5,PC}
    870          }
    871          
    872          /**
    873            * @}
    874            */
    875          
    876          /** @defgroup STM32H7B3I_DK_OSPI_NOR_Private_Functions OSPI_NOR Private Functions
    877            * @{
    878            */
    879          
    880          /**
    881            * @brief  Initializes the OSPI MSP.
    882            * @param  hospi OSPI handle
    883            * @retval None
    884            */

   \                                 In section .text, align 2, keep-with-next
    885          static void OSPI_NOR_MspInit(OSPI_HandleTypeDef *hospi)
    886          {
   \                     OSPI_NOR_MspInit: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
    887            GPIO_InitTypeDef GPIO_InitStruct;
    888          
    889            /* hospi unused argument(s) compilation warning */
    890            UNUSED(hospi);
    891          
    892            /* Enable the OctoSPI memory interface clock */
    893            OSPI_CLK_ENABLE();
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0xF451 0x4180      ORRS     R1,R1,#0x4000
   \       0x10   0x6001             STR      R1,[R0, #+0]
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0xF410 0x4080      ANDS     R0,R0,#0x4000
   \       0x18   0x9005             STR      R0,[SP, #+20]
   \       0x1A   0x9805             LDR      R0,[SP, #+20]
    894          
    895            /* Reset the OctoSPI memory interface */
    896            OSPI_FORCE_RESET();
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \       0x20   0x6801             LDR      R1,[R0, #+0]
   \       0x22   0xF451 0x4180      ORRS     R1,R1,#0x4000
   \       0x26   0x6001             STR      R1,[R0, #+0]
    897            OSPI_RELEASE_RESET();
   \       0x28   0x6801             LDR      R1,[R0, #+0]
   \       0x2A   0xF431 0x4180      BICS     R1,R1,#0x4000
   \       0x2E   0x6001             STR      R1,[R0, #+0]
    898          
    899            /* Enable GPIO clocks */
    900            OSPI_CLK_GPIO_CLK_ENABLE();
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \       0x34   0x6801             LDR      R1,[R0, #+0]
   \       0x36   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x3A   0x6001             STR      R1,[R0, #+0]
   \       0x3C   0x6801             LDR      R1,[R0, #+0]
   \       0x3E   0xF011 0x0102      ANDS     R1,R1,#0x2
   \       0x42   0x9105             STR      R1,[SP, #+20]
   \       0x44   0x9905             LDR      R1,[SP, #+20]
    901            OSPI_DQS_GPIO_CLK_ENABLE();
   \       0x46   0x6801             LDR      R1,[R0, #+0]
   \       0x48   0xF051 0x0104      ORRS     R1,R1,#0x4
   \       0x4C   0x6001             STR      R1,[R0, #+0]
   \       0x4E   0x6801             LDR      R1,[R0, #+0]
   \       0x50   0xF011 0x0104      ANDS     R1,R1,#0x4
   \       0x54   0x9105             STR      R1,[SP, #+20]
   \       0x56   0x9905             LDR      R1,[SP, #+20]
    902            OSPI_CS_GPIO_CLK_ENABLE();
   \       0x58   0x6801             LDR      R1,[R0, #+0]
   \       0x5A   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0x5E   0x6001             STR      R1,[R0, #+0]
   \       0x60   0x6801             LDR      R1,[R0, #+0]
   \       0x62   0xF011 0x0140      ANDS     R1,R1,#0x40
   \       0x66   0x9105             STR      R1,[SP, #+20]
   \       0x68   0x9905             LDR      R1,[SP, #+20]
    903            OSPI_D0_GPIO_CLK_ENABLE();
   \       0x6A   0x6801             LDR      R1,[R0, #+0]
   \       0x6C   0xF051 0x0108      ORRS     R1,R1,#0x8
   \       0x70   0x6001             STR      R1,[R0, #+0]
   \       0x72   0x6801             LDR      R1,[R0, #+0]
   \       0x74   0xF011 0x0108      ANDS     R1,R1,#0x8
   \       0x78   0x9105             STR      R1,[SP, #+20]
   \       0x7A   0x9905             LDR      R1,[SP, #+20]
    904            OSPI_D1_GPIO_CLK_ENABLE();
   \       0x7C   0x6801             LDR      R1,[R0, #+0]
   \       0x7E   0xF051 0x0120      ORRS     R1,R1,#0x20
   \       0x82   0x6001             STR      R1,[R0, #+0]
   \       0x84   0x6801             LDR      R1,[R0, #+0]
   \       0x86   0xF011 0x0120      ANDS     R1,R1,#0x20
   \       0x8A   0x9105             STR      R1,[SP, #+20]
   \       0x8C   0x9905             LDR      R1,[SP, #+20]
    905            OSPI_D2_GPIO_CLK_ENABLE();
   \       0x8E   0x6801             LDR      R1,[R0, #+0]
   \       0x90   0xF051 0x0120      ORRS     R1,R1,#0x20
   \       0x94   0x6001             STR      R1,[R0, #+0]
   \       0x96   0x6801             LDR      R1,[R0, #+0]
   \       0x98   0xF011 0x0120      ANDS     R1,R1,#0x20
   \       0x9C   0x9105             STR      R1,[SP, #+20]
   \       0x9E   0x9905             LDR      R1,[SP, #+20]
    906            OSPI_D3_GPIO_CLK_ENABLE();
   \       0xA0   0x6801             LDR      R1,[R0, #+0]
   \       0xA2   0xF051 0x0120      ORRS     R1,R1,#0x20
   \       0xA6   0x6001             STR      R1,[R0, #+0]
   \       0xA8   0x6801             LDR      R1,[R0, #+0]
   \       0xAA   0xF011 0x0120      ANDS     R1,R1,#0x20
   \       0xAE   0x9105             STR      R1,[SP, #+20]
   \       0xB0   0x9905             LDR      R1,[SP, #+20]
    907            OSPI_D4_GPIO_CLK_ENABLE();
   \       0xB2   0x6801             LDR      R1,[R0, #+0]
   \       0xB4   0xF051 0x0104      ORRS     R1,R1,#0x4
   \       0xB8   0x6001             STR      R1,[R0, #+0]
   \       0xBA   0x6801             LDR      R1,[R0, #+0]
   \       0xBC   0xF011 0x0104      ANDS     R1,R1,#0x4
   \       0xC0   0x9105             STR      R1,[SP, #+20]
   \       0xC2   0x9905             LDR      R1,[SP, #+20]
    908            OSPI_D5_GPIO_CLK_ENABLE();
   \       0xC4   0x6801             LDR      R1,[R0, #+0]
   \       0xC6   0xF051 0x0180      ORRS     R1,R1,#0x80
   \       0xCA   0x6001             STR      R1,[R0, #+0]
   \       0xCC   0x6801             LDR      R1,[R0, #+0]
   \       0xCE   0xF011 0x0180      ANDS     R1,R1,#0x80
   \       0xD2   0x9105             STR      R1,[SP, #+20]
   \       0xD4   0x9905             LDR      R1,[SP, #+20]
    909            OSPI_D6_GPIO_CLK_ENABLE();
   \       0xD6   0x6801             LDR      R1,[R0, #+0]
   \       0xD8   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0xDC   0x6001             STR      R1,[R0, #+0]
   \       0xDE   0x6801             LDR      R1,[R0, #+0]
   \       0xE0   0xF011 0x0140      ANDS     R1,R1,#0x40
   \       0xE4   0x9105             STR      R1,[SP, #+20]
   \       0xE6   0x9905             LDR      R1,[SP, #+20]
    910            OSPI_D7_GPIO_CLK_ENABLE();
   \       0xE8   0x6801             LDR      R1,[R0, #+0]
   \       0xEA   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0xEE   0x6001             STR      R1,[R0, #+0]
   \       0xF0   0x6800             LDR      R0,[R0, #+0]
   \       0xF2   0xF010 0x0040      ANDS     R0,R0,#0x40
   \       0xF6   0x9005             STR      R0,[SP, #+20]
   \       0xF8   0x9805             LDR      R0,[SP, #+20]
    911          
    912            /* OctoSPI CS GPIO pin configuration  */
    913            GPIO_InitStruct.Pin       = OSPI_CS_PIN;
   \       0xFA   0x2040             MOVS     R0,#+64
   \       0xFC   0x9000             STR      R0,[SP, #+0]
    914            GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
   \       0xFE   0x2002             MOVS     R0,#+2
   \      0x100   0x9001             STR      R0,[SP, #+4]
    915            GPIO_InitStruct.Pull      = GPIO_PULLUP;
   \      0x102   0x2001             MOVS     R0,#+1
   \      0x104   0x9002             STR      R0,[SP, #+8]
    916            GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
   \      0x106   0x2003             MOVS     R0,#+3
   \      0x108   0x9003             STR      R0,[SP, #+12]
    917            GPIO_InitStruct.Alternate = OSPI_CS_PIN_AF;
   \      0x10A   0x200A             MOVS     R0,#+10
   \      0x10C   0x9004             STR      R0,[SP, #+16]
    918            HAL_GPIO_Init(OSPI_CS_GPIO_PORT, &GPIO_InitStruct);
   \      0x10E   0x.... 0x....      LDR.W    R4,??DataTable18_6
   \      0x112   0x4669             MOV      R1,SP
   \      0x114   0x0020             MOVS     R0,R4
   \      0x116   0x.... 0x....      BL       HAL_GPIO_Init
    919          
    920            /* OctoSPI DQS GPIO pin configuration  */
    921            GPIO_InitStruct.Pin       = OSPI_DQS_PIN;
   \      0x11A   0x2020             MOVS     R0,#+32
   \      0x11C   0x9000             STR      R0,[SP, #+0]
    922            GPIO_InitStruct.Alternate = OSPI_DQS_PIN_AF;
   \      0x11E   0x200A             MOVS     R0,#+10
   \      0x120   0x9004             STR      R0,[SP, #+16]
    923            HAL_GPIO_Init(OSPI_DQS_GPIO_PORT, &GPIO_InitStruct);
   \      0x122   0x.... 0x....      LDR.W    R5,??DataTable18_7
   \      0x126   0x4669             MOV      R1,SP
   \      0x128   0x0028             MOVS     R0,R5
   \      0x12A   0x.... 0x....      BL       HAL_GPIO_Init
    924          
    925            /* OctoSPI CLK GPIO pin configuration  */
    926            GPIO_InitStruct.Pin       = OSPI_CLK_PIN;
   \      0x12E   0x2004             MOVS     R0,#+4
   \      0x130   0x9000             STR      R0,[SP, #+0]
    927            GPIO_InitStruct.Pull      = GPIO_NOPULL;
   \      0x132   0x2000             MOVS     R0,#+0
   \      0x134   0x9002             STR      R0,[SP, #+8]
    928            GPIO_InitStruct.Alternate = OSPI_CLK_PIN_AF;
   \      0x136   0x2009             MOVS     R0,#+9
   \      0x138   0x9004             STR      R0,[SP, #+16]
    929            HAL_GPIO_Init(OSPI_CLK_GPIO_PORT, &GPIO_InitStruct);
   \      0x13A   0x4669             MOV      R1,SP
   \      0x13C   0x.... 0x....      LDR.W    R0,??DataTable18_8
   \      0x140   0x.... 0x....      BL       HAL_GPIO_Init
    930          
    931            /* OctoSPI D0 GPIO pin configuration  */
    932            GPIO_InitStruct.Pin       = OSPI_D0_PIN;
   \      0x144   0xF44F 0x6000      MOV      R0,#+2048
   \      0x148   0x9000             STR      R0,[SP, #+0]
    933            GPIO_InitStruct.Alternate = OSPI_D0_PIN_AF;
   \      0x14A   0x2009             MOVS     R0,#+9
   \      0x14C   0x9004             STR      R0,[SP, #+16]
    934            HAL_GPIO_Init(OSPI_D0_GPIO_PORT, &GPIO_InitStruct);
   \      0x14E   0x.... 0x....      LDR.W    R6,??DataTable18_9
   \      0x152   0x4669             MOV      R1,SP
   \      0x154   0x0030             MOVS     R0,R6
   \      0x156   0x.... 0x....      BL       HAL_GPIO_Init
    935          
    936            /* OctoSPI D1 GPIO pin configuration  */
    937            GPIO_InitStruct.Pin       = OSPI_D1_PIN;
   \      0x15A   0xF44F 0x7700      MOV      R7,#+512
   \      0x15E   0x9700             STR      R7,[SP, #+0]
    938            GPIO_InitStruct.Alternate = OSPI_D1_PIN_AF;
   \      0x160   0x200A             MOVS     R0,#+10
   \      0x162   0x9004             STR      R0,[SP, #+16]
    939            HAL_GPIO_Init(OSPI_D1_GPIO_PORT, &GPIO_InitStruct);
   \      0x164   0x.... 0x....      LDR.W    R8,??DataTable18_10
   \      0x168   0x4669             MOV      R1,SP
   \      0x16A   0x4640             MOV      R0,R8
   \      0x16C   0x.... 0x....      BL       HAL_GPIO_Init
    940          
    941            /* OctoSPI D2 GPIO pin configuration  */
    942            GPIO_InitStruct.Pin       = OSPI_D2_PIN;
   \      0x170   0x2080             MOVS     R0,#+128
   \      0x172   0x9000             STR      R0,[SP, #+0]
    943            GPIO_InitStruct.Alternate = OSPI_D2_PIN_AF;
   \      0x174   0x200A             MOVS     R0,#+10
   \      0x176   0x9004             STR      R0,[SP, #+16]
    944            HAL_GPIO_Init(OSPI_D2_GPIO_PORT, &GPIO_InitStruct);
   \      0x178   0x4669             MOV      R1,SP
   \      0x17A   0x4640             MOV      R0,R8
   \      0x17C   0x.... 0x....      BL       HAL_GPIO_Init
    945          
    946            /* OctoSPI D3 GPIO pin configuration  */
    947            GPIO_InitStruct.Pin       = OSPI_D3_PIN;
   \      0x180   0x2040             MOVS     R0,#+64
   \      0x182   0x9000             STR      R0,[SP, #+0]
    948            GPIO_InitStruct.Alternate = OSPI_D3_PIN_AF;
   \      0x184   0x200A             MOVS     R0,#+10
   \      0x186   0x9004             STR      R0,[SP, #+16]
    949            HAL_GPIO_Init(OSPI_D3_GPIO_PORT, &GPIO_InitStruct);
   \      0x188   0x4669             MOV      R1,SP
   \      0x18A   0x4640             MOV      R0,R8
   \      0x18C   0x.... 0x....      BL       HAL_GPIO_Init
    950          
    951            /* OctoSPI D4 GPIO pin configuration  */
    952            GPIO_InitStruct.Pin       = OSPI_D4_PIN;
   \      0x190   0x2002             MOVS     R0,#+2
   \      0x192   0x9000             STR      R0,[SP, #+0]
    953            GPIO_InitStruct.Alternate = OSPI_D4_PIN_AF;
   \      0x194   0x200A             MOVS     R0,#+10
   \      0x196   0x9004             STR      R0,[SP, #+16]
    954            HAL_GPIO_Init(OSPI_D4_GPIO_PORT, &GPIO_InitStruct);
   \      0x198   0x4669             MOV      R1,SP
   \      0x19A   0x0028             MOVS     R0,R5
   \      0x19C   0x.... 0x....      BL       HAL_GPIO_Init
    955          
    956            /* OctoSPI D5 GPIO pin configuration  */
    957            GPIO_InitStruct.Pin       = OSPI_D5_PIN;
   \      0x1A0   0x2008             MOVS     R0,#+8
   \      0x1A2   0x9000             STR      R0,[SP, #+0]
    958            GPIO_InitStruct.Alternate = OSPI_D5_PIN_AF;
   \      0x1A4   0x2009             MOVS     R0,#+9
   \      0x1A6   0x9004             STR      R0,[SP, #+16]
    959            HAL_GPIO_Init(OSPI_D5_GPIO_PORT, &GPIO_InitStruct);
   \      0x1A8   0x4669             MOV      R1,SP
   \      0x1AA   0x.... 0x....      LDR.W    R0,??DataTable18_11
   \      0x1AE   0x.... 0x....      BL       HAL_GPIO_Init
    960          
    961            /* OctoSPI D6 GPIO pin configuration  */
    962            GPIO_InitStruct.Pin       = OSPI_D6_PIN;
   \      0x1B2   0x9700             STR      R7,[SP, #+0]
    963            GPIO_InitStruct.Alternate = OSPI_D6_PIN_AF;
   \      0x1B4   0x2009             MOVS     R0,#+9
   \      0x1B6   0x9004             STR      R0,[SP, #+16]
    964            HAL_GPIO_Init(OSPI_D6_GPIO_PORT, &GPIO_InitStruct);
   \      0x1B8   0x4669             MOV      R1,SP
   \      0x1BA   0x0020             MOVS     R0,R4
   \      0x1BC   0x.... 0x....      BL       HAL_GPIO_Init
    965          
    966            /* OctoSPI D7 GPIO pin configuration  */
    967            GPIO_InitStruct.Pin       = OSPI_D7_PIN;
   \      0x1C0   0x2080             MOVS     R0,#+128
   \      0x1C2   0x9000             STR      R0,[SP, #+0]
    968            GPIO_InitStruct.Alternate = OSPI_D7_PIN_AF;
   \      0x1C4   0x200A             MOVS     R0,#+10
   \      0x1C6   0x9004             STR      R0,[SP, #+16]
    969            HAL_GPIO_Init(OSPI_D7_GPIO_PORT, &GPIO_InitStruct);
   \      0x1C8   0x4669             MOV      R1,SP
   \      0x1CA   0x0030             MOVS     R0,R6
   \      0x1CC   0x.... 0x....      BL       HAL_GPIO_Init
    970          }
   \      0x1D0   0xB006             ADD      SP,SP,#+24
   \      0x1D2   0xE8BD 0x81F0      POP      {R4-R8,PC}
    971          
    972          /**
    973            * @brief  De-Initializes the OSPI MSP.
    974            * @param  hospi OSPI handle
    975            * @retval None
    976            */

   \                                 In section .text, align 2, keep-with-next
    977          static void OSPI_NOR_MspDeInit(OSPI_HandleTypeDef *hospi)
    978          {
   \                     OSPI_NOR_MspDeInit: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    979            /* hospi unused argument(s) compilation warning */
    980            UNUSED(hospi);
    981          
    982            /* OctoSPI GPIO pins de-configuration  */
    983            HAL_GPIO_DeInit(OSPI_CLK_GPIO_PORT, OSPI_CLK_PIN);
   \        0x2   0x2104             MOVS     R1,#+4
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable18_8
   \        0x8   0x.... 0x....      BL       HAL_GPIO_DeInit
    984            HAL_GPIO_DeInit(OSPI_DQS_GPIO_PORT, OSPI_DQS_PIN);
   \        0xC   0x.... 0x....      LDR.W    R4,??DataTable18_7
   \       0x10   0x2120             MOVS     R1,#+32
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0x.... 0x....      BL       HAL_GPIO_DeInit
    985            HAL_GPIO_DeInit(OSPI_CS_GPIO_PORT, OSPI_CS_PIN);
   \       0x18   0x.... 0x....      LDR.W    R5,??DataTable18_6
   \       0x1C   0x2140             MOVS     R1,#+64
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0x.... 0x....      BL       HAL_GPIO_DeInit
    986            HAL_GPIO_DeInit(OSPI_D0_GPIO_PORT, OSPI_D0_PIN);
   \       0x24   0x.... 0x....      LDR.W    R6,??DataTable18_9
   \       0x28   0xF44F 0x6100      MOV      R1,#+2048
   \       0x2C   0x0030             MOVS     R0,R6
   \       0x2E   0x.... 0x....      BL       HAL_GPIO_DeInit
    987            HAL_GPIO_DeInit(OSPI_D1_GPIO_PORT, OSPI_D1_PIN);
   \       0x32   0x.... 0x....      LDR.W    R7,??DataTable18_10
   \       0x36   0xF44F 0x7100      MOV      R1,#+512
   \       0x3A   0x0038             MOVS     R0,R7
   \       0x3C   0x.... 0x....      BL       HAL_GPIO_DeInit
    988            HAL_GPIO_DeInit(OSPI_D2_GPIO_PORT, OSPI_D2_PIN);
   \       0x40   0x2180             MOVS     R1,#+128
   \       0x42   0x0038             MOVS     R0,R7
   \       0x44   0x.... 0x....      BL       HAL_GPIO_DeInit
    989            HAL_GPIO_DeInit(OSPI_D3_GPIO_PORT, OSPI_D3_PIN);
   \       0x48   0x2140             MOVS     R1,#+64
   \       0x4A   0x0038             MOVS     R0,R7
   \       0x4C   0x.... 0x....      BL       HAL_GPIO_DeInit
    990            HAL_GPIO_DeInit(OSPI_D4_GPIO_PORT, OSPI_D4_PIN);
   \       0x50   0x2102             MOVS     R1,#+2
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x.... 0x....      BL       HAL_GPIO_DeInit
    991            HAL_GPIO_DeInit(OSPI_D5_GPIO_PORT, OSPI_D5_PIN);
   \       0x58   0x2108             MOVS     R1,#+8
   \       0x5A   0x.... 0x....      LDR.W    R0,??DataTable18_11
   \       0x5E   0x.... 0x....      BL       HAL_GPIO_DeInit
    992            HAL_GPIO_DeInit(OSPI_D6_GPIO_PORT, OSPI_D6_PIN);
   \       0x62   0xF44F 0x7100      MOV      R1,#+512
   \       0x66   0x0028             MOVS     R0,R5
   \       0x68   0x.... 0x....      BL       HAL_GPIO_DeInit
    993            HAL_GPIO_DeInit(OSPI_D7_GPIO_PORT, OSPI_D7_PIN);
   \       0x6C   0x2180             MOVS     R1,#+128
   \       0x6E   0x0030             MOVS     R0,R6
   \       0x70   0x.... 0x....      BL       HAL_GPIO_DeInit
    994          
    995            /* Reset the OctoSPI memory interface */
    996            OSPI_FORCE_RESET();
   \       0x74   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \       0x78   0x6801             LDR      R1,[R0, #+0]
   \       0x7A   0xF451 0x4180      ORRS     R1,R1,#0x4000
   \       0x7E   0x6001             STR      R1,[R0, #+0]
    997            OSPI_RELEASE_RESET();
   \       0x80   0x6801             LDR      R1,[R0, #+0]
   \       0x82   0xF431 0x4180      BICS     R1,R1,#0x4000
   \       0x86   0x6001             STR      R1,[R0, #+0]
    998          
    999            /* Disable the OctoSPI memory interface clock */
   1000            OSPI_CLK_DISABLE();
   \       0x88   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \       0x8C   0x6801             LDR      R1,[R0, #+0]
   \       0x8E   0xF431 0x4180      BICS     R1,R1,#0x4000
   \       0x92   0x6001             STR      R1,[R0, #+0]
   1001          }
   \       0x94   0xBDF1             POP      {R0,R4-R7,PC}
   1002          
   1003          /**
   1004            * @brief  This function reset the OSPI memory.
   1005            * @param  Instance  OSPI instance
   1006            * @retval BSP status
   1007            */

   \                                 In section .text, align 2, keep-with-next
   1008          static int32_t OSPI_NOR_ResetMemory (uint32_t Instance)
   1009          {
   \                     OSPI_NOR_ResetMemory: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   1010            int32_t ret = BSP_ERROR_NONE;
   \        0x4   0x2400             MOVS     R4,#+0
   1011          
   1012            /* Enable write operations */
   1013            if(MX25LM51245G_ResetEnable(&hospi_nor[Instance], BSP_OSPI_NOR_SPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
   \        0x6   0x2660             MOVS     R6,#+96
   \        0x8   0x.... 0x....      LDR.W    R7,??DataTable18_1
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x14   0x4438             ADD      R0,R7,R0
   \       0x16   0x.... 0x....      BL       MX25LM51245G_ResetEnable
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD002             BEQ.N    ??OSPI_NOR_ResetMemory_0
   1014            {
   1015              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x1E   0xF07F 0x0404      MVNS     R4,#+4
   \       0x22   0xE04B             B.N      ??OSPI_NOR_ResetMemory_1
   1016            }
   1017            else if(MX25LM51245G_ResetMemory(&hospi_nor[Instance], BSP_OSPI_NOR_SPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
   \                     ??OSPI_NOR_ResetMemory_0: (+1)
   \       0x24   0x2200             MOVS     R2,#+0
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x2C   0x4438             ADD      R0,R7,R0
   \       0x2E   0x.... 0x....      BL       MX25LM51245G_ResetMemory
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD002             BEQ.N    ??OSPI_NOR_ResetMemory_2
   1018            {
   1019              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x36   0xF07F 0x0404      MVNS     R4,#+4
   \       0x3A   0xE03F             B.N      ??OSPI_NOR_ResetMemory_1
   1020            }
   1021            else if(MX25LM51245G_ResetEnable(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
   \                     ??OSPI_NOR_ResetMemory_2: (+1)
   \       0x3C   0x2200             MOVS     R2,#+0
   \       0x3E   0x2101             MOVS     R1,#+1
   \       0x40   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x44   0x4438             ADD      R0,R7,R0
   \       0x46   0x.... 0x....      BL       MX25LM51245G_ResetEnable
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD002             BEQ.N    ??OSPI_NOR_ResetMemory_3
   1022            {
   1023              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x4E   0xF07F 0x0404      MVNS     R4,#+4
   \       0x52   0xE033             B.N      ??OSPI_NOR_ResetMemory_1
   1024            }
   1025            else if(MX25LM51245G_ResetMemory(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
   \                     ??OSPI_NOR_ResetMemory_3: (+1)
   \       0x54   0x2200             MOVS     R2,#+0
   \       0x56   0x2101             MOVS     R1,#+1
   \       0x58   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x5C   0x4438             ADD      R0,R7,R0
   \       0x5E   0x.... 0x....      BL       MX25LM51245G_ResetMemory
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD002             BEQ.N    ??OSPI_NOR_ResetMemory_4
   1026            {
   1027              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x66   0xF07F 0x0404      MVNS     R4,#+4
   \       0x6A   0xE027             B.N      ??OSPI_NOR_ResetMemory_1
   1028            }
   1029            else if(MX25LM51245G_ResetEnable(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_DTR_TRANSFER) != MX25LM51245G_OK)
   \                     ??OSPI_NOR_ResetMemory_4: (+1)
   \       0x6C   0x2201             MOVS     R2,#+1
   \       0x6E   0x2101             MOVS     R1,#+1
   \       0x70   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x74   0x4438             ADD      R0,R7,R0
   \       0x76   0x.... 0x....      BL       MX25LM51245G_ResetEnable
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD002             BEQ.N    ??OSPI_NOR_ResetMemory_5
   1030            {
   1031              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x7E   0xF07F 0x0404      MVNS     R4,#+4
   \       0x82   0xE01B             B.N      ??OSPI_NOR_ResetMemory_1
   1032            }
   1033            else if(MX25LM51245G_ResetMemory(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_DTR_TRANSFER) != MX25LM51245G_OK)
   \                     ??OSPI_NOR_ResetMemory_5: (+1)
   \       0x84   0x2201             MOVS     R2,#+1
   \       0x86   0x2101             MOVS     R1,#+1
   \       0x88   0xFB06 0xF605      MUL      R6,R6,R5
   \       0x8C   0xEB07 0x0006      ADD      R0,R7,R6
   \       0x90   0x.... 0x....      BL       MX25LM51245G_ResetMemory
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD002             BEQ.N    ??OSPI_NOR_ResetMemory_6
   1034            {
   1035              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x98   0xF07F 0x0404      MVNS     R4,#+4
   \       0x9C   0xE00E             B.N      ??OSPI_NOR_ResetMemory_1
   1036            }
   1037            else
   1038            {
   1039              Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_INDIRECT;      /* After reset S/W setting to indirect access   */
   \                     ??OSPI_NOR_ResetMemory_6: (+1)
   \       0x9E   0x....             LDR.N    R0,??DataTable18
   \       0xA0   0x2101             MOVS     R1,#+1
   \       0xA2   0xF800 0x1035      STRB     R1,[R0, R5, LSL #+3]
   1040              Ospi_Nor_Ctx[Instance].InterfaceMode = BSP_OSPI_NOR_SPI_MODE;         /* After reset H/W back to SPI mode by default  */
   \       0xA6   0x2100             MOVS     R1,#+0
   \       0xA8   0xEB00 0x02C5      ADD      R2,R0,R5, LSL #+3
   \       0xAC   0x7051             STRB     R1,[R2, #+1]
   1041              Ospi_Nor_Ctx[Instance].TransferRate  = BSP_OSPI_NOR_STR_TRANSFER;     /* After reset S/W setting to STR mode          */
   \       0xAE   0x2100             MOVS     R1,#+0
   \       0xB0   0xEB00 0x00C5      ADD      R0,R0,R5, LSL #+3
   \       0xB4   0x7081             STRB     R1,[R0, #+2]
   1042          
   1043              /* After SWreset CMD, wait in case SWReset occurred during erase operation */
   1044              HAL_Delay(MX25LM51245G_RESET_MAX_TIME);
   \       0xB6   0x2064             MOVS     R0,#+100
   \       0xB8   0x.... 0x....      BL       HAL_Delay
   1045            }
   1046          
   1047            /* Return BSP status */
   1048            return ret;
   \                     ??OSPI_NOR_ResetMemory_1: (+1)
   \       0xBC   0x0020             MOVS     R0,R4
   \       0xBE   0xBDF2             POP      {R1,R4-R7,PC}
   1049          }
   1050          
   1051          /**
   1052            * @brief  This function enables the octal DTR mode of the memory.
   1053            * @param  Instance  OSPI instance
   1054            * @retval BSP status
   1055            */

   \                                 In section .text, align 2, keep-with-next
   1056          static int32_t OSPI_NOR_EnterDOPIMode(uint32_t Instance)
   1057          {
   \                     OSPI_NOR_EnterDOPIMode: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   1058            int32_t ret = BSP_ERROR_NONE;
   \        0x6   0x2400             MOVS     R4,#+0
   1059            uint8_t reg[2];
   1060          
   1061            /* Enable write operations */
   1062            if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
   \        0x8   0x2660             MOVS     R6,#+96
   \        0xA   0x....             LDR.N    R7,??DataTable18_1
   \        0xC   0x.... 0x....      LDR.W    R8,??DataTable18
   \       0x10   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x14   0x7882             LDRB     R2,[R0, #+2]
   \       0x16   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x1A   0x7841             LDRB     R1,[R0, #+1]
   \       0x1C   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x20   0x4438             ADD      R0,R7,R0
   \       0x22   0x.... 0x....      BL       MX25LM51245G_WriteEnable
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD002             BEQ.N    ??OSPI_NOR_EnterDOPIMode_0
   1063            {
   1064              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x2A   0xF07F 0x0404      MVNS     R4,#+4
   \       0x2E   0xE070             B.N      ??OSPI_NOR_EnterDOPIMode_1
   1065            }
   1066            /* Write Configuration register 2 (with new dummy cycles) */
   1067            else if (MX25LM51245G_WriteCfg2Register(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_CR2_REG3_ADDR, MX25LM51245G_CR2_DC_6_CYCLES) != MX25LM51245G_OK)
   \                     ??OSPI_NOR_EnterDOPIMode_0: (+1)
   \       0x30   0x2007             MOVS     R0,#+7
   \       0x32   0x9000             STR      R0,[SP, #+0]
   \       0x34   0xF44F 0x7340      MOV      R3,#+768
   \       0x38   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x3C   0x7882             LDRB     R2,[R0, #+2]
   \       0x3E   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x42   0x7841             LDRB     R1,[R0, #+1]
   \       0x44   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x48   0x4438             ADD      R0,R7,R0
   \       0x4A   0x.... 0x....      BL       MX25LM51245G_WriteCfg2Register
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD002             BEQ.N    ??OSPI_NOR_EnterDOPIMode_2
   1068            {
   1069              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x52   0xF07F 0x0404      MVNS     R4,#+4
   \       0x56   0xE05C             B.N      ??OSPI_NOR_EnterDOPIMode_1
   1070            }
   1071            /* Enable write operations */
   1072            else if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
   \                     ??OSPI_NOR_EnterDOPIMode_2: (+1)
   \       0x58   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x5C   0x7882             LDRB     R2,[R0, #+2]
   \       0x5E   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x62   0x7841             LDRB     R1,[R0, #+1]
   \       0x64   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x68   0x4438             ADD      R0,R7,R0
   \       0x6A   0x.... 0x....      BL       MX25LM51245G_WriteEnable
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD002             BEQ.N    ??OSPI_NOR_EnterDOPIMode_3
   1073            {
   1074              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x72   0xF07F 0x0404      MVNS     R4,#+4
   \       0x76   0xE04C             B.N      ??OSPI_NOR_EnterDOPIMode_1
   1075            }
   1076            /* Write Configuration register 2 (with Octal I/O SPI protocol) */
   1077            else if (MX25LM51245G_WriteCfg2Register(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_CR2_REG1_ADDR, MX25LM51245G_CR2_DOPI) != MX25LM51245G_OK)
   \                     ??OSPI_NOR_EnterDOPIMode_3: (+1)
   \       0x78   0x2002             MOVS     R0,#+2
   \       0x7A   0x9000             STR      R0,[SP, #+0]
   \       0x7C   0x2300             MOVS     R3,#+0
   \       0x7E   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x82   0x7882             LDRB     R2,[R0, #+2]
   \       0x84   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x88   0x7841             LDRB     R1,[R0, #+1]
   \       0x8A   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x8E   0x4438             ADD      R0,R7,R0
   \       0x90   0x.... 0x....      BL       MX25LM51245G_WriteCfg2Register
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD002             BEQ.N    ??OSPI_NOR_EnterDOPIMode_4
   1078            {
   1079              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x98   0xF07F 0x0404      MVNS     R4,#+4
   \       0x9C   0xE039             B.N      ??OSPI_NOR_EnterDOPIMode_1
   1080            }
   1081            else
   1082            {
   1083              /* Wait that the configuration is effective and check that memory is ready */
   1084              HAL_Delay(MX25LM51245G_WRITE_REG_MAX_TIME);
   \                     ??OSPI_NOR_EnterDOPIMode_4: (+1)
   \       0x9E   0x2028             MOVS     R0,#+40
   \       0xA0   0x.... 0x....      BL       HAL_Delay
   1085          
   1086              /* Reconfigure the memory type of the peripheral */
   1087              hospi_nor[Instance].Init.MemoryType            = HAL_OSPI_MEMTYPE_MACRONIX;
   \       0xA4   0xF05F 0x7080      MOVS     R0,#+16777216
   \       0xA8   0xFB06 0xF105      MUL      R1,R6,R5
   \       0xAC   0x4439             ADD      R1,R7,R1
   \       0xAE   0x60C8             STR      R0,[R1, #+12]
   1088              hospi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_ENABLE;
   \       0xB0   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0xB4   0xFB06 0xF105      MUL      R1,R6,R5
   \       0xB8   0x4439             ADD      R1,R7,R1
   \       0xBA   0x62C8             STR      R0,[R1, #+44]
   1089              if (HAL_OSPI_Init(&hospi_nor[Instance]) != HAL_OK)
   \       0xBC   0xFB06 0xF005      MUL      R0,R6,R5
   \       0xC0   0x4438             ADD      R0,R7,R0
   \       0xC2   0x.... 0x....      BL       HAL_OSPI_Init
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD002             BEQ.N    ??OSPI_NOR_EnterDOPIMode_5
   1090              {
   1091                ret = BSP_ERROR_PERIPH_FAILURE;
   \       0xCA   0xF07F 0x0403      MVNS     R4,#+3
   \       0xCE   0xE020             B.N      ??OSPI_NOR_EnterDOPIMode_1
   1092              }
   1093              /* Check Flash busy ? */
   1094              else if (MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_DTR_TRANSFER) != MX25LM51245G_OK)
   \                     ??OSPI_NOR_EnterDOPIMode_5: (+1)
   \       0xD0   0x2201             MOVS     R2,#+1
   \       0xD2   0x2101             MOVS     R1,#+1
   \       0xD4   0xFB06 0xF005      MUL      R0,R6,R5
   \       0xD8   0x4438             ADD      R0,R7,R0
   \       0xDA   0x.... 0x....      BL       MX25LM51245G_AutoPollingMemReady
   \       0xDE   0x2800             CMP      R0,#+0
   \       0xE0   0xD002             BEQ.N    ??OSPI_NOR_EnterDOPIMode_6
   1095              {
   1096                ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0xE2   0xF07F 0x0404      MVNS     R4,#+4
   \       0xE6   0xE014             B.N      ??OSPI_NOR_EnterDOPIMode_1
   1097              }
   1098              /* Check the configuration has been correctly done */
   1099              else if (MX25LM51245G_ReadCfg2Register(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_DTR_TRANSFER, MX25LM51245G_CR2_REG1_ADDR, reg) != MX25LM51245G_OK)
   \                     ??OSPI_NOR_EnterDOPIMode_6: (+1)
   \       0xE8   0xA801             ADD      R0,SP,#+4
   \       0xEA   0x9000             STR      R0,[SP, #+0]
   \       0xEC   0x2300             MOVS     R3,#+0
   \       0xEE   0x2201             MOVS     R2,#+1
   \       0xF0   0x2101             MOVS     R1,#+1
   \       0xF2   0x4375             MULS     R5,R6,R5
   \       0xF4   0xEB07 0x0005      ADD      R0,R7,R5
   \       0xF8   0x.... 0x....      BL       MX25LM51245G_ReadCfg2Register
   \       0xFC   0x2800             CMP      R0,#+0
   \       0xFE   0xD002             BEQ.N    ??OSPI_NOR_EnterDOPIMode_7
   1100              {
   1101                ret = BSP_ERROR_COMPONENT_FAILURE;
   \      0x100   0xF07F 0x0404      MVNS     R4,#+4
   \      0x104   0xE005             B.N      ??OSPI_NOR_EnterDOPIMode_1
   1102              }
   1103              else
   1104              {
   1105                if (reg[0] != MX25LM51245G_CR2_DOPI)
   \                     ??OSPI_NOR_EnterDOPIMode_7: (+1)
   \      0x106   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \      0x10A   0x2802             CMP      R0,#+2
   \      0x10C   0xD001             BEQ.N    ??OSPI_NOR_EnterDOPIMode_1
   1106                {
   1107                  ret = BSP_ERROR_COMPONENT_FAILURE;
   \      0x10E   0xF07F 0x0404      MVNS     R4,#+4
   1108                }
   1109              }
   1110            }
   1111          
   1112            /* Return BSP status */
   1113            return ret;
   \                     ??OSPI_NOR_EnterDOPIMode_1: (+1)
   \      0x112   0x0020             MOVS     R0,R4
   \      0x114   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   1114          }
   1115          
   1116          /**
   1117            * @brief  This function enables the octal STR mode of the memory.
   1118            * @param  Instance  OSPI instance
   1119            * @retval BSP status
   1120            */

   \                                 In section .text, align 2, keep-with-next
   1121          static int32_t OSPI_NOR_EnterSOPIMode(uint32_t Instance)
   1122          {
   \                     OSPI_NOR_EnterSOPIMode: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   1123            int32_t ret = BSP_ERROR_NONE;
   \        0x6   0x2400             MOVS     R4,#+0
   1124            uint8_t reg[2];
   1125          
   1126            /* Enable write operations */
   1127            if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
   \        0x8   0x2660             MOVS     R6,#+96
   \        0xA   0x....             LDR.N    R7,??DataTable18_1
   \        0xC   0x.... 0x....      LDR.W    R8,??DataTable18
   \       0x10   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x14   0x7882             LDRB     R2,[R0, #+2]
   \       0x16   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x1A   0x7841             LDRB     R1,[R0, #+1]
   \       0x1C   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x20   0x4438             ADD      R0,R7,R0
   \       0x22   0x.... 0x....      BL       MX25LM51245G_WriteEnable
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD002             BEQ.N    ??OSPI_NOR_EnterSOPIMode_0
   1128            {
   1129              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x2A   0xF07F 0x0404      MVNS     R4,#+4
   \       0x2E   0xE05A             B.N      ??OSPI_NOR_EnterSOPIMode_1
   1130            }
   1131            /* Write Configuration register 2 (with new dummy cycles) */
   1132            else if (MX25LM51245G_WriteCfg2Register(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_CR2_REG3_ADDR, MX25LM51245G_CR2_DC_6_CYCLES) != MX25LM51245G_OK)
   \                     ??OSPI_NOR_EnterSOPIMode_0: (+1)
   \       0x30   0x2007             MOVS     R0,#+7
   \       0x32   0x9000             STR      R0,[SP, #+0]
   \       0x34   0xF44F 0x7340      MOV      R3,#+768
   \       0x38   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x3C   0x7882             LDRB     R2,[R0, #+2]
   \       0x3E   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x42   0x7841             LDRB     R1,[R0, #+1]
   \       0x44   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x48   0x4438             ADD      R0,R7,R0
   \       0x4A   0x.... 0x....      BL       MX25LM51245G_WriteCfg2Register
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD002             BEQ.N    ??OSPI_NOR_EnterSOPIMode_2
   1133            {
   1134              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x52   0xF07F 0x0404      MVNS     R4,#+4
   \       0x56   0xE046             B.N      ??OSPI_NOR_EnterSOPIMode_1
   1135            }
   1136            /* Enable write operations */
   1137            else if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
   \                     ??OSPI_NOR_EnterSOPIMode_2: (+1)
   \       0x58   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x5C   0x7882             LDRB     R2,[R0, #+2]
   \       0x5E   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x62   0x7841             LDRB     R1,[R0, #+1]
   \       0x64   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x68   0x4438             ADD      R0,R7,R0
   \       0x6A   0x.... 0x....      BL       MX25LM51245G_WriteEnable
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD002             BEQ.N    ??OSPI_NOR_EnterSOPIMode_3
   1138            {
   1139              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x72   0xF07F 0x0404      MVNS     R4,#+4
   \       0x76   0xE036             B.N      ??OSPI_NOR_EnterSOPIMode_1
   1140            }
   1141            /* Write Configuration register 2 (with Octal I/O SPI protocol) */
   1142            else if (MX25LM51245G_WriteCfg2Register(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_CR2_REG1_ADDR, MX25LM51245G_CR2_SOPI) != MX25LM51245G_OK)
   \                     ??OSPI_NOR_EnterSOPIMode_3: (+1)
   \       0x78   0x2001             MOVS     R0,#+1
   \       0x7A   0x9000             STR      R0,[SP, #+0]
   \       0x7C   0x2300             MOVS     R3,#+0
   \       0x7E   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x82   0x7882             LDRB     R2,[R0, #+2]
   \       0x84   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x88   0x7841             LDRB     R1,[R0, #+1]
   \       0x8A   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x8E   0x4438             ADD      R0,R7,R0
   \       0x90   0x.... 0x....      BL       MX25LM51245G_WriteCfg2Register
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD002             BEQ.N    ??OSPI_NOR_EnterSOPIMode_4
   1143            {
   1144              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x98   0xF07F 0x0404      MVNS     R4,#+4
   \       0x9C   0xE023             B.N      ??OSPI_NOR_EnterSOPIMode_1
   1145            }
   1146            else
   1147            {
   1148              /* Wait that the configuration is effective and check that memory is ready */
   1149              HAL_Delay(MX25LM51245G_WRITE_REG_MAX_TIME);
   \                     ??OSPI_NOR_EnterSOPIMode_4: (+1)
   \       0x9E   0x2028             MOVS     R0,#+40
   \       0xA0   0x.... 0x....      BL       HAL_Delay
   1150          
   1151              /* Check Flash busy ? */
   1152              if (MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
   \       0xA4   0x2200             MOVS     R2,#+0
   \       0xA6   0x2101             MOVS     R1,#+1
   \       0xA8   0xFB06 0xF005      MUL      R0,R6,R5
   \       0xAC   0x4438             ADD      R0,R7,R0
   \       0xAE   0x.... 0x....      BL       MX25LM51245G_AutoPollingMemReady
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD002             BEQ.N    ??OSPI_NOR_EnterSOPIMode_5
   1153              {
   1154                ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0xB6   0xF07F 0x0404      MVNS     R4,#+4
   \       0xBA   0xE014             B.N      ??OSPI_NOR_EnterSOPIMode_1
   1155              }
   1156              /* Check the configuration has been correctly done */
   1157              else if (MX25LM51245G_ReadCfg2Register(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_STR_TRANSFER, MX25LM51245G_CR2_REG1_ADDR, reg) != MX25LM51245G_OK)
   \                     ??OSPI_NOR_EnterSOPIMode_5: (+1)
   \       0xBC   0xA801             ADD      R0,SP,#+4
   \       0xBE   0x9000             STR      R0,[SP, #+0]
   \       0xC0   0x2300             MOVS     R3,#+0
   \       0xC2   0x2200             MOVS     R2,#+0
   \       0xC4   0x2101             MOVS     R1,#+1
   \       0xC6   0x4375             MULS     R5,R6,R5
   \       0xC8   0xEB07 0x0005      ADD      R0,R7,R5
   \       0xCC   0x.... 0x....      BL       MX25LM51245G_ReadCfg2Register
   \       0xD0   0x2800             CMP      R0,#+0
   \       0xD2   0xD002             BEQ.N    ??OSPI_NOR_EnterSOPIMode_6
   1158              {
   1159                ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0xD4   0xF07F 0x0404      MVNS     R4,#+4
   \       0xD8   0xE005             B.N      ??OSPI_NOR_EnterSOPIMode_1
   1160              }
   1161              else
   1162              {
   1163                if (reg[0] != MX25LM51245G_CR2_SOPI)
   \                     ??OSPI_NOR_EnterSOPIMode_6: (+1)
   \       0xDA   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0xDE   0x2801             CMP      R0,#+1
   \       0xE0   0xD001             BEQ.N    ??OSPI_NOR_EnterSOPIMode_1
   1164                {
   1165                  ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0xE2   0xF07F 0x0404      MVNS     R4,#+4
   1166                }
   1167              }
   1168            }
   1169          
   1170            /* Return BSP status */
   1171            return ret;
   \                     ??OSPI_NOR_EnterSOPIMode_1: (+1)
   \       0xE6   0x0020             MOVS     R0,R4
   \       0xE8   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   1172          }
   1173          
   1174          /**
   1175            * @brief  This function disables the octal DTR or STR mode of the memory.
   1176            * @param  Instance  OSPI instance
   1177            * @retval BSP status
   1178            */

   \                                 In section .text, align 2, keep-with-next
   1179          static int32_t OSPI_NOR_ExitOPIMode (uint32_t Instance)
   1180          {
   \                     OSPI_NOR_ExitOPIMode: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   1181            int32_t ret = BSP_ERROR_NONE;
   \        0x6   0x2400             MOVS     R4,#+0
   1182            uint8_t reg[2];
   1183          
   1184            /* Enable write operations */
   1185            if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
   \        0x8   0x2660             MOVS     R6,#+96
   \        0xA   0x....             LDR.N    R7,??DataTable18_1
   \        0xC   0x.... 0x....      LDR.W    R8,??DataTable18
   \       0x10   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x14   0x7882             LDRB     R2,[R0, #+2]
   \       0x16   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x1A   0x7841             LDRB     R1,[R0, #+1]
   \       0x1C   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x20   0x4438             ADD      R0,R7,R0
   \       0x22   0x.... 0x....      BL       MX25LM51245G_WriteEnable
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD002             BEQ.N    ??OSPI_NOR_ExitOPIMode_0
   1186            {
   1187              ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x2A   0xF07F 0x0404      MVNS     R4,#+4
   \       0x2E   0xE055             B.N      ??OSPI_NOR_ExitOPIMode_1
   1188            }
   1189            else
   1190            {
   1191              /* Write Configuration register 2 (with SPI protocol) */
   1192              reg[0] = 0;
   \                     ??OSPI_NOR_ExitOPIMode_0: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1193              reg[1] = 0;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1194              if (MX25LM51245G_WriteCfg2Register(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_CR2_REG1_ADDR, reg[0]) != MX25LM51245G_OK)
   \       0x3C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x40   0x9000             STR      R0,[SP, #+0]
   \       0x42   0x2300             MOVS     R3,#+0
   \       0x44   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x48   0x7882             LDRB     R2,[R0, #+2]
   \       0x4A   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x4E   0x7841             LDRB     R1,[R0, #+1]
   \       0x50   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x54   0x4438             ADD      R0,R7,R0
   \       0x56   0x.... 0x....      BL       MX25LM51245G_WriteCfg2Register
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD002             BEQ.N    ??OSPI_NOR_ExitOPIMode_2
   1195              {
   1196                ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0x5E   0xF07F 0x0404      MVNS     R4,#+4
   \       0x62   0xE03B             B.N      ??OSPI_NOR_ExitOPIMode_1
   1197              }
   1198              else
   1199              {
   1200                /* Wait that the configuration is effective and check that memory is ready */
   1201                HAL_Delay(MX25LM51245G_WRITE_REG_MAX_TIME);
   \                     ??OSPI_NOR_ExitOPIMode_2: (+1)
   \       0x64   0x2028             MOVS     R0,#+40
   \       0x66   0x.... 0x....      BL       HAL_Delay
   1202          
   1203                if (Ospi_Nor_Ctx[Instance].TransferRate == BSP_OSPI_NOR_DTR_TRANSFER)
   \       0x6A   0xEB08 0x00C5      ADD      R0,R8,R5, LSL #+3
   \       0x6E   0x7880             LDRB     R0,[R0, #+2]
   \       0x70   0x2801             CMP      R0,#+1
   \       0x72   0xD112             BNE.N    ??OSPI_NOR_ExitOPIMode_3
   1204                {
   1205                  /* Reconfigure the memory type of the peripheral */
   1206                  hospi_nor[Instance].Init.MemoryType            = HAL_OSPI_MEMTYPE_MICRON;
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xFB06 0xF105      MUL      R1,R6,R5
   \       0x7A   0x4439             ADD      R1,R7,R1
   \       0x7C   0x60C8             STR      R0,[R1, #+12]
   1207                  hospi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_DISABLE;
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0xFB06 0xF105      MUL      R1,R6,R5
   \       0x84   0x4439             ADD      R1,R7,R1
   \       0x86   0x62C8             STR      R0,[R1, #+44]
   1208                  if (HAL_OSPI_Init(&hospi_nor[Instance]) != HAL_OK)
   \       0x88   0xFB06 0xF005      MUL      R0,R6,R5
   \       0x8C   0x4438             ADD      R0,R7,R0
   \       0x8E   0x.... 0x....      BL       HAL_OSPI_Init
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD001             BEQ.N    ??OSPI_NOR_ExitOPIMode_3
   1209                  {
   1210                    ret = BSP_ERROR_PERIPH_FAILURE;
   \       0x96   0xF07F 0x0403      MVNS     R4,#+3
   1211                  }
   1212                }
   1213          
   1214                /* Check Flash busy ? */
   1215                if (MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], BSP_OSPI_NOR_SPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
   \                     ??OSPI_NOR_ExitOPIMode_3: (+1)
   \       0x9A   0x2200             MOVS     R2,#+0
   \       0x9C   0x2100             MOVS     R1,#+0
   \       0x9E   0xFB06 0xF005      MUL      R0,R6,R5
   \       0xA2   0x4438             ADD      R0,R7,R0
   \       0xA4   0x.... 0x....      BL       MX25LM51245G_AutoPollingMemReady
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD002             BEQ.N    ??OSPI_NOR_ExitOPIMode_4
   1216                {
   1217                  ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0xAC   0xF07F 0x0404      MVNS     R4,#+4
   \       0xB0   0xE014             B.N      ??OSPI_NOR_ExitOPIMode_1
   1218                }
   1219                /* Check the configuration has been correctly done */
   1220                else if (MX25LM51245G_ReadCfg2Register(&hospi_nor[Instance], BSP_OSPI_NOR_SPI_MODE, BSP_OSPI_NOR_STR_TRANSFER, MX25LM51245G_CR2_REG1_ADDR, reg) != MX25LM51245G_OK)
   \                     ??OSPI_NOR_ExitOPIMode_4: (+1)
   \       0xB2   0xA801             ADD      R0,SP,#+4
   \       0xB4   0x9000             STR      R0,[SP, #+0]
   \       0xB6   0x2300             MOVS     R3,#+0
   \       0xB8   0x2200             MOVS     R2,#+0
   \       0xBA   0x2100             MOVS     R1,#+0
   \       0xBC   0x4375             MULS     R5,R6,R5
   \       0xBE   0xEB07 0x0005      ADD      R0,R7,R5
   \       0xC2   0x.... 0x....      BL       MX25LM51245G_ReadCfg2Register
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD002             BEQ.N    ??OSPI_NOR_ExitOPIMode_5
   1221                {
   1222                  ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0xCA   0xF07F 0x0404      MVNS     R4,#+4
   \       0xCE   0xE005             B.N      ??OSPI_NOR_ExitOPIMode_1
   1223                }
   1224                else
   1225                {
   1226                  if (reg[0] != 0U)
   \                     ??OSPI_NOR_ExitOPIMode_5: (+1)
   \       0xD0   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0xD4   0x2800             CMP      R0,#+0
   \       0xD6   0xD001             BEQ.N    ??OSPI_NOR_ExitOPIMode_1
   1227                  {
   1228                    ret = BSP_ERROR_COMPONENT_FAILURE;
   \       0xD8   0xF07F 0x0404      MVNS     R4,#+4
   1229                  }
   1230                }
   1231              }
   1232            }
   1233          
   1234            /* Return BSP status */
   1235            return ret;
   \                     ??OSPI_NOR_ExitOPIMode_1: (+1)
   \       0xDC   0x0020             MOVS     R0,R4
   \       0xDE   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   1236          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x....'....        DC32     Ospi_Nor_Ctx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \        0x0   0x....'....        DC32     hospi_nor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \        0x0   0x....'....        DC32     `BSP_OSPI_NOR_GetStatus::reg`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \        0x0   0x5802'4534        DC32     0x58024534

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \        0x0   0x5802'447C        DC32     0x5802447c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \        0x0   0x5802'4540        DC32     0x58024540

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \        0x0   0x5802'1800        DC32     0x58021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \        0x0   0x5802'0800        DC32     0x58020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_8:
   \        0x0   0x5802'0400        DC32     0x58020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_9:
   \        0x0   0x5802'0C00        DC32     0x58020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_10:
   \        0x0   0x5802'1400        DC32     0x58021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_11:
   \        0x0   0x5802'1C00        DC32     0x58021c00
   1237          
   1238          /**
   1239            * @}
   1240            */
   1241          
   1242          /**
   1243            * @}
   1244            */
   1245          
   1246          /**
   1247            * @}
   1248            */
   1249          
   1250          /**
   1251            * @}
   1252            */
   1253          
   1254          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
   1255          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   BSP_OSPI_NOR_ConfigFlash
        24   -> OSPI_NOR_EnterDOPIMode
        24   -> OSPI_NOR_EnterSOPIMode
        24   -> OSPI_NOR_ExitOPIMode
      24   BSP_OSPI_NOR_DeInit
        24   -> BSP_OSPI_NOR_DisableMemoryMappedMode
        24   -> HAL_OSPI_DeInit
        24   -> OSPI_NOR_MspDeInit
      16   BSP_OSPI_NOR_DisableMemoryMappedMode
        16   -> HAL_OSPI_Abort
      16   BSP_OSPI_NOR_EnableMemoryMappedMode
        16   -> MX25LM51245G_EnableMemoryMappedModeDTR
        16   -> MX25LM51245G_EnableMemoryMappedModeSTR
      40   BSP_OSPI_NOR_Erase_Block
        40   -> MX25LM51245G_AutoPollingMemReady
        40   -> MX25LM51245G_BlockErase
        40   -> MX25LM51245G_WriteEnable
      24   BSP_OSPI_NOR_Erase_Chip
        24   -> MX25LM51245G_AutoPollingMemReady
        24   -> MX25LM51245G_ChipErase
        24   -> MX25LM51245G_WriteEnable
       8   BSP_OSPI_NOR_GetInfo
         8   -> MX25LM51245G_GetFlashInfo
      32   BSP_OSPI_NOR_GetStatus
        32   -> MX25LM51245G_ReadSecurityRegister
        32   -> MX25LM51245G_ReadStatusRegister
      80   BSP_OSPI_NOR_Init
        80   -> BSP_OSPI_NOR_ConfigFlash
        80   -> MX25LM51245G_AutoPollingMemReady
        80   -> MX25LM51245G_GetFlashInfo
        80   -> MX_OSPI_NOR_Init
        80   -> OSPI_NOR_MspInit
        80   -> OSPI_NOR_ResetMemory
      24   BSP_OSPI_NOR_Read
        24   -> MX25LM51245G_ReadDTR
        24   -> MX25LM51245G_ReadSTR
      16   BSP_OSPI_NOR_ReadID
        16   -> MX25LM51245G_ReadID
      16   BSP_OSPI_NOR_ResumeErase
        16   -> BSP_OSPI_NOR_GetStatus
        16   -> MX25LM51245G_Resume
      16   BSP_OSPI_NOR_SuspendErase
        16   -> BSP_OSPI_NOR_GetStatus
        16   -> MX25LM51245G_Suspend
      48   BSP_OSPI_NOR_Write
        48   -> MX25LM51245G_AutoPollingMemReady
        48   -> MX25LM51245G_PageProgram
        48   -> MX25LM51245G_PageProgramDTR
        48   -> MX25LM51245G_WriteEnable
       8   MX_OSPI_NOR_Init
         8   -> HAL_OSPI_Init
      32   OSPI_NOR_EnterDOPIMode
        32   -> HAL_Delay
        32   -> HAL_OSPI_Init
        32   -> MX25LM51245G_AutoPollingMemReady
        32   -> MX25LM51245G_ReadCfg2Register
        32   -> MX25LM51245G_WriteCfg2Register
        32   -> MX25LM51245G_WriteEnable
      32   OSPI_NOR_EnterSOPIMode
        32   -> HAL_Delay
        32   -> MX25LM51245G_AutoPollingMemReady
        32   -> MX25LM51245G_ReadCfg2Register
        32   -> MX25LM51245G_WriteCfg2Register
        32   -> MX25LM51245G_WriteEnable
      32   OSPI_NOR_ExitOPIMode
        32   -> HAL_Delay
        32   -> HAL_OSPI_Init
        32   -> MX25LM51245G_AutoPollingMemReady
        32   -> MX25LM51245G_ReadCfg2Register
        32   -> MX25LM51245G_WriteCfg2Register
        32   -> MX25LM51245G_WriteEnable
      24   OSPI_NOR_MspDeInit
        24   -> HAL_GPIO_DeInit
      48   OSPI_NOR_MspInit
        48   -> HAL_GPIO_Init
      24   OSPI_NOR_ResetMemory
        24   -> HAL_Delay
        24   -> MX25LM51245G_ResetEnable
        24   -> MX25LM51245G_ResetMemory


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_10
       4  ??DataTable18_11
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable18_9
     168  BSP_OSPI_NOR_ConfigFlash
     106  BSP_OSPI_NOR_DeInit
      70  BSP_OSPI_NOR_DisableMemoryMappedMode
     114  BSP_OSPI_NOR_EnableMemoryMappedMode
     144  BSP_OSPI_NOR_Erase_Block
     128  BSP_OSPI_NOR_Erase_Chip
      24  BSP_OSPI_NOR_GetInfo
     150  BSP_OSPI_NOR_GetStatus
     180  BSP_OSPI_NOR_Init
      92  BSP_OSPI_NOR_Read
      58  BSP_OSPI_NOR_ReadID
      96  BSP_OSPI_NOR_ResumeErase
      96  BSP_OSPI_NOR_SuspendErase
     266  BSP_OSPI_NOR_Write
      88  MX_OSPI_NOR_Init
     280  OSPI_NOR_EnterDOPIMode
     236  OSPI_NOR_EnterSOPIMode
     226  OSPI_NOR_ExitOPIMode
     150  OSPI_NOR_MspDeInit
     470  OSPI_NOR_MspInit
     192  OSPI_NOR_ResetMemory
       8  Ospi_Nor_Ctx
      96  hospi_nor
       2  reg

 
   106 bytes in section .bss
 3'382 bytes in section .text
 
 3'294 bytes of CODE memory (+ 88 bytes shared)
   106 bytes of DATA memory

Errors: none
Warnings: none
