###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         07/Feb/2022  20:39:41
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\BSP\STM32H7B3I-DK\stm32h7b3i_discovery_bus.c
#        [UTF-8]
#    Command line      =
#        -f
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\BSP\STM32H7B3I-DK\stm32h7b3i_discovery_bus.o.rsp
#        (D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\BSP\STM32H7B3I-DK\stm32h7b3i_discovery_bus.c
#        -D USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\BSP\STM32H7B3I-DK
#        -lA
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\BSP\STM32H7B3I-DK
#        -o
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\BSP\STM32H7B3I-DK
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Core/Inc\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/App\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\BSP\STM32H7B3I-DK\stm32h7b3i_discovery_bus.o.d
#    Locale            =  C
#    List file         =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\BSP\STM32H7B3I-DK\stm32h7b3i_discovery_bus.lst
#    Object file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\BSP\STM32H7B3I-DK\stm32h7b3i_discovery_bus.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\BSP\STM32H7B3I-DK\stm32h7b3i_discovery_bus.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32h7b3i_discovery_bus.c
      4            * @author  MCD Application Team
      5            * @brief   This file provides a set of firmware functions to communicate
      6            *          with  external devices available on STM32H7B3I-DK board (MB1332) from
      7            *          STMicroelectronics
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     12            * All rights reserved.</center></h2>
     13            *
     14            * This software component is licensed by ST under BSD 3-Clause license,
     15            * the "License"; You may not use this file except in compliance with the
     16            * License. You may obtain a copy of the License at:
     17            *                        opensource.org/licenses/BSD-3-Clause
     18            *
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32h7b3i_discovery_bus.h"
     24          
     25          /** @addtogroup BSP
     26            * @{
     27            */
     28          
     29          /** @addtogroup STM32H7B3I_DK
     30            * @{
     31            */
     32          
     33          /** @defgroup STM32H7B3I_DK_BUS BUS
     34            * @{
     35            */
     36          
     37          /** @defgroup STM32H7B3I_DK_BUS_Private_Constants Private Constants
     38            * @{
     39            */
     40          #ifndef I2C_VALID_TIMING_NBR
     41            #define I2C_VALID_TIMING_NBR                 128U
     42          #endif
     43          #define I2C_SPEED_FREQ_STANDARD                0U    /* 100 kHz */
     44          #define I2C_SPEED_FREQ_FAST                    1U    /* 400 kHz */
     45          #define I2C_SPEED_FREQ_FAST_PLUS               2U    /* 1 MHz */
     46          #define I2C_ANALOG_FILTER_DELAY_MIN            50U   /* ns */
     47          #define I2C_ANALOG_FILTER_DELAY_MAX            260U  /* ns */
     48          #define I2C_USE_ANALOG_FILTER                  1U
     49          #define I2C_DIGITAL_FILTER_COEF                0U
     50          #define I2C_PRESC_MAX                          16U
     51          #define I2C_SCLDEL_MAX                         16U
     52          #define I2C_SDADEL_MAX                         16U
     53          #define I2C_SCLH_MAX                           256U
     54          #define I2C_SCLL_MAX                           256U
     55          #define SEC2NSEC                               1000000000UL
     56          /**
     57            * @}
     58            */
     59          
     60          /** @defgroup STM32H7B3I_DK_BUS_Private_TypesPrivate Private Types
     61            * @{
     62            */
     63          typedef struct
     64          {
     65            uint32_t freq;       /* Frequency in Hz */
     66            uint32_t freq_min;   /* Minimum frequency in Hz */
     67            uint32_t freq_max;   /* Maximum frequency in Hz */
     68            uint32_t hddat_min;  /* Minimum data hold time in ns */
     69            uint32_t vddat_max;  /* Maximum data valid time in ns */
     70            uint32_t sudat_min;  /* Minimum data setup time in ns */
     71            uint32_t lscl_min;   /* Minimum low period of the SCL clock in ns */
     72            uint32_t hscl_min;   /* Minimum high period of SCL clock in ns */
     73            uint32_t trise;      /* Rise time in ns */
     74            uint32_t tfall;      /* Fall time in ns */
     75            uint32_t dnf;        /* Digital noise filter coefficient */
     76          } I2C_Charac_t;
     77          
     78          typedef struct
     79          {
     80            uint32_t presc;      /* Timing prescaler */
     81            uint32_t tscldel;    /* SCL delay */
     82            uint32_t tsdadel;    /* SDA delay */
     83            uint32_t sclh;       /* SCL high period */
     84            uint32_t scll;       /* SCL low period */
     85          } I2C_Timings_t;
     86          /**
     87            * @}
     88            */
     89          
     90          /** @defgroup STM32H7B3I_DK_BUS_Private_Constants Private Constants
     91            * @{
     92            */

   \                                 In section .rodata, align 4
     93          static const I2C_Charac_t I2C_Charac[] =
   \                     I2C_Charac:
   \        0x0   0x0001'86A0        DC32 100'000, 80'000, 120'000, 0, 3'450, 250, 4'700, 4'000, 640, 20, 0

   \              0x0001'3880  

   \              0x0001'D4C0  

   \              0x0000'0000  

   \              0x0000'0D7A  

   \              0x0000'00FA  

   \              0x0000'125C  

   \              0x0000'0FA0  

   \              0x0000'0280  

   \              0x0000'0014  

   \              0x0000'0000
   \       0x2C   0x0006'1A80        DC32 400'000, 320'000, 480'000, 0, 900, 100, 1'300, 600, 250, 100, 0

   \              0x0004'E200  

   \              0x0007'5300  

   \              0x0000'0000  

   \              0x0000'0384  

   \              0x0000'0064  

   \              0x0000'0514  

   \              0x0000'0258  

   \              0x0000'00FA  

   \              0x0000'0064  

   \              0x0000'0000
   \       0x58   0x000F'4240        DC32 1'000'000, 800'000, 1'200'000, 0, 450, 50, 500, 260, 60, 100, 0

   \              0x000C'3500  

   \              0x0012'4F80  

   \              0x0000'0000  

   \              0x0000'01C2  

   \              0x0000'0032  

   \              0x0000'01F4  

   \              0x0000'0104  

   \              0x0000'003C  

   \              0x0000'0064  

   \              0x0000'0000
     94          {
     95            [I2C_SPEED_FREQ_STANDARD] =
     96            {
     97              .freq = 100000,
     98              .freq_min = 80000,
     99              .freq_max = 120000,
    100              .hddat_min = 0,
    101              .vddat_max = 3450,
    102              .sudat_min = 250,
    103              .lscl_min = 4700,
    104              .hscl_min = 4000,
    105              .trise = 640,
    106              .tfall = 20,
    107              .dnf = I2C_DIGITAL_FILTER_COEF,
    108            },
    109            [I2C_SPEED_FREQ_FAST] =
    110            {
    111              .freq = 400000,
    112              .freq_min = 320000,
    113              .freq_max = 480000,
    114              .hddat_min = 0,
    115              .vddat_max = 900,
    116              .sudat_min = 100,
    117              .lscl_min = 1300,
    118              .hscl_min = 600,
    119              .trise = 250,
    120              .tfall = 100,
    121              .dnf = I2C_DIGITAL_FILTER_COEF,
    122            },
    123            [I2C_SPEED_FREQ_FAST_PLUS] =
    124            {
    125              .freq = 1000000,
    126              .freq_min = 800000,
    127              .freq_max = 1200000,
    128              .hddat_min = 0,
    129              .vddat_max = 450,
    130              .sudat_min = 50,
    131              .lscl_min = 500,
    132              .hscl_min = 260,
    133              .trise = 60,
    134              .tfall = 100,
    135              .dnf = I2C_DIGITAL_FILTER_COEF,
    136            },
    137          };
    138          /**
    139            * @}
    140            */
    141          
    142          /** @defgroup STM32H7B3I_DK_BUS_Private_Variables Private Variables
    143            * @{
    144            */
    145          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    146          static uint32_t IsI2c4MspCbValid = 0;
    147          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

   \                                 In section .bss, align 4
    148          static uint32_t I2c4InitCounter = 0;
   \                     I2c4InitCounter:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    149          static I2C_Timings_t I2c_valid_timing[I2C_VALID_TIMING_NBR];
   \                     I2c_valid_timing:
   \        0x0                      DS8 2'560

   \                                 In section .bss, align 4
    150          static uint32_t      I2c_valid_timing_nbr = 0;
   \                     I2c_valid_timing_nbr:
   \        0x0                      DS8 4
    151          /**
    152            * @}
    153            */
    154          
    155          /** @defgroup STM32H7B3I_DK_BUS_Exported_Variables Exported Variables
    156            * @{
    157            */

   \                                 In section .bss, align 4
    158          I2C_HandleTypeDef hbus_i2c4;
   \                     hbus_i2c4:
   \        0x0                      DS8 76
    159          /**
    160            * @}
    161            */
    162          
    163          /** @defgroup STM32H7B3I_DK_BUS_Private_FunctionPrototypes Private Function Prototypes
    164            * @{
    165            */
    166          static void I2C4_MspInit(I2C_HandleTypeDef *phi2c);
    167          static void I2C4_MspDeInit(I2C_HandleTypeDef *phi2c);
    168          static int32_t I2C4_WriteReg(uint16_t DevAddr, uint16_t MemAddSize, uint16_t Reg, uint8_t *pData, uint16_t Length);
    169          static int32_t I2C4_ReadReg(uint16_t DevAddr, uint16_t MemAddSize, uint16_t Reg, uint8_t *pData, uint16_t Length);
    170          static uint32_t I2C_GetTiming(uint32_t clock_src_freq, uint32_t i2c_freq);
    171          static uint32_t I2C_Compute_SCLL_SCLH(uint32_t clock_src_freq, uint32_t I2C_speed);
    172          static void     I2C_Compute_PRESC_SCLDEL_SDADEL(uint32_t clock_src_freq, uint32_t I2C_speed);
    173          /**
    174            * @}
    175            */
    176          
    177          /** @defgroup STM32H7B3I_DK_BUS_Exported_Functions Exported Functions
    178            * @{
    179            */
    180          /**
    181            * @brief  Initializes I2C HAL.
    182            * @retval BSP status
    183            */

   \                                 In section .text, align 2, keep-with-next
    184          int32_t BSP_I2C4_Init(void)
    185          {
   \                     BSP_I2C4_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    186            int32_t ret = BSP_ERROR_NONE;
   \        0x2   0x2400             MOVS     R4,#+0
    187          
    188            hbus_i2c4.Instance = BUS_I2C4;
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable13
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \        0xC   0x6028             STR      R0,[R5, #+0]
    189          
    190            if (I2c4InitCounter == 0U)
   \        0xE   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \       0x12   0x6808             LDR      R0,[R1, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD118             BNE.N    ??BSP_I2C4_Init_0
    191            {
    192              I2c4InitCounter++;
   \       0x18   0x6808             LDR      R0,[R1, #+0]
   \       0x1A   0x1C40             ADDS     R0,R0,#+1
   \       0x1C   0x6008             STR      R0,[R1, #+0]
    193          
    194              if (HAL_I2C_GetState(&hbus_i2c4) == HAL_I2C_STATE_RESET)
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0x.... 0x....      BL       HAL_I2C_GetState
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD110             BNE.N    ??BSP_I2C4_Init_0
    195              {
    196          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 0)
    197                /* Init the I2C4 Msp */
    198                I2C4_MspInit(&hbus_i2c4);
   \       0x28   0x0028             MOVS     R0,R5
   \       0x2A   0x.... 0x....      BL       I2C4_MspInit
    199          #else
    200                if (IsI2c4MspCbValid == 0U)
    201                {
    202                  if (BSP_I2C4_RegisterDefaultMspCallbacks() != BSP_ERROR_NONE)
    203                  {
    204                    ret = BSP_ERROR_MSP_FAILURE;
    205                  }
    206                }
    207                if (ret == BSP_ERROR_NONE)
    208                {
    209          #endif
    210                  if (MX_I2C4_Init(&hbus_i2c4, I2C_GetTiming(HAL_RCC_GetPCLK2Freq(), BUS_I2C4_FREQUENCY)) != HAL_OK)
   \       0x2E   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \       0x32   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \       0x36   0x.... 0x....      BL       I2C_GetTiming
   \       0x3A   0x0001             MOVS     R1,R0
   \       0x3C   0x0028             MOVS     R0,R5
   \       0x3E   0x.... 0x....      BL       MX_I2C4_Init
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD001             BEQ.N    ??BSP_I2C4_Init_0
    211                  {
    212                    ret = BSP_ERROR_BUS_FAILURE;
   \       0x46   0xF07F 0x0407      MVNS     R4,#+7
    213                  }
    214          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    215                }
    216          #endif
    217              }
    218            }
    219          
    220            return ret;
   \                     ??BSP_I2C4_Init_0: (+1)
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0xBD32             POP      {R1,R4,R5,PC}
    221          }
    222          
    223          /**
    224            * @brief  DeInitializes I2C HAL.
    225            * @retval BSP status
    226            */

   \                                 In section .text, align 2, keep-with-next
    227          int32_t BSP_I2C4_DeInit(void)
    228          {
   \                     BSP_I2C4_DeInit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    229            int32_t ret  = BSP_ERROR_NONE;
   \        0x2   0x2400             MOVS     R4,#+0
    230          
    231            I2c4InitCounter--;
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0x1E49             SUBS     R1,R1,#+1
   \        0xC   0x6001             STR      R1,[R0, #+0]
    232          
    233            if (I2c4InitCounter == 0U)
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD10B             BNE.N    ??BSP_I2C4_DeInit_0
    234            {
    235          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 0)
    236              I2C4_MspDeInit(&hbus_i2c4);
   \       0x14   0x.... 0x....      LDR.W    R5,??DataTable13
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0x.... 0x....      BL       I2C4_MspDeInit
    237          #endif /* (USE_HAL_I2C_REGISTER_CALLBACKS == 0) */
    238          
    239              /* Init the I2C */
    240              if (HAL_I2C_DeInit(&hbus_i2c4) != HAL_OK)
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0x.... 0x....      BL       HAL_I2C_DeInit
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD001             BEQ.N    ??BSP_I2C4_DeInit_0
    241              {
    242                ret = BSP_ERROR_BUS_FAILURE;
   \       0x28   0xF07F 0x0407      MVNS     R4,#+7
    243              }
    244            }
    245          
    246            return ret;
   \                     ??BSP_I2C4_DeInit_0: (+1)
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}
    247          }
    248          
    249          /**
    250            * @brief  MX I2C4 initialization.
    251            * @param  hI2c I2C handle
    252            * @param  timing I2C timing
    253            * @retval HAL status
    254            */

   \                                 In section .text, align 2
    255          __weak HAL_StatusTypeDef MX_I2C4_Init(I2C_HandleTypeDef *hI2c, uint32_t timing)
    256          {
   \                     MX_I2C4_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    257            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
    258          
    259            hI2c->Init.Timing           = timing;
   \        0x6   0x6061             STR      R1,[R4, #+4]
    260            hI2c->Init.OwnAddress1      = 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x60A0             STR      R0,[R4, #+8]
    261            hI2c->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x60E0             STR      R0,[R4, #+12]
    262            hI2c->Init.DualAddressMode  = I2C_DUALADDRESS_DISABLE;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x6120             STR      R0,[R4, #+16]
    263            hI2c->Init.OwnAddress2      = 0;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x6160             STR      R0,[R4, #+20]
    264            hI2c->Init.OwnAddress2Masks = I2C_OA2_NOMASK;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x61A0             STR      R0,[R4, #+24]
    265            hI2c->Init.GeneralCallMode  = I2C_GENERALCALL_DISABLE;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x61E0             STR      R0,[R4, #+28]
    266            hI2c->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x6220             STR      R0,[R4, #+32]
    267          
    268            if (HAL_I2C_Init(hI2c) != HAL_OK)
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       HAL_I2C_Init
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD001             BEQ.N    ??MX_I2C4_Init_0
    269            {
    270              status = HAL_ERROR;
   \       0x2E   0x2501             MOVS     R5,#+1
   \       0x30   0xE00E             B.N      ??MX_I2C4_Init_1
    271            }
    272            else
    273            {
    274              uint32_t analog_filter;
    275          
    276              analog_filter = I2C_ANALOGFILTER_ENABLE;
   \                     ??MX_I2C4_Init_0: (+1)
   \       0x32   0x2100             MOVS     R1,#+0
    277              if (HAL_I2CEx_ConfigAnalogFilter(hI2c, analog_filter) != HAL_OK)
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       HAL_I2CEx_ConfigAnalogFilter
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD001             BEQ.N    ??MX_I2C4_Init_2
    278              {
    279                status = HAL_ERROR;
   \       0x3E   0x2501             MOVS     R5,#+1
   \       0x40   0xE006             B.N      ??MX_I2C4_Init_1
    280              }
    281              else
    282              {
    283                if (HAL_I2CEx_ConfigDigitalFilter(hI2c, I2C_DIGITAL_FILTER_COEF) != HAL_OK)
   \                     ??MX_I2C4_Init_2: (+1)
   \       0x42   0x2100             MOVS     R1,#+0
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x.... 0x....      BL       HAL_I2CEx_ConfigDigitalFilter
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD000             BEQ.N    ??MX_I2C4_Init_1
    284                {
    285                  status = HAL_ERROR;
   \       0x4E   0x2501             MOVS     R5,#+1
    286                }
    287              }
    288            }
    289          
    290            return status;
   \                     ??MX_I2C4_Init_1: (+1)
   \       0x50   0x0028             MOVS     R0,R5
   \       0x52   0xB2C0             UXTB     R0,R0
   \       0x54   0xBD32             POP      {R1,R4,R5,PC}
    291          }
    292          
    293          /**
    294            * @brief  Write a 8bit value in a register of the device through BUS.
    295            * @param  DevAddr Device address on Bus.
    296            * @param  Reg    The target register address to write
    297            * @param  pData  The target register value to be written
    298            * @param  Length buffer size to be written
    299            * @retval BSP status
    300            */

   \                                 In section .text, align 2, keep-with-next
    301          int32_t BSP_I2C4_WriteReg(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
    302          {
   \                     BSP_I2C4_WriteReg: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    303            int32_t ret;
    304          
    305            if(I2C4_WriteReg(DevAddr, Reg, I2C_MEMADD_SIZE_8BIT, pData, Length) == 0)
   \        0x2   0xB29B             UXTH     R3,R3
   \        0x4   0x9300             STR      R3,[SP, #+0]
   \        0x6   0x0013             MOVS     R3,R2
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xB289             UXTH     R1,R1
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x.... 0x....      BL       I2C4_WriteReg
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD101             BNE.N    ??BSP_I2C4_WriteReg_0
    306            {
    307              ret = BSP_ERROR_NONE;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE00A             B.N      ??BSP_I2C4_WriteReg_1
    308            }
    309            else
    310            {
    311              if( HAL_I2C_GetError(&hbus_i2c4) == HAL_I2C_ERROR_AF)
   \                     ??BSP_I2C4_WriteReg_0: (+1)
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x1E   0x.... 0x....      BL       HAL_I2C_GetError
   \       0x22   0x2804             CMP      R0,#+4
   \       0x24   0xD102             BNE.N    ??BSP_I2C4_WriteReg_2
    312              {
    313                ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
   \       0x26   0xF07F 0x0065      MVNS     R0,#+101
   \       0x2A   0xE001             B.N      ??BSP_I2C4_WriteReg_1
    314              }
    315              else
    316              {
    317                ret =  BSP_ERROR_PERIPH_FAILURE;
   \                     ??BSP_I2C4_WriteReg_2: (+1)
   \       0x2C   0xF07F 0x0003      MVNS     R0,#+3
    318              }
    319            }
    320          
    321            return ret;
   \                     ??BSP_I2C4_WriteReg_1: (+1)
   \       0x30   0xBD02             POP      {R1,PC}
    322          }
    323          
    324          /**
    325            * @brief  Read a 8bit register of the device through BUS
    326            * @param  DevAddr Device address on BUS
    327            * @param  Reg     The target register address to read
    328            * @param  pData   Pointer to data buffer
    329            * @param  Length  Length of the data
    330            * @retval BSP status
    331            */

   \                                 In section .text, align 2, keep-with-next
    332          int32_t BSP_I2C4_ReadReg(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
    333          {
   \                     BSP_I2C4_ReadReg: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    334            int32_t ret;
    335          
    336            if(I2C4_ReadReg(DevAddr, Reg, I2C_MEMADD_SIZE_8BIT, pData, Length) == 0)
   \        0x2   0xB29B             UXTH     R3,R3
   \        0x4   0x9300             STR      R3,[SP, #+0]
   \        0x6   0x0013             MOVS     R3,R2
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xB289             UXTH     R1,R1
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x.... 0x....      BL       I2C4_ReadReg
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD101             BNE.N    ??BSP_I2C4_ReadReg_0
    337            {
    338              ret = BSP_ERROR_NONE;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE00A             B.N      ??BSP_I2C4_ReadReg_1
    339            }
    340            else
    341            {
    342              if( HAL_I2C_GetError(&hbus_i2c4) == HAL_I2C_ERROR_AF)
   \                     ??BSP_I2C4_ReadReg_0: (+1)
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x1E   0x.... 0x....      BL       HAL_I2C_GetError
   \       0x22   0x2804             CMP      R0,#+4
   \       0x24   0xD102             BNE.N    ??BSP_I2C4_ReadReg_2
    343              {
    344                ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
   \       0x26   0xF07F 0x0065      MVNS     R0,#+101
   \       0x2A   0xE001             B.N      ??BSP_I2C4_ReadReg_1
    345              }
    346              else
    347              {
    348                ret =  BSP_ERROR_PERIPH_FAILURE;
   \                     ??BSP_I2C4_ReadReg_2: (+1)
   \       0x2C   0xF07F 0x0003      MVNS     R0,#+3
    349              }
    350            }
    351          
    352            return ret;
   \                     ??BSP_I2C4_ReadReg_1: (+1)
   \       0x30   0xBD02             POP      {R1,PC}
    353          }
    354          
    355          /**
    356            * @brief  Write a 16bit value in a register of the device through BUS.
    357            * @param  DevAddr Device address on Bus.
    358            * @param  Reg    The target register address to write
    359            * @param  pData  The target register value to be written
    360            * @param  Length buffer size to be written
    361            * @retval BSP status
    362            */

   \                                 In section .text, align 2, keep-with-next
    363          int32_t BSP_I2C4_WriteReg16(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
    364          {
   \                     BSP_I2C4_WriteReg16: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    365            int32_t ret;
    366          
    367            if(I2C4_WriteReg(DevAddr, Reg, I2C_MEMADD_SIZE_16BIT, pData, Length) == 0)
   \        0x2   0xB29B             UXTH     R3,R3
   \        0x4   0x9300             STR      R3,[SP, #+0]
   \        0x6   0x0013             MOVS     R3,R2
   \        0x8   0x2202             MOVS     R2,#+2
   \        0xA   0xB289             UXTH     R1,R1
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x.... 0x....      BL       I2C4_WriteReg
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD101             BNE.N    ??BSP_I2C4_WriteReg16_0
    368            {
    369              ret = BSP_ERROR_NONE;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE00A             B.N      ??BSP_I2C4_WriteReg16_1
    370            }
    371            else
    372            {
    373              if( HAL_I2C_GetError(&hbus_i2c4) == HAL_I2C_ERROR_AF)
   \                     ??BSP_I2C4_WriteReg16_0: (+1)
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x1E   0x.... 0x....      BL       HAL_I2C_GetError
   \       0x22   0x2804             CMP      R0,#+4
   \       0x24   0xD102             BNE.N    ??BSP_I2C4_WriteReg16_2
    374              {
    375                ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
   \       0x26   0xF07F 0x0065      MVNS     R0,#+101
   \       0x2A   0xE001             B.N      ??BSP_I2C4_WriteReg16_1
    376              }
    377              else
    378              {
    379                ret =  BSP_ERROR_PERIPH_FAILURE;
   \                     ??BSP_I2C4_WriteReg16_2: (+1)
   \       0x2C   0xF07F 0x0003      MVNS     R0,#+3
    380              }
    381            }
    382          
    383            return ret;
   \                     ??BSP_I2C4_WriteReg16_1: (+1)
   \       0x30   0xBD02             POP      {R1,PC}
    384          }
    385          
    386          /**
    387            * @brief  Read a 16bit register of the device through BUS
    388            * @param  DevAddr Device address on BUS
    389            * @param  Reg     The target register address to read
    390            * @param  pData   Pointer to data buffer
    391            * @param  Length  Length of the data
    392            * @retval BSP status
    393            */

   \                                 In section .text, align 2, keep-with-next
    394          int32_t BSP_I2C4_ReadReg16(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
    395          {
   \                     BSP_I2C4_ReadReg16: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    396            int32_t ret;
    397          
    398            if(I2C4_ReadReg(DevAddr, Reg, I2C_MEMADD_SIZE_16BIT, pData, Length) == 0)
   \        0x2   0xB29B             UXTH     R3,R3
   \        0x4   0x9300             STR      R3,[SP, #+0]
   \        0x6   0x0013             MOVS     R3,R2
   \        0x8   0x2202             MOVS     R2,#+2
   \        0xA   0xB289             UXTH     R1,R1
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x.... 0x....      BL       I2C4_ReadReg
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD101             BNE.N    ??BSP_I2C4_ReadReg16_0
    399            {
    400              ret = BSP_ERROR_NONE;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE00A             B.N      ??BSP_I2C4_ReadReg16_1
    401            }
    402            else
    403            {
    404              if( HAL_I2C_GetError(&hbus_i2c4) == HAL_I2C_ERROR_AF)
   \                     ??BSP_I2C4_ReadReg16_0: (+1)
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x1E   0x.... 0x....      BL       HAL_I2C_GetError
   \       0x22   0x2804             CMP      R0,#+4
   \       0x24   0xD102             BNE.N    ??BSP_I2C4_ReadReg16_2
    405              {
    406                ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
   \       0x26   0xF07F 0x0065      MVNS     R0,#+101
   \       0x2A   0xE001             B.N      ??BSP_I2C4_ReadReg16_1
    407              }
    408              else
    409              {
    410                ret =  BSP_ERROR_PERIPH_FAILURE;
   \                     ??BSP_I2C4_ReadReg16_2: (+1)
   \       0x2C   0xF07F 0x0003      MVNS     R0,#+3
    411              }
    412            }
    413          
    414            return ret;
   \                     ??BSP_I2C4_ReadReg16_1: (+1)
   \       0x30   0xBD02             POP      {R1,PC}
    415          }
    416          
    417          /**
    418            * @brief  Checks if target device is ready for communication.
    419            * @note   This function is used with Memory devices
    420            * @param  DevAddr  Target device address
    421            * @param  Trials      Number of trials
    422            * @retval BSP status
    423            */

   \                                 In section .text, align 2, keep-with-next
    424          int32_t BSP_I2C4_IsReady(uint16_t DevAddr, uint32_t Trials)
    425          {
   \                     BSP_I2C4_IsReady: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x000A             MOVS     R2,R1
    426            int32_t ret = BSP_ERROR_NONE;
   \        0x4   0x2400             MOVS     R4,#+0
    427          
    428            if(HAL_I2C_IsDeviceReady(&hbus_i2c4, DevAddr, Trials, 1000) != HAL_OK)
   \        0x6   0xF44F 0x737A      MOV      R3,#+1000
   \        0xA   0x0001             MOVS     R1,R0
   \        0xC   0xB289             UXTH     R1,R1
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x12   0x.... 0x....      BL       HAL_I2C_IsDeviceReady
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ.N    ??BSP_I2C4_IsReady_0
    429            {
    430              ret = BSP_ERROR_BUSY;
   \       0x1A   0xF07F 0x0402      MVNS     R4,#+2
    431            }
    432          
    433            return ret;
   \                     ??BSP_I2C4_IsReady_0: (+1)
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0xBD10             POP      {R4,PC}
    434          }
    435          
    436          /**
    437            * @brief  Delay function
    438            * @retval Tick value
    439            */

   \                                 In section .text, align 2, keep-with-next
    440          int32_t BSP_GetTick(void)
    441          {
   \                     BSP_GetTick: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    442            return (int32_t)HAL_GetTick();
   \        0x2   0x.... 0x....      BL       HAL_GetTick
   \        0x6   0xBD02             POP      {R1,PC}
    443          }
    444          
    445          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    446          /**
    447            * @brief Register Default I2C4 Bus Msp Callbacks
    448            * @retval BSP status
    449            */
    450          int32_t BSP_I2C4_RegisterDefaultMspCallbacks (void)
    451          {
    452            int32_t ret = BSP_ERROR_NONE;
    453          
    454            __HAL_I2C_RESET_HANDLE_STATE(&hbus_i2c4);
    455          
    456            /* Register default MspInit/MspDeInit Callback */
    457            if(HAL_I2C_RegisterCallback(&hbus_i2c4, HAL_I2C_MSPINIT_CB_ID, I2C4_MspInit) != HAL_OK)
    458            {
    459              ret = BSP_ERROR_PERIPH_FAILURE;
    460            }
    461            else if(HAL_I2C_RegisterCallback(&hbus_i2c4, HAL_I2C_MSPDEINIT_CB_ID, I2C4_MspDeInit) != HAL_OK)
    462            {
    463              ret = BSP_ERROR_PERIPH_FAILURE;
    464            }
    465            else
    466            {
    467              IsI2c4MspCbValid = 1U;
    468            }
    469          
    470            /* BSP status */
    471            return ret;
    472          }
    473          
    474          /**
    475            * @brief Register I2C4 Bus Msp Callback registering
    476            * @param Callbacks     pointer to I2C4 MspInit/MspDeInit callback functions
    477            * @retval BSP status
    478            */
    479          int32_t BSP_I2C4_RegisterMspCallbacks (BSP_I2C_Cb_t *Callback)
    480          {
    481            int32_t ret = BSP_ERROR_NONE;
    482          
    483            __HAL_I2C_RESET_HANDLE_STATE(&hbus_i2c4);
    484          
    485            /* Register MspInit/MspDeInit Callbacks */
    486            if(HAL_I2C_RegisterCallback(&hbus_i2c4, HAL_I2C_MSPINIT_CB_ID, Callback->pMspI2cInitCb) != HAL_OK)
    487            {
    488              ret = BSP_ERROR_PERIPH_FAILURE;
    489            }
    490            else if(HAL_I2C_RegisterCallback(&hbus_i2c4, HAL_I2C_MSPDEINIT_CB_ID, Callback->pMspI2cDeInitCb) != HAL_OK)
    491            {
    492              ret = BSP_ERROR_PERIPH_FAILURE;
    493            }
    494            else
    495            {
    496              IsI2c4MspCbValid = 1U;
    497            }
    498          
    499            /* BSP status */
    500            return ret;
    501          }
    502          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    503          /**
    504            * @}
    505            */
    506          
    507          /** @defgroup STM32H7B3I_DK_BUS_Private_Functions Private Functions
    508            * @{
    509            */
    510          /**
    511            * @brief  Compute I2C timing according current I2C clock source and required I2C clock.
    512            * @param  clock_src_freq I2C clock source in Hz.
    513            * @param  i2c_freq Required I2C clock in Hz.
    514            * @retval I2C timing or 0 in case of error.
    515            */

   \                                 In section .text, align 2, keep-with-next
    516          static uint32_t I2C_GetTiming(uint32_t clock_src_freq, uint32_t i2c_freq)
    517          {
   \                     I2C_GetTiming: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    518            uint32_t ret = 0;
   \        0x4   0x2500             MOVS     R5,#+0
    519            uint32_t speed;
    520            uint32_t idx;
    521          
    522            if((clock_src_freq != 0U) && (i2c_freq != 0U))
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD044             BEQ.N    ??I2C_GetTiming_0
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD042             BEQ.N    ??I2C_GetTiming_0
    523            {
    524              for ( speed = 0 ; speed <=  (uint32_t)I2C_SPEED_FREQ_FAST_PLUS ; speed++)
   \        0xE   0x2600             MOVS     R6,#+0
   \       0x10   0xE000             B.N      ??I2C_GetTiming_1
   \                     ??I2C_GetTiming_2: (+1)
   \       0x12   0x1C76             ADDS     R6,R6,#+1
   \                     ??I2C_GetTiming_1: (+1)
   \       0x14   0x2E03             CMP      R6,#+3
   \       0x16   0xD23D             BCS.N    ??I2C_GetTiming_0
    525              {
    526                if ((i2c_freq >= I2C_Charac[speed].freq_min) &&
    527                    (i2c_freq <= I2C_Charac[speed].freq_max))
   \       0x18   0x202C             MOVS     R0,#+44
   \       0x1A   0x.... 0x....      LDR.W    R2,??DataTable13_4
   \       0x1E   0xFB00 0xF306      MUL      R3,R0,R6
   \       0x22   0x4413             ADD      R3,R2,R3
   \       0x24   0x685B             LDR      R3,[R3, #+4]
   \       0x26   0x4299             CMP      R1,R3
   \       0x28   0xD3F3             BCC.N    ??I2C_GetTiming_2
   \       0x2A   0xFB00 0xF006      MUL      R0,R0,R6
   \       0x2E   0x4410             ADD      R0,R2,R0
   \       0x30   0x6880             LDR      R0,[R0, #+8]
   \       0x32   0x4288             CMP      R0,R1
   \       0x34   0xD3ED             BCC.N    ??I2C_GetTiming_2
    528                {
    529                  I2C_Compute_PRESC_SCLDEL_SDADEL(clock_src_freq, speed);
   \       0x36   0x0031             MOVS     R1,R6
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0x.... 0x....      BL       I2C_Compute_PRESC_SCLDEL_SDADEL
    530                  idx = I2C_Compute_SCLL_SCLH(clock_src_freq, speed);
   \       0x3E   0x0031             MOVS     R1,R6
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x.... 0x....      BL       I2C_Compute_SCLL_SCLH
    531          
    532                  if (idx < I2C_VALID_TIMING_NBR)
   \       0x46   0x2880             CMP      R0,#+128
   \       0x48   0xD224             BCS.N    ??I2C_GetTiming_3
    533                  {
    534                    ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
    535                          ((I2c_valid_timing[idx].tscldel & 0x0FU) << 20) |\
    536                          ((I2c_valid_timing[idx].tsdadel & 0x0FU) << 16) |\
    537                          ((I2c_valid_timing[idx].sclh & 0xFFU) << 8) |\
    538                          ((I2c_valid_timing[idx].scll & 0xFFU) << 0);
   \       0x4A   0x2114             MOVS     R1,#+20
   \       0x4C   0x.... 0x....      LDR.W    R2,??DataTable13_5
   \       0x50   0xFB01 0xF300      MUL      R3,R1,R0
   \       0x54   0x58D3             LDR      R3,[R2, R3]
   \       0x56   0xFB01 0xF400      MUL      R4,R1,R0
   \       0x5A   0x4414             ADD      R4,R2,R4
   \       0x5C   0x6865             LDR      R5,[R4, #+4]
   \       0x5E   0x052D             LSLS     R5,R5,#+20
   \       0x60   0xF415 0x0570      ANDS     R5,R5,#0xF00000
   \       0x64   0xEA55 0x7503      ORRS     R5,R5,R3, LSL #+28
   \       0x68   0xFB01 0xF300      MUL      R3,R1,R0
   \       0x6C   0x4413             ADD      R3,R2,R3
   \       0x6E   0x689B             LDR      R3,[R3, #+8]
   \       0x70   0x041B             LSLS     R3,R3,#+16
   \       0x72   0xF413 0x2370      ANDS     R3,R3,#0xF0000
   \       0x76   0x431D             ORRS     R5,R3,R5
   \       0x78   0xFB01 0xF300      MUL      R3,R1,R0
   \       0x7C   0x4413             ADD      R3,R2,R3
   \       0x7E   0x68DB             LDR      R3,[R3, #+12]
   \       0x80   0x021B             LSLS     R3,R3,#+8
   \       0x82   0xF413 0x437F      ANDS     R3,R3,#0xFF00
   \       0x86   0x431D             ORRS     R5,R3,R5
   \       0x88   0x4348             MULS     R0,R1,R0
   \       0x8A   0x4410             ADD      R0,R2,R0
   \       0x8C   0x7C00             LDRB     R0,[R0, #+16]
   \       0x8E   0xF000 0x00FF      AND      R0,R0,#0xFF
   \       0x92   0x4305             ORRS     R5,R0,R5
    539                  }
    540                  break;
    541                }
    542              }
    543            }
    544          
    545            return ret;
   \                     ??I2C_GetTiming_3: (+1)
   \                     ??I2C_GetTiming_0: (+1)
   \       0x94   0x0028             MOVS     R0,R5
   \       0x96   0xBD70             POP      {R4-R6,PC}
    546          }
    547          
    548          /**
    549            * @brief  Compute PRESC, SCLDEL and SDADEL.
    550            * @param  clock_src_freq I2C source clock in HZ.
    551            * @param  I2C_speed I2C frequency (index).
    552            * @retval None.
    553            */

   \                                 In section .text, align 2, keep-with-next
    554          static void I2C_Compute_PRESC_SCLDEL_SDADEL(uint32_t clock_src_freq, uint32_t I2C_speed)
    555          {
   \                     I2C_Compute_PRESC_SCLDEL_SDADEL: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    556            uint32_t prev_presc = I2C_PRESC_MAX;
   \        0x4   0x2210             MOVS     R2,#+16
    557            uint32_t ti2cclk;
    558            int32_t  tsdadel_min, tsdadel_max;
    559            int32_t  tscldel_min;
    560            uint32_t presc, scldel, sdadel;
    561            uint32_t tafdel_min, tafdel_max;
    562          
    563            ti2cclk   = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
   \        0x6   0x.... 0x....      LDR.W    R3,??DataTable13_6
   \        0xA   0xEB13 0x0350      ADDS     R3,R3,R0, LSR #+1
   \        0xE   0xFBB3 0xF3F0      UDIV     R3,R3,R0
    564          
    565            tafdel_min = I2C_ANALOG_FILTER_DELAY_MIN;
   \       0x12   0x2432             MOVS     R4,#+50
    566            tafdel_max = I2C_ANALOG_FILTER_DELAY_MAX;
   \       0x14   0xF44F 0x7582      MOV      R5,#+260
    567          
    568            /* tDNF = DNF x tI2CCLK
    569               tPRESC = (PRESC+1) x tI2CCLK
    570               SDADEL >= {tf +tHD;DAT(min) - tAF(min) - tDNF - [3 x tI2CCLK]} / {tPRESC}
    571               SDADEL <= {tVD;DAT(max) - tr - tAF(max) - tDNF- [4 x tI2CCLK]} / {tPRESC} */
    572          
    573            tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
    574              (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
   \       0x18   0x272C             MOVS     R7,#+44
   \       0x1A   0x.... 0x....      LDR.W    R12,??DataTable13_4
   \       0x1E   0xFB07 0xF001      MUL      R0,R7,R1
   \       0x22   0x4460             ADD      R0,R12,R0
   \       0x24   0x6A46             LDR      R6,[R0, #+36]
   \       0x26   0xFB07 0xF001      MUL      R0,R7,R1
   \       0x2A   0x4460             ADD      R0,R12,R0
   \       0x2C   0x68C0             LDR      R0,[R0, #+12]
   \       0x2E   0x1986             ADDS     R6,R0,R6
   \       0x30   0x1B34             SUBS     R4,R6,R4
   \       0x32   0xFB07 0xF001      MUL      R0,R7,R1
   \       0x36   0x4460             ADD      R0,R12,R0
   \       0x38   0x6A80             LDR      R0,[R0, #+40]
   \       0x3A   0x1CC0             ADDS     R0,R0,#+3
   \       0x3C   0xFB03 0x4410      MLS      R4,R3,R0,R4
    575          
    576            tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
    577              (int32_t)tafdel_max - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 4) * (int32_t)ti2cclk);
   \       0x40   0xFB07 0xF001      MUL      R0,R7,R1
   \       0x44   0x4460             ADD      R0,R12,R0
   \       0x46   0x6906             LDR      R6,[R0, #+16]
   \       0x48   0xFB07 0xF001      MUL      R0,R7,R1
   \       0x4C   0x4460             ADD      R0,R12,R0
   \       0x4E   0x6A00             LDR      R0,[R0, #+32]
   \       0x50   0x1A36             SUBS     R6,R6,R0
   \       0x52   0x1B75             SUBS     R5,R6,R5
   \       0x54   0xFB07 0xF001      MUL      R0,R7,R1
   \       0x58   0x4460             ADD      R0,R12,R0
   \       0x5A   0x6A80             LDR      R0,[R0, #+40]
   \       0x5C   0x1D00             ADDS     R0,R0,#+4
   \       0x5E   0xFB03 0x5510      MLS      R5,R3,R0,R5
    578          
    579          
    580            /* {[tr+ tSU;DAT(min)] / [tPRESC]} - 1 <= SCLDEL */
    581            tscldel_min = (int32_t)I2C_Charac[I2C_speed].trise + (int32_t)I2C_Charac[I2C_speed].sudat_min;
   \       0x62   0xFB07 0xF001      MUL      R0,R7,R1
   \       0x66   0x4460             ADD      R0,R12,R0
   \       0x68   0x6A06             LDR      R6,[R0, #+32]
   \       0x6A   0x4379             MULS     R1,R7,R1
   \       0x6C   0xEB0C 0x0001      ADD      R0,R12,R1
   \       0x70   0x6940             LDR      R0,[R0, #+20]
   \       0x72   0x1986             ADDS     R6,R0,R6
    582          
    583            if (tsdadel_min <= 0)
   \       0x74   0x2C01             CMP      R4,#+1
   \       0x76   0xDA00             BGE.N    ??I2C_Compute_PRESC_SCLDEL_SDADEL_0
    584            {
    585              tsdadel_min = 0;
   \       0x78   0x2400             MOVS     R4,#+0
    586            }
    587          
    588            if (tsdadel_max <= 0)
   \                     ??I2C_Compute_PRESC_SCLDEL_SDADEL_0: (+1)
   \       0x7A   0x2D01             CMP      R5,#+1
   \       0x7C   0xDA00             BGE.N    ??I2C_Compute_PRESC_SCLDEL_SDADEL_1
    589            {
    590              tsdadel_max = 0;
   \       0x7E   0x2500             MOVS     R5,#+0
    591            }
    592          
    593            for (presc = 0; presc < I2C_PRESC_MAX; presc++)
   \                     ??I2C_Compute_PRESC_SCLDEL_SDADEL_1: (+1)
   \       0x80   0x2100             MOVS     R1,#+0
   \       0x82   0xE000             B.N      ??I2C_Compute_PRESC_SCLDEL_SDADEL_2
   \                     ??I2C_Compute_PRESC_SCLDEL_SDADEL_3: (+1)
   \       0x84   0x1C49             ADDS     R1,R1,#+1
   \                     ??I2C_Compute_PRESC_SCLDEL_SDADEL_2: (+1)
   \       0x86   0x2910             CMP      R1,#+16
   \       0x88   0xD243             BCS.N    ??I2C_Compute_PRESC_SCLDEL_SDADEL_4
    594            {
    595              for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
   \       0x8A   0x2700             MOVS     R7,#+0
   \       0x8C   0xE000             B.N      ??I2C_Compute_PRESC_SCLDEL_SDADEL_5
   \                     ??I2C_Compute_PRESC_SCLDEL_SDADEL_6: (+1)
   \       0x8E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??I2C_Compute_PRESC_SCLDEL_SDADEL_5: (+1)
   \       0x90   0x2F10             CMP      R7,#+16
   \       0x92   0xD2F7             BCS.N    ??I2C_Compute_PRESC_SCLDEL_SDADEL_3
    596              {
    597                /* TSCLDEL = (SCLDEL+1) * (PRESC+1) * TI2CCLK */
    598                uint32_t tscldel = (scldel + 1U) * (presc + 1U) * ti2cclk;
   \       0x94   0xF117 0x0C01      ADDS     R12,R7,#+1
   \       0x98   0x1C48             ADDS     R0,R1,#+1
   \       0x9A   0xFB00 0xFC0C      MUL      R12,R0,R12
   \       0x9E   0xFB03 0xFC0C      MUL      R12,R3,R12
    599          
    600                if (tscldel >= (uint32_t)tscldel_min)
   \       0xA2   0x45B4             CMP      R12,R6
   \       0xA4   0xD3F3             BCC.N    ??I2C_Compute_PRESC_SCLDEL_SDADEL_6
    601                {
    602                  for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0xE000             B.N      ??I2C_Compute_PRESC_SCLDEL_SDADEL_7
   \                     ??I2C_Compute_PRESC_SCLDEL_SDADEL_8: (+1)
   \       0xAA   0x1C40             ADDS     R0,R0,#+1
   \                     ??I2C_Compute_PRESC_SCLDEL_SDADEL_7: (+1)
   \       0xAC   0x2810             CMP      R0,#+16
   \       0xAE   0xD2EE             BCS.N    ??I2C_Compute_PRESC_SCLDEL_SDADEL_6
    603                  {
    604                    /* TSDADEL = SDADEL * (PRESC+1) * TI2CCLK */
    605                    uint32_t tsdadel = (sdadel * (presc + 1U)) * ti2cclk;
   \       0xB0   0xF111 0x0C01      ADDS     R12,R1,#+1
   \       0xB4   0xFB0C 0xFC00      MUL      R12,R12,R0
   \       0xB8   0xFB03 0xFC0C      MUL      R12,R3,R12
    606          
    607                    if ((tsdadel >= (uint32_t)tsdadel_min) && (tsdadel <= (uint32_t)tsdadel_max))
   \       0xBC   0x45A4             CMP      R12,R4
   \       0xBE   0xD3F4             BCC.N    ??I2C_Compute_PRESC_SCLDEL_SDADEL_8
   \       0xC0   0x4565             CMP      R5,R12
   \       0xC2   0xD3F2             BCC.N    ??I2C_Compute_PRESC_SCLDEL_SDADEL_8
    608                    {
    609                      if(presc != prev_presc)
   \       0xC4   0x4291             CMP      R1,R2
   \       0xC6   0xD0F0             BEQ.N    ??I2C_Compute_PRESC_SCLDEL_SDADEL_8
    610                      {
    611                        I2c_valid_timing[I2c_valid_timing_nbr].presc = presc;
   \       0xC8   0x.... 0x....      LDR.W    R12,??DataTable13_7
   \       0xCC   0x....             LDR.N    R2,??DataTable13_5
   \       0xCE   0xF05F 0x0E14      MOVS     LR,#+20
   \       0xD2   0xF8DC 0x8000      LDR      R8,[R12, #+0]
   \       0xD6   0xFB0E 0xF808      MUL      R8,LR,R8
   \       0xDA   0xF842 0x1008      STR      R1,[R2, R8]
    612                        I2c_valid_timing[I2c_valid_timing_nbr].tscldel = scldel;
   \       0xDE   0xF8DC 0x8000      LDR      R8,[R12, #+0]
   \       0xE2   0xFB0E 0xF808      MUL      R8,LR,R8
   \       0xE6   0x4490             ADD      R8,R2,R8
   \       0xE8   0xF8C8 0x7004      STR      R7,[R8, #+4]
    613                        I2c_valid_timing[I2c_valid_timing_nbr].tsdadel = sdadel;
   \       0xEC   0xF8DC 0x8000      LDR      R8,[R12, #+0]
   \       0xF0   0xFB0E 0xFE08      MUL      LR,LR,R8
   \       0xF4   0x4472             ADD      R2,R2,LR
   \       0xF6   0x6090             STR      R0,[R2, #+8]
    614                        prev_presc = presc;
   \       0xF8   0x000A             MOVS     R2,R1
    615                        I2c_valid_timing_nbr ++;
   \       0xFA   0xF8DC 0xE000      LDR      LR,[R12, #+0]
   \       0xFE   0xF11E 0x0E01      ADDS     LR,LR,#+1
   \      0x102   0xF8CC 0xE000      STR      LR,[R12, #+0]
    616          
    617                        if(I2c_valid_timing_nbr >= I2C_VALID_TIMING_NBR)
   \      0x106   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \      0x10A   0xF1BC 0x0F80      CMP      R12,#+128
   \      0x10E   0xD3CC             BCC.N    ??I2C_Compute_PRESC_SCLDEL_SDADEL_8
    618                        {
    619                          return;
   \      0x110   0xE7FF             B.N      ??I2C_Compute_PRESC_SCLDEL_SDADEL_9
    620                        }
    621                      }
    622                    }
    623                  }
    624                }
    625              }
    626            }
    627          }
   \                     ??I2C_Compute_PRESC_SCLDEL_SDADEL_4: (+1)
   \                     ??I2C_Compute_PRESC_SCLDEL_SDADEL_9: (+1)
   \      0x112   0xE8BD 0x81F0      POP      {R4-R8,PC}
    628          
    629          /**
    630            * @brief  Calculate SCLL and SCLH and find best configuration.
    631            * @param  clock_src_freq I2C source clock in HZ.
    632            * @param  I2C_speed I2C frequency (index).
    633            * @retval config index (0 to I2C_VALID_TIMING_NBR], 0xFFFFFFFF for no valid config.
    634            */

   \                                 In section .text, align 2, keep-with-next
    635          static uint32_t I2C_Compute_SCLL_SCLH (uint32_t clock_src_freq, uint32_t I2C_speed)
    636          {
   \                     I2C_Compute_SCLL_SCLH: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
    637           uint32_t ret = 0xFFFFFFFFU;
   \        0x6   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \        0xA   0x9203             STR      R2,[SP, #+12]
    638            uint32_t ti2cclk;
    639            uint32_t ti2cspeed;
    640            uint32_t prev_error;
    641            uint32_t dnf_delay;
    642            uint32_t clk_min, clk_max;
    643            uint32_t scll, sclh;
    644            uint32_t tafdel_min;
    645          
    646            ti2cclk   = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
   \        0xC   0x....             LDR.N    R5,??DataTable13_6
   \        0xE   0xEB15 0x0250      ADDS     R2,R5,R0, LSR #+1
   \       0x12   0xFBB2 0xF2F0      UDIV     R2,R2,R0
    647            ti2cspeed   = (SEC2NSEC + (I2C_Charac[I2C_speed].freq / 2U))/ I2C_Charac[I2C_speed].freq;
   \       0x16   0x232C             MOVS     R3,#+44
   \       0x18   0x....             LDR.N    R4,??DataTable13_4
   \       0x1A   0xFB03 0xF001      MUL      R0,R3,R1
   \       0x1E   0x5820             LDR      R0,[R4, R0]
   \       0x20   0xEB15 0x0550      ADDS     R5,R5,R0, LSR #+1
   \       0x24   0xFB03 0xF001      MUL      R0,R3,R1
   \       0x28   0x5820             LDR      R0,[R4, R0]
   \       0x2A   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \       0x2E   0x9002             STR      R0,[SP, #+8]
    648          
    649            tafdel_min = I2C_ANALOG_FILTER_DELAY_MIN;
   \       0x30   0x2032             MOVS     R0,#+50
   \       0x32   0x9000             STR      R0,[SP, #+0]
    650          
    651            /* tDNF = DNF x tI2CCLK */
    652            dnf_delay = I2C_Charac[I2C_speed].dnf * ti2cclk;
   \       0x34   0xFB03 0xF001      MUL      R0,R3,R1
   \       0x38   0x4420             ADD      R0,R4,R0
   \       0x3A   0x6A80             LDR      R0,[R0, #+40]
   \       0x3C   0x4350             MULS     R0,R2,R0
   \       0x3E   0x9001             STR      R0,[SP, #+4]
    653          
    654            clk_max = SEC2NSEC / I2C_Charac[I2C_speed].freq_min;
   \       0x40   0x....             LDR.N    R0,??DataTable13_6
   \       0x42   0xFB03 0xF501      MUL      R5,R3,R1
   \       0x46   0x4425             ADD      R5,R4,R5
   \       0x48   0x686D             LDR      R5,[R5, #+4]
   \       0x4A   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \       0x4E   0x9004             STR      R0,[SP, #+16]
    655            clk_min = SEC2NSEC / I2C_Charac[I2C_speed].freq_max;
   \       0x50   0x....             LDR.N    R0,??DataTable13_6
   \       0x52   0xFB03 0xF501      MUL      R5,R3,R1
   \       0x56   0x4425             ADD      R5,R4,R5
   \       0x58   0x68AD             LDR      R5,[R5, #+8]
   \       0x5A   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \       0x5E   0x9005             STR      R0,[SP, #+20]
    656          
    657            prev_error = ti2cspeed;
   \       0x60   0x9D02             LDR      R5,[SP, #+8]
    658          
    659            for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
   \       0x62   0x2600             MOVS     R6,#+0
   \       0x64   0xE000             B.N      ??I2C_Compute_SCLL_SCLH_0
   \                     ??I2C_Compute_SCLL_SCLH_1: (+1)
   \       0x66   0x1C76             ADDS     R6,R6,#+1
   \                     ??I2C_Compute_SCLL_SCLH_0: (+1)
   \       0x68   0x....             LDR.N    R0,??DataTable13_7
   \       0x6A   0x6800             LDR      R0,[R0, #+0]
   \       0x6C   0x4286             CMP      R6,R0
   \       0x6E   0xD272             BCS.N    ??I2C_Compute_SCLL_SCLH_2
    660            {
    661              /* tPRESC = (PRESC+1) x tI2CCLK*/
    662              uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;
   \       0x70   0x....             LDR.N    R7,??DataTable13_5
   \       0x72   0x2014             MOVS     R0,#+20
   \       0x74   0xFB00 0xF006      MUL      R0,R0,R6
   \       0x78   0xF857 0xE000      LDR      LR,[R7, R0]
   \       0x7C   0xF11E 0x0E01      ADDS     LR,LR,#+1
   \       0x80   0xFB02 0xFE0E      MUL      LR,R2,LR
    663          
    664              for (scll = 0; scll < I2C_SCLL_MAX; scll++)
   \       0x84   0xF05F 0x0800      MOVS     R8,#+0
   \       0x88   0xE044             B.N      ??I2C_Compute_SCLL_SCLH_3
    665              {
    666                /* tLOW(min) <= tAF(min) + tDNF + 2 x tI2CCLK + [(SCLL+1) x tPRESC ] */
    667                uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
    668          
    669          
    670                /* The I2CCLK period tI2CCLK must respect the following conditions:
    671                tI2CCLK < (tLOW - tfilters) / 4 and tI2CCLK < tHIGH */
    672                if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
    673                {
    674                  for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
    675                  {
    676                    /* tHIGH(min) <= tAF(min) + tDNF + 2 x tI2CCLK + [(SCLH+1) x tPRESC] */
    677                    uint32_t tscl_h = tafdel_min + dnf_delay + (2U * ti2cclk) + ((sclh + 1U) * tpresc);
   \                     ??I2C_Compute_SCLL_SCLH_4: (+1)
   \       0x8A   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \       0x8E   0x9801             LDR      R0,[SP, #+4]
   \       0x90   0xEB10 0x0C0C      ADDS     R12,R0,R12
   \       0x94   0xEB1C 0x0C42      ADDS     R12,R12,R2, LSL #+1
   \       0x98   0xF119 0x0001      ADDS     R0,R9,#+1
   \       0x9C   0xFB0E 0xCC00      MLA      R12,LR,R0,R12
    678          
    679                    /* tSCL = tf + tLOW + tr + tHIGH */
    680                    uint32_t tscl = tscl_l + tscl_h + I2C_Charac[I2C_speed].trise + I2C_Charac[I2C_speed].tfall;
   \       0xA0   0xEB1C 0x0B0A      ADDS     R11,R12,R10
   \       0xA4   0xFB03 0xF001      MUL      R0,R3,R1
   \       0xA8   0x4420             ADD      R0,R4,R0
   \       0xAA   0x6A00             LDR      R0,[R0, #+32]
   \       0xAC   0xEB10 0x0B0B      ADDS     R11,R0,R11
   \       0xB0   0xFB03 0xF001      MUL      R0,R3,R1
   \       0xB4   0x4420             ADD      R0,R4,R0
   \       0xB6   0x6A40             LDR      R0,[R0, #+36]
   \       0xB8   0xEB10 0x0B0B      ADDS     R11,R0,R11
    681          
    682                    if ((tscl >= clk_min) && (tscl <= clk_max) && (tscl_h >= I2C_Charac[I2C_speed].hscl_min) && (ti2cclk < tscl_h))
   \       0xBC   0x9805             LDR      R0,[SP, #+20]
   \       0xBE   0x4583             CMP      R11,R0
   \       0xC0   0xD321             BCC.N    ??I2C_Compute_SCLL_SCLH_5
   \       0xC2   0x9804             LDR      R0,[SP, #+16]
   \       0xC4   0x4558             CMP      R0,R11
   \       0xC6   0xD31E             BCC.N    ??I2C_Compute_SCLL_SCLH_5
   \       0xC8   0xFB03 0xF001      MUL      R0,R3,R1
   \       0xCC   0x4420             ADD      R0,R4,R0
   \       0xCE   0x69C0             LDR      R0,[R0, #+28]
   \       0xD0   0x4584             CMP      R12,R0
   \       0xD2   0xD318             BCC.N    ??I2C_Compute_SCLL_SCLH_5
   \       0xD4   0x4562             CMP      R2,R12
   \       0xD6   0xD216             BCS.N    ??I2C_Compute_SCLL_SCLH_5
    683                    {
    684                      int32_t error = (int32_t)tscl - (int32_t)ti2cspeed;
   \       0xD8   0x9802             LDR      R0,[SP, #+8]
   \       0xDA   0xEBBB 0x0B00      SUBS     R11,R11,R0
    685          
    686                      if (error < 0)
   \       0xDE   0xF1BB 0x0F00      CMP      R11,#+0
   \       0xE2   0xD501             BPL.N    ??I2C_Compute_SCLL_SCLH_6
    687                      {
    688                        error = -error;
   \       0xE4   0xF1DB 0x0B00      RSBS     R11,R11,#+0
    689                      }
    690          
    691                      /* look for the timings with the lowest clock error */
    692                      if ((uint32_t)error < prev_error)
   \                     ??I2C_Compute_SCLL_SCLH_6: (+1)
   \       0xE8   0x45AB             CMP      R11,R5
   \       0xEA   0xD20C             BCS.N    ??I2C_Compute_SCLL_SCLH_5
    693                      {
    694                        prev_error = (uint32_t)error;
   \       0xEC   0x465D             MOV      R5,R11
    695                        I2c_valid_timing[count].scll = scll;
   \       0xEE   0x2014             MOVS     R0,#+20
   \       0xF0   0xFB00 0xFC06      MUL      R12,R0,R6
   \       0xF4   0x44BC             ADD      R12,R7,R12
   \       0xF6   0xF8CC 0x8010      STR      R8,[R12, #+16]
    696                        I2c_valid_timing[count].sclh = sclh;
   \       0xFA   0xFB00 0xF006      MUL      R0,R0,R6
   \       0xFE   0x4438             ADD      R0,R7,R0
   \      0x100   0xF8C0 0x900C      STR      R9,[R0, #+12]
    697                        ret = count;
   \      0x104   0x9603             STR      R6,[SP, #+12]
    698                      }
    699                    }
    700                  }
   \                     ??I2C_Compute_SCLL_SCLH_5: (+1)
   \      0x106   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??I2C_Compute_SCLL_SCLH_7: (+1)
   \      0x10A   0xF5B9 0x7F80      CMP      R9,#+256
   \      0x10E   0xD3BC             BCC.N    ??I2C_Compute_SCLL_SCLH_4
   \                     ??I2C_Compute_SCLL_SCLH_8: (+1)
   \      0x110   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??I2C_Compute_SCLL_SCLH_3: (+1)
   \      0x114   0xF5B8 0x7F80      CMP      R8,#+256
   \      0x118   0xD2A5             BCS.N    ??I2C_Compute_SCLL_SCLH_1
   \      0x11A   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \      0x11E   0x9801             LDR      R0,[SP, #+4]
   \      0x120   0xEB10 0x0C0C      ADDS     R12,R0,R12
   \      0x124   0xEB1C 0x0C42      ADDS     R12,R12,R2, LSL #+1
   \      0x128   0xF118 0x0A01      ADDS     R10,R8,#+1
   \      0x12C   0xFB0E 0xCA0A      MLA      R10,LR,R10,R12
   \      0x130   0xFB03 0xF001      MUL      R0,R3,R1
   \      0x134   0x4420             ADD      R0,R4,R0
   \      0x136   0x6980             LDR      R0,[R0, #+24]
   \      0x138   0x4550             CMP      R0,R10
   \      0x13A   0xD2E9             BCS.N    ??I2C_Compute_SCLL_SCLH_8
   \      0x13C   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \      0x140   0xEBBA 0x0C0C      SUBS     R12,R10,R12
   \      0x144   0x9801             LDR      R0,[SP, #+4]
   \      0x146   0xEBBC 0x0C00      SUBS     R12,R12,R0
   \      0x14A   0xEBB2 0x0F9C      CMP      R2,R12, LSR #+2
   \      0x14E   0xD2DF             BCS.N    ??I2C_Compute_SCLL_SCLH_8
   \      0x150   0xF05F 0x0900      MOVS     R9,#+0
   \      0x154   0xE7D9             B.N      ??I2C_Compute_SCLL_SCLH_7
    701                }
    702              }
    703            }
    704          
    705            return ret;
   \                     ??I2C_Compute_SCLL_SCLH_2: (+1)
   \      0x156   0x9803             LDR      R0,[SP, #+12]
   \      0x158   0xB006             ADD      SP,SP,#+24
   \      0x15A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    706          }
    707          
    708          /**
    709            * @brief  Initializes I2C MSP.
    710            * @param  phi2c  I2C handler
    711            * @retval None
    712            */

   \                                 In section .text, align 2, keep-with-next
    713          static void I2C4_MspInit(I2C_HandleTypeDef *phi2c)
    714          {
   \                     I2C4_MspInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
    715            GPIO_InitTypeDef  gpio_init_structure;
    716          
    717            /* Prevent unused argument(s) compilation warning */
    718            UNUSED(phi2c);
    719          
    720            /*** Configure the GPIOs ***/
    721            /* Enable SCL GPIO clock */
    722            BUS_I2C4_SCL_GPIO_CLK_ENABLE();
   \        0x4   0x....             LDR.N    R0,??DataTable13_8
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0xF051 0x0108      ORRS     R1,R1,#0x8
   \        0xC   0x6001             STR      R1,[R0, #+0]
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0xF011 0x0108      ANDS     R1,R1,#0x8
   \       0x14   0x9105             STR      R1,[SP, #+20]
   \       0x16   0x9905             LDR      R1,[SP, #+20]
    723            /* Enable SDA GPIO clock */
    724            BUS_I2C4_SDA_GPIO_CLK_ENABLE();
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0xF051 0x0108      ORRS     R1,R1,#0x8
   \       0x1E   0x6001             STR      R1,[R0, #+0]
   \       0x20   0x6800             LDR      R0,[R0, #+0]
   \       0x22   0xF010 0x0008      ANDS     R0,R0,#0x8
   \       0x26   0x9005             STR      R0,[SP, #+20]
   \       0x28   0x9805             LDR      R0,[SP, #+20]
    725          
    726            /* Configure I2C Tx as alternate function */
    727            gpio_init_structure.Pin       = BUS_I2C4_SCL_PIN;
   \       0x2A   0xF44F 0x5080      MOV      R0,#+4096
   \       0x2E   0x9000             STR      R0,[SP, #+0]
    728            gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
   \       0x30   0x2012             MOVS     R0,#+18
   \       0x32   0x9001             STR      R0,[SP, #+4]
    729            gpio_init_structure.Pull      = GPIO_NOPULL;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x9002             STR      R0,[SP, #+8]
    730            gpio_init_structure.Speed 	= GPIO_SPEED_FREQ_HIGH;
   \       0x38   0x2002             MOVS     R0,#+2
   \       0x3A   0x9003             STR      R0,[SP, #+12]
    731            gpio_init_structure.Alternate = BUS_I2C4_SCL_AF;
   \       0x3C   0x2004             MOVS     R0,#+4
   \       0x3E   0x9004             STR      R0,[SP, #+16]
    732            HAL_GPIO_Init(BUS_I2C4_SCL_GPIO_PORT, &gpio_init_structure);
   \       0x40   0x....             LDR.N    R4,??DataTable13_9
   \       0x42   0x4669             MOV      R1,SP
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x.... 0x....      BL       HAL_GPIO_Init
    733          
    734            /* Configure I2C Rx as alternate function */
    735            gpio_init_structure.Pin       = BUS_I2C4_SDA_PIN;
   \       0x4A   0xF44F 0x5000      MOV      R0,#+8192
   \       0x4E   0x9000             STR      R0,[SP, #+0]
    736            gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
   \       0x50   0x2012             MOVS     R0,#+18
   \       0x52   0x9001             STR      R0,[SP, #+4]
    737            gpio_init_structure.Pull      = GPIO_NOPULL;
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x9002             STR      R0,[SP, #+8]
    738            gpio_init_structure.Speed 	= GPIO_SPEED_FREQ_HIGH;
   \       0x58   0x2002             MOVS     R0,#+2
   \       0x5A   0x9003             STR      R0,[SP, #+12]
    739            gpio_init_structure.Alternate = BUS_I2C4_SDA_AF;
   \       0x5C   0x2004             MOVS     R0,#+4
   \       0x5E   0x9004             STR      R0,[SP, #+16]
    740            HAL_GPIO_Init(BUS_I2C4_SDA_GPIO_PORT, &gpio_init_structure);
   \       0x60   0x4669             MOV      R1,SP
   \       0x62   0x0020             MOVS     R0,R4
   \       0x64   0x.... 0x....      BL       HAL_GPIO_Init
    741          
    742            /*** Configure the I2C peripheral ***/
    743            /* Enable I2C clock */
    744            BUS_I2C4_CLK_ENABLE();
   \       0x68   0x....             LDR.N    R0,??DataTable13_10
   \       0x6A   0x6801             LDR      R1,[R0, #+0]
   \       0x6C   0xF051 0x0180      ORRS     R1,R1,#0x80
   \       0x70   0x6001             STR      R1,[R0, #+0]
   \       0x72   0x6800             LDR      R0,[R0, #+0]
   \       0x74   0xF010 0x0080      ANDS     R0,R0,#0x80
   \       0x78   0x9005             STR      R0,[SP, #+20]
   \       0x7A   0x9805             LDR      R0,[SP, #+20]
    745          
    746            /* Force the I2C peripheral clock reset */
    747            BUS_I2C4_FORCE_RESET();
   \       0x7C   0x....             LDR.N    R0,??DataTable13_11
   \       0x7E   0x6801             LDR      R1,[R0, #+0]
   \       0x80   0xF051 0x0180      ORRS     R1,R1,#0x80
   \       0x84   0x6001             STR      R1,[R0, #+0]
    748          
    749            /* Release the I2C peripheral clock reset */
    750            BUS_I2C4_RELEASE_RESET();
   \       0x86   0x6801             LDR      R1,[R0, #+0]
   \       0x88   0xF031 0x0180      BICS     R1,R1,#0x80
   \       0x8C   0x6001             STR      R1,[R0, #+0]
    751          }
   \       0x8E   0xB006             ADD      SP,SP,#+24
   \       0x90   0xBD10             POP      {R4,PC}
    752          
    753          /**
    754            * @brief  DeInitializes I2C MSP.
    755            * @param  phi2c  I2C handler
    756            * @retval None
    757            */

   \                                 In section .text, align 2, keep-with-next
    758          static void I2C4_MspDeInit(I2C_HandleTypeDef *phi2c)
    759          {
   \                     I2C4_MspDeInit: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
    760            GPIO_InitTypeDef  gpio_init_structure;
    761          
    762            /* Prevent unused argument(s) compilation warning */
    763            UNUSED(phi2c);
    764          
    765            /* Configure I2C Tx, Rx as alternate function */
    766            gpio_init_structure.Pin = BUS_I2C4_SCL_PIN;
   \        0x4   0xF44F 0x5080      MOV      R0,#+4096
   \        0x8   0x9000             STR      R0,[SP, #+0]
    767            HAL_GPIO_DeInit(BUS_I2C4_SCL_GPIO_PORT, gpio_init_structure.Pin );
   \        0xA   0x....             LDR.N    R4,??DataTable13_9
   \        0xC   0x9900             LDR      R1,[SP, #+0]
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x.... 0x....      BL       HAL_GPIO_DeInit
    768            gpio_init_structure.Pin = BUS_I2C4_SDA_PIN;
   \       0x14   0xF44F 0x5000      MOV      R0,#+8192
   \       0x18   0x9000             STR      R0,[SP, #+0]
    769            HAL_GPIO_DeInit(BUS_I2C4_SDA_GPIO_PORT, gpio_init_structure.Pin);
   \       0x1A   0x9900             LDR      R1,[SP, #+0]
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       HAL_GPIO_DeInit
    770          
    771            /* Disable I2C clock */
    772            BUS_I2C4_CLK_DISABLE();
   \       0x22   0x....             LDR.N    R0,??DataTable13_10
   \       0x24   0x6801             LDR      R1,[R0, #+0]
   \       0x26   0xF031 0x0180      BICS     R1,R1,#0x80
   \       0x2A   0x6001             STR      R1,[R0, #+0]
    773          }
   \       0x2C   0xB006             ADD      SP,SP,#+24
   \       0x2E   0xBD10             POP      {R4,PC}
    774          
    775          /**
    776            * @brief  Write a value in a register of the device through BUS.
    777            * @param  DevAddr    Device address on Bus.
    778            * @param  MemAddSize Size of internal memory address
    779            * @param  Reg        The target register address to write
    780            * @param  pData      The target register value to be written
    781            * @param  Length     data length in bytes
    782            * @retval BSP status
    783            */

   \                                 In section .text, align 2, keep-with-next
    784          static int32_t I2C4_WriteReg(uint16_t DevAddr, uint16_t Reg, uint16_t MemAddSize, uint8_t *pData, uint16_t Length)
    785          {
   \                     I2C4_WriteReg: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
    786            if(HAL_I2C_Mem_Write(&hbus_i2c4, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
   \        0x2   0xF44F 0x747A      MOV      R4,#+1000
   \        0x6   0x9402             STR      R4,[SP, #+8]
   \        0x8   0xF8BD 0x4018      LDRH     R4,[SP, #+24]
   \        0xC   0x9401             STR      R4,[SP, #+4]
   \        0xE   0x9300             STR      R3,[SP, #+0]
   \       0x10   0x0013             MOVS     R3,R2
   \       0x12   0xB29B             UXTH     R3,R3
   \       0x14   0x000A             MOVS     R2,R1
   \       0x16   0xB292             UXTH     R2,R2
   \       0x18   0x0001             MOVS     R1,R0
   \       0x1A   0xB289             UXTH     R1,R1
   \       0x1C   0x....             LDR.N    R0,??DataTable13
   \       0x1E   0x.... 0x....      BL       HAL_I2C_Mem_Write
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD101             BNE.N    ??I2C4_WriteReg_0
    787            {
    788              return BSP_ERROR_NONE;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xE001             B.N      ??I2C4_WriteReg_1
    789            }
    790          
    791            return BSP_ERROR_BUS_FAILURE;
   \                     ??I2C4_WriteReg_0: (+1)
   \       0x2A   0xF07F 0x0007      MVNS     R0,#+7
   \                     ??I2C4_WriteReg_1: (+1)
   \       0x2E   0xB004             ADD      SP,SP,#+16
   \       0x30   0xBD10             POP      {R4,PC}
    792          }
    793          
    794          /**
    795            * @brief  Read a register of the device through BUS
    796            * @param  DevAddr    Device address on BUS
    797            * @param  MemAddSize Size of internal memory address
    798            * @param  Reg        The target register address to read
    799            * @param  pData      The target register value to be read
    800            * @param  Length     data length in bytes
    801            * @retval BSP status
    802            */

   \                                 In section .text, align 2, keep-with-next
    803          static int32_t I2C4_ReadReg(uint16_t DevAddr, uint16_t Reg, uint16_t MemAddSize, uint8_t *pData, uint16_t Length)
    804          {
   \                     I2C4_ReadReg: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
    805            if (HAL_I2C_Mem_Read(&hbus_i2c4, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
   \        0x2   0xF44F 0x747A      MOV      R4,#+1000
   \        0x6   0x9402             STR      R4,[SP, #+8]
   \        0x8   0xF8BD 0x4018      LDRH     R4,[SP, #+24]
   \        0xC   0x9401             STR      R4,[SP, #+4]
   \        0xE   0x9300             STR      R3,[SP, #+0]
   \       0x10   0x0013             MOVS     R3,R2
   \       0x12   0xB29B             UXTH     R3,R3
   \       0x14   0x000A             MOVS     R2,R1
   \       0x16   0xB292             UXTH     R2,R2
   \       0x18   0x0001             MOVS     R1,R0
   \       0x1A   0xB289             UXTH     R1,R1
   \       0x1C   0x....             LDR.N    R0,??DataTable13
   \       0x1E   0x.... 0x....      BL       HAL_I2C_Mem_Read
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD101             BNE.N    ??I2C4_ReadReg_0
    806            {
    807              return BSP_ERROR_NONE;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xE001             B.N      ??I2C4_ReadReg_1
    808            }
    809          
    810            return BSP_ERROR_BUS_FAILURE;
   \                     ??I2C4_ReadReg_0: (+1)
   \       0x2A   0xF07F 0x0007      MVNS     R0,#+7
   \                     ??I2C4_ReadReg_1: (+1)
   \       0x2E   0xB004             ADD      SP,SP,#+16
   \       0x30   0xBD10             POP      {R4,PC}
    811          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x....'....        DC32     hbus_i2c4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0x5800'1C00        DC32     0x58001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x....'....        DC32     I2c4InitCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \        0x0   0x0001'86A0        DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \        0x0   0x....'....        DC32     I2C_Charac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \        0x0   0x....'....        DC32     I2c_valid_timing

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \        0x0   0x3B9A'CA00        DC32     0x3b9aca00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \        0x0   0x....'....        DC32     I2c_valid_timing_nbr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \        0x0   0x5802'4540        DC32     0x58024540

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \        0x0   0x5802'0C00        DC32     0x58020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \        0x0   0x5802'4554        DC32     0x58024554

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \        0x0   0x5802'449C        DC32     0x5802449c
    812          
    813          /**
    814            * @}
    815            */
    816          
    817          /**
    818            * @}
    819            */
    820          
    821          /**
    822            * @}
    823            */
    824          
    825          /**
    826            * @}
    827            */
    828          
    829          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   BSP_GetTick
         8   -> HAL_GetTick
      16   BSP_I2C4_DeInit
        16   -> HAL_I2C_DeInit
        16   -> I2C4_MspDeInit
      16   BSP_I2C4_Init
        16   -> HAL_I2C_GetState
        16   -> HAL_RCC_GetPCLK2Freq
        16   -> I2C4_MspInit
        16   -> I2C_GetTiming
        16   -> MX_I2C4_Init
       8   BSP_I2C4_IsReady
         8   -> HAL_I2C_IsDeviceReady
       8   BSP_I2C4_ReadReg
         8   -> HAL_I2C_GetError
         8   -> I2C4_ReadReg
       8   BSP_I2C4_ReadReg16
         8   -> HAL_I2C_GetError
         8   -> I2C4_ReadReg
       8   BSP_I2C4_WriteReg
         8   -> HAL_I2C_GetError
         8   -> I2C4_WriteReg
       8   BSP_I2C4_WriteReg16
         8   -> HAL_I2C_GetError
         8   -> I2C4_WriteReg
      32   I2C4_MspDeInit
        32   -> HAL_GPIO_DeInit
      32   I2C4_MspInit
        32   -> HAL_GPIO_Init
      24   I2C4_ReadReg
        24   -> HAL_I2C_Mem_Read
      24   I2C4_WriteReg
        24   -> HAL_I2C_Mem_Write
      24   I2C_Compute_PRESC_SCLDEL_SDADEL
      60   I2C_Compute_SCLL_SCLH
      16   I2C_GetTiming
        16   -> I2C_Compute_PRESC_SCLDEL_SDADEL
        16   -> I2C_Compute_SCLL_SCLH
      16   MX_I2C4_Init
        16   -> HAL_I2CEx_ConfigAnalogFilter
        16   -> HAL_I2CEx_ConfigDigitalFilter
        16   -> HAL_I2C_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       8  BSP_GetTick
      48  BSP_I2C4_DeInit
      78  BSP_I2C4_Init
      34  BSP_I2C4_IsReady
      50  BSP_I2C4_ReadReg
      50  BSP_I2C4_ReadReg16
      50  BSP_I2C4_WriteReg
      50  BSP_I2C4_WriteReg16
      48  I2C4_MspDeInit
     146  I2C4_MspInit
      50  I2C4_ReadReg
      50  I2C4_WriteReg
     132  I2C_Charac
     278  I2C_Compute_PRESC_SCLDEL_SDADEL
     350  I2C_Compute_SCLL_SCLH
     152  I2C_GetTiming
       4  I2c4InitCounter
   2'560  I2c_valid_timing
       4  I2c_valid_timing_nbr
      86  MX_I2C4_Init
      76  hbus_i2c4

 
 2'644 bytes in section .bss
   132 bytes in section .rodata
 1'576 bytes in section .text
 
 1'490 bytes of CODE  memory (+ 86 bytes shared)
   132 bytes of CONST memory
 2'644 bytes of DATA  memory

Errors: none
Warnings: none
