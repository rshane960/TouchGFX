###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         08/Feb/2022  20:54:17
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_uart.c
#        [UTF-8]
#    Command line      =
#        -f
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_uart.o.rsp
#        (D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_uart.c
#        -D USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver
#        -lA
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver
#        -o
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Core/Inc\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/App\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_uart.o.d
#    Locale            =  C
#    List file         =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_uart.lst
#    Object file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_uart.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_uart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32h7xx_hal_uart.c
      4            * @author  MCD Application Team
      5            * @brief   UART HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Universal Asynchronous Receiver Transmitter Peripheral (UART).
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *           + Peripheral Control functions
     11            *
     12            *
     13            ******************************************************************************
     14            * @attention
     15            *
     16            * Copyright (c) 2017 STMicroelectronics.
     17            * All rights reserved.
     18            *
     19            * This software is licensed under terms that can be found in the LICENSE file
     20            * in the root directory of this software component.
     21            * If no LICENSE file comes with this software, it is provided AS-IS.
     22            *
     23            ******************************************************************************
     24            @verbatim
     25           ===============================================================================
     26                                  ##### How to use this driver #####
     27           ===============================================================================
     28            [..]
     29              The UART HAL driver can be used as follows:
     30          
     31              (#) Declare a UART_HandleTypeDef handle structure (eg. UART_HandleTypeDef huart).
     32              (#) Initialize the UART low level resources by implementing the HAL_UART_MspInit() API:
     33                  (++) Enable the USARTx interface clock.
     34                  (++) UART pins configuration:
     35                      (+++) Enable the clock for the UART GPIOs.
     36                      (+++) Configure these UART pins as alternate function pull-up.
     37                  (++) NVIC configuration if you need to use interrupt process (HAL_UART_Transmit_IT()
     38                       and HAL_UART_Receive_IT() APIs):
     39                      (+++) Configure the USARTx interrupt priority.
     40                      (+++) Enable the NVIC USART IRQ handle.
     41                  (++) UART interrupts handling:
     42                        -@@-  The specific UART interrupts (Transmission complete interrupt,
     43                          RXNE interrupt, RX/TX FIFOs related interrupts and Error Interrupts)
     44                          are managed using the macros __HAL_UART_ENABLE_IT() and __HAL_UART_DISABLE_IT()
     45                          inside the transmit and receive processes.
     46                  (++) DMA Configuration if you need to use DMA process (HAL_UART_Transmit_DMA()
     47                       and HAL_UART_Receive_DMA() APIs):
     48                      (+++) Declare a DMA handle structure for the Tx/Rx channel.
     49                      (+++) Enable the DMAx interface clock.
     50                      (+++) Configure the declared DMA handle structure with the required Tx/Rx parameters.
     51                      (+++) Configure the DMA Tx/Rx channel.
     52                      (+++) Associate the initialized DMA handle to the UART DMA Tx/Rx handle.
     53                      (+++) Configure the priority and enable the NVIC for the transfer complete
     54                            interrupt on the DMA Tx/Rx channel.
     55          
     56              (#) Program the Baud Rate, Word Length, Stop Bit, Parity, Prescaler value , Hardware
     57                  flow control and Mode (Receiver/Transmitter) in the huart handle Init structure.
     58          
     59              (#) If required, program UART advanced features (TX/RX pins swap, auto Baud rate detection,...)
     60                  in the huart handle AdvancedInit structure.
     61          
     62              (#) For the UART asynchronous mode, initialize the UART registers by calling
     63                  the HAL_UART_Init() API.
     64          
     65              (#) For the UART Half duplex mode, initialize the UART registers by calling
     66                  the HAL_HalfDuplex_Init() API.
     67          
     68              (#) For the UART LIN (Local Interconnection Network) mode, initialize the UART registers
     69                  by calling the HAL_LIN_Init() API.
     70          
     71              (#) For the UART Multiprocessor mode, initialize the UART registers
     72                  by calling the HAL_MultiProcessor_Init() API.
     73          
     74              (#) For the UART RS485 Driver Enabled mode, initialize the UART registers
     75                  by calling the HAL_RS485Ex_Init() API.
     76          
     77              [..]
     78              (@) These API's (HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init(), HAL_MultiProcessor_Init(),
     79                  also configure the low level Hardware GPIO, CLOCK, CORTEX...etc) by
     80                  calling the customized HAL_UART_MspInit() API.
     81          
     82              ##### Callback registration #####
     83              ==================================
     84          
     85              [..]
     86              The compilation define USE_HAL_UART_REGISTER_CALLBACKS when set to 1
     87              allows the user to configure dynamically the driver callbacks.
     88          
     89              [..]
     90              Use Function HAL_UART_RegisterCallback() to register a user callback.
     91              Function HAL_UART_RegisterCallback() allows to register following callbacks:
     92              (+) TxHalfCpltCallback        : Tx Half Complete Callback.
     93              (+) TxCpltCallback            : Tx Complete Callback.
     94              (+) RxHalfCpltCallback        : Rx Half Complete Callback.
     95              (+) RxCpltCallback            : Rx Complete Callback.
     96              (+) ErrorCallback             : Error Callback.
     97              (+) AbortCpltCallback         : Abort Complete Callback.
     98              (+) AbortTransmitCpltCallback : Abort Transmit Complete Callback.
     99              (+) AbortReceiveCpltCallback  : Abort Receive Complete Callback.
    100              (+) WakeupCallback            : Wakeup Callback.
    101              (+) RxFifoFullCallback        : Rx Fifo Full Callback.
    102              (+) TxFifoEmptyCallback       : Tx Fifo Empty Callback.
    103              (+) MspInitCallback           : UART MspInit.
    104              (+) MspDeInitCallback         : UART MspDeInit.
    105              This function takes as parameters the HAL peripheral handle, the Callback ID
    106              and a pointer to the user callback function.
    107          
    108              [..]
    109              Use function HAL_UART_UnRegisterCallback() to reset a callback to the default
    110              weak (surcharged) function.
    111              HAL_UART_UnRegisterCallback() takes as parameters the HAL peripheral handle,
    112              and the Callback ID.
    113              This function allows to reset following callbacks:
    114              (+) TxHalfCpltCallback        : Tx Half Complete Callback.
    115              (+) TxCpltCallback            : Tx Complete Callback.
    116              (+) RxHalfCpltCallback        : Rx Half Complete Callback.
    117              (+) RxCpltCallback            : Rx Complete Callback.
    118              (+) ErrorCallback             : Error Callback.
    119              (+) AbortCpltCallback         : Abort Complete Callback.
    120              (+) AbortTransmitCpltCallback : Abort Transmit Complete Callback.
    121              (+) AbortReceiveCpltCallback  : Abort Receive Complete Callback.
    122              (+) WakeupCallback            : Wakeup Callback.
    123              (+) RxFifoFullCallback        : Rx Fifo Full Callback.
    124              (+) TxFifoEmptyCallback       : Tx Fifo Empty Callback.
    125              (+) MspInitCallback           : UART MspInit.
    126              (+) MspDeInitCallback         : UART MspDeInit.
    127          
    128              [..]
    129              For specific callback RxEventCallback, use dedicated registration/reset functions:
    130              respectively HAL_UART_RegisterRxEventCallback() , HAL_UART_UnRegisterRxEventCallback().
    131          
    132              [..]
    133              By default, after the HAL_UART_Init() and when the state is HAL_UART_STATE_RESET
    134              all callbacks are set to the corresponding weak (surcharged) functions:
    135              examples HAL_UART_TxCpltCallback(), HAL_UART_RxHalfCpltCallback().
    136              Exception done for MspInit and MspDeInit functions that are respectively
    137              reset to the legacy weak (surcharged) functions in the HAL_UART_Init()
    138              and HAL_UART_DeInit() only when these callbacks are null (not registered beforehand).
    139              If not, MspInit or MspDeInit are not null, the HAL_UART_Init() and HAL_UART_DeInit()
    140              keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
    141          
    142              [..]
    143              Callbacks can be registered/unregistered in HAL_UART_STATE_READY state only.
    144              Exception done MspInit/MspDeInit that can be registered/unregistered
    145              in HAL_UART_STATE_READY or HAL_UART_STATE_RESET state, thus registered (user)
    146              MspInit/DeInit callbacks can be used during the Init/DeInit.
    147              In that case first register the MspInit/MspDeInit user callbacks
    148              using HAL_UART_RegisterCallback() before calling HAL_UART_DeInit()
    149              or HAL_UART_Init() function.
    150          
    151              [..]
    152              When The compilation define USE_HAL_UART_REGISTER_CALLBACKS is set to 0 or
    153              not defined, the callback registration feature is not available
    154              and weak (surcharged) callbacks are used.
    155          
    156          
    157            @endverbatim
    158            ******************************************************************************
    159            */
    160          
    161          /* Includes ------------------------------------------------------------------*/
    162          #include "stm32h7xx_hal.h"
    163          
    164          /** @addtogroup STM32H7xx_HAL_Driver
    165            * @{
    166            */
    167          
    168          /** @defgroup UART UART
    169            * @brief HAL UART module driver
    170            * @{
    171            */
    172          
    173          #ifdef HAL_UART_MODULE_ENABLED
    174          
    175          /* Private typedef -----------------------------------------------------------*/
    176          /* Private define ------------------------------------------------------------*/
    177          /** @defgroup UART_Private_Constants UART Private Constants
    178            * @{
    179            */
    180          #define USART_CR1_FIELDS  ((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | \
    181                                                USART_CR1_OVER8 | USART_CR1_FIFOEN)) /*!< UART or USART CR1 fields of parameters set by UART_SetConfig API */
    182          
    183          #define USART_CR3_FIELDS  ((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT | USART_CR3_TXFTCFG | \
    184                                                USART_CR3_RXFTCFG)) /*!< UART or USART CR3 fields of parameters set by UART_SetConfig API */
    185          
    186          #define LPUART_BRR_MIN  0x00000300U  /* LPUART BRR minimum authorized value */
    187          #define LPUART_BRR_MAX  0x000FFFFFU  /* LPUART BRR maximum authorized value */
    188          
    189          #define UART_BRR_MIN    0x10U        /* UART BRR minimum authorized value */
    190          #define UART_BRR_MAX    0x0000FFFFU  /* UART BRR maximum authorized value */
    191          /**
    192            * @}
    193            */
    194          
    195          /* Private macros ------------------------------------------------------------*/
    196          /* Private function prototypes -----------------------------------------------*/
    197          /** @addtogroup UART_Private_Functions
    198            * @{
    199            */
    200          static void UART_EndTxTransfer(UART_HandleTypeDef *huart);
    201          static void UART_EndRxTransfer(UART_HandleTypeDef *huart);
    202          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    203          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    204          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    205          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    206          static void UART_DMAError(DMA_HandleTypeDef *hdma);
    207          static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma);
    208          static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma);
    209          static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma);
    210          static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma);
    211          static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma);
    212          static void UART_TxISR_8BIT(UART_HandleTypeDef *huart);
    213          static void UART_TxISR_16BIT(UART_HandleTypeDef *huart);
    214          static void UART_TxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart);
    215          static void UART_TxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart);
    216          static void UART_EndTransmit_IT(UART_HandleTypeDef *huart);
    217          static void UART_RxISR_8BIT(UART_HandleTypeDef *huart);
    218          static void UART_RxISR_16BIT(UART_HandleTypeDef *huart);
    219          static void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart);
    220          static void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart);
    221          /**
    222            * @}
    223            */
    224          
    225          /* Private variables ---------------------------------------------------------*/
    226          /** @addtogroup UART_Private_variables
    227            * @{
    228            */

   \                                 In section .rodata, align 4
    229          const uint16_t UARTPrescTable[12] = {1U, 2U, 4U, 6U, 8U, 10U, 12U, 16U, 32U, 64U, 128U, 256U};
   \                     UARTPrescTable:
   \        0x0   0x0001 0x0002      DC16 1, 2, 4, 6, 8, 10, 12, 16, 32, 64, 128, 256

   \               0x0004 0x000

   \              6 0x0008 0x00

   \              0A 0x000C 0x0

   \              010 0x0020 0x

   \              0040 0x0080 0

   \              x0100
    230          /**
    231            * @}
    232            */
    233          
    234          /* Exported Constants --------------------------------------------------------*/
    235          /* Exported functions --------------------------------------------------------*/
    236          
    237          /** @defgroup UART_Exported_Functions UART Exported Functions
    238            * @{
    239            */
    240          
    241          /** @defgroup UART_Exported_Functions_Group1 Initialization and de-initialization functions
    242            *  @brief    Initialization and Configuration functions
    243            *
    244          @verbatim
    245          ===============================================================================
    246                      ##### Initialization and Configuration functions #####
    247           ===============================================================================
    248              [..]
    249              This subsection provides a set of functions allowing to initialize the USARTx or the UARTy
    250              in asynchronous mode.
    251                (+) For the asynchronous mode the parameters below can be configured:
    252                  (++) Baud Rate
    253                  (++) Word Length
    254                  (++) Stop Bit
    255                  (++) Parity: If the parity is enabled, then the MSB bit of the data written
    256                       in the data register is transmitted but is changed by the parity bit.
    257                  (++) Hardware flow control
    258                  (++) Receiver/transmitter modes
    259                  (++) Over Sampling Method
    260                  (++) One-Bit Sampling Method
    261                (+) For the asynchronous mode, the following advanced features can be configured as well:
    262                  (++) TX and/or RX pin level inversion
    263                  (++) data logical level inversion
    264                  (++) RX and TX pins swap
    265                  (++) RX overrun detection disabling
    266                  (++) DMA disabling on RX error
    267                  (++) MSB first on communication line
    268                  (++) auto Baud rate detection
    269              [..]
    270              The HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init()and HAL_MultiProcessor_Init()API
    271              follow respectively the UART asynchronous, UART Half duplex, UART LIN mode
    272              and UART multiprocessor mode configuration procedures (details for the procedures
    273              are available in reference manual).
    274          
    275          @endverbatim
    276          
    277            Depending on the frame length defined by the M1 and M0 bits (7-bit,
    278            8-bit or 9-bit), the possible UART formats are listed in the
    279            following table.
    280          
    281            Table 1. UART frame format.
    282              +-----------------------------------------------------------------------+
    283              |  M1 bit |  M0 bit |  PCE bit  |             UART frame                |
    284              |---------|---------|-----------|---------------------------------------|
    285              |    0    |    0    |    0      |    | SB |    8 bit data   | STB |     |
    286              |---------|---------|-----------|---------------------------------------|
    287              |    0    |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    288              |---------|---------|-----------|---------------------------------------|
    289              |    0    |    1    |    0      |    | SB |    9 bit data   | STB |     |
    290              |---------|---------|-----------|---------------------------------------|
    291              |    0    |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    292              |---------|---------|-----------|---------------------------------------|
    293              |    1    |    0    |    0      |    | SB |    7 bit data   | STB |     |
    294              |---------|---------|-----------|---------------------------------------|
    295              |    1    |    0    |    1      |    | SB | 6 bit data | PB | STB |     |
    296              +-----------------------------------------------------------------------+
    297          
    298            * @{
    299            */
    300          
    301          /**
    302            * @brief Initialize the UART mode according to the specified
    303            *        parameters in the UART_InitTypeDef and initialize the associated handle.
    304            * @param huart UART handle.
    305            * @retval HAL status
    306            */

   \                                 In section .text, align 2, keep-with-next
    307          HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
    308          {
   \                     HAL_UART_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    309            /* Check the UART handle allocation */
    310            if (huart == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_UART_Init_0
    311            {
    312              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE037             B.N      ??HAL_UART_Init_1
    313            }
    314          
    315            if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
   \                     ??HAL_UART_Init_0: (+1)
   \        0xC   0x69A0             LDR      R0,[R4, #+24]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD1FF             BNE.N    ??HAL_UART_Init_2
    316            {
    317              /* Check the parameters */
    318              assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
    319            }
    320            else
    321            {
    322              /* Check the parameters */
    323              assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
    324            }
    325          
    326            if (huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_UART_Init_3: (+1)
   \                     ??HAL_UART_Init_2: (+1)
   \       0x12   0xF8D4 0x0084      LDR      R0,[R4, #+132]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD105             BNE.N    ??HAL_UART_Init_4
    327            {
    328              /* Allocate lock resource and initialize it */
    329              huart->Lock = HAL_UNLOCKED;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xF884 0x0080      STRB     R0,[R4, #+128]
    330          
    331          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    332              UART_InitCallbacksToDefault(huart);
    333          
    334              if (huart->MspInitCallback == NULL)
    335              {
    336                huart->MspInitCallback = HAL_UART_MspInit;
    337              }
    338          
    339              /* Init the low level hardware */
    340              huart->MspInitCallback(huart);
    341          #else
    342              /* Init the low level hardware : GPIO, CLOCK */
    343              HAL_UART_MspInit(huart);
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       HAL_UART_MspInit
    344          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
    345            }
    346          
    347            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_Init_4: (+1)
   \       0x26   0x2024             MOVS     R0,#+36
   \       0x28   0xF8C4 0x0084      STR      R0,[R4, #+132]
    348          
    349            __HAL_UART_DISABLE(huart);
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6800             LDR      R0,[R0, #+0]
   \       0x30   0x0840             LSRS     R0,R0,#+1
   \       0x32   0x0040             LSLS     R0,R0,#+1
   \       0x34   0x6821             LDR      R1,[R4, #+0]
   \       0x36   0x6008             STR      R0,[R1, #+0]
    350          
    351            /* Set the UART Communication parameters */
    352            if (UART_SetConfig(huart) == HAL_ERROR)
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0x.... 0x....      BL       UART_SetConfig
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD101             BNE.N    ??HAL_UART_Init_5
    353            {
    354              return HAL_ERROR;
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0xE01A             B.N      ??HAL_UART_Init_1
    355            }
    356          
    357            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
   \                     ??HAL_UART_Init_5: (+1)
   \       0x46   0x6AA0             LDR      R0,[R4, #+40]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD002             BEQ.N    ??HAL_UART_Init_6
    358            {
    359              UART_AdvFeatureConfig(huart);
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x.... 0x....      BL       UART_AdvFeatureConfig
    360            }
    361          
    362            /* In asynchronous mode, the following bits must be kept cleared:
    363            - LINEN and CLKEN bits in the USART_CR2 register,
    364            - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
    365            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \                     ??HAL_UART_Init_6: (+1)
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x6840             LDR      R0,[R0, #+4]
   \       0x56   0xF430 0x4090      BICS     R0,R0,#0x4800
   \       0x5A   0x6821             LDR      R1,[R4, #+0]
   \       0x5C   0x6048             STR      R0,[R1, #+4]
    366            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6880             LDR      R0,[R0, #+8]
   \       0x62   0xF030 0x002A      BICS     R0,R0,#0x2A
   \       0x66   0x6821             LDR      R1,[R4, #+0]
   \       0x68   0x6088             STR      R0,[R1, #+8]
    367          
    368            __HAL_UART_ENABLE(huart);
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6800             LDR      R0,[R0, #+0]
   \       0x6E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x72   0x6821             LDR      R1,[R4, #+0]
   \       0x74   0x6008             STR      R0,[R1, #+0]
    369          
    370            /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
    371            return (UART_CheckIdleState(huart));
   \       0x76   0x0020             MOVS     R0,R4
   \       0x78   0x.... 0x....      BL       UART_CheckIdleState
   \                     ??HAL_UART_Init_1: (+1)
   \       0x7C   0xBD10             POP      {R4,PC}
    372          }
    373          
    374          /**
    375            * @brief Initialize the half-duplex mode according to the specified
    376            *        parameters in the UART_InitTypeDef and creates the associated handle.
    377            * @param huart UART handle.
    378            * @retval HAL status
    379            */

   \                                 In section .text, align 2, keep-with-next
    380          HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
    381          {
   \                     HAL_HalfDuplex_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    382            /* Check the UART handle allocation */
    383            if (huart == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_HalfDuplex_Init_0
    384            {
    385              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE03A             B.N      ??HAL_HalfDuplex_Init_1
    386            }
    387          
    388            /* Check UART instance */
    389            assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
    390          
    391            if (huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_HalfDuplex_Init_0: (+1)
   \        0xC   0xF8D4 0x0084      LDR      R0,[R4, #+132]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD105             BNE.N    ??HAL_HalfDuplex_Init_2
    392            {
    393              /* Allocate lock resource and initialize it */
    394              huart->Lock = HAL_UNLOCKED;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xF884 0x0080      STRB     R0,[R4, #+128]
    395          
    396          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    397              UART_InitCallbacksToDefault(huart);
    398          
    399              if (huart->MspInitCallback == NULL)
    400              {
    401                huart->MspInitCallback = HAL_UART_MspInit;
    402              }
    403          
    404              /* Init the low level hardware */
    405              huart->MspInitCallback(huart);
    406          #else
    407              /* Init the low level hardware : GPIO, CLOCK */
    408              HAL_UART_MspInit(huart);
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       HAL_UART_MspInit
    409          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
    410            }
    411          
    412            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_HalfDuplex_Init_2: (+1)
   \       0x20   0x2024             MOVS     R0,#+36
   \       0x22   0xF8C4 0x0084      STR      R0,[R4, #+132]
    413          
    414            __HAL_UART_DISABLE(huart);
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0x0840             LSRS     R0,R0,#+1
   \       0x2C   0x0040             LSLS     R0,R0,#+1
   \       0x2E   0x6821             LDR      R1,[R4, #+0]
   \       0x30   0x6008             STR      R0,[R1, #+0]
    415          
    416            /* Set the UART Communication parameters */
    417            if (UART_SetConfig(huart) == HAL_ERROR)
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       UART_SetConfig
   \       0x38   0x2801             CMP      R0,#+1
   \       0x3A   0xD101             BNE.N    ??HAL_HalfDuplex_Init_3
    418            {
    419              return HAL_ERROR;
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xE020             B.N      ??HAL_HalfDuplex_Init_1
    420            }
    421          
    422            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
   \                     ??HAL_HalfDuplex_Init_3: (+1)
   \       0x40   0x6AA0             LDR      R0,[R4, #+40]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD002             BEQ.N    ??HAL_HalfDuplex_Init_4
    423            {
    424              UART_AdvFeatureConfig(huart);
   \       0x46   0x0020             MOVS     R0,R4
   \       0x48   0x.... 0x....      BL       UART_AdvFeatureConfig
    425            }
    426          
    427            /* In half-duplex mode, the following bits must be kept cleared:
    428            - LINEN and CLKEN bits in the USART_CR2 register,
    429            - SCEN and IREN bits in the USART_CR3 register.*/
    430            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \                     ??HAL_HalfDuplex_Init_4: (+1)
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x6840             LDR      R0,[R0, #+4]
   \       0x50   0xF430 0x4090      BICS     R0,R0,#0x4800
   \       0x54   0x6821             LDR      R1,[R4, #+0]
   \       0x56   0x6048             STR      R0,[R1, #+4]
    431            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x6880             LDR      R0,[R0, #+8]
   \       0x5C   0xF030 0x0022      BICS     R0,R0,#0x22
   \       0x60   0x6821             LDR      R1,[R4, #+0]
   \       0x62   0x6088             STR      R0,[R1, #+8]
    432          
    433            /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    434            SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x6880             LDR      R0,[R0, #+8]
   \       0x68   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0x6C   0x6821             LDR      R1,[R4, #+0]
   \       0x6E   0x6088             STR      R0,[R1, #+8]
    435          
    436            __HAL_UART_ENABLE(huart);
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x6800             LDR      R0,[R0, #+0]
   \       0x74   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x78   0x6821             LDR      R1,[R4, #+0]
   \       0x7A   0x6008             STR      R0,[R1, #+0]
    437          
    438            /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
    439            return (UART_CheckIdleState(huart));
   \       0x7C   0x0020             MOVS     R0,R4
   \       0x7E   0x.... 0x....      BL       UART_CheckIdleState
   \                     ??HAL_HalfDuplex_Init_1: (+1)
   \       0x82   0xBD10             POP      {R4,PC}
    440          }
    441          
    442          
    443          /**
    444            * @brief Initialize the LIN mode according to the specified
    445            *        parameters in the UART_InitTypeDef and creates the associated handle.
    446            * @param huart             UART handle.
    447            * @param BreakDetectLength Specifies the LIN break detection length.
    448            *        This parameter can be one of the following values:
    449            *          @arg @ref UART_LINBREAKDETECTLENGTH_10B 10-bit break detection
    450            *          @arg @ref UART_LINBREAKDETECTLENGTH_11B 11-bit break detection
    451            * @retval HAL status
    452            */

   \                                 In section .text, align 2, keep-with-next
    453          HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
    454          {
   \                     HAL_LIN_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    455            /* Check the UART handle allocation */
    456            if (huart == NULL)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??HAL_LIN_Init_0
    457            {
    458              return HAL_ERROR;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE04C             B.N      ??HAL_LIN_Init_1
    459            }
    460          
    461            /* Check the LIN UART instance */
    462            assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
    463            /* Check the Break detection length parameter */
    464            assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
    465          
    466            /* LIN mode limited to 16-bit oversampling only */
    467            if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
   \                     ??HAL_LIN_Init_0: (+1)
   \        0xE   0x69E0             LDR      R0,[R4, #+28]
   \       0x10   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x14   0xD101             BNE.N    ??HAL_LIN_Init_2
    468            {
    469              return HAL_ERROR;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xE046             B.N      ??HAL_LIN_Init_1
    470            }
    471            /* LIN mode limited to 8-bit data length */
    472            if (huart->Init.WordLength != UART_WORDLENGTH_8B)
   \                     ??HAL_LIN_Init_2: (+1)
   \       0x1A   0x68A0             LDR      R0,[R4, #+8]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD001             BEQ.N    ??HAL_LIN_Init_3
    473            {
    474              return HAL_ERROR;
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xE041             B.N      ??HAL_LIN_Init_1
    475            }
    476          
    477            if (huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_LIN_Init_3: (+1)
   \       0x24   0xF8D4 0x0084      LDR      R0,[R4, #+132]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD105             BNE.N    ??HAL_LIN_Init_4
    478            {
    479              /* Allocate lock resource and initialize it */
    480              huart->Lock = HAL_UNLOCKED;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xF884 0x0080      STRB     R0,[R4, #+128]
    481          
    482          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    483              UART_InitCallbacksToDefault(huart);
    484          
    485              if (huart->MspInitCallback == NULL)
    486              {
    487                huart->MspInitCallback = HAL_UART_MspInit;
    488              }
    489          
    490              /* Init the low level hardware */
    491              huart->MspInitCallback(huart);
    492          #else
    493              /* Init the low level hardware : GPIO, CLOCK */
    494              HAL_UART_MspInit(huart);
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       HAL_UART_MspInit
    495          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
    496            }
    497          
    498            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_LIN_Init_4: (+1)
   \       0x38   0x2024             MOVS     R0,#+36
   \       0x3A   0xF8C4 0x0084      STR      R0,[R4, #+132]
    499          
    500            __HAL_UART_DISABLE(huart);
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6800             LDR      R0,[R0, #+0]
   \       0x42   0x0840             LSRS     R0,R0,#+1
   \       0x44   0x0040             LSLS     R0,R0,#+1
   \       0x46   0x6821             LDR      R1,[R4, #+0]
   \       0x48   0x6008             STR      R0,[R1, #+0]
    501          
    502            /* Set the UART Communication parameters */
    503            if (UART_SetConfig(huart) == HAL_ERROR)
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x.... 0x....      BL       UART_SetConfig
   \       0x50   0x2801             CMP      R0,#+1
   \       0x52   0xD101             BNE.N    ??HAL_LIN_Init_5
    504            {
    505              return HAL_ERROR;
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0xE027             B.N      ??HAL_LIN_Init_1
    506            }
    507          
    508            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
   \                     ??HAL_LIN_Init_5: (+1)
   \       0x58   0x6AA0             LDR      R0,[R4, #+40]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD002             BEQ.N    ??HAL_LIN_Init_6
    509            {
    510              UART_AdvFeatureConfig(huart);
   \       0x5E   0x0020             MOVS     R0,R4
   \       0x60   0x.... 0x....      BL       UART_AdvFeatureConfig
    511            }
    512          
    513            /* In LIN mode, the following bits must be kept cleared:
    514            - LINEN and CLKEN bits in the USART_CR2 register,
    515            - SCEN and IREN bits in the USART_CR3 register.*/
    516            CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
   \                     ??HAL_LIN_Init_6: (+1)
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x6840             LDR      R0,[R0, #+4]
   \       0x68   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x6C   0x6821             LDR      R1,[R4, #+0]
   \       0x6E   0x6048             STR      R0,[R1, #+4]
    517            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x6880             LDR      R0,[R0, #+8]
   \       0x74   0xF030 0x002A      BICS     R0,R0,#0x2A
   \       0x78   0x6821             LDR      R1,[R4, #+0]
   \       0x7A   0x6088             STR      R0,[R1, #+8]
    518          
    519            /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    520            SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x6840             LDR      R0,[R0, #+4]
   \       0x80   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \       0x84   0x6821             LDR      R1,[R4, #+0]
   \       0x86   0x6048             STR      R0,[R1, #+4]
    521          
    522            /* Set the USART LIN Break detection length. */
    523            MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6840             LDR      R0,[R0, #+4]
   \       0x8C   0xF030 0x0020      BICS     R0,R0,#0x20
   \       0x90   0x4305             ORRS     R5,R5,R0
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x6045             STR      R5,[R0, #+4]
    524          
    525            __HAL_UART_ENABLE(huart);
   \       0x96   0x6820             LDR      R0,[R4, #+0]
   \       0x98   0x6800             LDR      R0,[R0, #+0]
   \       0x9A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x9E   0x6821             LDR      R1,[R4, #+0]
   \       0xA0   0x6008             STR      R0,[R1, #+0]
    526          
    527            /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
    528            return (UART_CheckIdleState(huart));
   \       0xA2   0x0020             MOVS     R0,R4
   \       0xA4   0x.... 0x....      BL       UART_CheckIdleState
   \                     ??HAL_LIN_Init_1: (+1)
   \       0xA8   0xBD32             POP      {R1,R4,R5,PC}
    529          }
    530          
    531          
    532          /**
    533            * @brief Initialize the multiprocessor mode according to the specified
    534            *        parameters in the UART_InitTypeDef and initialize the associated handle.
    535            * @param huart        UART handle.
    536            * @param Address      UART node address (4-, 6-, 7- or 8-bit long).
    537            * @param WakeUpMethod Specifies the UART wakeup method.
    538            *        This parameter can be one of the following values:
    539            *          @arg @ref UART_WAKEUPMETHOD_IDLELINE WakeUp by an idle line detection
    540            *          @arg @ref UART_WAKEUPMETHOD_ADDRESSMARK WakeUp by an address mark
    541            * @note  If the user resorts to idle line detection wake up, the Address parameter
    542            *        is useless and ignored by the initialization function.
    543            * @note  If the user resorts to address mark wake up, the address length detection
    544            *        is configured by default to 4 bits only. For the UART to be able to
    545            *        manage 6-, 7- or 8-bit long addresses detection, the API
    546            *        HAL_MultiProcessorEx_AddressLength_Set() must be called after
    547            *        HAL_MultiProcessor_Init().
    548            * @retval HAL status
    549            */

   \                                 In section .text, align 2, keep-with-next
    550          HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
    551          {
   \                     HAL_MultiProcessor_Init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    552            /* Check the UART handle allocation */
    553            if (huart == NULL)
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD101             BNE.N    ??HAL_MultiProcessor_Init_0
    554            {
    555              return HAL_ERROR;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE044             B.N      ??HAL_MultiProcessor_Init_1
    556            }
    557          
    558            /* Check the wake up method parameter */
    559            assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
    560          
    561            if (huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_MultiProcessor_Init_0: (+1)
   \       0x10   0xF8D4 0x0084      LDR      R0,[R4, #+132]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD105             BNE.N    ??HAL_MultiProcessor_Init_2
    562            {
    563              /* Allocate lock resource and initialize it */
    564              huart->Lock = HAL_UNLOCKED;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF884 0x0080      STRB     R0,[R4, #+128]
    565          
    566          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    567              UART_InitCallbacksToDefault(huart);
    568          
    569              if (huart->MspInitCallback == NULL)
    570              {
    571                huart->MspInitCallback = HAL_UART_MspInit;
    572              }
    573          
    574              /* Init the low level hardware */
    575              huart->MspInitCallback(huart);
    576          #else
    577              /* Init the low level hardware : GPIO, CLOCK */
    578              HAL_UART_MspInit(huart);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       HAL_UART_MspInit
    579          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
    580            }
    581          
    582            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_MultiProcessor_Init_2: (+1)
   \       0x24   0x2024             MOVS     R0,#+36
   \       0x26   0xF8C4 0x0084      STR      R0,[R4, #+132]
    583          
    584            __HAL_UART_DISABLE(huart);
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x6800             LDR      R0,[R0, #+0]
   \       0x2E   0x0840             LSRS     R0,R0,#+1
   \       0x30   0x0040             LSLS     R0,R0,#+1
   \       0x32   0x6821             LDR      R1,[R4, #+0]
   \       0x34   0x6008             STR      R0,[R1, #+0]
    585          
    586            /* Set the UART Communication parameters */
    587            if (UART_SetConfig(huart) == HAL_ERROR)
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x.... 0x....      BL       UART_SetConfig
   \       0x3C   0x2801             CMP      R0,#+1
   \       0x3E   0xD101             BNE.N    ??HAL_MultiProcessor_Init_3
    588            {
    589              return HAL_ERROR;
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0xE02A             B.N      ??HAL_MultiProcessor_Init_1
    590            }
    591          
    592            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
   \                     ??HAL_MultiProcessor_Init_3: (+1)
   \       0x44   0x6AA0             LDR      R0,[R4, #+40]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD002             BEQ.N    ??HAL_MultiProcessor_Init_4
    593            {
    594              UART_AdvFeatureConfig(huart);
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x.... 0x....      BL       UART_AdvFeatureConfig
    595            }
    596          
    597            /* In multiprocessor mode, the following bits must be kept cleared:
    598            - LINEN and CLKEN bits in the USART_CR2 register,
    599            - SCEN, HDSEL and IREN  bits in the USART_CR3 register. */
    600            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \                     ??HAL_MultiProcessor_Init_4: (+1)
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x6840             LDR      R0,[R0, #+4]
   \       0x54   0xF430 0x4090      BICS     R0,R0,#0x4800
   \       0x58   0x6821             LDR      R1,[R4, #+0]
   \       0x5A   0x6048             STR      R0,[R1, #+4]
    601            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x6880             LDR      R0,[R0, #+8]
   \       0x60   0xF030 0x002A      BICS     R0,R0,#0x2A
   \       0x64   0x6821             LDR      R1,[R4, #+0]
   \       0x66   0x6088             STR      R0,[R1, #+8]
    602          
    603            if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
   \       0x68   0xF5B6 0x6F00      CMP      R6,#+2048
   \       0x6C   0xD105             BNE.N    ??HAL_MultiProcessor_Init_5
    604            {
    605              /* If address mark wake up method is chosen, set the USART address node */
    606              MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS));
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x6840             LDR      R0,[R0, #+4]
   \       0x72   0xF365 0x601F      BFI      R0,R5,#+24,#+8
   \       0x76   0x6821             LDR      R1,[R4, #+0]
   \       0x78   0x6048             STR      R0,[R1, #+4]
    607            }
    608          
    609            /* Set the wake up method by setting the WAKE bit in the CR1 register */
    610            MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
   \                     ??HAL_MultiProcessor_Init_5: (+1)
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x6800             LDR      R0,[R0, #+0]
   \       0x7E   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x82   0x4306             ORRS     R6,R6,R0
   \       0x84   0x6820             LDR      R0,[R4, #+0]
   \       0x86   0x6006             STR      R6,[R0, #+0]
    611          
    612            __HAL_UART_ENABLE(huart);
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6800             LDR      R0,[R0, #+0]
   \       0x8C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x90   0x6821             LDR      R1,[R4, #+0]
   \       0x92   0x6008             STR      R0,[R1, #+0]
    613          
    614            /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
    615            return (UART_CheckIdleState(huart));
   \       0x94   0x0020             MOVS     R0,R4
   \       0x96   0x.... 0x....      BL       UART_CheckIdleState
   \                     ??HAL_MultiProcessor_Init_1: (+1)
   \       0x9A   0xBD70             POP      {R4-R6,PC}
    616          }
    617          
    618          
    619          /**
    620            * @brief DeInitialize the UART peripheral.
    621            * @param huart UART handle.
    622            * @retval HAL status
    623            */

   \                                 In section .text, align 2, keep-with-next
    624          HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
    625          {
   \                     HAL_UART_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    626            /* Check the UART handle allocation */
    627            if (huart == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_UART_DeInit_0
    628            {
    629              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE023             B.N      ??HAL_UART_DeInit_1
    630            }
    631          
    632            /* Check the parameters */
    633            assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
    634          
    635            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_DeInit_0: (+1)
   \        0xC   0x2024             MOVS     R0,#+36
   \        0xE   0xF8C4 0x0084      STR      R0,[R4, #+132]
    636          
    637            __HAL_UART_DISABLE(huart);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x0840             LSRS     R0,R0,#+1
   \       0x18   0x0040             LSLS     R0,R0,#+1
   \       0x1A   0x6821             LDR      R1,[R4, #+0]
   \       0x1C   0x6008             STR      R0,[R1, #+0]
    638          
    639            huart->Instance->CR1 = 0x0U;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6821             LDR      R1,[R4, #+0]
   \       0x22   0x6008             STR      R0,[R1, #+0]
    640            huart->Instance->CR2 = 0x0U;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x6821             LDR      R1,[R4, #+0]
   \       0x28   0x6048             STR      R0,[R1, #+4]
    641            huart->Instance->CR3 = 0x0U;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x6821             LDR      R1,[R4, #+0]
   \       0x2E   0x6088             STR      R0,[R1, #+8]
    642          
    643          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    644            if (huart->MspDeInitCallback == NULL)
    645            {
    646              huart->MspDeInitCallback = HAL_UART_MspDeInit;
    647            }
    648            /* DeInit the low level hardware */
    649            huart->MspDeInitCallback(huart);
    650          #else
    651            /* DeInit the low level hardware */
    652            HAL_UART_MspDeInit(huart);
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       HAL_UART_MspDeInit
    653          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
    654          
    655            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xF8C4 0x008C      STR      R0,[R4, #+140]
    656            huart->gState = HAL_UART_STATE_RESET;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xF8C4 0x0084      STR      R0,[R4, #+132]
    657            huart->RxState = HAL_UART_STATE_RESET;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xF8C4 0x0088      STR      R0,[R4, #+136]
    658            huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x66E0             STR      R0,[R4, #+108]
    659          
    660            __HAL_UNLOCK(huart);
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xF884 0x0080      STRB     R0,[R4, #+128]
    661          
    662            return HAL_OK;
   \       0x52   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DeInit_1: (+1)
   \       0x54   0xBD10             POP      {R4,PC}
    663          }
    664          
    665          /**
    666            * @brief Initialize the UART MSP.
    667            * @param huart UART handle.
    668            * @retval None
    669            */

   \                                 In section .text, align 2
    670          __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
    671          {
    672            /* Prevent unused argument(s) compilation warning */
    673            UNUSED(huart);
    674          
    675            /* NOTE : This function should not be modified, when the callback is needed,
    676                      the HAL_UART_MspInit can be implemented in the user file
    677             */
    678          }
   \                     HAL_UART_MspInit: (+1)
   \        0x0   0x4770             BX       LR
    679          
    680          /**
    681            * @brief DeInitialize the UART MSP.
    682            * @param huart UART handle.
    683            * @retval None
    684            */

   \                                 In section .text, align 2
    685          __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
    686          {
    687            /* Prevent unused argument(s) compilation warning */
    688            UNUSED(huart);
    689          
    690            /* NOTE : This function should not be modified, when the callback is needed,
    691                      the HAL_UART_MspDeInit can be implemented in the user file
    692             */
    693          }
   \                     HAL_UART_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
    694          
    695          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    696          /**
    697            * @brief  Register a User UART Callback
    698            *         To be used instead of the weak predefined callback
    699            * @param  huart uart handle
    700            * @param  CallbackID ID of the callback to be registered
    701            *         This parameter can be one of the following values:
    702            *           @arg @ref HAL_UART_TX_HALFCOMPLETE_CB_ID Tx Half Complete Callback ID
    703            *           @arg @ref HAL_UART_TX_COMPLETE_CB_ID Tx Complete Callback ID
    704            *           @arg @ref HAL_UART_RX_HALFCOMPLETE_CB_ID Rx Half Complete Callback ID
    705            *           @arg @ref HAL_UART_RX_COMPLETE_CB_ID Rx Complete Callback ID
    706            *           @arg @ref HAL_UART_ERROR_CB_ID Error Callback ID
    707            *           @arg @ref HAL_UART_ABORT_COMPLETE_CB_ID Abort Complete Callback ID
    708            *           @arg @ref HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID Abort Transmit Complete Callback ID
    709            *           @arg @ref HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID Abort Receive Complete Callback ID
    710            *           @arg @ref HAL_UART_WAKEUP_CB_ID Wakeup Callback ID
    711            *           @arg @ref HAL_UART_RX_FIFO_FULL_CB_ID Rx Fifo Full Callback ID
    712            *           @arg @ref HAL_UART_TX_FIFO_EMPTY_CB_ID Tx Fifo Empty Callback ID
    713            *           @arg @ref HAL_UART_MSPINIT_CB_ID MspInit Callback ID
    714            *           @arg @ref HAL_UART_MSPDEINIT_CB_ID MspDeInit Callback ID
    715            * @param  pCallback pointer to the Callback function
    716            * @retval HAL status
    717            */
    718          HAL_StatusTypeDef HAL_UART_RegisterCallback(UART_HandleTypeDef *huart, HAL_UART_CallbackIDTypeDef CallbackID,
    719                                                      pUART_CallbackTypeDef pCallback)
    720          {
    721            HAL_StatusTypeDef status = HAL_OK;
    722          
    723            if (pCallback == NULL)
    724            {
    725              huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
    726          
    727              return HAL_ERROR;
    728            }
    729          
    730            __HAL_LOCK(huart);
    731          
    732            if (huart->gState == HAL_UART_STATE_READY)
    733            {
    734              switch (CallbackID)
    735              {
    736                case HAL_UART_TX_HALFCOMPLETE_CB_ID :
    737                  huart->TxHalfCpltCallback = pCallback;
    738                  break;
    739          
    740                case HAL_UART_TX_COMPLETE_CB_ID :
    741                  huart->TxCpltCallback = pCallback;
    742                  break;
    743          
    744                case HAL_UART_RX_HALFCOMPLETE_CB_ID :
    745                  huart->RxHalfCpltCallback = pCallback;
    746                  break;
    747          
    748                case HAL_UART_RX_COMPLETE_CB_ID :
    749                  huart->RxCpltCallback = pCallback;
    750                  break;
    751          
    752                case HAL_UART_ERROR_CB_ID :
    753                  huart->ErrorCallback = pCallback;
    754                  break;
    755          
    756                case HAL_UART_ABORT_COMPLETE_CB_ID :
    757                  huart->AbortCpltCallback = pCallback;
    758                  break;
    759          
    760                case HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID :
    761                  huart->AbortTransmitCpltCallback = pCallback;
    762                  break;
    763          
    764                case HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID :
    765                  huart->AbortReceiveCpltCallback = pCallback;
    766                  break;
    767          
    768                case HAL_UART_WAKEUP_CB_ID :
    769                  huart->WakeupCallback = pCallback;
    770                  break;
    771          
    772                case HAL_UART_RX_FIFO_FULL_CB_ID :
    773                  huart->RxFifoFullCallback = pCallback;
    774                  break;
    775          
    776                case HAL_UART_TX_FIFO_EMPTY_CB_ID :
    777                  huart->TxFifoEmptyCallback = pCallback;
    778                  break;
    779          
    780                case HAL_UART_MSPINIT_CB_ID :
    781                  huart->MspInitCallback = pCallback;
    782                  break;
    783          
    784                case HAL_UART_MSPDEINIT_CB_ID :
    785                  huart->MspDeInitCallback = pCallback;
    786                  break;
    787          
    788                default :
    789                  huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
    790          
    791                  status =  HAL_ERROR;
    792                  break;
    793              }
    794            }
    795            else if (huart->gState == HAL_UART_STATE_RESET)
    796            {
    797              switch (CallbackID)
    798              {
    799                case HAL_UART_MSPINIT_CB_ID :
    800                  huart->MspInitCallback = pCallback;
    801                  break;
    802          
    803                case HAL_UART_MSPDEINIT_CB_ID :
    804                  huart->MspDeInitCallback = pCallback;
    805                  break;
    806          
    807                default :
    808                  huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
    809          
    810                  status =  HAL_ERROR;
    811                  break;
    812              }
    813            }
    814            else
    815            {
    816              huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
    817          
    818              status =  HAL_ERROR;
    819            }
    820          
    821            __HAL_UNLOCK(huart);
    822          
    823            return status;
    824          }
    825          
    826          /**
    827            * @brief  Unregister an UART Callback
    828            *         UART callaback is redirected to the weak predefined callback
    829            * @param  huart uart handle
    830            * @param  CallbackID ID of the callback to be unregistered
    831            *         This parameter can be one of the following values:
    832            *           @arg @ref HAL_UART_TX_HALFCOMPLETE_CB_ID Tx Half Complete Callback ID
    833            *           @arg @ref HAL_UART_TX_COMPLETE_CB_ID Tx Complete Callback ID
    834            *           @arg @ref HAL_UART_RX_HALFCOMPLETE_CB_ID Rx Half Complete Callback ID
    835            *           @arg @ref HAL_UART_RX_COMPLETE_CB_ID Rx Complete Callback ID
    836            *           @arg @ref HAL_UART_ERROR_CB_ID Error Callback ID
    837            *           @arg @ref HAL_UART_ABORT_COMPLETE_CB_ID Abort Complete Callback ID
    838            *           @arg @ref HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID Abort Transmit Complete Callback ID
    839            *           @arg @ref HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID Abort Receive Complete Callback ID
    840            *           @arg @ref HAL_UART_WAKEUP_CB_ID Wakeup Callback ID
    841            *           @arg @ref HAL_UART_RX_FIFO_FULL_CB_ID Rx Fifo Full Callback ID
    842            *           @arg @ref HAL_UART_TX_FIFO_EMPTY_CB_ID Tx Fifo Empty Callback ID
    843            *           @arg @ref HAL_UART_MSPINIT_CB_ID MspInit Callback ID
    844            *           @arg @ref HAL_UART_MSPDEINIT_CB_ID MspDeInit Callback ID
    845            * @retval HAL status
    846            */
    847          HAL_StatusTypeDef HAL_UART_UnRegisterCallback(UART_HandleTypeDef *huart, HAL_UART_CallbackIDTypeDef CallbackID)
    848          {
    849            HAL_StatusTypeDef status = HAL_OK;
    850          
    851            __HAL_LOCK(huart);
    852          
    853            if (HAL_UART_STATE_READY == huart->gState)
    854            {
    855              switch (CallbackID)
    856              {
    857                case HAL_UART_TX_HALFCOMPLETE_CB_ID :
    858                  huart->TxHalfCpltCallback = HAL_UART_TxHalfCpltCallback;               /* Legacy weak  TxHalfCpltCallback    */
    859                  break;
    860          
    861                case HAL_UART_TX_COMPLETE_CB_ID :
    862                  huart->TxCpltCallback = HAL_UART_TxCpltCallback;                       /* Legacy weak TxCpltCallback         */
    863                  break;
    864          
    865                case HAL_UART_RX_HALFCOMPLETE_CB_ID :
    866                  huart->RxHalfCpltCallback = HAL_UART_RxHalfCpltCallback;               /* Legacy weak RxHalfCpltCallback     */
    867                  break;
    868          
    869                case HAL_UART_RX_COMPLETE_CB_ID :
    870                  huart->RxCpltCallback = HAL_UART_RxCpltCallback;                       /* Legacy weak RxCpltCallback         */
    871                  break;
    872          
    873                case HAL_UART_ERROR_CB_ID :
    874                  huart->ErrorCallback = HAL_UART_ErrorCallback;                         /* Legacy weak ErrorCallback          */
    875                  break;
    876          
    877                case HAL_UART_ABORT_COMPLETE_CB_ID :
    878                  huart->AbortCpltCallback = HAL_UART_AbortCpltCallback;                 /* Legacy weak AbortCpltCallback      */
    879                  break;
    880          
    881                case HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID :
    882                  huart->AbortTransmitCpltCallback = HAL_UART_AbortTransmitCpltCallback; /* Legacy weak
    883                                                                                            AbortTransmitCpltCallback          */
    884                  break;
    885          
    886                case HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID :
    887                  huart->AbortReceiveCpltCallback = HAL_UART_AbortReceiveCpltCallback;   /* Legacy weak
    888                                                                                            AbortReceiveCpltCallback           */
    889                  break;
    890          
    891                case HAL_UART_WAKEUP_CB_ID :
    892                  huart->WakeupCallback = HAL_UARTEx_WakeupCallback;                     /* Legacy weak WakeupCallback         */
    893                  break;
    894          
    895                case HAL_UART_RX_FIFO_FULL_CB_ID :
    896                  huart->RxFifoFullCallback = HAL_UARTEx_RxFifoFullCallback;             /* Legacy weak RxFifoFullCallback     */
    897                  break;
    898          
    899                case HAL_UART_TX_FIFO_EMPTY_CB_ID :
    900                  huart->TxFifoEmptyCallback = HAL_UARTEx_TxFifoEmptyCallback;           /* Legacy weak TxFifoEmptyCallback    */
    901                  break;
    902          
    903                case HAL_UART_MSPINIT_CB_ID :
    904                  huart->MspInitCallback = HAL_UART_MspInit;                             /* Legacy weak MspInitCallback        */
    905                  break;
    906          
    907                case HAL_UART_MSPDEINIT_CB_ID :
    908                  huart->MspDeInitCallback = HAL_UART_MspDeInit;                         /* Legacy weak MspDeInitCallback      */
    909                  break;
    910          
    911                default :
    912                  huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
    913          
    914                  status =  HAL_ERROR;
    915                  break;
    916              }
    917            }
    918            else if (HAL_UART_STATE_RESET == huart->gState)
    919            {
    920              switch (CallbackID)
    921              {
    922                case HAL_UART_MSPINIT_CB_ID :
    923                  huart->MspInitCallback = HAL_UART_MspInit;
    924                  break;
    925          
    926                case HAL_UART_MSPDEINIT_CB_ID :
    927                  huart->MspDeInitCallback = HAL_UART_MspDeInit;
    928                  break;
    929          
    930                default :
    931                  huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
    932          
    933                  status =  HAL_ERROR;
    934                  break;
    935              }
    936            }
    937            else
    938            {
    939              huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
    940          
    941              status =  HAL_ERROR;
    942            }
    943          
    944            __HAL_UNLOCK(huart);
    945          
    946            return status;
    947          }
    948          
    949          /**
    950            * @brief  Register a User UART Rx Event Callback
    951            *         To be used instead of the weak predefined callback
    952            * @param  huart     Uart handle
    953            * @param  pCallback Pointer to the Rx Event Callback function
    954            * @retval HAL status
    955            */
    956          HAL_StatusTypeDef HAL_UART_RegisterRxEventCallback(UART_HandleTypeDef *huart, pUART_RxEventCallbackTypeDef pCallback)
    957          {
    958            HAL_StatusTypeDef status = HAL_OK;
    959          
    960            if (pCallback == NULL)
    961            {
    962              huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
    963          
    964              return HAL_ERROR;
    965            }
    966          
    967            /* Process locked */
    968            __HAL_LOCK(huart);
    969          
    970            if (huart->gState == HAL_UART_STATE_READY)
    971            {
    972              huart->RxEventCallback = pCallback;
    973            }
    974            else
    975            {
    976              huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
    977          
    978              status =  HAL_ERROR;
    979            }
    980          
    981            /* Release Lock */
    982            __HAL_UNLOCK(huart);
    983          
    984            return status;
    985          }
    986          
    987          /**
    988            * @brief  UnRegister the UART Rx Event Callback
    989            *         UART Rx Event Callback is redirected to the weak HAL_UARTEx_RxEventCallback() predefined callback
    990            * @param  huart     Uart handle
    991            * @retval HAL status
    992            */
    993          HAL_StatusTypeDef HAL_UART_UnRegisterRxEventCallback(UART_HandleTypeDef *huart)
    994          {
    995            HAL_StatusTypeDef status = HAL_OK;
    996          
    997            /* Process locked */
    998            __HAL_LOCK(huart);
    999          
   1000            if (huart->gState == HAL_UART_STATE_READY)
   1001            {
   1002              huart->RxEventCallback = HAL_UARTEx_RxEventCallback; /* Legacy weak UART Rx Event Callback  */
   1003            }
   1004            else
   1005            {
   1006              huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
   1007          
   1008              status =  HAL_ERROR;
   1009            }
   1010          
   1011            /* Release Lock */
   1012            __HAL_UNLOCK(huart);
   1013            return status;
   1014          }
   1015          
   1016          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   1017          
   1018          /**
   1019            * @}
   1020            */
   1021          
   1022          /** @defgroup UART_Exported_Functions_Group2 IO operation functions
   1023            * @brief UART Transmit/Receive functions
   1024            *
   1025          @verbatim
   1026           ===============================================================================
   1027                                ##### IO operation functions #####
   1028           ===============================================================================
   1029              This subsection provides a set of functions allowing to manage the UART asynchronous
   1030              and Half duplex data transfers.
   1031          
   1032              (#) There are two mode of transfer:
   1033                 (+) Blocking mode: The communication is performed in polling mode.
   1034                     The HAL status of all data processing is returned by the same function
   1035                     after finishing transfer.
   1036                 (+) Non-Blocking mode: The communication is performed using Interrupts
   1037                     or DMA, These API's return the HAL status.
   1038                     The end of the data processing will be indicated through the
   1039                     dedicated UART IRQ when using Interrupt mode or the DMA IRQ when
   1040                     using DMA mode.
   1041                     The HAL_UART_TxCpltCallback(), HAL_UART_RxCpltCallback() user callbacks
   1042                     will be executed respectively at the end of the transmit or Receive process
   1043                     The HAL_UART_ErrorCallback()user callback will be executed when a communication error is detected
   1044          
   1045              (#) Blocking mode API's are :
   1046                  (+) HAL_UART_Transmit()
   1047                  (+) HAL_UART_Receive()
   1048          
   1049              (#) Non-Blocking mode API's with Interrupt are :
   1050                  (+) HAL_UART_Transmit_IT()
   1051                  (+) HAL_UART_Receive_IT()
   1052                  (+) HAL_UART_IRQHandler()
   1053          
   1054              (#) Non-Blocking mode API's with DMA are :
   1055                  (+) HAL_UART_Transmit_DMA()
   1056                  (+) HAL_UART_Receive_DMA()
   1057                  (+) HAL_UART_DMAPause()
   1058                  (+) HAL_UART_DMAResume()
   1059                  (+) HAL_UART_DMAStop()
   1060          
   1061              (#) A set of Transfer Complete Callbacks are provided in Non_Blocking mode:
   1062                  (+) HAL_UART_TxHalfCpltCallback()
   1063                  (+) HAL_UART_TxCpltCallback()
   1064                  (+) HAL_UART_RxHalfCpltCallback()
   1065                  (+) HAL_UART_RxCpltCallback()
   1066                  (+) HAL_UART_ErrorCallback()
   1067          
   1068              (#) Non-Blocking mode transfers could be aborted using Abort API's :
   1069                  (+) HAL_UART_Abort()
   1070                  (+) HAL_UART_AbortTransmit()
   1071                  (+) HAL_UART_AbortReceive()
   1072                  (+) HAL_UART_Abort_IT()
   1073                  (+) HAL_UART_AbortTransmit_IT()
   1074                  (+) HAL_UART_AbortReceive_IT()
   1075          
   1076              (#) For Abort services based on interrupts (HAL_UART_Abortxxx_IT), a set of Abort Complete Callbacks are provided:
   1077                  (+) HAL_UART_AbortCpltCallback()
   1078                  (+) HAL_UART_AbortTransmitCpltCallback()
   1079                  (+) HAL_UART_AbortReceiveCpltCallback()
   1080          
   1081              (#) A Rx Event Reception Callback (Rx event notification) is available for Non_Blocking modes of enhanced
   1082                  reception services:
   1083                  (+) HAL_UARTEx_RxEventCallback()
   1084          
   1085              (#) In Non-Blocking mode transfers, possible errors are split into 2 categories.
   1086                  Errors are handled as follows :
   1087                 (+) Error is considered as Recoverable and non blocking : Transfer could go till end, but error severity is
   1088                     to be evaluated by user : this concerns Frame Error, Parity Error or Noise Error
   1089                     in Interrupt mode reception .
   1090                     Received character is then retrieved and stored in Rx buffer, Error code is set to allow user
   1091                     to identify error type, and HAL_UART_ErrorCallback() user callback is executed.
   1092                     Transfer is kept ongoing on UART side.
   1093                     If user wants to abort it, Abort services should be called by user.
   1094                 (+) Error is considered as Blocking : Transfer could not be completed properly and is aborted.
   1095                     This concerns Overrun Error In Interrupt mode reception and all errors in DMA mode.
   1096                     Error code is set to allow user to identify error type, and HAL_UART_ErrorCallback()
   1097                     user callback is executed.
   1098          
   1099              -@- In the Half duplex communication, it is forbidden to run the transmit
   1100                  and receive process in parallel, the UART state HAL_UART_STATE_BUSY_TX_RX can't be useful.
   1101          
   1102          @endverbatim
   1103            * @{
   1104            */
   1105          
   1106          /**
   1107            * @brief Send an amount of data in blocking mode.
   1108            * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1109            *         the sent data is handled as a set of u16. In this case, Size must indicate the number
   1110            *         of u16 provided through pData.
   1111            * @note When FIFO mode is enabled, writing a data in the TDR register adds one
   1112            *       data to the TXFIFO. Write operations to the TDR register are performed
   1113            *       when TXFNF flag is set. From hardware perspective, TXFNF flag and
   1114            *       TXE are mapped on the same bit-field.
   1115            * @param huart   UART handle.
   1116            * @param pData   Pointer to data buffer (u8 or u16 data elements).
   1117            * @param Size    Amount of data elements (u8 or u16) to be sent.
   1118            * @param Timeout Timeout duration.
   1119            * @retval HAL status
   1120            */

   \                                 In section .text, align 2, keep-with-next
   1121          HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1122          {
   \                     HAL_UART_Transmit: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001F             MOVS     R7,R3
   1123            const uint8_t  *pdata8bits;
   1124            const uint16_t *pdata16bits;
   1125            uint32_t tickstart;
   1126          
   1127            /* Check that a Tx process is not already ongoing */
   1128            if (huart->gState == HAL_UART_STATE_READY)
   \        0xC   0xF8D6 0x0084      LDR      R0,[R6, #+132]
   \       0x10   0x2820             CMP      R0,#+32
   \       0x12   0xD15D             BNE.N    ??HAL_UART_Transmit_0
   1129            {
   1130              if ((pData == NULL) || (Size == 0U))
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD003             BEQ.N    ??HAL_UART_Transmit_1
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0xB280             UXTH     R0,R0
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD101             BNE.N    ??HAL_UART_Transmit_2
   1131              {
   1132                return  HAL_ERROR;
   \                     ??HAL_UART_Transmit_1: (+1)
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xE056             B.N      ??HAL_UART_Transmit_3
   1133              }
   1134          
   1135              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_2: (+1)
   \       0x24   0xF896 0x0080      LDRB     R0,[R6, #+128]
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD101             BNE.N    ??HAL_UART_Transmit_4
   \       0x2C   0x2002             MOVS     R0,#+2
   \       0x2E   0xE050             B.N      ??HAL_UART_Transmit_3
   \                     ??HAL_UART_Transmit_4: (+1)
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0xF886 0x0080      STRB     R0,[R6, #+128]
   1136          
   1137              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xF8C6 0x008C      STR      R0,[R6, #+140]
   1138              huart->gState = HAL_UART_STATE_BUSY_TX;
   \       0x3C   0x2021             MOVS     R0,#+33
   \       0x3E   0xF8C6 0x0084      STR      R0,[R6, #+132]
   1139          
   1140              /* Init tickstart for timeout management */
   1141              tickstart = HAL_GetTick();
   \       0x42   0x.... 0x....      BL       HAL_GetTick
   \       0x46   0x4680             MOV      R8,R0
   1142          
   1143              huart->TxXferSize  = Size;
   \       0x48   0xF8A6 0x4054      STRH     R4,[R6, #+84]
   1144              huart->TxXferCount = Size;
   \       0x4C   0xF8A6 0x4056      STRH     R4,[R6, #+86]
   1145          
   1146              /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
   1147              if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
   \       0x50   0x68B0             LDR      R0,[R6, #+8]
   \       0x52   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x56   0xD104             BNE.N    ??HAL_UART_Transmit_5
   \       0x58   0x6930             LDR      R0,[R6, #+16]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD101             BNE.N    ??HAL_UART_Transmit_5
   1148              {
   1149                pdata8bits  = NULL;
   \       0x5E   0x2400             MOVS     R4,#+0
   1150                pdata16bits = (const uint16_t *) pData;
   \       0x60   0xE001             B.N      ??HAL_UART_Transmit_6
   1151              }
   1152              else
   1153              {
   1154                pdata8bits  = pData;
   \                     ??HAL_UART_Transmit_5: (+1)
   \       0x62   0x002C             MOVS     R4,R5
   1155                pdata16bits = NULL;
   \       0x64   0x2500             MOVS     R5,#+0
   1156              }
   1157          
   1158              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Transmit_6: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xF886 0x0080      STRB     R0,[R6, #+128]
   \       0x6C   0xE011             B.N      ??HAL_UART_Transmit_7
   1159          
   1160              while (huart->TxXferCount > 0U)
   1161              {
   1162                if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
   1163                {
   1164                  return HAL_TIMEOUT;
   1165                }
   1166                if (pdata8bits == NULL)
   1167                {
   1168                  huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
   1169                  pdata16bits++;
   1170                }
   1171                else
   1172                {
   1173                  huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
   \                     ??HAL_UART_Transmit_8: (+1)
   \       0x6E   0x7820             LDRB     R0,[R4, #+0]
   \       0x70   0x6831             LDR      R1,[R6, #+0]
   \       0x72   0x6288             STR      R0,[R1, #+40]
   1174                  pdata8bits++;
   \       0x74   0x1C64             ADDS     R4,R4,#+1
   \       0x76   0xE007             B.N      ??HAL_UART_Transmit_9
   1175                }
   \                     ??HAL_UART_Transmit_10: (+1)
   \       0x78   0x2C00             CMP      R4,#+0
   \       0x7A   0xD1F8             BNE.N    ??HAL_UART_Transmit_8
   \       0x7C   0x8828             LDRH     R0,[R5, #+0]
   \       0x7E   0x05C0             LSLS     R0,R0,#+23
   \       0x80   0x0DC0             LSRS     R0,R0,#+23
   \       0x82   0x6831             LDR      R1,[R6, #+0]
   \       0x84   0x6288             STR      R0,[R1, #+40]
   \       0x86   0x1CAD             ADDS     R5,R5,#+2
   1176                huart->TxXferCount--;
   \                     ??HAL_UART_Transmit_9: (+1)
   \       0x88   0xF8B6 0x0056      LDRH     R0,[R6, #+86]
   \       0x8C   0x1E40             SUBS     R0,R0,#+1
   \       0x8E   0xF8A6 0x0056      STRH     R0,[R6, #+86]
   \                     ??HAL_UART_Transmit_7: (+1)
   \       0x92   0xF8B6 0x0056      LDRH     R0,[R6, #+86]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD00A             BEQ.N    ??HAL_UART_Transmit_11
   \       0x9A   0x9700             STR      R7,[SP, #+0]
   \       0x9C   0x4643             MOV      R3,R8
   \       0x9E   0x2200             MOVS     R2,#+0
   \       0xA0   0x2180             MOVS     R1,#+128
   \       0xA2   0x0030             MOVS     R0,R6
   \       0xA4   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD0E5             BEQ.N    ??HAL_UART_Transmit_10
   \       0xAC   0x2003             MOVS     R0,#+3
   \       0xAE   0xE010             B.N      ??HAL_UART_Transmit_3
   1177              }
   1178          
   1179              if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
   \                     ??HAL_UART_Transmit_11: (+1)
   \       0xB0   0x9700             STR      R7,[SP, #+0]
   \       0xB2   0x4643             MOV      R3,R8
   \       0xB4   0x2200             MOVS     R2,#+0
   \       0xB6   0x2140             MOVS     R1,#+64
   \       0xB8   0x0030             MOVS     R0,R6
   \       0xBA   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD001             BEQ.N    ??HAL_UART_Transmit_12
   1180              {
   1181                return HAL_TIMEOUT;
   \       0xC2   0x2003             MOVS     R0,#+3
   \       0xC4   0xE005             B.N      ??HAL_UART_Transmit_3
   1182              }
   1183          
   1184              /* At end of Tx process, restore huart->gState to Ready */
   1185              huart->gState = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Transmit_12: (+1)
   \       0xC6   0x2020             MOVS     R0,#+32
   \       0xC8   0xF8C6 0x0084      STR      R0,[R6, #+132]
   1186          
   1187              return HAL_OK;
   \       0xCC   0x2000             MOVS     R0,#+0
   \       0xCE   0xE000             B.N      ??HAL_UART_Transmit_3
   1188            }
   1189            else
   1190            {
   1191              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_0: (+1)
   \       0xD0   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_3: (+1)
   \       0xD2   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   1192            }
   1193          }
   1194          
   1195          /**
   1196            * @brief Receive an amount of data in blocking mode.
   1197            * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1198            *         the received data is handled as a set of u16. In this case, Size must indicate the number
   1199            *         of u16 available through pData.
   1200            * @note When FIFO mode is enabled, the RXFNE flag is set as long as the RXFIFO
   1201            *       is not empty. Read operations from the RDR register are performed when
   1202            *       RXFNE flag is set. From hardware perspective, RXFNE flag and
   1203            *       RXNE are mapped on the same bit-field.
   1204            * @param huart   UART handle.
   1205            * @param pData   Pointer to data buffer (u8 or u16 data elements).
   1206            * @param Size    Amount of data elements (u8 or u16) to be received.
   1207            * @param Timeout Timeout duration.
   1208            * @retval HAL status
   1209            */

   \                                 In section .text, align 2, keep-with-next
   1210          HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1211          {
   \                     HAL_UART_Receive: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001F             MOVS     R7,R3
   1212            uint8_t  *pdata8bits;
   1213            uint16_t *pdata16bits;
   1214            uint16_t uhMask;
   1215            uint32_t tickstart;
   1216          
   1217            /* Check that a Rx process is not already ongoing */
   1218            if (huart->RxState == HAL_UART_STATE_READY)
   \        0xC   0xF8D6 0x0088      LDR      R0,[R6, #+136]
   \       0x10   0x2820             CMP      R0,#+32
   \       0x12   0xF040 0x8089      BNE.W    ??HAL_UART_Receive_0
   1219            {
   1220              if ((pData == NULL) || (Size == 0U))
   \       0x16   0x2D00             CMP      R5,#+0
   \       0x18   0xD003             BEQ.N    ??HAL_UART_Receive_1
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0xB280             UXTH     R0,R0
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD101             BNE.N    ??HAL_UART_Receive_2
   1221              {
   1222                return  HAL_ERROR;
   \                     ??HAL_UART_Receive_1: (+1)
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xE081             B.N      ??HAL_UART_Receive_3
   1223              }
   1224          
   1225              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_2: (+1)
   \       0x26   0xF896 0x0080      LDRB     R0,[R6, #+128]
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD101             BNE.N    ??HAL_UART_Receive_4
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0xE07B             B.N      ??HAL_UART_Receive_3
   \                     ??HAL_UART_Receive_4: (+1)
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xF886 0x0080      STRB     R0,[R6, #+128]
   1226          
   1227              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xF8C6 0x008C      STR      R0,[R6, #+140]
   1228              huart->RxState = HAL_UART_STATE_BUSY_RX;
   \       0x3E   0x2022             MOVS     R0,#+34
   \       0x40   0xF8C6 0x0088      STR      R0,[R6, #+136]
   1229              huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x66F0             STR      R0,[R6, #+108]
   1230          
   1231              /* Init tickstart for timeout management */
   1232              tickstart = HAL_GetTick();
   \       0x48   0x.... 0x....      BL       HAL_GetTick
   \       0x4C   0x4680             MOV      R8,R0
   1233          
   1234              huart->RxXferSize  = Size;
   \       0x4E   0xF8A6 0x405C      STRH     R4,[R6, #+92]
   1235              huart->RxXferCount = Size;
   \       0x52   0xF8A6 0x405E      STRH     R4,[R6, #+94]
   1236          
   1237              /* Computation of UART mask to apply to RDR register */
   1238              UART_MASK_COMPUTATION(huart);
   \       0x56   0x68B0             LDR      R0,[R6, #+8]
   \       0x58   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x5C   0xD10B             BNE.N    ??HAL_UART_Receive_5
   \       0x5E   0x6930             LDR      R0,[R6, #+16]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD104             BNE.N    ??HAL_UART_Receive_6
   \       0x64   0xF240 0x10FF      MOVW     R0,#+511
   \       0x68   0xF8A6 0x0060      STRH     R0,[R6, #+96]
   \       0x6C   0xE023             B.N      ??HAL_UART_Receive_7
   \                     ??HAL_UART_Receive_6: (+1)
   \       0x6E   0x20FF             MOVS     R0,#+255
   \       0x70   0xF8A6 0x0060      STRH     R0,[R6, #+96]
   \       0x74   0xE01F             B.N      ??HAL_UART_Receive_7
   \                     ??HAL_UART_Receive_5: (+1)
   \       0x76   0x68B0             LDR      R0,[R6, #+8]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD10A             BNE.N    ??HAL_UART_Receive_8
   \       0x7C   0x6930             LDR      R0,[R6, #+16]
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD103             BNE.N    ??HAL_UART_Receive_9
   \       0x82   0x20FF             MOVS     R0,#+255
   \       0x84   0xF8A6 0x0060      STRH     R0,[R6, #+96]
   \       0x88   0xE015             B.N      ??HAL_UART_Receive_7
   \                     ??HAL_UART_Receive_9: (+1)
   \       0x8A   0x207F             MOVS     R0,#+127
   \       0x8C   0xF8A6 0x0060      STRH     R0,[R6, #+96]
   \       0x90   0xE011             B.N      ??HAL_UART_Receive_7
   \                     ??HAL_UART_Receive_8: (+1)
   \       0x92   0x68B0             LDR      R0,[R6, #+8]
   \       0x94   0xF1B0 0x5F80      CMP      R0,#+268435456
   \       0x98   0xD10A             BNE.N    ??HAL_UART_Receive_10
   \       0x9A   0x6930             LDR      R0,[R6, #+16]
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD103             BNE.N    ??HAL_UART_Receive_11
   \       0xA0   0x207F             MOVS     R0,#+127
   \       0xA2   0xF8A6 0x0060      STRH     R0,[R6, #+96]
   \       0xA6   0xE006             B.N      ??HAL_UART_Receive_7
   \                     ??HAL_UART_Receive_11: (+1)
   \       0xA8   0x203F             MOVS     R0,#+63
   \       0xAA   0xF8A6 0x0060      STRH     R0,[R6, #+96]
   \       0xAE   0xE002             B.N      ??HAL_UART_Receive_7
   \                     ??HAL_UART_Receive_10: (+1)
   \       0xB0   0x2000             MOVS     R0,#+0
   \       0xB2   0xF8A6 0x0060      STRH     R0,[R6, #+96]
   1239              uhMask = huart->Mask;
   \                     ??HAL_UART_Receive_7: (+1)
   \       0xB6   0xF8B6 0x9060      LDRH     R9,[R6, #+96]
   1240          
   1241              /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
   1242              if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
   \       0xBA   0x68B0             LDR      R0,[R6, #+8]
   \       0xBC   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0xC0   0xD104             BNE.N    ??HAL_UART_Receive_12
   \       0xC2   0x6930             LDR      R0,[R6, #+16]
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD101             BNE.N    ??HAL_UART_Receive_12
   1243              {
   1244                pdata8bits  = NULL;
   \       0xC8   0x2400             MOVS     R4,#+0
   1245                pdata16bits = (uint16_t *) pData;
   \       0xCA   0xE001             B.N      ??HAL_UART_Receive_13
   1246              }
   1247              else
   1248              {
   1249                pdata8bits  = pData;
   \                     ??HAL_UART_Receive_12: (+1)
   \       0xCC   0x002C             MOVS     R4,R5
   1250                pdata16bits = NULL;
   \       0xCE   0x2500             MOVS     R5,#+0
   1251              }
   1252          
   1253              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Receive_13: (+1)
   \       0xD0   0x2000             MOVS     R0,#+0
   \       0xD2   0xF886 0x0080      STRB     R0,[R6, #+128]
   \       0xD6   0xE013             B.N      ??HAL_UART_Receive_14
   1254          
   1255              /* as long as data have to be received */
   1256              while (huart->RxXferCount > 0U)
   1257              {
   1258                if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
   1259                {
   1260                  return HAL_TIMEOUT;
   1261                }
   1262                if (pdata8bits == NULL)
   1263                {
   1264                  *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
   1265                  pdata16bits++;
   1266                }
   1267                else
   1268                {
   1269                  *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
   \                     ??HAL_UART_Receive_15: (+1)
   \       0xD8   0x6830             LDR      R0,[R6, #+0]
   \       0xDA   0x6A40             LDR      R0,[R0, #+36]
   \       0xDC   0xEA19 0x0000      ANDS     R0,R9,R0
   \       0xE0   0x7020             STRB     R0,[R4, #+0]
   1270                  pdata8bits++;
   \       0xE2   0x1C64             ADDS     R4,R4,#+1
   \       0xE4   0xE007             B.N      ??HAL_UART_Receive_16
   1271                }
   \                     ??HAL_UART_Receive_17: (+1)
   \       0xE6   0x2C00             CMP      R4,#+0
   \       0xE8   0xD1F6             BNE.N    ??HAL_UART_Receive_15
   \       0xEA   0x6830             LDR      R0,[R6, #+0]
   \       0xEC   0x6A40             LDR      R0,[R0, #+36]
   \       0xEE   0xEA19 0x0000      ANDS     R0,R9,R0
   \       0xF2   0x8028             STRH     R0,[R5, #+0]
   \       0xF4   0x1CAD             ADDS     R5,R5,#+2
   1272                huart->RxXferCount--;
   \                     ??HAL_UART_Receive_16: (+1)
   \       0xF6   0xF8B6 0x005E      LDRH     R0,[R6, #+94]
   \       0xFA   0x1E40             SUBS     R0,R0,#+1
   \       0xFC   0xF8A6 0x005E      STRH     R0,[R6, #+94]
   \                     ??HAL_UART_Receive_14: (+1)
   \      0x100   0xF8B6 0x005E      LDRH     R0,[R6, #+94]
   \      0x104   0x2800             CMP      R0,#+0
   \      0x106   0xD00A             BEQ.N    ??HAL_UART_Receive_18
   \      0x108   0x9700             STR      R7,[SP, #+0]
   \      0x10A   0x4643             MOV      R3,R8
   \      0x10C   0x2200             MOVS     R2,#+0
   \      0x10E   0x2120             MOVS     R1,#+32
   \      0x110   0x0030             MOVS     R0,R6
   \      0x112   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \      0x116   0x2800             CMP      R0,#+0
   \      0x118   0xD0E5             BEQ.N    ??HAL_UART_Receive_17
   \      0x11A   0x2003             MOVS     R0,#+3
   \      0x11C   0xE005             B.N      ??HAL_UART_Receive_3
   1273              }
   1274          
   1275              /* At end of Rx process, restore huart->RxState to Ready */
   1276              huart->RxState = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Receive_18: (+1)
   \      0x11E   0x2020             MOVS     R0,#+32
   \      0x120   0xF8C6 0x0088      STR      R0,[R6, #+136]
   1277          
   1278              return HAL_OK;
   \      0x124   0x2000             MOVS     R0,#+0
   \      0x126   0xE000             B.N      ??HAL_UART_Receive_3
   1279            }
   1280            else
   1281            {
   1282              return HAL_BUSY;
   \                     ??HAL_UART_Receive_0: (+1)
   \      0x128   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_3: (+1)
   \      0x12A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1283            }
   1284          }
   1285          
   1286          /**
   1287            * @brief Send an amount of data in interrupt mode.
   1288            * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1289            *         the sent data is handled as a set of u16. In this case, Size must indicate the number
   1290            *         of u16 provided through pData.
   1291            * @param huart UART handle.
   1292            * @param pData Pointer to data buffer (u8 or u16 data elements).
   1293            * @param Size  Amount of data elements (u8 or u16) to be sent.
   1294            * @retval HAL status
   1295            */

   \                                 In section .text, align 2, keep-with-next
   1296          HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size)
   1297          {
   1298            /* Check that a Tx process is not already ongoing */
   1299            if (huart->gState == HAL_UART_STATE_READY)
   \                     HAL_UART_Transmit_IT: (+1)
   \        0x0   0xF8D0 0x3084      LDR      R3,[R0, #+132]
   \        0x4   0x2B20             CMP      R3,#+32
   \        0x6   0xD15D             BNE.N    ??HAL_UART_Transmit_IT_0
   1300            {
   1301              if ((pData == NULL) || (Size == 0U))
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD003             BEQ.N    ??HAL_UART_Transmit_IT_1
   \        0xC   0x0013             MOVS     R3,R2
   \        0xE   0xB29B             UXTH     R3,R3
   \       0x10   0x2B00             CMP      R3,#+0
   \       0x12   0xD101             BNE.N    ??HAL_UART_Transmit_IT_2
   1302              {
   1303                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_IT_1: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xE056             B.N      ??HAL_UART_Transmit_IT_3
   1304              }
   1305          
   1306              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_IT_2: (+1)
   \       0x18   0xF890 0x3080      LDRB     R3,[R0, #+128]
   \       0x1C   0x2B01             CMP      R3,#+1
   \       0x1E   0xD101             BNE.N    ??HAL_UART_Transmit_IT_4
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xE050             B.N      ??HAL_UART_Transmit_IT_3
   \                     ??HAL_UART_Transmit_IT_4: (+1)
   \       0x24   0x2301             MOVS     R3,#+1
   \       0x26   0xF880 0x3080      STRB     R3,[R0, #+128]
   1307          
   1308              huart->pTxBuffPtr  = pData;
   \       0x2A   0x6501             STR      R1,[R0, #+80]
   1309              huart->TxXferSize  = Size;
   \       0x2C   0xF8A0 0x2054      STRH     R2,[R0, #+84]
   1310              huart->TxXferCount = Size;
   \       0x30   0xF8A0 0x2056      STRH     R2,[R0, #+86]
   1311              huart->TxISR       = NULL;
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x6741             STR      R1,[R0, #+116]
   1312          
   1313              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x38   0x2100             MOVS     R1,#+0
   \       0x3A   0xF8C0 0x108C      STR      R1,[R0, #+140]
   1314              huart->gState = HAL_UART_STATE_BUSY_TX;
   \       0x3E   0x2121             MOVS     R1,#+33
   \       0x40   0xF8C0 0x1084      STR      R1,[R0, #+132]
   1315          
   1316              /* Configure Tx interrupt processing */
   1317              if (huart->FifoMode == UART_FIFOMODE_ENABLE)
   \       0x44   0x6E41             LDR      R1,[R0, #+100]
   \       0x46   0xF1B1 0x5F00      CMP      R1,#+536870912
   \       0x4A   0xD11E             BNE.N    ??HAL_UART_Transmit_IT_5
   1318              {
   1319                /* Set the Tx ISR function pointer according to the data word length */
   1320                if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
   \       0x4C   0x6881             LDR      R1,[R0, #+8]
   \       0x4E   0xF5B1 0x5F80      CMP      R1,#+4096
   \       0x52   0xD106             BNE.N    ??HAL_UART_Transmit_IT_6
   \       0x54   0x6901             LDR      R1,[R0, #+16]
   \       0x56   0x2900             CMP      R1,#+0
   \       0x58   0xD103             BNE.N    ??HAL_UART_Transmit_IT_6
   1321                {
   1322                  huart->TxISR = UART_TxISR_16BIT_FIFOEN;
   \       0x5A   0x.... 0x....      LDR.W    R1,??DataTable9
   \       0x5E   0x6741             STR      R1,[R0, #+116]
   \       0x60   0xE002             B.N      ??HAL_UART_Transmit_IT_7
   1323                }
   1324                else
   1325                {
   1326                  huart->TxISR = UART_TxISR_8BIT_FIFOEN;
   \                     ??HAL_UART_Transmit_IT_6: (+1)
   \       0x62   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \       0x66   0x6741             STR      R1,[R0, #+116]
   1327                }
   1328          
   1329                __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Transmit_IT_7: (+1)
   \       0x68   0x2100             MOVS     R1,#+0
   \       0x6A   0xF880 0x1080      STRB     R1,[R0, #+128]
   1330          
   1331                /* Enable the TX FIFO threshold interrupt */
   1332                ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
   \                     ??HAL_UART_Transmit_IT_8: (+1)
   \       0x6E   0x6801             LDR      R1,[R0, #+0]
   \       0x70   0x3108             ADDS     R1,R1,#+8
   \       0x72   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x76   0xF452 0x0200      ORRS     R2,R2,#0x800000
   \       0x7A   0x6801             LDR      R1,[R0, #+0]
   \       0x7C   0xF111 0x0308      ADDS     R3,R1,#+8
   \       0x80   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x84   0x2900             CMP      R1,#+0
   \       0x86   0xD1F2             BNE.N    ??HAL_UART_Transmit_IT_8
   \       0x88   0xE01A             B.N      ??HAL_UART_Transmit_IT_9
   1333              }
   1334              else
   1335              {
   1336                /* Set the Tx ISR function pointer according to the data word length */
   1337                if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
   \                     ??HAL_UART_Transmit_IT_5: (+1)
   \       0x8A   0x6881             LDR      R1,[R0, #+8]
   \       0x8C   0xF5B1 0x5F80      CMP      R1,#+4096
   \       0x90   0xD106             BNE.N    ??HAL_UART_Transmit_IT_10
   \       0x92   0x6901             LDR      R1,[R0, #+16]
   \       0x94   0x2900             CMP      R1,#+0
   \       0x96   0xD103             BNE.N    ??HAL_UART_Transmit_IT_10
   1338                {
   1339                  huart->TxISR = UART_TxISR_16BIT;
   \       0x98   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \       0x9C   0x6741             STR      R1,[R0, #+116]
   \       0x9E   0xE002             B.N      ??HAL_UART_Transmit_IT_11
   1340                }
   1341                else
   1342                {
   1343                  huart->TxISR = UART_TxISR_8BIT;
   \                     ??HAL_UART_Transmit_IT_10: (+1)
   \       0xA0   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \       0xA4   0x6741             STR      R1,[R0, #+116]
   1344                }
   1345          
   1346                __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Transmit_IT_11: (+1)
   \       0xA6   0x2100             MOVS     R1,#+0
   \       0xA8   0xF880 0x1080      STRB     R1,[R0, #+128]
   1347          
   1348                /* Enable the Transmit Data Register Empty interrupt */
   1349                ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
   \                     ??HAL_UART_Transmit_IT_12: (+1)
   \       0xAC   0x6801             LDR      R1,[R0, #+0]
   \       0xAE   0xE851 0x2F00      LDREX    R2,[R1]
   \       0xB2   0xF052 0x0280      ORRS     R2,R2,#0x80
   \       0xB6   0x6803             LDR      R3,[R0, #+0]
   \       0xB8   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0xBC   0x2900             CMP      R1,#+0
   \       0xBE   0xD1F5             BNE.N    ??HAL_UART_Transmit_IT_12
   1350              }
   1351          
   1352              return HAL_OK;
   \                     ??HAL_UART_Transmit_IT_9: (+1)
   \       0xC0   0x2000             MOVS     R0,#+0
   \       0xC2   0xE000             B.N      ??HAL_UART_Transmit_IT_3
   1353            }
   1354            else
   1355            {
   1356              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_IT_0: (+1)
   \       0xC4   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_IT_3: (+1)
   \       0xC6   0x4770             BX       LR
   1357            }
   1358          }
   1359          
   1360          /**
   1361            * @brief Receive an amount of data in interrupt mode.
   1362            * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1363            *         the received data is handled as a set of u16. In this case, Size must indicate the number
   1364            *         of u16 available through pData.
   1365            * @param huart UART handle.
   1366            * @param pData Pointer to data buffer (u8 or u16 data elements).
   1367            * @param Size  Amount of data elements (u8 or u16) to be received.
   1368            * @retval HAL status
   1369            */

   \                                 In section .text, align 2, keep-with-next
   1370          HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
   1371          {
   \                     HAL_UART_Receive_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0003             MOVS     R3,R0
   1372            /* Check that a Rx process is not already ongoing */
   1373            if (huart->RxState == HAL_UART_STATE_READY)
   \        0x4   0xF8D3 0x0088      LDR      R0,[R3, #+136]
   \        0x8   0x2820             CMP      R0,#+32
   \        0xA   0xD12A             BNE.N    ??HAL_UART_Receive_IT_0
   1374            {
   1375              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD003             BEQ.N    ??HAL_UART_Receive_IT_1
   \       0x10   0x0010             MOVS     R0,R2
   \       0x12   0xB280             UXTH     R0,R0
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??HAL_UART_Receive_IT_2
   1376              {
   1377                return HAL_ERROR;
   \                     ??HAL_UART_Receive_IT_1: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE023             B.N      ??HAL_UART_Receive_IT_3
   1378              }
   1379          
   1380              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_IT_2: (+1)
   \       0x1C   0xF893 0x0080      LDRB     R0,[R3, #+128]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD101             BNE.N    ??HAL_UART_Receive_IT_4
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0xE01D             B.N      ??HAL_UART_Receive_IT_3
   \                     ??HAL_UART_Receive_IT_4: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xF883 0x0080      STRB     R0,[R3, #+128]
   1381          
   1382              /* Set Reception type to Standard reception */
   1383              huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x66D8             STR      R0,[R3, #+108]
   1384          
   1385              if (!(IS_LPUART_INSTANCE(huart->Instance)))
   \       0x32   0x6818             LDR      R0,[R3, #+0]
   \       0x34   0x.... 0x....      LDR.W    R4,??DataTable9_4
   \       0x38   0x42A0             CMP      R0,R4
   \       0x3A   0xD00D             BEQ.N    ??HAL_UART_Receive_IT_5
   1386              {
   1387                /* Check that USART RTOEN bit is set */
   1388                if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
   \       0x3C   0x6818             LDR      R0,[R3, #+0]
   \       0x3E   0x6840             LDR      R0,[R0, #+4]
   \       0x40   0x0200             LSLS     R0,R0,#+8
   \       0x42   0xD509             BPL.N    ??HAL_UART_Receive_IT_5
   1389                {
   1390                  /* Enable the UART Receiver Timeout Interrupt */
   1391                  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
   \                     ??HAL_UART_Receive_IT_6: (+1)
   \       0x44   0x6818             LDR      R0,[R3, #+0]
   \       0x46   0xE850 0x4F00      LDREX    R4,[R0]
   \       0x4A   0xF054 0x6480      ORRS     R4,R4,#0x4000000
   \       0x4E   0x681D             LDR      R5,[R3, #+0]
   \       0x50   0xE845 0x4000      STREX    R0,R4,[R5]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD1F5             BNE.N    ??HAL_UART_Receive_IT_6
   1392                }
   1393              }
   1394          
   1395              return (UART_Start_Receive_IT(huart, pData, Size));
   \                     ??HAL_UART_Receive_IT_5: (+1)
   \       0x58   0xB292             UXTH     R2,R2
   \       0x5A   0x0018             MOVS     R0,R3
   \       0x5C   0x.... 0x....      BL       UART_Start_Receive_IT
   \       0x60   0xE000             B.N      ??HAL_UART_Receive_IT_3
   1396            }
   1397            else
   1398            {
   1399              return HAL_BUSY;
   \                     ??HAL_UART_Receive_IT_0: (+1)
   \       0x62   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_IT_3: (+1)
   \       0x64   0xBD32             POP      {R1,R4,R5,PC}
   1400            }
   1401          }
   1402          
   1403          /**
   1404            * @brief Send an amount of data in DMA mode.
   1405            * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1406            *         the sent data is handled as a set of u16. In this case, Size must indicate the number
   1407            *         of u16 provided through pData.
   1408            * @param huart UART handle.
   1409            * @param pData Pointer to data buffer (u8 or u16 data elements).
   1410            * @param Size  Amount of data elements (u8 or u16) to be sent.
   1411            * @retval HAL status
   1412            */

   \                                 In section .text, align 2, keep-with-next
   1413          HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size)
   1414          {
   \                     HAL_UART_Transmit_DMA: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0013             MOVS     R3,R2
   1415            /* Check that a Tx process is not already ongoing */
   1416            if (huart->gState == HAL_UART_STATE_READY)
   \        0x6   0xF8D4 0x0084      LDR      R0,[R4, #+132]
   \        0xA   0x2820             CMP      R0,#+32
   \        0xC   0xD157             BNE.N    ??HAL_UART_Transmit_DMA_0
   1417            {
   1418              if ((pData == NULL) || (Size == 0U))
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD003             BEQ.N    ??HAL_UART_Transmit_DMA_1
   \       0x12   0x0018             MOVS     R0,R3
   \       0x14   0xB280             UXTH     R0,R0
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_2
   1419              {
   1420                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_DMA_1: (+1)
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE050             B.N      ??HAL_UART_Transmit_DMA_3
   1421              }
   1422          
   1423              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_DMA_2: (+1)
   \       0x1E   0xF894 0x0080      LDRB     R0,[R4, #+128]
   \       0x22   0x2801             CMP      R0,#+1
   \       0x24   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_4
   \       0x26   0x2002             MOVS     R0,#+2
   \       0x28   0xE04A             B.N      ??HAL_UART_Transmit_DMA_3
   \                     ??HAL_UART_Transmit_DMA_4: (+1)
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xF884 0x0080      STRB     R0,[R4, #+128]
   1424          
   1425              huart->pTxBuffPtr  = pData;
   \       0x30   0x6521             STR      R1,[R4, #+80]
   1426              huart->TxXferSize  = Size;
   \       0x32   0xF8A4 0x3054      STRH     R3,[R4, #+84]
   1427              huart->TxXferCount = Size;
   \       0x36   0xF8A4 0x3056      STRH     R3,[R4, #+86]
   1428          
   1429              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xF8C4 0x008C      STR      R0,[R4, #+140]
   1430              huart->gState = HAL_UART_STATE_BUSY_TX;
   \       0x40   0x2021             MOVS     R0,#+33
   \       0x42   0xF8C4 0x0084      STR      R0,[R4, #+132]
   1431          
   1432              if (huart->hdmatx != NULL)
   \       0x46   0x6FA0             LDR      R0,[R4, #+120]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD023             BEQ.N    ??HAL_UART_Transmit_DMA_5
   1433              {
   1434                /* Set the UART DMA transfer complete callback */
   1435                huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable9_5
   \       0x50   0x6FA1             LDR      R1,[R4, #+120]
   \       0x52   0x63C8             STR      R0,[R1, #+60]
   1436          
   1437                /* Set the UART DMA Half transfer complete callback */
   1438                huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable9_6
   \       0x58   0x6FA1             LDR      R1,[R4, #+120]
   \       0x5A   0x6408             STR      R0,[R1, #+64]
   1439          
   1440                /* Set the DMA error callback */
   1441                huart->hdmatx->XferErrorCallback = UART_DMAError;
   \       0x5C   0x.... 0x....      LDR.W    R0,??DataTable10
   \       0x60   0x6FA1             LDR      R1,[R4, #+120]
   \       0x62   0x64C8             STR      R0,[R1, #+76]
   1442          
   1443                /* Set the DMA abort callback */
   1444                huart->hdmatx->XferAbortCallback = NULL;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x6FA1             LDR      R1,[R4, #+120]
   \       0x68   0x6508             STR      R0,[R1, #+80]
   1445          
   1446                /* Enable the UART transmit DMA channel */
   1447                if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
   \       0x6A   0xB29B             UXTH     R3,R3
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0xF110 0x0228      ADDS     R2,R0,#+40
   \       0x72   0x6D21             LDR      R1,[R4, #+80]
   \       0x74   0x6FA0             LDR      R0,[R4, #+120]
   \       0x76   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD00A             BEQ.N    ??HAL_UART_Transmit_DMA_5
   1448                {
   1449                  /* Set error code to DMA */
   1450                  huart->ErrorCode = HAL_UART_ERROR_DMA;
   \       0x7E   0x2010             MOVS     R0,#+16
   \       0x80   0xF8C4 0x008C      STR      R0,[R4, #+140]
   1451          
   1452                  __HAL_UNLOCK(huart);
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0xF884 0x0080      STRB     R0,[R4, #+128]
   1453          
   1454                  /* Restore huart->gState to ready */
   1455                  huart->gState = HAL_UART_STATE_READY;
   \       0x8A   0x2020             MOVS     R0,#+32
   \       0x8C   0xF8C4 0x0084      STR      R0,[R4, #+132]
   1456          
   1457                  return HAL_ERROR;
   \       0x90   0x2001             MOVS     R0,#+1
   \       0x92   0xE015             B.N      ??HAL_UART_Transmit_DMA_3
   1458                }
   1459              }
   1460              /* Clear the TC flag in the ICR register */
   1461              __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
   \                     ??HAL_UART_Transmit_DMA_5: (+1)
   \       0x94   0x2040             MOVS     R0,#+64
   \       0x96   0x6821             LDR      R1,[R4, #+0]
   \       0x98   0x6208             STR      R0,[R1, #+32]
   1462          
   1463              __HAL_UNLOCK(huart);
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0xF884 0x0080      STRB     R0,[R4, #+128]
   1464          
   1465              /* Enable the DMA transfer for transmit request by setting the DMAT bit
   1466              in the UART CR3 register */
   1467              ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \                     ??HAL_UART_Transmit_DMA_6: (+1)
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x3008             ADDS     R0,R0,#+8
   \       0xA4   0xE850 0x1F00      LDREX    R1,[R0]
   \       0xA8   0xF051 0x0180      ORRS     R1,R1,#0x80
   \       0xAC   0x6820             LDR      R0,[R4, #+0]
   \       0xAE   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0xB2   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD1F2             BNE.N    ??HAL_UART_Transmit_DMA_6
   1468          
   1469              return HAL_OK;
   \       0xBA   0x2000             MOVS     R0,#+0
   \       0xBC   0xE000             B.N      ??HAL_UART_Transmit_DMA_3
   1470            }
   1471            else
   1472            {
   1473              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_DMA_0: (+1)
   \       0xBE   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_DMA_3: (+1)
   \       0xC0   0xBD10             POP      {R4,PC}
   1474            }
   1475          }
   1476          
   1477          /**
   1478            * @brief Receive an amount of data in DMA mode.
   1479            * @note   When the UART parity is enabled (PCE = 1), the received data contain
   1480            *         the parity bit (MSB position).
   1481            * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1482            *         the received data is handled as a set of u16. In this case, Size must indicate the number
   1483            *         of u16 available through pData.
   1484            * @param huart UART handle.
   1485            * @param pData Pointer to data buffer (u8 or u16 data elements).
   1486            * @param Size  Amount of data elements (u8 or u16) to be received.
   1487            * @retval HAL status
   1488            */

   \                                 In section .text, align 2, keep-with-next
   1489          HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
   1490          {
   \                     HAL_UART_Receive_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0003             MOVS     R3,R0
   1491            /* Check that a Rx process is not already ongoing */
   1492            if (huart->RxState == HAL_UART_STATE_READY)
   \        0x4   0xF8D3 0x0088      LDR      R0,[R3, #+136]
   \        0x8   0x2820             CMP      R0,#+32
   \        0xA   0xD12A             BNE.N    ??HAL_UART_Receive_DMA_0
   1493            {
   1494              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD003             BEQ.N    ??HAL_UART_Receive_DMA_1
   \       0x10   0x0010             MOVS     R0,R2
   \       0x12   0xB280             UXTH     R0,R0
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??HAL_UART_Receive_DMA_2
   1495              {
   1496                return HAL_ERROR;
   \                     ??HAL_UART_Receive_DMA_1: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE023             B.N      ??HAL_UART_Receive_DMA_3
   1497              }
   1498          
   1499              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_DMA_2: (+1)
   \       0x1C   0xF893 0x0080      LDRB     R0,[R3, #+128]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD101             BNE.N    ??HAL_UART_Receive_DMA_4
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0xE01D             B.N      ??HAL_UART_Receive_DMA_3
   \                     ??HAL_UART_Receive_DMA_4: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xF883 0x0080      STRB     R0,[R3, #+128]
   1500          
   1501              /* Set Reception type to Standard reception */
   1502              huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x66D8             STR      R0,[R3, #+108]
   1503          
   1504              if (!(IS_LPUART_INSTANCE(huart->Instance)))
   \       0x32   0x6818             LDR      R0,[R3, #+0]
   \       0x34   0x.... 0x....      LDR.W    R4,??DataTable9_4
   \       0x38   0x42A0             CMP      R0,R4
   \       0x3A   0xD00D             BEQ.N    ??HAL_UART_Receive_DMA_5
   1505              {
   1506                /* Check that USART RTOEN bit is set */
   1507                if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
   \       0x3C   0x6818             LDR      R0,[R3, #+0]
   \       0x3E   0x6840             LDR      R0,[R0, #+4]
   \       0x40   0x0200             LSLS     R0,R0,#+8
   \       0x42   0xD509             BPL.N    ??HAL_UART_Receive_DMA_5
   1508                {
   1509                  /* Enable the UART Receiver Timeout Interrupt */
   1510                  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
   \                     ??HAL_UART_Receive_DMA_6: (+1)
   \       0x44   0x6818             LDR      R0,[R3, #+0]
   \       0x46   0xE850 0x4F00      LDREX    R4,[R0]
   \       0x4A   0xF054 0x6480      ORRS     R4,R4,#0x4000000
   \       0x4E   0x681D             LDR      R5,[R3, #+0]
   \       0x50   0xE845 0x4000      STREX    R0,R4,[R5]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD1F5             BNE.N    ??HAL_UART_Receive_DMA_6
   1511                }
   1512              }
   1513          
   1514              return (UART_Start_Receive_DMA(huart, pData, Size));
   \                     ??HAL_UART_Receive_DMA_5: (+1)
   \       0x58   0xB292             UXTH     R2,R2
   \       0x5A   0x0018             MOVS     R0,R3
   \       0x5C   0x.... 0x....      BL       UART_Start_Receive_DMA
   \       0x60   0xE000             B.N      ??HAL_UART_Receive_DMA_3
   1515            }
   1516            else
   1517            {
   1518              return HAL_BUSY;
   \                     ??HAL_UART_Receive_DMA_0: (+1)
   \       0x62   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_DMA_3: (+1)
   \       0x64   0xBD32             POP      {R1,R4,R5,PC}
   1519            }
   1520          }
   1521          
   1522          /**
   1523            * @brief Pause the DMA Transfer.
   1524            * @param huart UART handle.
   1525            * @retval HAL status
   1526            */

   \                                 In section .text, align 2, keep-with-next
   1527          HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
   1528          {
   \                     HAL_UART_DMAPause: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0001             MOVS     R1,R0
   1529            const HAL_UART_StateTypeDef gstate = huart->gState;
   \        0x4   0xF8D1 0x0084      LDR      R0,[R1, #+132]
   1530            const HAL_UART_StateTypeDef rxstate = huart->RxState;
   \        0x8   0xF8D1 0x2088      LDR      R2,[R1, #+136]
   1531          
   1532            __HAL_LOCK(huart);
   \        0xC   0xF891 0x3080      LDRB     R3,[R1, #+128]
   \       0x10   0x2B01             CMP      R3,#+1
   \       0x12   0xD101             BNE.N    ??HAL_UART_DMAPause_0
   \       0x14   0x2002             MOVS     R0,#+2
   \       0x16   0xE043             B.N      ??HAL_UART_DMAPause_1
   \                     ??HAL_UART_DMAPause_0: (+1)
   \       0x18   0x2301             MOVS     R3,#+1
   \       0x1A   0xF881 0x3080      STRB     R3,[R1, #+128]
   1533          
   1534            if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
   1535                (gstate == HAL_UART_STATE_BUSY_TX))
   \       0x1E   0x680B             LDR      R3,[R1, #+0]
   \       0x20   0x689B             LDR      R3,[R3, #+8]
   \       0x22   0x061B             LSLS     R3,R3,#+24
   \       0x24   0xD50E             BPL.N    ??HAL_UART_DMAPause_2
   \       0x26   0x2821             CMP      R0,#+33
   \       0x28   0xD10C             BNE.N    ??HAL_UART_DMAPause_2
   1536            {
   1537              /* Disable the UART DMA Tx request */
   1538              ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \                     ??HAL_UART_DMAPause_3: (+1)
   \       0x2A   0x6808             LDR      R0,[R1, #+0]
   \       0x2C   0x3008             ADDS     R0,R0,#+8
   \       0x2E   0xE850 0x3F00      LDREX    R3,[R0]
   \       0x32   0xF033 0x0380      BICS     R3,R3,#0x80
   \       0x36   0x6808             LDR      R0,[R1, #+0]
   \       0x38   0xF110 0x0408      ADDS     R4,R0,#+8
   \       0x3C   0xE844 0x3000      STREX    R0,R3,[R4]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD1F2             BNE.N    ??HAL_UART_DMAPause_3
   1539            }
   1540            if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
   1541                (rxstate == HAL_UART_STATE_BUSY_RX))
   \                     ??HAL_UART_DMAPause_2: (+1)
   \       0x44   0x6808             LDR      R0,[R1, #+0]
   \       0x46   0x6880             LDR      R0,[R0, #+8]
   \       0x48   0x0640             LSLS     R0,R0,#+25
   \       0x4A   0xD525             BPL.N    ??HAL_UART_DMAPause_4
   \       0x4C   0x2A22             CMP      R2,#+34
   \       0x4E   0xD123             BNE.N    ??HAL_UART_DMAPause_4
   1542            {
   1543              /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
   1544              ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \                     ??HAL_UART_DMAPause_5: (+1)
   \       0x50   0x6808             LDR      R0,[R1, #+0]
   \       0x52   0xE850 0x2F00      LDREX    R2,[R0]
   \       0x56   0xF432 0x7280      BICS     R2,R2,#0x100
   \       0x5A   0x680B             LDR      R3,[R1, #+0]
   \       0x5C   0xE843 0x2000      STREX    R0,R2,[R3]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD1F5             BNE.N    ??HAL_UART_DMAPause_5
   1545              ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \                     ??HAL_UART_DMAPause_6: (+1)
   \       0x64   0x6808             LDR      R0,[R1, #+0]
   \       0x66   0x3008             ADDS     R0,R0,#+8
   \       0x68   0xE850 0x2F00      LDREX    R2,[R0]
   \       0x6C   0x0852             LSRS     R2,R2,#+1
   \       0x6E   0x0052             LSLS     R2,R2,#+1
   \       0x70   0x6808             LDR      R0,[R1, #+0]
   \       0x72   0xF110 0x0308      ADDS     R3,R0,#+8
   \       0x76   0xE843 0x2000      STREX    R0,R2,[R3]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD1F2             BNE.N    ??HAL_UART_DMAPause_6
   1546          
   1547              /* Disable the UART DMA Rx request */
   1548              ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_DMAPause_7: (+1)
   \       0x7E   0x6808             LDR      R0,[R1, #+0]
   \       0x80   0x3008             ADDS     R0,R0,#+8
   \       0x82   0xE850 0x2F00      LDREX    R2,[R0]
   \       0x86   0xF032 0x0240      BICS     R2,R2,#0x40
   \       0x8A   0x6808             LDR      R0,[R1, #+0]
   \       0x8C   0xF110 0x0308      ADDS     R3,R0,#+8
   \       0x90   0xE843 0x2000      STREX    R0,R2,[R3]
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD1F2             BNE.N    ??HAL_UART_DMAPause_7
   1549            }
   1550          
   1551            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAPause_4: (+1)
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0xF881 0x0080      STRB     R0,[R1, #+128]
   1552          
   1553            return HAL_OK;
   \       0x9E   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAPause_1: (+1)
   \       0xA0   0xBC10             POP      {R4}
   \       0xA2   0x4770             BX       LR
   1554          }
   1555          
   1556          /**
   1557            * @brief Resume the DMA Transfer.
   1558            * @param huart UART handle.
   1559            * @retval HAL status
   1560            */

   \                                 In section .text, align 2, keep-with-next
   1561          HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
   1562          {
   1563            __HAL_LOCK(huart);
   \                     HAL_UART_DMAResume: (+1)
   \        0x0   0xF890 0x1080      LDRB     R1,[R0, #+128]
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD101             BNE.N    ??HAL_UART_DMAResume_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xE045             B.N      ??HAL_UART_DMAResume_1
   \                     ??HAL_UART_DMAResume_0: (+1)
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0xF880 0x1080      STRB     R1,[R0, #+128]
   1564          
   1565            if (huart->gState == HAL_UART_STATE_BUSY_TX)
   \       0x12   0xF8D0 0x1084      LDR      R1,[R0, #+132]
   \       0x16   0x2921             CMP      R1,#+33
   \       0x18   0xD10C             BNE.N    ??HAL_UART_DMAResume_2
   1566            {
   1567              /* Enable the UART DMA Tx request */
   1568              ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \                     ??HAL_UART_DMAResume_3: (+1)
   \       0x1A   0x6801             LDR      R1,[R0, #+0]
   \       0x1C   0x3108             ADDS     R1,R1,#+8
   \       0x1E   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x22   0xF052 0x0280      ORRS     R2,R2,#0x80
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0xF111 0x0308      ADDS     R3,R1,#+8
   \       0x2C   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD1F2             BNE.N    ??HAL_UART_DMAResume_3
   1569            }
   1570            if (huart->RxState == HAL_UART_STATE_BUSY_RX)
   \                     ??HAL_UART_DMAResume_2: (+1)
   \       0x34   0xF8D0 0x1088      LDR      R1,[R0, #+136]
   \       0x38   0x2922             CMP      R1,#+34
   \       0x3A   0xD129             BNE.N    ??HAL_UART_DMAResume_4
   1571            {
   1572              /* Clear the Overrun flag before resuming the Rx transfer */
   1573              __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
   \       0x3C   0x2108             MOVS     R1,#+8
   \       0x3E   0x6802             LDR      R2,[R0, #+0]
   \       0x40   0x6211             STR      R1,[R2, #+32]
   1574          
   1575              /* Re-enable PE and ERR (Frame error, noise error, overrun error) interrupts */
   1576              if (huart->Init.Parity != UART_PARITY_NONE)
   \       0x42   0x6901             LDR      R1,[R0, #+16]
   \       0x44   0x2900             CMP      R1,#+0
   \       0x46   0xD009             BEQ.N    ??HAL_UART_DMAResume_5
   1577              {    
   1578                ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \                     ??HAL_UART_DMAResume_6: (+1)
   \       0x48   0x6801             LDR      R1,[R0, #+0]
   \       0x4A   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x4E   0xF452 0x7280      ORRS     R2,R2,#0x100
   \       0x52   0x6803             LDR      R3,[R0, #+0]
   \       0x54   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x58   0x2900             CMP      R1,#+0
   \       0x5A   0xD1F5             BNE.N    ??HAL_UART_DMAResume_6
   1579              }
   1580              ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \                     ??HAL_UART_DMAResume_5: (+1)
   \                     ??HAL_UART_DMAResume_7: (+1)
   \       0x5C   0x6801             LDR      R1,[R0, #+0]
   \       0x5E   0x3108             ADDS     R1,R1,#+8
   \       0x60   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x64   0xF052 0x0201      ORRS     R2,R2,#0x1
   \       0x68   0x6801             LDR      R1,[R0, #+0]
   \       0x6A   0xF111 0x0308      ADDS     R3,R1,#+8
   \       0x6E   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x72   0x2900             CMP      R1,#+0
   \       0x74   0xD1F2             BNE.N    ??HAL_UART_DMAResume_7
   1581          
   1582              /* Enable the UART DMA Rx request */
   1583              ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_DMAResume_8: (+1)
   \       0x76   0x6801             LDR      R1,[R0, #+0]
   \       0x78   0x3108             ADDS     R1,R1,#+8
   \       0x7A   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x7E   0xF052 0x0240      ORRS     R2,R2,#0x40
   \       0x82   0x6801             LDR      R1,[R0, #+0]
   \       0x84   0xF111 0x0308      ADDS     R3,R1,#+8
   \       0x88   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x8C   0x2900             CMP      R1,#+0
   \       0x8E   0xD1F2             BNE.N    ??HAL_UART_DMAResume_8
   1584            }
   1585          
   1586            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAResume_4: (+1)
   \       0x90   0x2100             MOVS     R1,#+0
   \       0x92   0xF880 0x1080      STRB     R1,[R0, #+128]
   1587          
   1588            return HAL_OK;
   \       0x96   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAResume_1: (+1)
   \       0x98   0x4770             BX       LR
   1589          }
   1590          
   1591          /**
   1592            * @brief Stop the DMA Transfer.
   1593            * @param huart UART handle.
   1594            * @retval HAL status
   1595            */

   \                                 In section .text, align 2, keep-with-next
   1596          HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
   1597          {
   \                     HAL_UART_DMAStop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1598            /* The Lock is not implemented on this API to allow the user application
   1599               to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() /
   1600               HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback:
   1601               indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete
   1602               interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of
   1603               the stream and the corresponding call back is executed. */
   1604          
   1605            const HAL_UART_StateTypeDef gstate = huart->gState;
   \        0x4   0xF8D4 0x0084      LDR      R0,[R4, #+132]
   1606            const HAL_UART_StateTypeDef rxstate = huart->RxState;
   \        0x8   0xF8D4 0x5088      LDR      R5,[R4, #+136]
   1607          
   1608            /* Stop UART DMA Tx request if ongoing */
   1609            if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
   1610                (gstate == HAL_UART_STATE_BUSY_TX))
   \        0xC   0x6821             LDR      R1,[R4, #+0]
   \        0xE   0x6889             LDR      R1,[R1, #+8]
   \       0x10   0x0609             LSLS     R1,R1,#+24
   \       0x12   0xD523             BPL.N    ??HAL_UART_DMAStop_0
   \       0x14   0x2821             CMP      R0,#+33
   \       0x16   0xD121             BNE.N    ??HAL_UART_DMAStop_0
   1611            {
   1612              ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \                     ??HAL_UART_DMAStop_1: (+1)
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x3008             ADDS     R0,R0,#+8
   \       0x1C   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x20   0xF031 0x0180      BICS     R1,R1,#0x80
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0x2A   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD1F2             BNE.N    ??HAL_UART_DMAStop_1
   1613          
   1614              /* Abort the UART DMA Tx channel */
   1615              if (huart->hdmatx != NULL)
   \       0x32   0x6FA0             LDR      R0,[R4, #+120]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD00E             BEQ.N    ??HAL_UART_DMAStop_2
   1616              {
   1617                if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
   \       0x38   0x6FA0             LDR      R0,[R4, #+120]
   \       0x3A   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD009             BEQ.N    ??HAL_UART_DMAStop_2
   1618                {
   1619                  if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
   \       0x42   0x6FA0             LDR      R0,[R4, #+120]
   \       0x44   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x48   0x2820             CMP      R0,#+32
   \       0x4A   0xD104             BNE.N    ??HAL_UART_DMAStop_2
   1620                  {
   1621                    /* Set error code to DMA */
   1622                    huart->ErrorCode = HAL_UART_ERROR_DMA;
   \       0x4C   0x2010             MOVS     R0,#+16
   \       0x4E   0xF8C4 0x008C      STR      R0,[R4, #+140]
   1623          
   1624                    return HAL_TIMEOUT;
   \       0x52   0x2003             MOVS     R0,#+3
   \       0x54   0xE02B             B.N      ??HAL_UART_DMAStop_3
   1625                  }
   1626                }
   1627              }
   1628          
   1629              UART_EndTxTransfer(huart);
   \                     ??HAL_UART_DMAStop_2: (+1)
   \       0x56   0x0020             MOVS     R0,R4
   \       0x58   0x.... 0x....      BL       UART_EndTxTransfer
   1630            }
   1631          
   1632            /* Stop UART DMA Rx request if ongoing */
   1633            if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
   1634                (rxstate == HAL_UART_STATE_BUSY_RX))
   \                     ??HAL_UART_DMAStop_0: (+1)
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x6880             LDR      R0,[R0, #+8]
   \       0x60   0x0640             LSLS     R0,R0,#+25
   \       0x62   0xD523             BPL.N    ??HAL_UART_DMAStop_4
   \       0x64   0x2D22             CMP      R5,#+34
   \       0x66   0xD121             BNE.N    ??HAL_UART_DMAStop_4
   1635            {
   1636              ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_DMAStop_5: (+1)
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x3008             ADDS     R0,R0,#+8
   \       0x6C   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x70   0xF031 0x0140      BICS     R1,R1,#0x40
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0x7A   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD1F2             BNE.N    ??HAL_UART_DMAStop_5
   1637          
   1638              /* Abort the UART DMA Rx channel */
   1639              if (huart->hdmarx != NULL)
   \       0x82   0x6FE0             LDR      R0,[R4, #+124]
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD00E             BEQ.N    ??HAL_UART_DMAStop_6
   1640              {
   1641                if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
   \       0x88   0x6FE0             LDR      R0,[R4, #+124]
   \       0x8A   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD009             BEQ.N    ??HAL_UART_DMAStop_6
   1642                {
   1643                  if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
   \       0x92   0x6FE0             LDR      R0,[R4, #+124]
   \       0x94   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x98   0x2820             CMP      R0,#+32
   \       0x9A   0xD104             BNE.N    ??HAL_UART_DMAStop_6
   1644                  {
   1645                    /* Set error code to DMA */
   1646                    huart->ErrorCode = HAL_UART_ERROR_DMA;
   \       0x9C   0x2010             MOVS     R0,#+16
   \       0x9E   0xF8C4 0x008C      STR      R0,[R4, #+140]
   1647          
   1648                    return HAL_TIMEOUT;
   \       0xA2   0x2003             MOVS     R0,#+3
   \       0xA4   0xE003             B.N      ??HAL_UART_DMAStop_3
   1649                  }
   1650                }
   1651              }
   1652          
   1653              UART_EndRxTransfer(huart);
   \                     ??HAL_UART_DMAStop_6: (+1)
   \       0xA6   0x0020             MOVS     R0,R4
   \       0xA8   0x.... 0x....      BL       UART_EndRxTransfer
   1654            }
   1655          
   1656            return HAL_OK;
   \                     ??HAL_UART_DMAStop_4: (+1)
   \       0xAC   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAStop_3: (+1)
   \       0xAE   0xBD32             POP      {R1,R4,R5,PC}
   1657          }
   1658          
   1659          /**
   1660            * @brief  Abort ongoing transfers (blocking mode).
   1661            * @param  huart UART handle.
   1662            * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode.
   1663            *         This procedure performs following operations :
   1664            *           - Disable UART Interrupts (Tx and Rx)
   1665            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1666            *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
   1667            *           - Set handle State to READY
   1668            * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
   1669            * @retval HAL status
   1670            */

   \                                 In section .text, align 2, keep-with-next
   1671          HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
   1672          {
   \                     HAL_UART_Abort: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1673            /* Disable TXE, TC, RXNE, PE, RXFT, TXFT and ERR (Frame error, noise error, overrun error) interrupts */
   1674            ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
   1675                                                    USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
   \                     ??HAL_UART_Abort_0: (+1)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0xE850 0x1F00      LDREX    R1,[R0]
   \        0xA   0xF431 0x71F0      BICS     R1,R1,#0x1E0
   \        0xE   0x6822             LDR      R2,[R4, #+0]
   \       0x10   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD1F5             BNE.N    ??HAL_UART_Abort_0
   1676            ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE);
   \                     ??HAL_UART_Abort_1: (+1)
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x3008             ADDS     R0,R0,#+8
   \       0x1C   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x24   0x4001             ANDS     R1,R0,R1
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0x2C   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD1F1             BNE.N    ??HAL_UART_Abort_1
   1677          
   1678            /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
   1679            if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
   \       0x34   0x6EE0             LDR      R0,[R4, #+108]
   \       0x36   0x2801             CMP      R0,#+1
   \       0x38   0xD109             BNE.N    ??HAL_UART_Abort_2
   1680            {
   1681              ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
   \                     ??HAL_UART_Abort_3: (+1)
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x40   0xF031 0x0110      BICS     R1,R1,#0x10
   \       0x44   0x6822             LDR      R2,[R4, #+0]
   \       0x46   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD1F5             BNE.N    ??HAL_UART_Abort_3
   1682            }
   1683          
   1684            /* Abort the UART DMA Tx channel if enabled */
   1685            if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
   \                     ??HAL_UART_Abort_2: (+1)
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x6880             LDR      R0,[R0, #+8]
   \       0x52   0x0600             LSLS     R0,R0,#+24
   \       0x54   0xD521             BPL.N    ??HAL_UART_Abort_4
   1686            {
   1687              /* Disable the UART DMA Tx request if enabled */
   1688              ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \                     ??HAL_UART_Abort_5: (+1)
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x3008             ADDS     R0,R0,#+8
   \       0x5A   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x5E   0xF031 0x0180      BICS     R1,R1,#0x80
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0x68   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD1F2             BNE.N    ??HAL_UART_Abort_5
   1689          
   1690              /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
   1691              if (huart->hdmatx != NULL)
   \       0x70   0x6FA0             LDR      R0,[R4, #+120]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD011             BEQ.N    ??HAL_UART_Abort_4
   1692              {
   1693                /* Set the UART DMA Abort callback to Null.
   1694                   No call back execution at end of DMA abort procedure */
   1695                huart->hdmatx->XferAbortCallback = NULL;
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x6FA1             LDR      R1,[R4, #+120]
   \       0x7A   0x6508             STR      R0,[R1, #+80]
   1696          
   1697                if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
   \       0x7C   0x6FA0             LDR      R0,[R4, #+120]
   \       0x7E   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD009             BEQ.N    ??HAL_UART_Abort_4
   1698                {
   1699                  if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
   \       0x86   0x6FA0             LDR      R0,[R4, #+120]
   \       0x88   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x8C   0x2820             CMP      R0,#+32
   \       0x8E   0xD104             BNE.N    ??HAL_UART_Abort_4
   1700                  {
   1701                    /* Set error code to DMA */
   1702                    huart->ErrorCode = HAL_UART_ERROR_DMA;
   \       0x90   0x2010             MOVS     R0,#+16
   \       0x92   0xF8C4 0x008C      STR      R0,[R4, #+140]
   1703          
   1704                    return HAL_TIMEOUT;
   \       0x96   0x2003             MOVS     R0,#+3
   \       0x98   0xE04A             B.N      ??HAL_UART_Abort_6
   1705                  }
   1706                }
   1707              }
   1708            }
   1709          
   1710            /* Abort the UART DMA Rx channel if enabled */
   1711            if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \                     ??HAL_UART_Abort_4: (+1)
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x6880             LDR      R0,[R0, #+8]
   \       0x9E   0x0640             LSLS     R0,R0,#+25
   \       0xA0   0xD521             BPL.N    ??HAL_UART_Abort_7
   1712            {
   1713              /* Disable the UART DMA Rx request if enabled */
   1714              ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_Abort_8: (+1)
   \       0xA2   0x6820             LDR      R0,[R4, #+0]
   \       0xA4   0x3008             ADDS     R0,R0,#+8
   \       0xA6   0xE850 0x1F00      LDREX    R1,[R0]
   \       0xAA   0xF031 0x0140      BICS     R1,R1,#0x40
   \       0xAE   0x6820             LDR      R0,[R4, #+0]
   \       0xB0   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0xB4   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD1F2             BNE.N    ??HAL_UART_Abort_8
   1715          
   1716              /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
   1717              if (huart->hdmarx != NULL)
   \       0xBC   0x6FE0             LDR      R0,[R4, #+124]
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD011             BEQ.N    ??HAL_UART_Abort_7
   1718              {
   1719                /* Set the UART DMA Abort callback to Null.
   1720                   No call back execution at end of DMA abort procedure */
   1721                huart->hdmarx->XferAbortCallback = NULL;
   \       0xC2   0x2000             MOVS     R0,#+0
   \       0xC4   0x6FE1             LDR      R1,[R4, #+124]
   \       0xC6   0x6508             STR      R0,[R1, #+80]
   1722          
   1723                if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
   \       0xC8   0x6FE0             LDR      R0,[R4, #+124]
   \       0xCA   0x.... 0x....      BL       HAL_DMA_Abort
   \       0xCE   0x2800             CMP      R0,#+0
   \       0xD0   0xD009             BEQ.N    ??HAL_UART_Abort_7
   1724                {
   1725                  if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
   \       0xD2   0x6FE0             LDR      R0,[R4, #+124]
   \       0xD4   0x.... 0x....      BL       HAL_DMA_GetError
   \       0xD8   0x2820             CMP      R0,#+32
   \       0xDA   0xD104             BNE.N    ??HAL_UART_Abort_7
   1726                  {
   1727                    /* Set error code to DMA */
   1728                    huart->ErrorCode = HAL_UART_ERROR_DMA;
   \       0xDC   0x2010             MOVS     R0,#+16
   \       0xDE   0xF8C4 0x008C      STR      R0,[R4, #+140]
   1729          
   1730                    return HAL_TIMEOUT;
   \       0xE2   0x2003             MOVS     R0,#+3
   \       0xE4   0xE024             B.N      ??HAL_UART_Abort_6
   1731                  }
   1732                }
   1733              }
   1734            }
   1735          
   1736            /* Reset Tx and Rx transfer counters */
   1737            huart->TxXferCount = 0U;
   \                     ??HAL_UART_Abort_7: (+1)
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0xF8A4 0x0056      STRH     R0,[R4, #+86]
   1738            huart->RxXferCount = 0U;
   \       0xEC   0x2000             MOVS     R0,#+0
   \       0xEE   0xF8A4 0x005E      STRH     R0,[R4, #+94]
   1739          
   1740            /* Clear the Error flags in the ICR register */
   1741            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
   \       0xF2   0x200F             MOVS     R0,#+15
   \       0xF4   0x6821             LDR      R1,[R4, #+0]
   \       0xF6   0x6208             STR      R0,[R1, #+32]
   1742          
   1743            /* Flush the whole TX FIFO (if needed) */
   1744            if (huart->FifoMode == UART_FIFOMODE_ENABLE)
   \       0xF8   0x6E60             LDR      R0,[R4, #+100]
   \       0xFA   0xF1B0 0x5F00      CMP      R0,#+536870912
   \       0xFE   0xD105             BNE.N    ??HAL_UART_Abort_9
   1745            {
   1746              __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
   \      0x100   0x6820             LDR      R0,[R4, #+0]
   \      0x102   0x6980             LDR      R0,[R0, #+24]
   \      0x104   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x108   0x6821             LDR      R1,[R4, #+0]
   \      0x10A   0x6188             STR      R0,[R1, #+24]
   1747            }
   1748          
   1749            /* Discard the received data */
   1750            __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
   \                     ??HAL_UART_Abort_9: (+1)
   \      0x10C   0x6820             LDR      R0,[R4, #+0]
   \      0x10E   0x6980             LDR      R0,[R0, #+24]
   \      0x110   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x114   0x6821             LDR      R1,[R4, #+0]
   \      0x116   0x6188             STR      R0,[R1, #+24]
   1751          
   1752            /* Restore huart->gState and huart->RxState to Ready */
   1753            huart->gState  = HAL_UART_STATE_READY;
   \      0x118   0x2020             MOVS     R0,#+32
   \      0x11A   0xF8C4 0x0084      STR      R0,[R4, #+132]
   1754            huart->RxState = HAL_UART_STATE_READY;
   \      0x11E   0x2020             MOVS     R0,#+32
   \      0x120   0xF8C4 0x0088      STR      R0,[R4, #+136]
   1755            huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \      0x124   0x2000             MOVS     R0,#+0
   \      0x126   0x66E0             STR      R0,[R4, #+108]
   1756          
   1757            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \      0x128   0x2000             MOVS     R0,#+0
   \      0x12A   0xF8C4 0x008C      STR      R0,[R4, #+140]
   1758          
   1759            return HAL_OK;
   \      0x12E   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_Abort_6: (+1)
   \      0x130   0xBD10             POP      {R4,PC}
   1760          }
   1761          
   1762          /**
   1763            * @brief  Abort ongoing Transmit transfer (blocking mode).
   1764            * @param  huart UART handle.
   1765            * @note   This procedure could be used for aborting any ongoing Tx transfer started in Interrupt or DMA mode.
   1766            *         This procedure performs following operations :
   1767            *           - Disable UART Interrupts (Tx)
   1768            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1769            *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
   1770            *           - Set handle State to READY
   1771            * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
   1772            * @retval HAL status
   1773            */

   \                                 In section .text, align 2, keep-with-next
   1774          HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
   1775          {
   \                     HAL_UART_AbortTransmit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1776            /* Disable TCIE, TXEIE and TXFTIE interrupts */
   1777            ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TCIE | USART_CR1_TXEIE_TXFNFIE));
   \                     ??HAL_UART_AbortTransmit_0: (+1)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0xE850 0x1F00      LDREX    R1,[R0]
   \        0xA   0xF031 0x01C0      BICS     R1,R1,#0xC0
   \        0xE   0x6822             LDR      R2,[R4, #+0]
   \       0x10   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD1F5             BNE.N    ??HAL_UART_AbortTransmit_0
   1778            ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
   \                     ??HAL_UART_AbortTransmit_1: (+1)
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x3008             ADDS     R0,R0,#+8
   \       0x1C   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x20   0xF431 0x0100      BICS     R1,R1,#0x800000
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0x2A   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD1F2             BNE.N    ??HAL_UART_AbortTransmit_1
   1779          
   1780            /* Abort the UART DMA Tx channel if enabled */
   1781            if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x6880             LDR      R0,[R0, #+8]
   \       0x36   0x0600             LSLS     R0,R0,#+24
   \       0x38   0xD521             BPL.N    ??HAL_UART_AbortTransmit_2
   1782            {
   1783              /* Disable the UART DMA Tx request if enabled */
   1784              ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \                     ??HAL_UART_AbortTransmit_3: (+1)
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x3008             ADDS     R0,R0,#+8
   \       0x3E   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x42   0xF031 0x0180      BICS     R1,R1,#0x80
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0x4C   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD1F2             BNE.N    ??HAL_UART_AbortTransmit_3
   1785          
   1786              /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
   1787              if (huart->hdmatx != NULL)
   \       0x54   0x6FA0             LDR      R0,[R4, #+120]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD011             BEQ.N    ??HAL_UART_AbortTransmit_2
   1788              {
   1789                /* Set the UART DMA Abort callback to Null.
   1790                   No call back execution at end of DMA abort procedure */
   1791                huart->hdmatx->XferAbortCallback = NULL;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x6FA1             LDR      R1,[R4, #+120]
   \       0x5E   0x6508             STR      R0,[R1, #+80]
   1792          
   1793                if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
   \       0x60   0x6FA0             LDR      R0,[R4, #+120]
   \       0x62   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD009             BEQ.N    ??HAL_UART_AbortTransmit_2
   1794                {
   1795                  if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
   \       0x6A   0x6FA0             LDR      R0,[R4, #+120]
   \       0x6C   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x70   0x2820             CMP      R0,#+32
   \       0x72   0xD104             BNE.N    ??HAL_UART_AbortTransmit_2
   1796                  {
   1797                    /* Set error code to DMA */
   1798                    huart->ErrorCode = HAL_UART_ERROR_DMA;
   \       0x74   0x2010             MOVS     R0,#+16
   \       0x76   0xF8C4 0x008C      STR      R0,[R4, #+140]
   1799          
   1800                    return HAL_TIMEOUT;
   \       0x7A   0x2003             MOVS     R0,#+3
   \       0x7C   0xE010             B.N      ??HAL_UART_AbortTransmit_4
   1801                  }
   1802                }
   1803              }
   1804            }
   1805          
   1806            /* Reset Tx transfer counter */
   1807            huart->TxXferCount = 0U;
   \                     ??HAL_UART_AbortTransmit_2: (+1)
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0xF8A4 0x0056      STRH     R0,[R4, #+86]
   1808          
   1809            /* Flush the whole TX FIFO (if needed) */
   1810            if (huart->FifoMode == UART_FIFOMODE_ENABLE)
   \       0x84   0x6E60             LDR      R0,[R4, #+100]
   \       0x86   0xF1B0 0x5F00      CMP      R0,#+536870912
   \       0x8A   0xD105             BNE.N    ??HAL_UART_AbortTransmit_5
   1811            {
   1812              __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x6980             LDR      R0,[R0, #+24]
   \       0x90   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x94   0x6821             LDR      R1,[R4, #+0]
   \       0x96   0x6188             STR      R0,[R1, #+24]
   1813            }
   1814          
   1815            /* Restore huart->gState to Ready */
   1816            huart->gState = HAL_UART_STATE_READY;
   \                     ??HAL_UART_AbortTransmit_5: (+1)
   \       0x98   0x2020             MOVS     R0,#+32
   \       0x9A   0xF8C4 0x0084      STR      R0,[R4, #+132]
   1817          
   1818            return HAL_OK;
   \       0x9E   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_AbortTransmit_4: (+1)
   \       0xA0   0xBD10             POP      {R4,PC}
   1819          }
   1820          
   1821          /**
   1822            * @brief  Abort ongoing Receive transfer (blocking mode).
   1823            * @param  huart UART handle.
   1824            * @note   This procedure could be used for aborting any ongoing Rx transfer started in Interrupt or DMA mode.
   1825            *         This procedure performs following operations :
   1826            *           - Disable UART Interrupts (Rx)
   1827            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1828            *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
   1829            *           - Set handle State to READY
   1830            * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
   1831            * @retval HAL status
   1832            */

   \                                 In section .text, align 2, keep-with-next
   1833          HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
   1834          {
   \                     HAL_UART_AbortReceive: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1835            /* Disable PEIE, EIE, RXNEIE and RXFTIE interrupts */
   1836            ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE));
   \                     ??HAL_UART_AbortReceive_0: (+1)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0xE850 0x1F00      LDREX    R1,[R0]
   \        0xA   0xF431 0x7190      BICS     R1,R1,#0x120
   \        0xE   0x6822             LDR      R2,[R4, #+0]
   \       0x10   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD1F5             BNE.N    ??HAL_UART_AbortReceive_0
   1837            ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE | USART_CR3_RXFTIE);
   \                     ??HAL_UART_AbortReceive_1: (+1)
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x3008             ADDS     R0,R0,#+8
   \       0x1C   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x24   0x4001             ANDS     R1,R0,R1
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0x2C   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD1F1             BNE.N    ??HAL_UART_AbortReceive_1
   1838          
   1839            /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
   1840            if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
   \       0x34   0x6EE0             LDR      R0,[R4, #+108]
   \       0x36   0x2801             CMP      R0,#+1
   \       0x38   0xD109             BNE.N    ??HAL_UART_AbortReceive_2
   1841            {
   1842              ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
   \                     ??HAL_UART_AbortReceive_3: (+1)
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x40   0xF031 0x0110      BICS     R1,R1,#0x10
   \       0x44   0x6822             LDR      R2,[R4, #+0]
   \       0x46   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD1F5             BNE.N    ??HAL_UART_AbortReceive_3
   1843            }
   1844          
   1845            /* Abort the UART DMA Rx channel if enabled */
   1846            if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \                     ??HAL_UART_AbortReceive_2: (+1)
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x6880             LDR      R0,[R0, #+8]
   \       0x52   0x0640             LSLS     R0,R0,#+25
   \       0x54   0xD521             BPL.N    ??HAL_UART_AbortReceive_4
   1847            {
   1848              /* Disable the UART DMA Rx request if enabled */
   1849              ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_AbortReceive_5: (+1)
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x3008             ADDS     R0,R0,#+8
   \       0x5A   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x5E   0xF031 0x0140      BICS     R1,R1,#0x40
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0x68   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD1F2             BNE.N    ??HAL_UART_AbortReceive_5
   1850          
   1851              /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
   1852              if (huart->hdmarx != NULL)
   \       0x70   0x6FE0             LDR      R0,[R4, #+124]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD011             BEQ.N    ??HAL_UART_AbortReceive_4
   1853              {
   1854                /* Set the UART DMA Abort callback to Null.
   1855                   No call back execution at end of DMA abort procedure */
   1856                huart->hdmarx->XferAbortCallback = NULL;
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x6FE1             LDR      R1,[R4, #+124]
   \       0x7A   0x6508             STR      R0,[R1, #+80]
   1857          
   1858                if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
   \       0x7C   0x6FE0             LDR      R0,[R4, #+124]
   \       0x7E   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD009             BEQ.N    ??HAL_UART_AbortReceive_4
   1859                {
   1860                  if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
   \       0x86   0x6FE0             LDR      R0,[R4, #+124]
   \       0x88   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x8C   0x2820             CMP      R0,#+32
   \       0x8E   0xD104             BNE.N    ??HAL_UART_AbortReceive_4
   1861                  {
   1862                    /* Set error code to DMA */
   1863                    huart->ErrorCode = HAL_UART_ERROR_DMA;
   \       0x90   0x2010             MOVS     R0,#+16
   \       0x92   0xF8C4 0x008C      STR      R0,[R4, #+140]
   1864          
   1865                    return HAL_TIMEOUT;
   \       0x96   0x2003             MOVS     R0,#+3
   \       0x98   0xE011             B.N      ??HAL_UART_AbortReceive_6
   1866                  }
   1867                }
   1868              }
   1869            }
   1870          
   1871            /* Reset Rx transfer counter */
   1872            huart->RxXferCount = 0U;
   \                     ??HAL_UART_AbortReceive_4: (+1)
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0xF8A4 0x005E      STRH     R0,[R4, #+94]
   1873          
   1874            /* Clear the Error flags in the ICR register */
   1875            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
   \       0xA0   0x200F             MOVS     R0,#+15
   \       0xA2   0x6821             LDR      R1,[R4, #+0]
   \       0xA4   0x6208             STR      R0,[R1, #+32]
   1876          
   1877            /* Discard the received data */
   1878            __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
   \       0xA6   0x6820             LDR      R0,[R4, #+0]
   \       0xA8   0x6980             LDR      R0,[R0, #+24]
   \       0xAA   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0xAE   0x6821             LDR      R1,[R4, #+0]
   \       0xB0   0x6188             STR      R0,[R1, #+24]
   1879          
   1880            /* Restore huart->RxState to Ready */
   1881            huart->RxState = HAL_UART_STATE_READY;
   \       0xB2   0x2020             MOVS     R0,#+32
   \       0xB4   0xF8C4 0x0088      STR      R0,[R4, #+136]
   1882            huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \       0xB8   0x2000             MOVS     R0,#+0
   \       0xBA   0x66E0             STR      R0,[R4, #+108]
   1883          
   1884            return HAL_OK;
   \       0xBC   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_AbortReceive_6: (+1)
   \       0xBE   0xBD10             POP      {R4,PC}
   1885          }
   1886          
   1887          /**
   1888            * @brief  Abort ongoing transfers (Interrupt mode).
   1889            * @param  huart UART handle.
   1890            * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode.
   1891            *         This procedure performs following operations :
   1892            *           - Disable UART Interrupts (Tx and Rx)
   1893            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1894            *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
   1895            *           - Set handle State to READY
   1896            *           - At abort completion, call user abort complete callback
   1897            * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
   1898            *         considered as completed only when user abort complete callback is executed (not when exiting function).
   1899            * @retval HAL status
   1900            */

   \                                 In section .text, align 2, keep-with-next
   1901          HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
   1902          {
   \                     HAL_UART_Abort_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1903            uint32_t abortcplt = 1U;
   \        0x4   0x2501             MOVS     R5,#+1
   1904          
   1905            /* Disable interrupts */
   1906            ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_TCIE | USART_CR1_RXNEIE_RXFNEIE |
   1907                                                    USART_CR1_TXEIE_TXFNFIE));
   \                     ??HAL_UART_Abort_IT_0: (+1)
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0xE850 0x1F00      LDREX    R1,[R0]
   \        0xC   0xF431 0x71F0      BICS     R1,R1,#0x1E0
   \       0x10   0x6822             LDR      R2,[R4, #+0]
   \       0x12   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD1F5             BNE.N    ??HAL_UART_Abort_IT_0
   1908            ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE));
   \                     ??HAL_UART_Abort_IT_1: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x3008             ADDS     R0,R0,#+8
   \       0x1E   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x26   0x4001             ANDS     R1,R0,R1
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0x2E   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD1F1             BNE.N    ??HAL_UART_Abort_IT_1
   1909          
   1910            /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
   1911            if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
   \       0x36   0x6EE0             LDR      R0,[R4, #+108]
   \       0x38   0x2801             CMP      R0,#+1
   \       0x3A   0xD109             BNE.N    ??HAL_UART_Abort_IT_2
   1912            {
   1913              ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
   \                     ??HAL_UART_Abort_IT_3: (+1)
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x42   0xF031 0x0110      BICS     R1,R1,#0x10
   \       0x46   0x6822             LDR      R2,[R4, #+0]
   \       0x48   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD1F5             BNE.N    ??HAL_UART_Abort_IT_3
   1914            }
   1915          
   1916            /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
   1917               before any call to DMA Abort functions */
   1918            /* DMA Tx Handle is valid */
   1919            if (huart->hdmatx != NULL)
   \                     ??HAL_UART_Abort_IT_2: (+1)
   \       0x50   0x6FA0             LDR      R0,[R4, #+120]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD00B             BEQ.N    ??HAL_UART_Abort_IT_4
   1920            {
   1921              /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
   1922                 Otherwise, set it to NULL */
   1923              if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x6880             LDR      R0,[R0, #+8]
   \       0x5A   0x0600             LSLS     R0,R0,#+24
   \       0x5C   0xD504             BPL.N    ??HAL_UART_Abort_IT_5
   1924              {
   1925                huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x62   0x6FA1             LDR      R1,[R4, #+120]
   \       0x64   0x6508             STR      R0,[R1, #+80]
   \       0x66   0xE002             B.N      ??HAL_UART_Abort_IT_4
   1926              }
   1927              else
   1928              {
   1929                huart->hdmatx->XferAbortCallback = NULL;
   \                     ??HAL_UART_Abort_IT_5: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0x6FA1             LDR      R1,[R4, #+120]
   \       0x6C   0x6508             STR      R0,[R1, #+80]
   1930              }
   1931            }
   1932            /* DMA Rx Handle is valid */
   1933            if (huart->hdmarx != NULL)
   \                     ??HAL_UART_Abort_IT_4: (+1)
   \       0x6E   0x6FE0             LDR      R0,[R4, #+124]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD00B             BEQ.N    ??HAL_UART_Abort_IT_6
   1934            {
   1935              /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
   1936                 Otherwise, set it to NULL */
   1937              if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x6880             LDR      R0,[R0, #+8]
   \       0x78   0x0640             LSLS     R0,R0,#+25
   \       0x7A   0xD504             BPL.N    ??HAL_UART_Abort_IT_7
   1938              {
   1939                huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
   \       0x7C   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \       0x80   0x6FE1             LDR      R1,[R4, #+124]
   \       0x82   0x6508             STR      R0,[R1, #+80]
   \       0x84   0xE002             B.N      ??HAL_UART_Abort_IT_6
   1940              }
   1941              else
   1942              {
   1943                huart->hdmarx->XferAbortCallback = NULL;
   \                     ??HAL_UART_Abort_IT_7: (+1)
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0x6FE1             LDR      R1,[R4, #+124]
   \       0x8A   0x6508             STR      R0,[R1, #+80]
   1944              }
   1945            }
   1946          
   1947            /* Abort the UART DMA Tx channel if enabled */
   1948            if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
   \                     ??HAL_UART_Abort_IT_6: (+1)
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x6880             LDR      R0,[R0, #+8]
   \       0x90   0x0600             LSLS     R0,R0,#+24
   \       0x92   0xD519             BPL.N    ??HAL_UART_Abort_IT_8
   1949            {
   1950              /* Disable DMA Tx at UART level */
   1951              ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \                     ??HAL_UART_Abort_IT_9: (+1)
   \       0x94   0x6820             LDR      R0,[R4, #+0]
   \       0x96   0x3008             ADDS     R0,R0,#+8
   \       0x98   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x9C   0xF031 0x0180      BICS     R1,R1,#0x80
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0xA6   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD1F2             BNE.N    ??HAL_UART_Abort_IT_9
   1952          
   1953              /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
   1954              if (huart->hdmatx != NULL)
   \       0xAE   0x6FA0             LDR      R0,[R4, #+120]
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD009             BEQ.N    ??HAL_UART_Abort_IT_8
   1955              {
   1956                /* UART Tx DMA Abort callback has already been initialised :
   1957                   will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
   1958          
   1959                /* Abort DMA TX */
   1960                if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
   \       0xB4   0x6FA0             LDR      R0,[R4, #+120]
   \       0xB6   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD003             BEQ.N    ??HAL_UART_Abort_IT_10
   1961                {
   1962                  huart->hdmatx->XferAbortCallback = NULL;
   \       0xBE   0x2000             MOVS     R0,#+0
   \       0xC0   0x6FA1             LDR      R1,[R4, #+120]
   \       0xC2   0x6508             STR      R0,[R1, #+80]
   \       0xC4   0xE000             B.N      ??HAL_UART_Abort_IT_8
   1963                }
   1964                else
   1965                {
   1966                  abortcplt = 0U;
   \                     ??HAL_UART_Abort_IT_10: (+1)
   \       0xC6   0x2500             MOVS     R5,#+0
   1967                }
   1968              }
   1969            }
   1970          
   1971            /* Abort the UART DMA Rx channel if enabled */
   1972            if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \                     ??HAL_UART_Abort_IT_8: (+1)
   \       0xC8   0x6820             LDR      R0,[R4, #+0]
   \       0xCA   0x6880             LDR      R0,[R0, #+8]
   \       0xCC   0x0640             LSLS     R0,R0,#+25
   \       0xCE   0xD51A             BPL.N    ??HAL_UART_Abort_IT_11
   1973            {
   1974              /* Disable the UART DMA Rx request if enabled */
   1975              ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_Abort_IT_12: (+1)
   \       0xD0   0x6820             LDR      R0,[R4, #+0]
   \       0xD2   0x3008             ADDS     R0,R0,#+8
   \       0xD4   0xE850 0x1F00      LDREX    R1,[R0]
   \       0xD8   0xF031 0x0140      BICS     R1,R1,#0x40
   \       0xDC   0x6820             LDR      R0,[R4, #+0]
   \       0xDE   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0xE2   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xD1F2             BNE.N    ??HAL_UART_Abort_IT_12
   1976          
   1977              /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
   1978              if (huart->hdmarx != NULL)
   \       0xEA   0x6FE0             LDR      R0,[R4, #+124]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD00A             BEQ.N    ??HAL_UART_Abort_IT_11
   1979              {
   1980                /* UART Rx DMA Abort callback has already been initialised :
   1981                   will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
   1982          
   1983                /* Abort DMA RX */
   1984                if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
   \       0xF0   0x6FE0             LDR      R0,[R4, #+124]
   \       0xF2   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0xF6   0x2800             CMP      R0,#+0
   \       0xF8   0xD004             BEQ.N    ??HAL_UART_Abort_IT_13
   1985                {
   1986                  huart->hdmarx->XferAbortCallback = NULL;
   \       0xFA   0x2000             MOVS     R0,#+0
   \       0xFC   0x6FE1             LDR      R1,[R4, #+124]
   \       0xFE   0x6508             STR      R0,[R1, #+80]
   1987                  abortcplt = 1U;
   \      0x100   0x2501             MOVS     R5,#+1
   \      0x102   0xE000             B.N      ??HAL_UART_Abort_IT_11
   1988                }
   1989                else
   1990                {
   1991                  abortcplt = 0U;
   \                     ??HAL_UART_Abort_IT_13: (+1)
   \      0x104   0x2500             MOVS     R5,#+0
   1992                }
   1993              }
   1994            }
   1995          
   1996            /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
   1997            if (abortcplt == 1U)
   \                     ??HAL_UART_Abort_IT_11: (+1)
   \      0x106   0x2D01             CMP      R5,#+1
   \      0x108   0xD12A             BNE.N    ??HAL_UART_Abort_IT_14
   1998            {
   1999              /* Reset Tx and Rx transfer counters */
   2000              huart->TxXferCount = 0U;
   \      0x10A   0x2000             MOVS     R0,#+0
   \      0x10C   0xF8A4 0x0056      STRH     R0,[R4, #+86]
   2001              huart->RxXferCount = 0U;
   \      0x110   0x2000             MOVS     R0,#+0
   \      0x112   0xF8A4 0x005E      STRH     R0,[R4, #+94]
   2002          
   2003              /* Clear ISR function pointers */
   2004              huart->RxISR = NULL;
   \      0x116   0x2000             MOVS     R0,#+0
   \      0x118   0x6720             STR      R0,[R4, #+112]
   2005              huart->TxISR = NULL;
   \      0x11A   0x2000             MOVS     R0,#+0
   \      0x11C   0x6760             STR      R0,[R4, #+116]
   2006          
   2007              /* Reset errorCode */
   2008              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \      0x11E   0x2000             MOVS     R0,#+0
   \      0x120   0xF8C4 0x008C      STR      R0,[R4, #+140]
   2009          
   2010              /* Clear the Error flags in the ICR register */
   2011              __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
   \      0x124   0x200F             MOVS     R0,#+15
   \      0x126   0x6821             LDR      R1,[R4, #+0]
   \      0x128   0x6208             STR      R0,[R1, #+32]
   2012          
   2013              /* Flush the whole TX FIFO (if needed) */
   2014              if (huart->FifoMode == UART_FIFOMODE_ENABLE)
   \      0x12A   0x6E60             LDR      R0,[R4, #+100]
   \      0x12C   0xF1B0 0x5F00      CMP      R0,#+536870912
   \      0x130   0xD105             BNE.N    ??HAL_UART_Abort_IT_15
   2015              {
   2016                __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
   \      0x132   0x6820             LDR      R0,[R4, #+0]
   \      0x134   0x6980             LDR      R0,[R0, #+24]
   \      0x136   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x13A   0x6821             LDR      R1,[R4, #+0]
   \      0x13C   0x6188             STR      R0,[R1, #+24]
   2017              }
   2018          
   2019              /* Discard the received data */
   2020              __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
   \                     ??HAL_UART_Abort_IT_15: (+1)
   \      0x13E   0x6820             LDR      R0,[R4, #+0]
   \      0x140   0x6980             LDR      R0,[R0, #+24]
   \      0x142   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x146   0x6821             LDR      R1,[R4, #+0]
   \      0x148   0x6188             STR      R0,[R1, #+24]
   2021          
   2022              /* Restore huart->gState and huart->RxState to Ready */
   2023              huart->gState  = HAL_UART_STATE_READY;
   \      0x14A   0x2020             MOVS     R0,#+32
   \      0x14C   0xF8C4 0x0084      STR      R0,[R4, #+132]
   2024              huart->RxState = HAL_UART_STATE_READY;
   \      0x150   0x2020             MOVS     R0,#+32
   \      0x152   0xF8C4 0x0088      STR      R0,[R4, #+136]
   2025              huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \      0x156   0x2000             MOVS     R0,#+0
   \      0x158   0x66E0             STR      R0,[R4, #+108]
   2026          
   2027              /* As no DMA to be aborted, call directly user Abort complete callback */
   2028          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2029              /* Call registered Abort complete callback */
   2030              huart->AbortCpltCallback(huart);
   2031          #else
   2032              /* Call legacy weak Abort complete callback */
   2033              HAL_UART_AbortCpltCallback(huart);
   \      0x15A   0x0020             MOVS     R0,R4
   \      0x15C   0x.... 0x....      BL       HAL_UART_AbortCpltCallback
   2034          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2035            }
   2036          
   2037            return HAL_OK;
   \                     ??HAL_UART_Abort_IT_14: (+1)
   \      0x160   0x2000             MOVS     R0,#+0
   \      0x162   0xBD32             POP      {R1,R4,R5,PC}
   2038          }
   2039          
   2040          /**
   2041            * @brief  Abort ongoing Transmit transfer (Interrupt mode).
   2042            * @param  huart UART handle.
   2043            * @note   This procedure could be used for aborting any ongoing Tx transfer started in Interrupt or DMA mode.
   2044            *         This procedure performs following operations :
   2045            *           - Disable UART Interrupts (Tx)
   2046            *           - Disable the DMA transfer in the peripheral register (if enabled)
   2047            *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
   2048            *           - Set handle State to READY
   2049            *           - At abort completion, call user abort complete callback
   2050            * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
   2051            *         considered as completed only when user abort complete callback is executed (not when exiting function).
   2052            * @retval HAL status
   2053            */

   \                                 In section .text, align 2, keep-with-next
   2054          HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
   2055          {
   \                     HAL_UART_AbortTransmit_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2056            /* Disable interrupts */
   2057            ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TCIE | USART_CR1_TXEIE_TXFNFIE));
   \                     ??HAL_UART_AbortTransmit_IT_0: (+1)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0xE850 0x1F00      LDREX    R1,[R0]
   \        0xA   0xF031 0x01C0      BICS     R1,R1,#0xC0
   \        0xE   0x6822             LDR      R2,[R4, #+0]
   \       0x10   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD1F5             BNE.N    ??HAL_UART_AbortTransmit_IT_0
   2058            ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
   \                     ??HAL_UART_AbortTransmit_IT_1: (+1)
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x3008             ADDS     R0,R0,#+8
   \       0x1C   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x20   0xF431 0x0100      BICS     R1,R1,#0x800000
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0x2A   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD1F2             BNE.N    ??HAL_UART_AbortTransmit_IT_1
   2059          
   2060            /* Abort the UART DMA Tx channel if enabled */
   2061            if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x6880             LDR      R0,[R0, #+8]
   \       0x36   0x0600             LSLS     R0,R0,#+24
   \       0x38   0xD529             BPL.N    ??HAL_UART_AbortTransmit_IT_2
   2062            {
   2063              /* Disable the UART DMA Tx request if enabled */
   2064              ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \                     ??HAL_UART_AbortTransmit_IT_3: (+1)
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x3008             ADDS     R0,R0,#+8
   \       0x3E   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x42   0xF031 0x0180      BICS     R1,R1,#0x80
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0x4C   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD1F2             BNE.N    ??HAL_UART_AbortTransmit_IT_3
   2065          
   2066              /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
   2067              if (huart->hdmatx != NULL)
   \       0x54   0x6FA0             LDR      R0,[R4, #+120]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD00D             BEQ.N    ??HAL_UART_AbortTransmit_IT_4
   2068              {
   2069                /* Set the UART DMA Abort callback :
   2070                   will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
   2071                huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
   \       0x5A   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \       0x5E   0x6FA1             LDR      R1,[R4, #+120]
   \       0x60   0x6508             STR      R0,[R1, #+80]
   2072          
   2073                /* Abort DMA TX */
   2074                if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
   \       0x62   0x6FA0             LDR      R0,[R4, #+120]
   \       0x64   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD025             BEQ.N    ??HAL_UART_AbortTransmit_IT_5
   2075                {
   2076                  /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
   2077                  huart->hdmatx->XferAbortCallback(huart->hdmatx);
   \       0x6C   0x6FA0             LDR      R0,[R4, #+120]
   \       0x6E   0x6FA1             LDR      R1,[R4, #+120]
   \       0x70   0x6D09             LDR      R1,[R1, #+80]
   \       0x72   0x4788             BLX      R1
   \       0x74   0xE020             B.N      ??HAL_UART_AbortTransmit_IT_5
   2078                }
   2079              }
   2080              else
   2081              {
   2082                /* Reset Tx transfer counter */
   2083                huart->TxXferCount = 0U;
   \                     ??HAL_UART_AbortTransmit_IT_4: (+1)
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xF8A4 0x0056      STRH     R0,[R4, #+86]
   2084          
   2085                /* Clear TxISR function pointers */
   2086                huart->TxISR = NULL;
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x6760             STR      R0,[R4, #+116]
   2087          
   2088                /* Restore huart->gState to Ready */
   2089                huart->gState = HAL_UART_STATE_READY;
   \       0x80   0x2020             MOVS     R0,#+32
   \       0x82   0xF8C4 0x0084      STR      R0,[R4, #+132]
   2090          
   2091                /* As no DMA to be aborted, call directly user Abort complete callback */
   2092          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2093                /* Call registered Abort Transmit Complete Callback */
   2094                huart->AbortTransmitCpltCallback(huart);
   2095          #else
   2096                /* Call legacy weak Abort Transmit Complete Callback */
   2097                HAL_UART_AbortTransmitCpltCallback(huart);
   \       0x86   0x0020             MOVS     R0,R4
   \       0x88   0x.... 0x....      BL       HAL_UART_AbortTransmitCpltCallback
   \       0x8C   0xE014             B.N      ??HAL_UART_AbortTransmit_IT_5
   2098          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2099              }
   2100            }
   2101            else
   2102            {
   2103              /* Reset Tx transfer counter */
   2104              huart->TxXferCount = 0U;
   \                     ??HAL_UART_AbortTransmit_IT_2: (+1)
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0xF8A4 0x0056      STRH     R0,[R4, #+86]
   2105          
   2106              /* Clear TxISR function pointers */
   2107              huart->TxISR = NULL;
   \       0x94   0x2000             MOVS     R0,#+0
   \       0x96   0x6760             STR      R0,[R4, #+116]
   2108          
   2109              /* Flush the whole TX FIFO (if needed) */
   2110              if (huart->FifoMode == UART_FIFOMODE_ENABLE)
   \       0x98   0x6E60             LDR      R0,[R4, #+100]
   \       0x9A   0xF1B0 0x5F00      CMP      R0,#+536870912
   \       0x9E   0xD105             BNE.N    ??HAL_UART_AbortTransmit_IT_6
   2111              {
   2112                __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x6980             LDR      R0,[R0, #+24]
   \       0xA4   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xA8   0x6821             LDR      R1,[R4, #+0]
   \       0xAA   0x6188             STR      R0,[R1, #+24]
   2113              }
   2114          
   2115              /* Restore huart->gState to Ready */
   2116              huart->gState = HAL_UART_STATE_READY;
   \                     ??HAL_UART_AbortTransmit_IT_6: (+1)
   \       0xAC   0x2020             MOVS     R0,#+32
   \       0xAE   0xF8C4 0x0084      STR      R0,[R4, #+132]
   2117          
   2118              /* As no DMA to be aborted, call directly user Abort complete callback */
   2119          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2120              /* Call registered Abort Transmit Complete Callback */
   2121              huart->AbortTransmitCpltCallback(huart);
   2122          #else
   2123              /* Call legacy weak Abort Transmit Complete Callback */
   2124              HAL_UART_AbortTransmitCpltCallback(huart);
   \       0xB2   0x0020             MOVS     R0,R4
   \       0xB4   0x.... 0x....      BL       HAL_UART_AbortTransmitCpltCallback
   2125          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2126            }
   2127          
   2128            return HAL_OK;
   \                     ??HAL_UART_AbortTransmit_IT_5: (+1)
   \       0xB8   0x2000             MOVS     R0,#+0
   \       0xBA   0xBD10             POP      {R4,PC}
   2129          }
   2130          
   2131          /**
   2132            * @brief  Abort ongoing Receive transfer (Interrupt mode).
   2133            * @param  huart UART handle.
   2134            * @note   This procedure could be used for aborting any ongoing Rx transfer started in Interrupt or DMA mode.
   2135            *         This procedure performs following operations :
   2136            *           - Disable UART Interrupts (Rx)
   2137            *           - Disable the DMA transfer in the peripheral register (if enabled)
   2138            *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
   2139            *           - Set handle State to READY
   2140            *           - At abort completion, call user abort complete callback
   2141            * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
   2142            *         considered as completed only when user abort complete callback is executed (not when exiting function).
   2143            * @retval HAL status
   2144            */

   \                                 In section .text, align 2, keep-with-next
   2145          HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
   2146          {
   \                     HAL_UART_AbortReceive_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2147            /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   2148            ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE));
   \                     ??HAL_UART_AbortReceive_IT_0: (+1)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0xE850 0x1F00      LDREX    R1,[R0]
   \        0xA   0xF431 0x7190      BICS     R1,R1,#0x120
   \        0xE   0x6822             LDR      R2,[R4, #+0]
   \       0x10   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD1F5             BNE.N    ??HAL_UART_AbortReceive_IT_0
   2149            ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
   \                     ??HAL_UART_AbortReceive_IT_1: (+1)
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x3008             ADDS     R0,R0,#+8
   \       0x1C   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x24   0x4001             ANDS     R1,R0,R1
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0x2C   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD1F1             BNE.N    ??HAL_UART_AbortReceive_IT_1
   2150          
   2151            /* If Reception till IDLE event was ongoing, disable IDLEIE interrupt */
   2152            if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
   \       0x34   0x6EE0             LDR      R0,[R4, #+108]
   \       0x36   0x2801             CMP      R0,#+1
   \       0x38   0xD109             BNE.N    ??HAL_UART_AbortReceive_IT_2
   2153            {
   2154              ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
   \                     ??HAL_UART_AbortReceive_IT_3: (+1)
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x40   0xF031 0x0110      BICS     R1,R1,#0x10
   \       0x44   0x6822             LDR      R2,[R4, #+0]
   \       0x46   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD1F5             BNE.N    ??HAL_UART_AbortReceive_IT_3
   2155            }
   2156          
   2157            /* Abort the UART DMA Rx channel if enabled */
   2158            if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \                     ??HAL_UART_AbortReceive_IT_2: (+1)
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x6880             LDR      R0,[R0, #+8]
   \       0x52   0x0640             LSLS     R0,R0,#+25
   \       0x54   0xD534             BPL.N    ??HAL_UART_AbortReceive_IT_4
   2159            {
   2160              /* Disable the UART DMA Rx request if enabled */
   2161              ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_AbortReceive_IT_5: (+1)
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x3008             ADDS     R0,R0,#+8
   \       0x5A   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x5E   0xF031 0x0140      BICS     R1,R1,#0x40
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0x68   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD1F2             BNE.N    ??HAL_UART_AbortReceive_IT_5
   2162          
   2163              /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
   2164              if (huart->hdmarx != NULL)
   \       0x70   0x6FE0             LDR      R0,[R4, #+124]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD00D             BEQ.N    ??HAL_UART_AbortReceive_IT_6
   2165              {
   2166                /* Set the UART DMA Abort callback :
   2167                   will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
   2168                huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
   \       0x76   0x.... 0x....      LDR.W    R0,??DataTable13_5
   \       0x7A   0x6FE1             LDR      R1,[R4, #+124]
   \       0x7C   0x6508             STR      R0,[R1, #+80]
   2169          
   2170                /* Abort DMA RX */
   2171                if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
   \       0x7E   0x6FE0             LDR      R0,[R4, #+124]
   \       0x80   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD02B             BEQ.N    ??HAL_UART_AbortReceive_IT_7
   2172                {
   2173                  /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
   2174                  huart->hdmarx->XferAbortCallback(huart->hdmarx);
   \       0x88   0x6FE0             LDR      R0,[R4, #+124]
   \       0x8A   0x6FE1             LDR      R1,[R4, #+124]
   \       0x8C   0x6D09             LDR      R1,[R1, #+80]
   \       0x8E   0x4788             BLX      R1
   \       0x90   0xE026             B.N      ??HAL_UART_AbortReceive_IT_7
   2175                }
   2176              }
   2177              else
   2178              {
   2179                /* Reset Rx transfer counter */
   2180                huart->RxXferCount = 0U;
   \                     ??HAL_UART_AbortReceive_IT_6: (+1)
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0xF8A4 0x005E      STRH     R0,[R4, #+94]
   2181          
   2182                /* Clear RxISR function pointer */
   2183                huart->pRxBuffPtr = NULL;
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0x65A0             STR      R0,[R4, #+88]
   2184          
   2185                /* Clear the Error flags in the ICR register */
   2186                __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
   \       0x9C   0x200F             MOVS     R0,#+15
   \       0x9E   0x6821             LDR      R1,[R4, #+0]
   \       0xA0   0x6208             STR      R0,[R1, #+32]
   2187          
   2188                /* Discard the received data */
   2189                __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
   \       0xA2   0x6820             LDR      R0,[R4, #+0]
   \       0xA4   0x6980             LDR      R0,[R0, #+24]
   \       0xA6   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0xAA   0x6821             LDR      R1,[R4, #+0]
   \       0xAC   0x6188             STR      R0,[R1, #+24]
   2190          
   2191                /* Restore huart->RxState to Ready */
   2192                huart->RxState = HAL_UART_STATE_READY;
   \       0xAE   0x2020             MOVS     R0,#+32
   \       0xB0   0xF8C4 0x0088      STR      R0,[R4, #+136]
   2193                huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0x66E0             STR      R0,[R4, #+108]
   2194          
   2195                /* As no DMA to be aborted, call directly user Abort complete callback */
   2196          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2197                /* Call registered Abort Receive Complete Callback */
   2198                huart->AbortReceiveCpltCallback(huart);
   2199          #else
   2200                /* Call legacy weak Abort Receive Complete Callback */
   2201                HAL_UART_AbortReceiveCpltCallback(huart);
   \       0xB8   0x0020             MOVS     R0,R4
   \       0xBA   0x.... 0x....      BL       HAL_UART_AbortReceiveCpltCallback
   \       0xBE   0xE00F             B.N      ??HAL_UART_AbortReceive_IT_7
   2202          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2203              }
   2204            }
   2205            else
   2206            {
   2207              /* Reset Rx transfer counter */
   2208              huart->RxXferCount = 0U;
   \                     ??HAL_UART_AbortReceive_IT_4: (+1)
   \       0xC0   0x2000             MOVS     R0,#+0
   \       0xC2   0xF8A4 0x005E      STRH     R0,[R4, #+94]
   2209          
   2210              /* Clear RxISR function pointer */
   2211              huart->pRxBuffPtr = NULL;
   \       0xC6   0x2000             MOVS     R0,#+0
   \       0xC8   0x65A0             STR      R0,[R4, #+88]
   2212          
   2213              /* Clear the Error flags in the ICR register */
   2214              __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
   \       0xCA   0x200F             MOVS     R0,#+15
   \       0xCC   0x6821             LDR      R1,[R4, #+0]
   \       0xCE   0x6208             STR      R0,[R1, #+32]
   2215          
   2216              /* Restore huart->RxState to Ready */
   2217              huart->RxState = HAL_UART_STATE_READY;
   \       0xD0   0x2020             MOVS     R0,#+32
   \       0xD2   0xF8C4 0x0088      STR      R0,[R4, #+136]
   2218              huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0x66E0             STR      R0,[R4, #+108]
   2219          
   2220              /* As no DMA to be aborted, call directly user Abort complete callback */
   2221          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2222              /* Call registered Abort Receive Complete Callback */
   2223              huart->AbortReceiveCpltCallback(huart);
   2224          #else
   2225              /* Call legacy weak Abort Receive Complete Callback */
   2226              HAL_UART_AbortReceiveCpltCallback(huart);
   \       0xDA   0x0020             MOVS     R0,R4
   \       0xDC   0x.... 0x....      BL       HAL_UART_AbortReceiveCpltCallback
   2227          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2228            }
   2229          
   2230            return HAL_OK;
   \                     ??HAL_UART_AbortReceive_IT_7: (+1)
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0xBD10             POP      {R4,PC}
   2231          }
   2232          
   2233          /**
   2234            * @brief Handle UART interrupt request.
   2235            * @param huart UART handle.
   2236            * @retval None
   2237            */

   \                                 In section .text, align 2, keep-with-next
   2238          void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
   2239          {
   \                     HAL_UART_IRQHandler: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2240            uint32_t isrflags   = READ_REG(huart->Instance->ISR);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x69C1             LDR      R1,[R0, #+28]
   2241            uint32_t cr1its     = READ_REG(huart->Instance->CR1);
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x6802             LDR      R2,[R0, #+0]
   2242            uint32_t cr3its     = READ_REG(huart->Instance->CR3);
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x6883             LDR      R3,[R0, #+8]
   2243          
   2244            uint32_t errorflags;
   2245            uint32_t errorcode;
   2246          
   2247            /* If no error occurs */
   2248            errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
   \       0x10   0xF640 0x000F      MOVW     R0,#+2063
   \       0x14   0x4008             ANDS     R0,R0,R1
   2249            if (errorflags == 0U)
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD10C             BNE.N    ??HAL_UART_IRQHandler_0
   2250            {
   2251              /* UART in mode Receiver ---------------------------------------------------*/
   2252              if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
   2253                  && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
   2254                      || ((cr3its & USART_CR3_RXFTIE) != 0U)))
   \       0x1A   0x068D             LSLS     R5,R1,#+26
   \       0x1C   0xD50A             BPL.N    ??HAL_UART_IRQHandler_0
   \       0x1E   0x0695             LSLS     R5,R2,#+26
   \       0x20   0xD401             BMI.N    ??HAL_UART_IRQHandler_1
   \       0x22   0x00DD             LSLS     R5,R3,#+3
   \       0x24   0xD506             BPL.N    ??HAL_UART_IRQHandler_0
   2255              {
   2256                if (huart->RxISR != NULL)
   \                     ??HAL_UART_IRQHandler_1: (+1)
   \       0x26   0x6F20             LDR      R0,[R4, #+112]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD002             BEQ.N    ??HAL_UART_IRQHandler_2
   2257                {
   2258                  huart->RxISR(huart);
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x6F21             LDR      R1,[R4, #+112]
   \       0x30   0x4788             BLX      R1
   2259                }
   2260                return;
   \                     ??HAL_UART_IRQHandler_2: (+1)
   \       0x32   0xE1DA             B.N      ??HAL_UART_IRQHandler_3
   2261              }
   2262            }
   2263          
   2264            /* If some errors occur */
   2265            if ((errorflags != 0U)
   2266                && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
   2267                     || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
   \                     ??HAL_UART_IRQHandler_0: (+1)
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xF000 0x80A3      BEQ.W    ??HAL_UART_IRQHandler_4
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable13_6
   \       0x3E   0x4203             TST      R3,R0
   \       0x40   0xD104             BNE.N    ??HAL_UART_IRQHandler_5
   \       0x42   0x.... 0x....      LDR.W    R5,??DataTable13_7
   \       0x46   0x422A             TST      R2,R5
   \       0x48   0xF000 0x809A      BEQ.W    ??HAL_UART_IRQHandler_4
   2268            {
   2269              /* UART parity error interrupt occurred -------------------------------------*/
   2270              if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
   \                     ??HAL_UART_IRQHandler_5: (+1)
   \       0x4C   0xF011 0x0501      ANDS     R5,R1,#0x1
   \       0x50   0xB2ED             UXTB     R5,R5
   \       0x52   0x2D00             CMP      R5,#+0
   \       0x54   0xD00A             BEQ.N    ??HAL_UART_IRQHandler_6
   \       0x56   0x05D5             LSLS     R5,R2,#+23
   \       0x58   0xD508             BPL.N    ??HAL_UART_IRQHandler_6
   2271              {
   2272                __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
   \       0x5A   0x2501             MOVS     R5,#+1
   \       0x5C   0x6826             LDR      R6,[R4, #+0]
   \       0x5E   0x6235             STR      R5,[R6, #+32]
   2273          
   2274                huart->ErrorCode |= HAL_UART_ERROR_PE;
   \       0x60   0xF8D4 0x508C      LDR      R5,[R4, #+140]
   \       0x64   0xF055 0x0501      ORRS     R5,R5,#0x1
   \       0x68   0xF8C4 0x508C      STR      R5,[R4, #+140]
   2275              }
   2276          
   2277              /* UART frame error interrupt occurred --------------------------------------*/
   2278              if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
   \                     ??HAL_UART_IRQHandler_6: (+1)
   \       0x6C   0x078D             LSLS     R5,R1,#+30
   \       0x6E   0xD50D             BPL.N    ??HAL_UART_IRQHandler_7
   \       0x70   0xF013 0x0501      ANDS     R5,R3,#0x1
   \       0x74   0xB2ED             UXTB     R5,R5
   \       0x76   0x2D00             CMP      R5,#+0
   \       0x78   0xD008             BEQ.N    ??HAL_UART_IRQHandler_7
   2279              {
   2280                __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
   \       0x7A   0x2502             MOVS     R5,#+2
   \       0x7C   0x6826             LDR      R6,[R4, #+0]
   \       0x7E   0x6235             STR      R5,[R6, #+32]
   2281          
   2282                huart->ErrorCode |= HAL_UART_ERROR_FE;
   \       0x80   0xF8D4 0x508C      LDR      R5,[R4, #+140]
   \       0x84   0xF055 0x0504      ORRS     R5,R5,#0x4
   \       0x88   0xF8C4 0x508C      STR      R5,[R4, #+140]
   2283              }
   2284          
   2285              /* UART noise error interrupt occurred --------------------------------------*/
   2286              if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
   \                     ??HAL_UART_IRQHandler_7: (+1)
   \       0x8C   0x074D             LSLS     R5,R1,#+29
   \       0x8E   0xD50D             BPL.N    ??HAL_UART_IRQHandler_8
   \       0x90   0xF013 0x0501      ANDS     R5,R3,#0x1
   \       0x94   0xB2ED             UXTB     R5,R5
   \       0x96   0x2D00             CMP      R5,#+0
   \       0x98   0xD008             BEQ.N    ??HAL_UART_IRQHandler_8
   2287              {
   2288                __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
   \       0x9A   0x2504             MOVS     R5,#+4
   \       0x9C   0x6826             LDR      R6,[R4, #+0]
   \       0x9E   0x6235             STR      R5,[R6, #+32]
   2289          
   2290                huart->ErrorCode |= HAL_UART_ERROR_NE;
   \       0xA0   0xF8D4 0x508C      LDR      R5,[R4, #+140]
   \       0xA4   0xF055 0x0502      ORRS     R5,R5,#0x2
   \       0xA8   0xF8C4 0x508C      STR      R5,[R4, #+140]
   2291              }
   2292          
   2293              /* UART Over-Run interrupt occurred -----------------------------------------*/
   2294              if (((isrflags & USART_ISR_ORE) != 0U)
   2295                  && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
   2296                      ((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)))
   \                     ??HAL_UART_IRQHandler_8: (+1)
   \       0xAC   0x070D             LSLS     R5,R1,#+28
   \       0xAE   0xD50C             BPL.N    ??HAL_UART_IRQHandler_9
   \       0xB0   0x0695             LSLS     R5,R2,#+26
   \       0xB2   0xD401             BMI.N    ??HAL_UART_IRQHandler_10
   \       0xB4   0x4203             TST      R3,R0
   \       0xB6   0xD008             BEQ.N    ??HAL_UART_IRQHandler_9
   2297              {
   2298                __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
   \                     ??HAL_UART_IRQHandler_10: (+1)
   \       0xB8   0x2008             MOVS     R0,#+8
   \       0xBA   0x6825             LDR      R5,[R4, #+0]
   \       0xBC   0x6228             STR      R0,[R5, #+32]
   2299          
   2300                huart->ErrorCode |= HAL_UART_ERROR_ORE;
   \       0xBE   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   \       0xC2   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0xC6   0xF8C4 0x008C      STR      R0,[R4, #+140]
   2301              }
   2302          
   2303              /* UART Receiver Timeout interrupt occurred ---------------------------------*/
   2304              if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
   \                     ??HAL_UART_IRQHandler_9: (+1)
   \       0xCA   0x0508             LSLS     R0,R1,#+20
   \       0xCC   0xD50B             BPL.N    ??HAL_UART_IRQHandler_11
   \       0xCE   0x0150             LSLS     R0,R2,#+5
   \       0xD0   0xD509             BPL.N    ??HAL_UART_IRQHandler_11
   2305              {
   2306                __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
   \       0xD2   0xF44F 0x6000      MOV      R0,#+2048
   \       0xD6   0x6825             LDR      R5,[R4, #+0]
   \       0xD8   0x6228             STR      R0,[R5, #+32]
   2307          
   2308                huart->ErrorCode |= HAL_UART_ERROR_RTO;
   \       0xDA   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   \       0xDE   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0xE2   0xF8C4 0x008C      STR      R0,[R4, #+140]
   2309              }
   2310          
   2311              /* Call UART Error Call back function if need be ----------------------------*/
   2312              if (huart->ErrorCode != HAL_UART_ERROR_NONE)
   \                     ??HAL_UART_IRQHandler_11: (+1)
   \       0xE6   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   \       0xEA   0x2800             CMP      R0,#+0
   \       0xEC   0xD047             BEQ.N    ??HAL_UART_IRQHandler_12
   2313              {
   2314                /* UART in mode Receiver --------------------------------------------------*/
   2315                if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
   2316                    && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
   2317                        || ((cr3its & USART_CR3_RXFTIE) != 0U)))
   \       0xEE   0x0688             LSLS     R0,R1,#+26
   \       0xF0   0xD509             BPL.N    ??HAL_UART_IRQHandler_13
   \       0xF2   0x0690             LSLS     R0,R2,#+26
   \       0xF4   0xD401             BMI.N    ??HAL_UART_IRQHandler_14
   \       0xF6   0x00D8             LSLS     R0,R3,#+3
   \       0xF8   0xD505             BPL.N    ??HAL_UART_IRQHandler_13
   2318                {
   2319                  if (huart->RxISR != NULL)
   \                     ??HAL_UART_IRQHandler_14: (+1)
   \       0xFA   0x6F20             LDR      R0,[R4, #+112]
   \       0xFC   0x2800             CMP      R0,#+0
   \       0xFE   0xD002             BEQ.N    ??HAL_UART_IRQHandler_13
   2320                  {
   2321                    huart->RxISR(huart);
   \      0x100   0x0020             MOVS     R0,R4
   \      0x102   0x6F21             LDR      R1,[R4, #+112]
   \      0x104   0x4788             BLX      R1
   2322                  }
   2323                }
   2324          
   2325                /* If Error is to be considered as blocking :
   2326                    - Receiver Timeout error in Reception
   2327                    - Overrun error in Reception
   2328                    - any error occurs in DMA mode reception
   2329                */
   2330                errorcode = huart->ErrorCode;
   \                     ??HAL_UART_IRQHandler_13: (+1)
   \      0x106   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   2331                if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
   2332                    ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
   \      0x10A   0x6821             LDR      R1,[R4, #+0]
   \      0x10C   0x6889             LDR      R1,[R1, #+8]
   \      0x10E   0x0649             LSLS     R1,R1,#+25
   \      0x110   0xD402             BMI.N    ??HAL_UART_IRQHandler_15
   \      0x112   0xF010 0x0F28      TST      R0,#0x28
   \      0x116   0xD02C             BEQ.N    ??HAL_UART_IRQHandler_16
   2333                {
   2334                  /* Blocking error : transfer is aborted
   2335                     Set the UART state ready to be able to start again the process,
   2336                     Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
   2337                  UART_EndRxTransfer(huart);
   \                     ??HAL_UART_IRQHandler_15: (+1)
   \      0x118   0x0020             MOVS     R0,R4
   \      0x11A   0x.... 0x....      BL       UART_EndRxTransfer
   2338          
   2339                  /* Abort the UART DMA Rx channel if enabled */
   2340                  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \      0x11E   0x6820             LDR      R0,[R4, #+0]
   \      0x120   0x6880             LDR      R0,[R0, #+8]
   \      0x122   0x0640             LSLS     R0,R0,#+25
   \      0x124   0xD521             BPL.N    ??HAL_UART_IRQHandler_17
   2341                  {
   2342                    /* Disable the UART DMA Rx request if enabled */
   2343                    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_IRQHandler_18: (+1)
   \      0x126   0x6820             LDR      R0,[R4, #+0]
   \      0x128   0x3008             ADDS     R0,R0,#+8
   \      0x12A   0xE850 0x1F00      LDREX    R1,[R0]
   \      0x12E   0xF031 0x0140      BICS     R1,R1,#0x40
   \      0x132   0x6820             LDR      R0,[R4, #+0]
   \      0x134   0xF110 0x0208      ADDS     R2,R0,#+8
   \      0x138   0xE842 0x1000      STREX    R0,R1,[R2]
   \      0x13C   0x2800             CMP      R0,#+0
   \      0x13E   0xD1F2             BNE.N    ??HAL_UART_IRQHandler_18
   2344          
   2345                    /* Abort the UART DMA Rx channel */
   2346                    if (huart->hdmarx != NULL)
   \      0x140   0x6FE0             LDR      R0,[R4, #+124]
   \      0x142   0x2800             CMP      R0,#+0
   \      0x144   0xD00D             BEQ.N    ??HAL_UART_IRQHandler_19
   2347                    {
   2348                      /* Set the UART DMA Abort callback :
   2349                         will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
   2350                      huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
   \      0x146   0x.... 0x....      LDR.W    R0,??DataTable13_8
   \      0x14A   0x6FE1             LDR      R1,[R4, #+124]
   \      0x14C   0x6508             STR      R0,[R1, #+80]
   2351          
   2352                      /* Abort DMA RX */
   2353                      if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
   \      0x14E   0x6FE0             LDR      R0,[R4, #+124]
   \      0x150   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \      0x154   0x2800             CMP      R0,#+0
   \      0x156   0xD012             BEQ.N    ??HAL_UART_IRQHandler_12
   2354                      {
   2355                        /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
   2356                        huart->hdmarx->XferAbortCallback(huart->hdmarx);
   \      0x158   0x6FE0             LDR      R0,[R4, #+124]
   \      0x15A   0x6FE1             LDR      R1,[R4, #+124]
   \      0x15C   0x6D09             LDR      R1,[R1, #+80]
   \      0x15E   0x4788             BLX      R1
   \      0x160   0xE00D             B.N      ??HAL_UART_IRQHandler_12
   2357                      }
   2358                    }
   2359                    else
   2360                    {
   2361                      /* Call user error callback */
   2362          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2363                      /*Call registered error callback*/
   2364                      huart->ErrorCallback(huart);
   2365          #else
   2366                      /*Call legacy weak error callback*/
   2367                      HAL_UART_ErrorCallback(huart);
   \                     ??HAL_UART_IRQHandler_19: (+1)
   \      0x162   0x0020             MOVS     R0,R4
   \      0x164   0x.... 0x....      BL       HAL_UART_ErrorCallback
   \      0x168   0xE009             B.N      ??HAL_UART_IRQHandler_12
   2368          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2369          
   2370                    }
   2371                  }
   2372                  else
   2373                  {
   2374                    /* Call user error callback */
   2375          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2376                    /*Call registered error callback*/
   2377                    huart->ErrorCallback(huart);
   2378          #else
   2379                    /*Call legacy weak error callback*/
   2380                    HAL_UART_ErrorCallback(huart);
   \                     ??HAL_UART_IRQHandler_17: (+1)
   \      0x16A   0x0020             MOVS     R0,R4
   \      0x16C   0x.... 0x....      BL       HAL_UART_ErrorCallback
   \      0x170   0xE005             B.N      ??HAL_UART_IRQHandler_12
   2381          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2382                  }
   2383                }
   2384                else
   2385                {
   2386                  /* Non Blocking error : transfer could go on.
   2387                     Error is notified to user through user error callback */
   2388          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2389                  /*Call registered error callback*/
   2390                  huart->ErrorCallback(huart);
   2391          #else
   2392                  /*Call legacy weak error callback*/
   2393                  HAL_UART_ErrorCallback(huart);
   \                     ??HAL_UART_IRQHandler_16: (+1)
   \      0x172   0x0020             MOVS     R0,R4
   \      0x174   0x.... 0x....      BL       HAL_UART_ErrorCallback
   2394          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2395                  huart->ErrorCode = HAL_UART_ERROR_NONE;
   \      0x178   0x2000             MOVS     R0,#+0
   \      0x17A   0xF8C4 0x008C      STR      R0,[R4, #+140]
   2396                }
   2397              }
   2398              return;
   \                     ??HAL_UART_IRQHandler_12: (+1)
   \      0x17E   0xE134             B.N      ??HAL_UART_IRQHandler_3
   2399          
   2400            } /* End if some error occurs */
   2401          
   2402            /* Check current reception Mode :
   2403               If Reception till IDLE event has been selected : */
   2404            if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
   2405                && ((isrflags & USART_ISR_IDLE) != 0U)
   2406                && ((cr1its & USART_ISR_IDLE) != 0U))
   \                     ??HAL_UART_IRQHandler_4: (+1)
   \      0x180   0x6EE0             LDR      R0,[R4, #+108]
   \      0x182   0x2801             CMP      R0,#+1
   \      0x184   0xF040 0x8100      BNE.W    ??HAL_UART_IRQHandler_20
   \      0x188   0x06C8             LSLS     R0,R1,#+27
   \      0x18A   0xF140 0x80FD      BPL.W    ??HAL_UART_IRQHandler_20
   \      0x18E   0x06D0             LSLS     R0,R2,#+27
   \      0x190   0xF140 0x80FA      BPL.W    ??HAL_UART_IRQHandler_20
   2407            {
   2408              __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
   \      0x194   0x2010             MOVS     R0,#+16
   \      0x196   0x6821             LDR      R1,[R4, #+0]
   \      0x198   0x6208             STR      R0,[R1, #+32]
   2409          
   2410              /* Check if DMA mode is enabled in UART */
   2411              if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \      0x19A   0x6820             LDR      R0,[R4, #+0]
   \      0x19C   0x6880             LDR      R0,[R0, #+8]
   \      0x19E   0x0640             LSLS     R0,R0,#+25
   \      0x1A0   0xF140 0x80B8      BPL.W    ??HAL_UART_IRQHandler_21
   2412              {
   2413                /* DMA mode enabled */
   2414                /* Check received length : If all expected data are received, do nothing,
   2415                   (DMA cplt callback will be called).
   2416                   Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
   2417                uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
   \      0x1A4   0x6FE0             LDR      R0,[R4, #+124]
   \      0x1A6   0x6800             LDR      R0,[R0, #+0]
   \      0x1A8   0x.... 0x....      LDR.W    R1,??DataTable14
   \      0x1AC   0x4288             CMP      R0,R1
   \      0x1AE   0xD059             BEQ.N    ??HAL_UART_IRQHandler_22
   \      0x1B0   0x6FE0             LDR      R0,[R4, #+124]
   \      0x1B2   0x6800             LDR      R0,[R0, #+0]
   \      0x1B4   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \      0x1B8   0x4288             CMP      R0,R1
   \      0x1BA   0xD053             BEQ.N    ??HAL_UART_IRQHandler_22
   \      0x1BC   0x6FE0             LDR      R0,[R4, #+124]
   \      0x1BE   0x6800             LDR      R0,[R0, #+0]
   \      0x1C0   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \      0x1C4   0x4288             CMP      R0,R1
   \      0x1C6   0xD04D             BEQ.N    ??HAL_UART_IRQHandler_22
   \      0x1C8   0x6FE0             LDR      R0,[R4, #+124]
   \      0x1CA   0x6800             LDR      R0,[R0, #+0]
   \      0x1CC   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \      0x1D0   0x4288             CMP      R0,R1
   \      0x1D2   0xD047             BEQ.N    ??HAL_UART_IRQHandler_22
   \      0x1D4   0x6FE0             LDR      R0,[R4, #+124]
   \      0x1D6   0x6800             LDR      R0,[R0, #+0]
   \      0x1D8   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \      0x1DC   0x4288             CMP      R0,R1
   \      0x1DE   0xD041             BEQ.N    ??HAL_UART_IRQHandler_22
   \      0x1E0   0x6FE0             LDR      R0,[R4, #+124]
   \      0x1E2   0x6800             LDR      R0,[R0, #+0]
   \      0x1E4   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \      0x1E8   0x4288             CMP      R0,R1
   \      0x1EA   0xD03B             BEQ.N    ??HAL_UART_IRQHandler_22
   \      0x1EC   0x6FE0             LDR      R0,[R4, #+124]
   \      0x1EE   0x6800             LDR      R0,[R0, #+0]
   \      0x1F0   0x.... 0x....      LDR.W    R1,??DataTable14_6
   \      0x1F4   0x4288             CMP      R0,R1
   \      0x1F6   0xD035             BEQ.N    ??HAL_UART_IRQHandler_22
   \      0x1F8   0x6FE0             LDR      R0,[R4, #+124]
   \      0x1FA   0x6800             LDR      R0,[R0, #+0]
   \      0x1FC   0x.... 0x....      LDR.W    R1,??DataTable14_7
   \      0x200   0x4288             CMP      R0,R1
   \      0x202   0xD02F             BEQ.N    ??HAL_UART_IRQHandler_22
   \      0x204   0x6FE0             LDR      R0,[R4, #+124]
   \      0x206   0x6800             LDR      R0,[R0, #+0]
   \      0x208   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \      0x20C   0x4288             CMP      R0,R1
   \      0x20E   0xD029             BEQ.N    ??HAL_UART_IRQHandler_22
   \      0x210   0x6FE0             LDR      R0,[R4, #+124]
   \      0x212   0x6800             LDR      R0,[R0, #+0]
   \      0x214   0x.... 0x....      LDR.W    R1,??DataTable14_9
   \      0x218   0x4288             CMP      R0,R1
   \      0x21A   0xD023             BEQ.N    ??HAL_UART_IRQHandler_22
   \      0x21C   0x6FE0             LDR      R0,[R4, #+124]
   \      0x21E   0x6800             LDR      R0,[R0, #+0]
   \      0x220   0x.... 0x....      LDR.W    R1,??DataTable14_10
   \      0x224   0x4288             CMP      R0,R1
   \      0x226   0xD01D             BEQ.N    ??HAL_UART_IRQHandler_22
   \      0x228   0x6FE0             LDR      R0,[R4, #+124]
   \      0x22A   0x6800             LDR      R0,[R0, #+0]
   \      0x22C   0x.... 0x....      LDR.W    R1,??DataTable14_11
   \      0x230   0x4288             CMP      R0,R1
   \      0x232   0xD017             BEQ.N    ??HAL_UART_IRQHandler_22
   \      0x234   0x6FE0             LDR      R0,[R4, #+124]
   \      0x236   0x6800             LDR      R0,[R0, #+0]
   \      0x238   0x.... 0x....      LDR.W    R1,??DataTable14_12
   \      0x23C   0x4288             CMP      R0,R1
   \      0x23E   0xD011             BEQ.N    ??HAL_UART_IRQHandler_22
   \      0x240   0x6FE0             LDR      R0,[R4, #+124]
   \      0x242   0x6800             LDR      R0,[R0, #+0]
   \      0x244   0x.... 0x....      LDR.W    R1,??DataTable14_13
   \      0x248   0x4288             CMP      R0,R1
   \      0x24A   0xD00B             BEQ.N    ??HAL_UART_IRQHandler_22
   \      0x24C   0x6FE0             LDR      R0,[R4, #+124]
   \      0x24E   0x6800             LDR      R0,[R0, #+0]
   \      0x250   0x.... 0x....      LDR.W    R1,??DataTable14_14
   \      0x254   0x4288             CMP      R0,R1
   \      0x256   0xD005             BEQ.N    ??HAL_UART_IRQHandler_22
   \      0x258   0x6FE0             LDR      R0,[R4, #+124]
   \      0x25A   0x6800             LDR      R0,[R0, #+0]
   \      0x25C   0x.... 0x....      LDR.W    R1,??DataTable14_15
   \      0x260   0x4288             CMP      R0,R1
   \      0x262   0xD103             BNE.N    ??HAL_UART_IRQHandler_23
   \                     ??HAL_UART_IRQHandler_22: (+1)
   \      0x264   0x6FE0             LDR      R0,[R4, #+124]
   \      0x266   0x6800             LDR      R0,[R0, #+0]
   \      0x268   0x6841             LDR      R1,[R0, #+4]
   \      0x26A   0xE002             B.N      ??HAL_UART_IRQHandler_24
   \                     ??HAL_UART_IRQHandler_23: (+1)
   \      0x26C   0x6FE0             LDR      R0,[R4, #+124]
   \      0x26E   0x6800             LDR      R0,[R0, #+0]
   \      0x270   0x6841             LDR      R1,[R0, #+4]
   2418                if ((nb_remaining_rx_data > 0U)
   2419                    && (nb_remaining_rx_data < huart->RxXferSize))
   \                     ??HAL_UART_IRQHandler_24: (+1)
   \      0x272   0x0008             MOVS     R0,R1
   \      0x274   0xB280             UXTH     R0,R0
   \      0x276   0x2800             CMP      R0,#+0
   \      0x278   0xD04B             BEQ.N    ??HAL_UART_IRQHandler_25
   \      0x27A   0x0008             MOVS     R0,R1
   \      0x27C   0xF8B4 0x205C      LDRH     R2,[R4, #+92]
   \      0x280   0xB280             UXTH     R0,R0
   \      0x282   0x4290             CMP      R0,R2
   \      0x284   0xD245             BCS.N    ??HAL_UART_IRQHandler_25
   2420                {
   2421                  /* Reception is not complete */
   2422                  huart->RxXferCount = nb_remaining_rx_data;
   \      0x286   0xF8A4 0x105E      STRH     R1,[R4, #+94]
   2423          
   2424                  /* In Normal mode, end DMA xfer and HAL UART Rx process*/
   2425                  if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
   \      0x28A   0x6FE0             LDR      R0,[R4, #+124]
   \      0x28C   0x69C0             LDR      R0,[R0, #+28]
   \      0x28E   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x292   0xD035             BEQ.N    ??HAL_UART_IRQHandler_26
   2426                  {
   2427                    /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
   2428                    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \                     ??HAL_UART_IRQHandler_27: (+1)
   \      0x294   0x6820             LDR      R0,[R4, #+0]
   \      0x296   0xE850 0x1F00      LDREX    R1,[R0]
   \      0x29A   0xF431 0x7180      BICS     R1,R1,#0x100
   \      0x29E   0x6822             LDR      R2,[R4, #+0]
   \      0x2A0   0xE842 0x1000      STREX    R0,R1,[R2]
   \      0x2A4   0x2800             CMP      R0,#+0
   \      0x2A6   0xD1F5             BNE.N    ??HAL_UART_IRQHandler_27
   2429                    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \                     ??HAL_UART_IRQHandler_28: (+1)
   \      0x2A8   0x6820             LDR      R0,[R4, #+0]
   \      0x2AA   0x3008             ADDS     R0,R0,#+8
   \      0x2AC   0xE850 0x1F00      LDREX    R1,[R0]
   \      0x2B0   0x0849             LSRS     R1,R1,#+1
   \      0x2B2   0x0049             LSLS     R1,R1,#+1
   \      0x2B4   0x6820             LDR      R0,[R4, #+0]
   \      0x2B6   0xF110 0x0208      ADDS     R2,R0,#+8
   \      0x2BA   0xE842 0x1000      STREX    R0,R1,[R2]
   \      0x2BE   0x2800             CMP      R0,#+0
   \      0x2C0   0xD1F2             BNE.N    ??HAL_UART_IRQHandler_28
   2430          
   2431                    /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
   2432                       in the UART CR3 register */
   2433                    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_IRQHandler_29: (+1)
   \      0x2C2   0x6820             LDR      R0,[R4, #+0]
   \      0x2C4   0x3008             ADDS     R0,R0,#+8
   \      0x2C6   0xE850 0x1F00      LDREX    R1,[R0]
   \      0x2CA   0xF031 0x0140      BICS     R1,R1,#0x40
   \      0x2CE   0x6820             LDR      R0,[R4, #+0]
   \      0x2D0   0xF110 0x0208      ADDS     R2,R0,#+8
   \      0x2D4   0xE842 0x1000      STREX    R0,R1,[R2]
   \      0x2D8   0x2800             CMP      R0,#+0
   \      0x2DA   0xD1F2             BNE.N    ??HAL_UART_IRQHandler_29
   2434          
   2435                    /* At end of Rx process, restore huart->RxState to Ready */
   2436                    huart->RxState = HAL_UART_STATE_READY;
   \      0x2DC   0x2020             MOVS     R0,#+32
   \      0x2DE   0xF8C4 0x0088      STR      R0,[R4, #+136]
   2437                    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \      0x2E2   0x2000             MOVS     R0,#+0
   \      0x2E4   0x66E0             STR      R0,[R4, #+108]
   2438          
   2439                    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
   \                     ??HAL_UART_IRQHandler_30: (+1)
   \      0x2E6   0x6820             LDR      R0,[R4, #+0]
   \      0x2E8   0xE850 0x1F00      LDREX    R1,[R0]
   \      0x2EC   0xF031 0x0110      BICS     R1,R1,#0x10
   \      0x2F0   0x6822             LDR      R2,[R4, #+0]
   \      0x2F2   0xE842 0x1000      STREX    R0,R1,[R2]
   \      0x2F6   0x2800             CMP      R0,#+0
   \      0x2F8   0xD1F5             BNE.N    ??HAL_UART_IRQHandler_30
   2440          
   2441                    /* Last bytes received, so no need as the abort is immediate */
   2442                    (void)HAL_DMA_Abort(huart->hdmarx);
   \      0x2FA   0x6FE0             LDR      R0,[R4, #+124]
   \      0x2FC   0x.... 0x....      BL       HAL_DMA_Abort
   2443                  }
   2444          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2445                  /*Call registered Rx Event callback*/
   2446                  huart->RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
   2447          #else
   2448                  /*Call legacy weak Rx Event callback*/
   2449                  HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
   \                     ??HAL_UART_IRQHandler_26: (+1)
   \      0x300   0xF8B4 0x105C      LDRH     R1,[R4, #+92]
   \      0x304   0xF8B4 0x005E      LDRH     R0,[R4, #+94]
   \      0x308   0x1A09             SUBS     R1,R1,R0
   \      0x30A   0xB289             UXTH     R1,R1
   \      0x30C   0x0020             MOVS     R0,R4
   \      0x30E   0x.... 0x....      BL       HAL_UARTEx_RxEventCallback
   2450          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
   2451                }
   2452                return;
   \                     ??HAL_UART_IRQHandler_25: (+1)
   \      0x312   0xE06A             B.N      ??HAL_UART_IRQHandler_3
   2453              }
   2454              else
   2455              {
   2456                /* DMA mode not enabled */
   2457                /* Check received length : If all expected data are received, do nothing.
   2458                   Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
   2459                uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
   \                     ??HAL_UART_IRQHandler_21: (+1)
   \      0x314   0xF8B4 0x005C      LDRH     R0,[R4, #+92]
   \      0x318   0xF8B4 0x105E      LDRH     R1,[R4, #+94]
   \      0x31C   0x1A41             SUBS     R1,R0,R1
   2460                if ((huart->RxXferCount > 0U)
   2461                    && (nb_rx_data > 0U))
   \      0x31E   0xF8B4 0x005E      LDRH     R0,[R4, #+94]
   \      0x322   0x2800             CMP      R0,#+0
   \      0x324   0xD02F             BEQ.N    ??HAL_UART_IRQHandler_31
   \      0x326   0x0008             MOVS     R0,R1
   \      0x328   0xB280             UXTH     R0,R0
   \      0x32A   0x2800             CMP      R0,#+0
   \      0x32C   0xD02B             BEQ.N    ??HAL_UART_IRQHandler_31
   2462                {
   2463                  /* Disable the UART Parity Error Interrupt and RXNE interrupts */
   2464                  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
   \                     ??HAL_UART_IRQHandler_32: (+1)
   \      0x32E   0x6820             LDR      R0,[R4, #+0]
   \      0x330   0xE850 0x2F00      LDREX    R2,[R0]
   \      0x334   0xF432 0x7290      BICS     R2,R2,#0x120
   \      0x338   0x6823             LDR      R3,[R4, #+0]
   \      0x33A   0xE843 0x2000      STREX    R0,R2,[R3]
   \      0x33E   0x2800             CMP      R0,#+0
   \      0x340   0xD1F5             BNE.N    ??HAL_UART_IRQHandler_32
   2465          
   2466                  /* Disable the UART Error Interrupt:(Frame error, noise error, overrun error) and RX FIFO Threshold interrupt */
   2467                  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
   \                     ??HAL_UART_IRQHandler_33: (+1)
   \      0x342   0x6820             LDR      R0,[R4, #+0]
   \      0x344   0x3008             ADDS     R0,R0,#+8
   \      0x346   0xE850 0x2F00      LDREX    R2,[R0]
   \      0x34A   0x....             LDR.N    R0,??DataTable13_1
   \      0x34C   0x4002             ANDS     R2,R0,R2
   \      0x34E   0x6820             LDR      R0,[R4, #+0]
   \      0x350   0xF110 0x0308      ADDS     R3,R0,#+8
   \      0x354   0xE843 0x2000      STREX    R0,R2,[R3]
   \      0x358   0x2800             CMP      R0,#+0
   \      0x35A   0xD1F2             BNE.N    ??HAL_UART_IRQHandler_33
   2468          
   2469                  /* Rx process is completed, restore huart->RxState to Ready */
   2470                  huart->RxState = HAL_UART_STATE_READY;
   \      0x35C   0x2020             MOVS     R0,#+32
   \      0x35E   0xF8C4 0x0088      STR      R0,[R4, #+136]
   2471                  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \      0x362   0x2000             MOVS     R0,#+0
   \      0x364   0x66E0             STR      R0,[R4, #+108]
   2472          
   2473                  /* Clear RxISR function pointer */
   2474                  huart->RxISR = NULL;
   \      0x366   0x2000             MOVS     R0,#+0
   \      0x368   0x6720             STR      R0,[R4, #+112]
   2475          
   2476                  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
   \                     ??HAL_UART_IRQHandler_34: (+1)
   \      0x36A   0x6820             LDR      R0,[R4, #+0]
   \      0x36C   0xE850 0x2F00      LDREX    R2,[R0]
   \      0x370   0xF032 0x0210      BICS     R2,R2,#0x10
   \      0x374   0x6823             LDR      R3,[R4, #+0]
   \      0x376   0xE843 0x2000      STREX    R0,R2,[R3]
   \      0x37A   0x2800             CMP      R0,#+0
   \      0x37C   0xD1F5             BNE.N    ??HAL_UART_IRQHandler_34
   2477          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2478                  /*Call registered Rx complete callback*/
   2479                  huart->RxEventCallback(huart, nb_rx_data);
   2480          #else
   2481                  /*Call legacy weak Rx Event callback*/
   2482                  HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
   \      0x37E   0xB289             UXTH     R1,R1
   \      0x380   0x0020             MOVS     R0,R4
   \      0x382   0x.... 0x....      BL       HAL_UARTEx_RxEventCallback
   2483          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
   2484                }
   2485                return;
   \                     ??HAL_UART_IRQHandler_31: (+1)
   \      0x386   0xE030             B.N      ??HAL_UART_IRQHandler_3
   2486              }
   2487            }
   2488          
   2489            /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
   2490            if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
   \                     ??HAL_UART_IRQHandler_20: (+1)
   \      0x388   0x02C8             LSLS     R0,R1,#+11
   \      0x38A   0xD509             BPL.N    ??HAL_UART_IRQHandler_35
   \      0x38C   0x0258             LSLS     R0,R3,#+9
   \      0x38E   0xD507             BPL.N    ??HAL_UART_IRQHandler_35
   2491            {
   2492              __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
   \      0x390   0xF45F 0x1080      MOVS     R0,#+1048576
   \      0x394   0x6821             LDR      R1,[R4, #+0]
   \      0x396   0x6208             STR      R0,[R1, #+32]
   2493          
   2494              /* UART Rx state is not reset as a reception process might be ongoing.
   2495                 If UART handle state fields need to be reset to READY, this could be done in Wakeup callback */
   2496          
   2497          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2498              /* Call registered Wakeup Callback */
   2499              huart->WakeupCallback(huart);
   2500          #else
   2501              /* Call legacy weak Wakeup Callback */
   2502              HAL_UARTEx_WakeupCallback(huart);
   \      0x398   0x0020             MOVS     R0,R4
   \      0x39A   0x.... 0x....      BL       HAL_UARTEx_WakeupCallback
   2503          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2504              return;
   \      0x39E   0xE024             B.N      ??HAL_UART_IRQHandler_3
   2505            }
   2506          
   2507            /* UART in mode Transmitter ------------------------------------------------*/
   2508            if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
   2509                && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
   2510                    || ((cr3its & USART_CR3_TXFTIE) != 0U)))
   \                     ??HAL_UART_IRQHandler_35: (+1)
   \      0x3A0   0x0608             LSLS     R0,R1,#+24
   \      0x3A2   0xD50A             BPL.N    ??HAL_UART_IRQHandler_36
   \      0x3A4   0x0610             LSLS     R0,R2,#+24
   \      0x3A6   0xD401             BMI.N    ??HAL_UART_IRQHandler_37
   \      0x3A8   0x0218             LSLS     R0,R3,#+8
   \      0x3AA   0xD506             BPL.N    ??HAL_UART_IRQHandler_36
   2511            {
   2512              if (huart->TxISR != NULL)
   \                     ??HAL_UART_IRQHandler_37: (+1)
   \      0x3AC   0x6F60             LDR      R0,[R4, #+116]
   \      0x3AE   0x2800             CMP      R0,#+0
   \      0x3B0   0xD002             BEQ.N    ??HAL_UART_IRQHandler_38
   2513              {
   2514                huart->TxISR(huart);
   \      0x3B2   0x0020             MOVS     R0,R4
   \      0x3B4   0x6F61             LDR      R1,[R4, #+116]
   \      0x3B6   0x4788             BLX      R1
   2515              }
   2516              return;
   \                     ??HAL_UART_IRQHandler_38: (+1)
   \      0x3B8   0xE017             B.N      ??HAL_UART_IRQHandler_3
   2517            }
   2518          
   2519            /* UART in mode Transmitter (transmission end) -----------------------------*/
   2520            if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
   \                     ??HAL_UART_IRQHandler_36: (+1)
   \      0x3BA   0x0648             LSLS     R0,R1,#+25
   \      0x3BC   0xD505             BPL.N    ??HAL_UART_IRQHandler_39
   \      0x3BE   0x0650             LSLS     R0,R2,#+25
   \      0x3C0   0xD503             BPL.N    ??HAL_UART_IRQHandler_39
   2521            {
   2522              UART_EndTransmit_IT(huart);
   \      0x3C2   0x0020             MOVS     R0,R4
   \      0x3C4   0x.... 0x....      BL       UART_EndTransmit_IT
   2523              return;
   \      0x3C8   0xE00F             B.N      ??HAL_UART_IRQHandler_3
   2524            }
   2525          
   2526            /* UART TX Fifo Empty occurred ----------------------------------------------*/
   2527            if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
   \                     ??HAL_UART_IRQHandler_39: (+1)
   \      0x3CA   0x0208             LSLS     R0,R1,#+8
   \      0x3CC   0xD505             BPL.N    ??HAL_UART_IRQHandler_40
   \      0x3CE   0x0050             LSLS     R0,R2,#+1
   \      0x3D0   0xD503             BPL.N    ??HAL_UART_IRQHandler_40
   2528            {
   2529          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2530              /* Call registered Tx Fifo Empty Callback */
   2531              huart->TxFifoEmptyCallback(huart);
   2532          #else
   2533              /* Call legacy weak Tx Fifo Empty Callback */
   2534              HAL_UARTEx_TxFifoEmptyCallback(huart);
   \      0x3D2   0x0020             MOVS     R0,R4
   \      0x3D4   0x.... 0x....      BL       HAL_UARTEx_TxFifoEmptyCallback
   2535          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2536              return;
   \      0x3D8   0xE007             B.N      ??HAL_UART_IRQHandler_3
   2537            }
   2538          
   2539            /* UART RX Fifo Full occurred ----------------------------------------------*/
   2540            if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
   \                     ??HAL_UART_IRQHandler_40: (+1)
   \      0x3DA   0x01C8             LSLS     R0,R1,#+7
   \      0x3DC   0xD505             BPL.N    ??HAL_UART_IRQHandler_41
   \      0x3DE   0x2A00             CMP      R2,#+0
   \      0x3E0   0xD503             BPL.N    ??HAL_UART_IRQHandler_41
   2541            {
   2542          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2543              /* Call registered Rx Fifo Full Callback */
   2544              huart->RxFifoFullCallback(huart);
   2545          #else
   2546              /* Call legacy weak Rx Fifo Full Callback */
   2547              HAL_UARTEx_RxFifoFullCallback(huart);
   \      0x3E2   0x0020             MOVS     R0,R4
   \      0x3E4   0x.... 0x....      BL       HAL_UARTEx_RxFifoFullCallback
   2548          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2549              return;
   \      0x3E8   0xE7FF             B.N      ??HAL_UART_IRQHandler_3
   2550            }
   2551          }
   \                     ??HAL_UART_IRQHandler_41: (+1)
   \                     ??HAL_UART_IRQHandler_3: (+1)
   \      0x3EA   0xBD70             POP      {R4-R6,PC}
   2552          
   2553          /**
   2554            * @brief Tx Transfer completed callback.
   2555            * @param huart UART handle.
   2556            * @retval None
   2557            */

   \                                 In section .text, align 2
   2558          __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
   2559          {
   2560            /* Prevent unused argument(s) compilation warning */
   2561            UNUSED(huart);
   2562          
   2563            /* NOTE : This function should not be modified, when the callback is needed,
   2564                      the HAL_UART_TxCpltCallback can be implemented in the user file.
   2565             */
   2566          }
   \                     HAL_UART_TxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2567          
   2568          /**
   2569            * @brief  Tx Half Transfer completed callback.
   2570            * @param  huart UART handle.
   2571            * @retval None
   2572            */

   \                                 In section .text, align 2
   2573          __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
   2574          {
   2575            /* Prevent unused argument(s) compilation warning */
   2576            UNUSED(huart);
   2577          
   2578            /* NOTE: This function should not be modified, when the callback is needed,
   2579                     the HAL_UART_TxHalfCpltCallback can be implemented in the user file.
   2580             */
   2581          }
   \                     HAL_UART_TxHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2582          
   2583          /**
   2584            * @brief  Rx Transfer completed callback.
   2585            * @param  huart UART handle.
   2586            * @retval None
   2587            */

   \                                 In section .text, align 2
   2588          __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
   2589          {
   2590            /* Prevent unused argument(s) compilation warning */
   2591            UNUSED(huart);
   2592          
   2593            /* NOTE : This function should not be modified, when the callback is needed,
   2594                      the HAL_UART_RxCpltCallback can be implemented in the user file.
   2595             */
   2596          }
   \                     HAL_UART_RxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2597          
   2598          /**
   2599            * @brief  Rx Half Transfer completed callback.
   2600            * @param  huart UART handle.
   2601            * @retval None
   2602            */

   \                                 In section .text, align 2
   2603          __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
   2604          {
   2605            /* Prevent unused argument(s) compilation warning */
   2606            UNUSED(huart);
   2607          
   2608            /* NOTE: This function should not be modified, when the callback is needed,
   2609                     the HAL_UART_RxHalfCpltCallback can be implemented in the user file.
   2610             */
   2611          }
   \                     HAL_UART_RxHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2612          
   2613          /**
   2614            * @brief  UART error callback.
   2615            * @param  huart UART handle.
   2616            * @retval None
   2617            */

   \                                 In section .text, align 2
   2618          __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
   2619          {
   2620            /* Prevent unused argument(s) compilation warning */
   2621            UNUSED(huart);
   2622          
   2623            /* NOTE : This function should not be modified, when the callback is needed,
   2624                      the HAL_UART_ErrorCallback can be implemented in the user file.
   2625             */
   2626          }
   \                     HAL_UART_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR
   2627          
   2628          /**
   2629            * @brief  UART Abort Complete callback.
   2630            * @param  huart UART handle.
   2631            * @retval None
   2632            */

   \                                 In section .text, align 2
   2633          __weak void HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart)
   2634          {
   2635            /* Prevent unused argument(s) compilation warning */
   2636            UNUSED(huart);
   2637          
   2638            /* NOTE : This function should not be modified, when the callback is needed,
   2639                      the HAL_UART_AbortCpltCallback can be implemented in the user file.
   2640             */
   2641          }
   \                     HAL_UART_AbortCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2642          
   2643          /**
   2644            * @brief  UART Abort Complete callback.
   2645            * @param  huart UART handle.
   2646            * @retval None
   2647            */

   \                                 In section .text, align 2
   2648          __weak void HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart)
   2649          {
   2650            /* Prevent unused argument(s) compilation warning */
   2651            UNUSED(huart);
   2652          
   2653            /* NOTE : This function should not be modified, when the callback is needed,
   2654                      the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
   2655             */
   2656          }
   \                     HAL_UART_AbortTransmitCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2657          
   2658          /**
   2659            * @brief  UART Abort Receive Complete callback.
   2660            * @param  huart UART handle.
   2661            * @retval None
   2662            */

   \                                 In section .text, align 2
   2663          __weak void HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart)
   2664          {
   2665            /* Prevent unused argument(s) compilation warning */
   2666            UNUSED(huart);
   2667          
   2668            /* NOTE : This function should not be modified, when the callback is needed,
   2669                      the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
   2670             */
   2671          }
   \                     HAL_UART_AbortReceiveCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2672          
   2673          /**
   2674            * @brief  Reception Event Callback (Rx event notification called after use of advanced reception service).
   2675            * @param  huart UART handle
   2676            * @param  Size  Number of data available in application reception buffer (indicates a position in
   2677            *               reception buffer until which, data are available)
   2678            * @retval None
   2679            */

   \                                 In section .text, align 2
   2680          __weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
   2681          {
   2682            /* Prevent unused argument(s) compilation warning */
   2683            UNUSED(huart);
   2684            UNUSED(Size);
   2685          
   2686            /* NOTE : This function should not be modified, when the callback is needed,
   2687                      the HAL_UARTEx_RxEventCallback can be implemented in the user file.
   2688             */
   2689          }
   \                     HAL_UARTEx_RxEventCallback: (+1)
   \        0x0   0x4770             BX       LR
   2690          
   2691          /**
   2692            * @}
   2693            */
   2694          
   2695          /** @defgroup UART_Exported_Functions_Group3 Peripheral Control functions
   2696            *  @brief   UART control functions
   2697            *
   2698          @verbatim
   2699           ===============================================================================
   2700                                ##### Peripheral Control functions #####
   2701           ===============================================================================
   2702              [..]
   2703              This subsection provides a set of functions allowing to control the UART.
   2704               (+) HAL_UART_ReceiverTimeout_Config() API allows to configure the receiver timeout value on the fly
   2705               (+) HAL_UART_EnableReceiverTimeout() API enables the receiver timeout feature
   2706               (+) HAL_UART_DisableReceiverTimeout() API disables the receiver timeout feature
   2707               (+) HAL_MultiProcessor_EnableMuteMode() API enables mute mode
   2708               (+) HAL_MultiProcessor_DisableMuteMode() API disables mute mode
   2709               (+) HAL_MultiProcessor_EnterMuteMode() API enters mute mode
   2710               (+) UART_SetConfig() API configures the UART peripheral
   2711               (+) UART_AdvFeatureConfig() API optionally configures the UART advanced features
   2712               (+) UART_CheckIdleState() API ensures that TEACK and/or REACK are set after initialization
   2713               (+) HAL_HalfDuplex_EnableTransmitter() API disables receiver and enables transmitter
   2714               (+) HAL_HalfDuplex_EnableReceiver() API disables transmitter and enables receiver
   2715               (+) HAL_LIN_SendBreak() API transmits the break characters
   2716          @endverbatim
   2717            * @{
   2718            */
   2719          
   2720          /**
   2721            * @brief  Update on the fly the receiver timeout value in RTOR register.
   2722            * @param  huart Pointer to a UART_HandleTypeDef structure that contains
   2723            *                    the configuration information for the specified UART module.
   2724            * @param  TimeoutValue receiver timeout value in number of baud blocks. The timeout
   2725            *                     value must be less or equal to 0x0FFFFFFFF.
   2726            * @retval None
   2727            */

   \                                 In section .text, align 2, keep-with-next
   2728          void HAL_UART_ReceiverTimeout_Config(UART_HandleTypeDef *huart, uint32_t TimeoutValue)
   2729          {
   2730            if (!(IS_LPUART_INSTANCE(huart->Instance)))
   \                     HAL_UART_ReceiverTimeout_Config: (+1)
   \        0x0   0x6802             LDR      R2,[R0, #+0]
   \        0x2   0x.... 0x....      LDR.W    R3,??DataTable14_16
   \        0x6   0x429A             CMP      R2,R3
   \        0x8   0xD006             BEQ.N    ??HAL_UART_ReceiverTimeout_Config_0
   2731            {
   2732              assert_param(IS_UART_RECEIVER_TIMEOUT_VALUE(TimeoutValue));
   2733              MODIFY_REG(huart->Instance->RTOR, USART_RTOR_RTO, TimeoutValue);
   \        0xA   0x6802             LDR      R2,[R0, #+0]
   \        0xC   0x6952             LDR      R2,[R2, #+20]
   \        0xE   0xF012 0x427F      ANDS     R2,R2,#0xFF000000
   \       0x12   0x4311             ORRS     R1,R1,R2
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x6141             STR      R1,[R0, #+20]
   2734            }
   2735          }
   \                     ??HAL_UART_ReceiverTimeout_Config_0: (+1)
   \       0x18   0x4770             BX       LR
   2736          
   2737          /**
   2738            * @brief  Enable the UART receiver timeout feature.
   2739            * @param  huart Pointer to a UART_HandleTypeDef structure that contains
   2740            *                    the configuration information for the specified UART module.
   2741            * @retval HAL status
   2742            */

   \                                 In section .text, align 2, keep-with-next
   2743          HAL_StatusTypeDef HAL_UART_EnableReceiverTimeout(UART_HandleTypeDef *huart)
   2744          {
   2745            if (!(IS_LPUART_INSTANCE(huart->Instance)))
   \                     HAL_UART_EnableReceiverTimeout: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x.... 0x....      LDR.W    R2,??DataTable14_16
   \        0x6   0x4291             CMP      R1,R2
   \        0x8   0xD01F             BEQ.N    ??HAL_UART_EnableReceiverTimeout_0
   2746            {
   2747              if (huart->gState == HAL_UART_STATE_READY)
   \        0xA   0xF8D0 0x1084      LDR      R1,[R0, #+132]
   \        0xE   0x2920             CMP      R1,#+32
   \       0x10   0xD119             BNE.N    ??HAL_UART_EnableReceiverTimeout_1
   2748              {
   2749                /* Process Locked */
   2750                __HAL_LOCK(huart);
   \       0x12   0xF890 0x1080      LDRB     R1,[R0, #+128]
   \       0x16   0x2901             CMP      R1,#+1
   \       0x18   0xD101             BNE.N    ??HAL_UART_EnableReceiverTimeout_2
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0xE016             B.N      ??HAL_UART_EnableReceiverTimeout_3
   \                     ??HAL_UART_EnableReceiverTimeout_2: (+1)
   \       0x1E   0x2101             MOVS     R1,#+1
   \       0x20   0xF880 0x1080      STRB     R1,[R0, #+128]
   2751          
   2752                huart->gState = HAL_UART_STATE_BUSY;
   \       0x24   0x2124             MOVS     R1,#+36
   \       0x26   0xF8C0 0x1084      STR      R1,[R0, #+132]
   2753          
   2754                /* Set the USART RTOEN bit */
   2755                SET_BIT(huart->Instance->CR2, USART_CR2_RTOEN);
   \       0x2A   0x6801             LDR      R1,[R0, #+0]
   \       0x2C   0x6849             LDR      R1,[R1, #+4]
   \       0x2E   0xF451 0x0100      ORRS     R1,R1,#0x800000
   \       0x32   0x6802             LDR      R2,[R0, #+0]
   \       0x34   0x6051             STR      R1,[R2, #+4]
   2756          
   2757                huart->gState = HAL_UART_STATE_READY;
   \       0x36   0x2120             MOVS     R1,#+32
   \       0x38   0xF8C0 0x1084      STR      R1,[R0, #+132]
   2758          
   2759                /* Process Unlocked */
   2760                __HAL_UNLOCK(huart);
   \       0x3C   0x2100             MOVS     R1,#+0
   \       0x3E   0xF880 0x1080      STRB     R1,[R0, #+128]
   2761          
   2762                return HAL_OK;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xE002             B.N      ??HAL_UART_EnableReceiverTimeout_3
   2763              }
   2764              else
   2765              {
   2766                return HAL_BUSY;
   \                     ??HAL_UART_EnableReceiverTimeout_1: (+1)
   \       0x46   0x2002             MOVS     R0,#+2
   \       0x48   0xE000             B.N      ??HAL_UART_EnableReceiverTimeout_3
   2767              }
   2768            }
   2769            else
   2770            {
   2771              return HAL_ERROR;
   \                     ??HAL_UART_EnableReceiverTimeout_0: (+1)
   \       0x4A   0x2001             MOVS     R0,#+1
   \                     ??HAL_UART_EnableReceiverTimeout_3: (+1)
   \       0x4C   0x4770             BX       LR
   2772            }
   2773          }
   2774          
   2775          /**
   2776            * @brief  Disable the UART receiver timeout feature.
   2777            * @param  huart Pointer to a UART_HandleTypeDef structure that contains
   2778            *                    the configuration information for the specified UART module.
   2779            * @retval HAL status
   2780            */

   \                                 In section .text, align 2, keep-with-next
   2781          HAL_StatusTypeDef HAL_UART_DisableReceiverTimeout(UART_HandleTypeDef *huart)
   2782          {
   2783            if (!(IS_LPUART_INSTANCE(huart->Instance)))
   \                     HAL_UART_DisableReceiverTimeout: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x.... 0x....      LDR.W    R2,??DataTable14_16
   \        0x6   0x4291             CMP      R1,R2
   \        0x8   0xD01F             BEQ.N    ??HAL_UART_DisableReceiverTimeout_0
   2784            {
   2785              if (huart->gState == HAL_UART_STATE_READY)
   \        0xA   0xF8D0 0x1084      LDR      R1,[R0, #+132]
   \        0xE   0x2920             CMP      R1,#+32
   \       0x10   0xD119             BNE.N    ??HAL_UART_DisableReceiverTimeout_1
   2786              {
   2787                /* Process Locked */
   2788                __HAL_LOCK(huart);
   \       0x12   0xF890 0x1080      LDRB     R1,[R0, #+128]
   \       0x16   0x2901             CMP      R1,#+1
   \       0x18   0xD101             BNE.N    ??HAL_UART_DisableReceiverTimeout_2
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0xE016             B.N      ??HAL_UART_DisableReceiverTimeout_3
   \                     ??HAL_UART_DisableReceiverTimeout_2: (+1)
   \       0x1E   0x2101             MOVS     R1,#+1
   \       0x20   0xF880 0x1080      STRB     R1,[R0, #+128]
   2789          
   2790                huart->gState = HAL_UART_STATE_BUSY;
   \       0x24   0x2124             MOVS     R1,#+36
   \       0x26   0xF8C0 0x1084      STR      R1,[R0, #+132]
   2791          
   2792                /* Clear the USART RTOEN bit */
   2793                CLEAR_BIT(huart->Instance->CR2, USART_CR2_RTOEN);
   \       0x2A   0x6801             LDR      R1,[R0, #+0]
   \       0x2C   0x6849             LDR      R1,[R1, #+4]
   \       0x2E   0xF431 0x0100      BICS     R1,R1,#0x800000
   \       0x32   0x6802             LDR      R2,[R0, #+0]
   \       0x34   0x6051             STR      R1,[R2, #+4]
   2794          
   2795                huart->gState = HAL_UART_STATE_READY;
   \       0x36   0x2120             MOVS     R1,#+32
   \       0x38   0xF8C0 0x1084      STR      R1,[R0, #+132]
   2796          
   2797                /* Process Unlocked */
   2798                __HAL_UNLOCK(huart);
   \       0x3C   0x2100             MOVS     R1,#+0
   \       0x3E   0xF880 0x1080      STRB     R1,[R0, #+128]
   2799          
   2800                return HAL_OK;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xE002             B.N      ??HAL_UART_DisableReceiverTimeout_3
   2801              }
   2802              else
   2803              {
   2804                return HAL_BUSY;
   \                     ??HAL_UART_DisableReceiverTimeout_1: (+1)
   \       0x46   0x2002             MOVS     R0,#+2
   \       0x48   0xE000             B.N      ??HAL_UART_DisableReceiverTimeout_3
   2805              }
   2806            }
   2807            else
   2808            {
   2809              return HAL_ERROR;
   \                     ??HAL_UART_DisableReceiverTimeout_0: (+1)
   \       0x4A   0x2001             MOVS     R0,#+1
   \                     ??HAL_UART_DisableReceiverTimeout_3: (+1)
   \       0x4C   0x4770             BX       LR
   2810            }
   2811          }
   2812          
   2813          /**
   2814            * @brief  Enable UART in mute mode (does not mean UART enters mute mode;
   2815            *         to enter mute mode, HAL_MultiProcessor_EnterMuteMode() API must be called).
   2816            * @param  huart UART handle.
   2817            * @retval HAL status
   2818            */

   \                                 In section .text, align 2, keep-with-next
   2819          HAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart)
   2820          {
   \                     HAL_MultiProcessor_EnableMuteMode: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2821            __HAL_LOCK(huart);
   \        0x2   0xF890 0x1080      LDRB     R1,[R0, #+128]
   \        0x6   0x2901             CMP      R1,#+1
   \        0x8   0xD101             BNE.N    ??HAL_MultiProcessor_EnableMuteMode_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE014             B.N      ??HAL_MultiProcessor_EnableMuteMode_1
   \                     ??HAL_MultiProcessor_EnableMuteMode_0: (+1)
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0xF880 0x1080      STRB     R1,[R0, #+128]
   2822          
   2823            huart->gState = HAL_UART_STATE_BUSY;
   \       0x14   0x2124             MOVS     R1,#+36
   \       0x16   0xF8C0 0x1084      STR      R1,[R0, #+132]
   2824          
   2825            /* Enable USART mute mode by setting the MME bit in the CR1 register */
   2826            ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_MME);
   \                     ??HAL_MultiProcessor_EnableMuteMode_2: (+1)
   \       0x1A   0x6801             LDR      R1,[R0, #+0]
   \       0x1C   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x20   0xF452 0x5200      ORRS     R2,R2,#0x2000
   \       0x24   0x6803             LDR      R3,[R0, #+0]
   \       0x26   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x2A   0x2900             CMP      R1,#+0
   \       0x2C   0xD1F5             BNE.N    ??HAL_MultiProcessor_EnableMuteMode_2
   2827          
   2828            huart->gState = HAL_UART_STATE_READY;
   \       0x2E   0x2120             MOVS     R1,#+32
   \       0x30   0xF8C0 0x1084      STR      R1,[R0, #+132]
   2829          
   2830            return (UART_CheckIdleState(huart));
   \       0x34   0x.... 0x....      BL       UART_CheckIdleState
   \                     ??HAL_MultiProcessor_EnableMuteMode_1: (+1)
   \       0x38   0xBD02             POP      {R1,PC}
   2831          }
   2832          
   2833          /**
   2834            * @brief  Disable UART mute mode (does not mean the UART actually exits mute mode
   2835            *         as it may not have been in mute mode at this very moment).
   2836            * @param  huart UART handle.
   2837            * @retval HAL status
   2838            */

   \                                 In section .text, align 2, keep-with-next
   2839          HAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart)
   2840          {
   \                     HAL_MultiProcessor_DisableMuteMode: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2841            __HAL_LOCK(huart);
   \        0x2   0xF890 0x1080      LDRB     R1,[R0, #+128]
   \        0x6   0x2901             CMP      R1,#+1
   \        0x8   0xD101             BNE.N    ??HAL_MultiProcessor_DisableMuteMode_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE014             B.N      ??HAL_MultiProcessor_DisableMuteMode_1
   \                     ??HAL_MultiProcessor_DisableMuteMode_0: (+1)
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0xF880 0x1080      STRB     R1,[R0, #+128]
   2842          
   2843            huart->gState = HAL_UART_STATE_BUSY;
   \       0x14   0x2124             MOVS     R1,#+36
   \       0x16   0xF8C0 0x1084      STR      R1,[R0, #+132]
   2844          
   2845            /* Disable USART mute mode by clearing the MME bit in the CR1 register */
   2846            ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_MME);
   \                     ??HAL_MultiProcessor_DisableMuteMode_2: (+1)
   \       0x1A   0x6801             LDR      R1,[R0, #+0]
   \       0x1C   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x20   0xF432 0x5200      BICS     R2,R2,#0x2000
   \       0x24   0x6803             LDR      R3,[R0, #+0]
   \       0x26   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x2A   0x2900             CMP      R1,#+0
   \       0x2C   0xD1F5             BNE.N    ??HAL_MultiProcessor_DisableMuteMode_2
   2847          
   2848            huart->gState = HAL_UART_STATE_READY;
   \       0x2E   0x2120             MOVS     R1,#+32
   \       0x30   0xF8C0 0x1084      STR      R1,[R0, #+132]
   2849          
   2850            return (UART_CheckIdleState(huart));
   \       0x34   0x.... 0x....      BL       UART_CheckIdleState
   \                     ??HAL_MultiProcessor_DisableMuteMode_1: (+1)
   \       0x38   0xBD02             POP      {R1,PC}
   2851          }
   2852          
   2853          /**
   2854            * @brief Enter UART mute mode (means UART actually enters mute mode).
   2855            * @note  To exit from mute mode, HAL_MultiProcessor_DisableMuteMode() API must be called.
   2856            * @param huart UART handle.
   2857            * @retval None
   2858            */

   \                                 In section .text, align 2, keep-with-next
   2859          void HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
   2860          {
   2861            __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);
   \                     HAL_MultiProcessor_EnterMuteMode: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x6989             LDR      R1,[R1, #+24]
   \        0x4   0xF051 0x0104      ORRS     R1,R1,#0x4
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0x6181             STR      R1,[R0, #+24]
   2862          }
   \        0xC   0x4770             BX       LR
   2863          
   2864          /**
   2865            * @brief  Enable the UART transmitter and disable the UART receiver.
   2866            * @param  huart UART handle.
   2867            * @retval HAL status
   2868            */

   \                                 In section .text, align 2, keep-with-next
   2869          HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
   2870          {
   2871            __HAL_LOCK(huart);
   \                     HAL_HalfDuplex_EnableTransmitter: (+1)
   \        0x0   0xF890 0x1080      LDRB     R1,[R0, #+128]
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD101             BNE.N    ??HAL_HalfDuplex_EnableTransmitter_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xE020             B.N      ??HAL_HalfDuplex_EnableTransmitter_1
   \                     ??HAL_HalfDuplex_EnableTransmitter_0: (+1)
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0xF880 0x1080      STRB     R1,[R0, #+128]
   2872            huart->gState = HAL_UART_STATE_BUSY;
   \       0x12   0x2124             MOVS     R1,#+36
   \       0x14   0xF8C0 0x1084      STR      R1,[R0, #+132]
   2873          
   2874            /* Clear TE and RE bits */
   2875            ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
   \                     ??HAL_HalfDuplex_EnableTransmitter_2: (+1)
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x1E   0xF032 0x020C      BICS     R2,R2,#0xC
   \       0x22   0x6803             LDR      R3,[R0, #+0]
   \       0x24   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x28   0x2900             CMP      R1,#+0
   \       0x2A   0xD1F5             BNE.N    ??HAL_HalfDuplex_EnableTransmitter_2
   2876          
   2877            /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
   2878            ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TE);
   \                     ??HAL_HalfDuplex_EnableTransmitter_3: (+1)
   \       0x2C   0x6801             LDR      R1,[R0, #+0]
   \       0x2E   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x32   0xF052 0x0208      ORRS     R2,R2,#0x8
   \       0x36   0x6803             LDR      R3,[R0, #+0]
   \       0x38   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x3C   0x2900             CMP      R1,#+0
   \       0x3E   0xD1F5             BNE.N    ??HAL_HalfDuplex_EnableTransmitter_3
   2879          
   2880            huart->gState = HAL_UART_STATE_READY;
   \       0x40   0x2120             MOVS     R1,#+32
   \       0x42   0xF8C0 0x1084      STR      R1,[R0, #+132]
   2881          
   2882            __HAL_UNLOCK(huart);
   \       0x46   0x2100             MOVS     R1,#+0
   \       0x48   0xF880 0x1080      STRB     R1,[R0, #+128]
   2883          
   2884            return HAL_OK;
   \       0x4C   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_EnableTransmitter_1: (+1)
   \       0x4E   0x4770             BX       LR
   2885          }
   2886          
   2887          /**
   2888            * @brief  Enable the UART receiver and disable the UART transmitter.
   2889            * @param  huart UART handle.
   2890            * @retval HAL status.
   2891            */

   \                                 In section .text, align 2, keep-with-next
   2892          HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
   2893          {
   2894            __HAL_LOCK(huart);
   \                     HAL_HalfDuplex_EnableReceiver: (+1)
   \        0x0   0xF890 0x1080      LDRB     R1,[R0, #+128]
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD101             BNE.N    ??HAL_HalfDuplex_EnableReceiver_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xE020             B.N      ??HAL_HalfDuplex_EnableReceiver_1
   \                     ??HAL_HalfDuplex_EnableReceiver_0: (+1)
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0xF880 0x1080      STRB     R1,[R0, #+128]
   2895            huart->gState = HAL_UART_STATE_BUSY;
   \       0x12   0x2124             MOVS     R1,#+36
   \       0x14   0xF8C0 0x1084      STR      R1,[R0, #+132]
   2896          
   2897            /* Clear TE and RE bits */
   2898            ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
   \                     ??HAL_HalfDuplex_EnableReceiver_2: (+1)
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x1E   0xF032 0x020C      BICS     R2,R2,#0xC
   \       0x22   0x6803             LDR      R3,[R0, #+0]
   \       0x24   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x28   0x2900             CMP      R1,#+0
   \       0x2A   0xD1F5             BNE.N    ??HAL_HalfDuplex_EnableReceiver_2
   2899          
   2900            /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
   2901            ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RE);
   \                     ??HAL_HalfDuplex_EnableReceiver_3: (+1)
   \       0x2C   0x6801             LDR      R1,[R0, #+0]
   \       0x2E   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x32   0xF052 0x0204      ORRS     R2,R2,#0x4
   \       0x36   0x6803             LDR      R3,[R0, #+0]
   \       0x38   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x3C   0x2900             CMP      R1,#+0
   \       0x3E   0xD1F5             BNE.N    ??HAL_HalfDuplex_EnableReceiver_3
   2902          
   2903            huart->gState = HAL_UART_STATE_READY;
   \       0x40   0x2120             MOVS     R1,#+32
   \       0x42   0xF8C0 0x1084      STR      R1,[R0, #+132]
   2904          
   2905            __HAL_UNLOCK(huart);
   \       0x46   0x2100             MOVS     R1,#+0
   \       0x48   0xF880 0x1080      STRB     R1,[R0, #+128]
   2906          
   2907            return HAL_OK;
   \       0x4C   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_EnableReceiver_1: (+1)
   \       0x4E   0x4770             BX       LR
   2908          }
   2909          
   2910          
   2911          /**
   2912            * @brief  Transmit break characters.
   2913            * @param  huart UART handle.
   2914            * @retval HAL status
   2915            */

   \                                 In section .text, align 2, keep-with-next
   2916          HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
   2917          {
   2918            /* Check the parameters */
   2919            assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
   2920          
   2921            __HAL_LOCK(huart);
   \                     HAL_LIN_SendBreak: (+1)
   \        0x0   0xF890 0x1080      LDRB     R1,[R0, #+128]
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD101             BNE.N    ??HAL_LIN_SendBreak_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xE012             B.N      ??HAL_LIN_SendBreak_1
   \                     ??HAL_LIN_SendBreak_0: (+1)
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0xF880 0x1080      STRB     R1,[R0, #+128]
   2922          
   2923            huart->gState = HAL_UART_STATE_BUSY;
   \       0x12   0x2124             MOVS     R1,#+36
   \       0x14   0xF8C0 0x1084      STR      R1,[R0, #+132]
   2924          
   2925            /* Send break characters */
   2926            __HAL_UART_SEND_REQ(huart, UART_SENDBREAK_REQUEST);
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0x6989             LDR      R1,[R1, #+24]
   \       0x1C   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x20   0x6802             LDR      R2,[R0, #+0]
   \       0x22   0x6191             STR      R1,[R2, #+24]
   2927          
   2928            huart->gState = HAL_UART_STATE_READY;
   \       0x24   0x2120             MOVS     R1,#+32
   \       0x26   0xF8C0 0x1084      STR      R1,[R0, #+132]
   2929          
   2930            __HAL_UNLOCK(huart);
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0xF880 0x1080      STRB     R1,[R0, #+128]
   2931          
   2932            return HAL_OK;
   \       0x30   0x2000             MOVS     R0,#+0
   \                     ??HAL_LIN_SendBreak_1: (+1)
   \       0x32   0x4770             BX       LR
   2933          }
   2934          
   2935          /**
   2936            * @}
   2937            */
   2938          
   2939          /** @defgroup UART_Exported_Functions_Group4 Peripheral State and Error functions
   2940            *  @brief   UART Peripheral State functions
   2941            *
   2942          @verbatim
   2943            ==============================================================================
   2944                      ##### Peripheral State and Error functions #####
   2945            ==============================================================================
   2946              [..]
   2947              This subsection provides functions allowing to :
   2948                (+) Return the UART handle state.
   2949                (+) Return the UART handle error code
   2950          
   2951          @endverbatim
   2952            * @{
   2953            */
   2954          
   2955          /**
   2956            * @brief Return the UART handle state.
   2957            * @param  huart Pointer to a UART_HandleTypeDef structure that contains
   2958            *               the configuration information for the specified UART.
   2959            * @retval HAL state
   2960            */

   \                                 In section .text, align 2, keep-with-next
   2961          HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
   2962          {
   \                     HAL_UART_GetState: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   2963            uint32_t temp1;
   2964            uint32_t temp2;
   2965            temp1 = huart->gState;
   \        0x2   0xF8D1 0x0084      LDR      R0,[R1, #+132]
   2966            temp2 = huart->RxState;
   \        0x6   0xF8D1 0x1088      LDR      R1,[R1, #+136]
   2967          
   2968            return (HAL_UART_StateTypeDef)(temp1 | temp2);
   \        0xA   0x4308             ORRS     R0,R1,R0
   \        0xC   0x4770             BX       LR
   2969          }
   2970          
   2971          /**
   2972            * @brief  Return the UART handle error code.
   2973            * @param  huart Pointer to a UART_HandleTypeDef structure that contains
   2974            *               the configuration information for the specified UART.
   2975            * @retval UART Error Code
   2976            */

   \                                 In section .text, align 2, keep-with-next
   2977          uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
   2978          {
   2979            return huart->ErrorCode;
   \                     HAL_UART_GetError: (+1)
   \        0x0   0xF8D0 0x008C      LDR      R0,[R0, #+140]
   \        0x4   0x4770             BX       LR
   2980          }
   2981          /**
   2982            * @}
   2983            */
   2984          
   2985          /**
   2986            * @}
   2987            */
   2988          
   2989          /** @defgroup UART_Private_Functions UART Private Functions
   2990            * @{
   2991            */
   2992          
   2993          /**
   2994            * @brief  Initialize the callbacks to their default values.
   2995            * @param  huart UART handle.
   2996            * @retval none
   2997            */
   2998          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2999          void UART_InitCallbacksToDefault(UART_HandleTypeDef *huart)
   3000          {
   3001            /* Init the UART Callback settings */
   3002            huart->TxHalfCpltCallback        = HAL_UART_TxHalfCpltCallback;        /* Legacy weak TxHalfCpltCallback        */
   3003            huart->TxCpltCallback            = HAL_UART_TxCpltCallback;            /* Legacy weak TxCpltCallback            */
   3004            huart->RxHalfCpltCallback        = HAL_UART_RxHalfCpltCallback;        /* Legacy weak RxHalfCpltCallback        */
   3005            huart->RxCpltCallback            = HAL_UART_RxCpltCallback;            /* Legacy weak RxCpltCallback            */
   3006            huart->ErrorCallback             = HAL_UART_ErrorCallback;             /* Legacy weak ErrorCallback             */
   3007            huart->AbortCpltCallback         = HAL_UART_AbortCpltCallback;         /* Legacy weak AbortCpltCallback         */
   3008            huart->AbortTransmitCpltCallback = HAL_UART_AbortTransmitCpltCallback; /* Legacy weak AbortTransmitCpltCallback */
   3009            huart->AbortReceiveCpltCallback  = HAL_UART_AbortReceiveCpltCallback;  /* Legacy weak AbortReceiveCpltCallback  */
   3010            huart->WakeupCallback            = HAL_UARTEx_WakeupCallback;          /* Legacy weak WakeupCallback            */
   3011            huart->RxFifoFullCallback        = HAL_UARTEx_RxFifoFullCallback;      /* Legacy weak RxFifoFullCallback        */
   3012            huart->TxFifoEmptyCallback       = HAL_UARTEx_TxFifoEmptyCallback;     /* Legacy weak TxFifoEmptyCallback       */
   3013            huart->RxEventCallback           = HAL_UARTEx_RxEventCallback;         /* Legacy weak RxEventCallback           */
   3014          
   3015          }
   3016          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   3017          
   3018          /**
   3019            * @brief Configure the UART peripheral.
   3020            * @param huart UART handle.
   3021            * @retval HAL status
   3022            */

   \                                 In section .text, align 2, keep-with-next
   3023          HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
   3024          {
   \                     UART_SetConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x0004             MOVS     R4,R0
   3025            uint32_t tmpreg;
   3026            uint16_t brrtemp;
   3027            UART_ClockSourceTypeDef clocksource;
   3028            uint32_t usartdiv;
   3029            HAL_StatusTypeDef ret               = HAL_OK;
   \        0x6   0x2500             MOVS     R5,#+0
   3030            uint32_t lpuart_ker_ck_pres;
   3031            PLL2_ClocksTypeDef pll2_clocks;
   3032            PLL3_ClocksTypeDef pll3_clocks;
   3033            uint32_t pclk;
   3034          
   3035            /* Check the parameters */
   3036            assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
   3037            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
   3038            if (UART_INSTANCE_LOWPOWER(huart))
   \        0x8   0x.... 0x....      LDR.W    R1,??DataTable14_16
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xD0FF             BEQ.N    ??UART_SetConfig_0
   3039            {
   3040              assert_param(IS_LPUART_STOPBITS(huart->Init.StopBits));
   3041            }
   3042            else
   3043            {
   3044              assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
   3045              assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
   3046            }
   3047          
   3048            assert_param(IS_UART_PARITY(huart->Init.Parity));
   3049            assert_param(IS_UART_MODE(huart->Init.Mode));
   3050            assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
   3051            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
   3052            assert_param(IS_UART_PRESCALER(huart->Init.ClockPrescaler));
   3053          
   3054            /*-------------------------- USART CR1 Configuration -----------------------*/
   3055            /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure
   3056            *  the UART Word Length, Parity, Mode and oversampling:
   3057            *  set the M bits according to huart->Init.WordLength value
   3058            *  set PCE and PS bits according to huart->Init.Parity value
   3059            *  set TE and RE bits according to huart->Init.Mode value
   3060            *  set OVER8 bit according to huart->Init.OverSampling value */
   3061            tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
   \                     ??UART_SetConfig_1: (+1)
   \                     ??UART_SetConfig_0: (+1)
   \       0x12   0x68A2             LDR      R2,[R4, #+8]
   \       0x14   0x6920             LDR      R0,[R4, #+16]
   \       0x16   0x4302             ORRS     R2,R0,R2
   \       0x18   0x6960             LDR      R0,[R4, #+20]
   \       0x1A   0x4302             ORRS     R2,R0,R2
   \       0x1C   0x69E0             LDR      R0,[R4, #+28]
   \       0x1E   0x4302             ORRS     R2,R0,R2
   3062            MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x6803             LDR      R3,[R0, #+0]
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable15
   \       0x28   0x4003             ANDS     R3,R0,R3
   \       0x2A   0x431A             ORRS     R2,R2,R3
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6002             STR      R2,[R0, #+0]
   3063          
   3064            /*-------------------------- USART CR2 Configuration -----------------------*/
   3065            /* Configure the UART Stop Bits: Set STOP[13:12] bits according
   3066            * to huart->Init.StopBits value */
   3067            MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6842             LDR      R2,[R0, #+4]
   \       0x34   0xF432 0x5240      BICS     R2,R2,#0x3000
   \       0x38   0x68E0             LDR      R0,[R4, #+12]
   \       0x3A   0x4302             ORRS     R2,R0,R2
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6042             STR      R2,[R0, #+4]
   3068          
   3069            /*-------------------------- USART CR3 Configuration -----------------------*/
   3070            /* Configure
   3071            * - UART HardWare Flow Control: set CTSE and RTSE bits according
   3072            *   to huart->Init.HwFlowCtl value
   3073            * - one-bit sampling method versus three samples' majority rule according
   3074            *   to huart->Init.OneBitSampling (not applicable to LPUART) */
   3075            tmpreg = (uint32_t)huart->Init.HwFlowCtl;
   \       0x40   0x69A2             LDR      R2,[R4, #+24]
   3076          
   3077            if (!(UART_INSTANCE_LOWPOWER(huart)))
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x4288             CMP      R0,R1
   \       0x46   0xD001             BEQ.N    ??UART_SetConfig_2
   3078            {
   3079              tmpreg |= huart->Init.OneBitSampling;
   \       0x48   0x6A20             LDR      R0,[R4, #+32]
   \       0x4A   0x4302             ORRS     R2,R0,R2
   3080            }
   3081            MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
   \                     ??UART_SetConfig_2: (+1)
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x6883             LDR      R3,[R0, #+8]
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \       0x54   0x4003             ANDS     R3,R0,R3
   \       0x56   0x431A             ORRS     R2,R2,R3
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x6082             STR      R2,[R0, #+8]
   3082          
   3083            /*-------------------------- USART PRESC Configuration -----------------------*/
   3084            /* Configure
   3085            * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
   3086            MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x6AC2             LDR      R2,[R0, #+44]
   \       0x60   0x0912             LSRS     R2,R2,#+4
   \       0x62   0x0112             LSLS     R2,R2,#+4
   \       0x64   0x6A60             LDR      R0,[R4, #+36]
   \       0x66   0x4302             ORRS     R2,R0,R2
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x62C2             STR      R2,[R0, #+44]
   3087          
   3088            /*-------------------------- USART BRR Configuration -----------------------*/
   3089            UART_GETCLOCKSOURCE(huart, clocksource);
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x.... 0x....      LDR.W    R2,??DataTable15_2
   \       0x72   0x4290             CMP      R0,R2
   \       0x74   0xD11F             BNE.N    ??UART_SetConfig_3
   \       0x76   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \       0x7A   0x6800             LDR      R0,[R0, #+0]
   \       0x7C   0xF010 0x0038      ANDS     R0,R0,#0x38
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD00A             BEQ.N    ??UART_SetConfig_4
   \       0x84   0x2808             CMP      R0,#+8
   \       0x86   0xD00A             BEQ.N    ??UART_SetConfig_5
   \       0x88   0x2810             CMP      R0,#+16
   \       0x8A   0xD00A             BEQ.N    ??UART_SetConfig_6
   \       0x8C   0x2818             CMP      R0,#+24
   \       0x8E   0xD00A             BEQ.N    ??UART_SetConfig_7
   \       0x90   0x2820             CMP      R0,#+32
   \       0x92   0xD00A             BEQ.N    ??UART_SetConfig_8
   \       0x94   0x2828             CMP      R0,#+40
   \       0x96   0xD00A             BEQ.N    ??UART_SetConfig_9
   \       0x98   0xE00B             B.N      ??UART_SetConfig_10
   \                     ??UART_SetConfig_4: (+1)
   \       0x9A   0x2001             MOVS     R0,#+1
   \       0x9C   0xE16E             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_5: (+1)
   \       0x9E   0x2004             MOVS     R0,#+4
   \       0xA0   0xE16C             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_6: (+1)
   \       0xA2   0x2008             MOVS     R0,#+8
   \       0xA4   0xE16A             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_7: (+1)
   \       0xA6   0x2010             MOVS     R0,#+16
   \       0xA8   0xE168             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_8: (+1)
   \       0xAA   0x2020             MOVS     R0,#+32
   \       0xAC   0xE166             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_9: (+1)
   \       0xAE   0x2040             MOVS     R0,#+64
   \       0xB0   0xE164             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_10: (+1)
   \       0xB2   0x2080             MOVS     R0,#+128
   \       0xB4   0xE162             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_3: (+1)
   \       0xB6   0x6820             LDR      R0,[R4, #+0]
   \       0xB8   0x.... 0x....      LDR.W    R2,??DataTable15_4
   \       0xBC   0x4290             CMP      R0,R2
   \       0xBE   0xD11D             BNE.N    ??UART_SetConfig_12
   \       0xC0   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \       0xC4   0x6800             LDR      R0,[R0, #+0]
   \       0xC6   0xF010 0x0007      ANDS     R0,R0,#0x7
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0xD008             BEQ.N    ??UART_SetConfig_13
   \       0xCE   0x2802             CMP      R0,#+2
   \       0xD0   0xD00A             BEQ.N    ??UART_SetConfig_14
   \       0xD2   0xD307             BCC.N    ??UART_SetConfig_15
   \       0xD4   0x2804             CMP      R0,#+4
   \       0xD6   0xD00B             BEQ.N    ??UART_SetConfig_16
   \       0xD8   0xD308             BCC.N    ??UART_SetConfig_17
   \       0xDA   0x2805             CMP      R0,#+5
   \       0xDC   0xD00A             BEQ.N    ??UART_SetConfig_18
   \       0xDE   0xE00B             B.N      ??UART_SetConfig_19
   \                     ??UART_SetConfig_13: (+1)
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0xE14B             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_15: (+1)
   \       0xE4   0x2004             MOVS     R0,#+4
   \       0xE6   0xE149             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_14: (+1)
   \       0xE8   0x2008             MOVS     R0,#+8
   \       0xEA   0xE147             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_17: (+1)
   \       0xEC   0x2010             MOVS     R0,#+16
   \       0xEE   0xE145             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_16: (+1)
   \       0xF0   0x2020             MOVS     R0,#+32
   \       0xF2   0xE143             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_18: (+1)
   \       0xF4   0x2040             MOVS     R0,#+64
   \       0xF6   0xE141             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_19: (+1)
   \       0xF8   0x2080             MOVS     R0,#+128
   \       0xFA   0xE13F             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_12: (+1)
   \       0xFC   0x6820             LDR      R0,[R4, #+0]
   \       0xFE   0x.... 0x....      LDR.W    R2,??DataTable15_5
   \      0x102   0x4290             CMP      R0,R2
   \      0x104   0xD11D             BNE.N    ??UART_SetConfig_20
   \      0x106   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \      0x10A   0x6800             LDR      R0,[R0, #+0]
   \      0x10C   0xF010 0x0007      ANDS     R0,R0,#0x7
   \      0x110   0x2800             CMP      R0,#+0
   \      0x112   0xD008             BEQ.N    ??UART_SetConfig_21
   \      0x114   0x2802             CMP      R0,#+2
   \      0x116   0xD00A             BEQ.N    ??UART_SetConfig_22
   \      0x118   0xD307             BCC.N    ??UART_SetConfig_23
   \      0x11A   0x2804             CMP      R0,#+4
   \      0x11C   0xD00B             BEQ.N    ??UART_SetConfig_24
   \      0x11E   0xD308             BCC.N    ??UART_SetConfig_25
   \      0x120   0x2805             CMP      R0,#+5
   \      0x122   0xD00A             BEQ.N    ??UART_SetConfig_26
   \      0x124   0xE00B             B.N      ??UART_SetConfig_27
   \                     ??UART_SetConfig_21: (+1)
   \      0x126   0x2000             MOVS     R0,#+0
   \      0x128   0xE128             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_23: (+1)
   \      0x12A   0x2004             MOVS     R0,#+4
   \      0x12C   0xE126             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_22: (+1)
   \      0x12E   0x2008             MOVS     R0,#+8
   \      0x130   0xE124             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_25: (+1)
   \      0x132   0x2010             MOVS     R0,#+16
   \      0x134   0xE122             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_24: (+1)
   \      0x136   0x2020             MOVS     R0,#+32
   \      0x138   0xE120             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_26: (+1)
   \      0x13A   0x2040             MOVS     R0,#+64
   \      0x13C   0xE11E             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_27: (+1)
   \      0x13E   0x2080             MOVS     R0,#+128
   \      0x140   0xE11C             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_20: (+1)
   \      0x142   0x6820             LDR      R0,[R4, #+0]
   \      0x144   0x.... 0x....      LDR.W    R2,??DataTable15_6
   \      0x148   0x4290             CMP      R0,R2
   \      0x14A   0xD11D             BNE.N    ??UART_SetConfig_28
   \      0x14C   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \      0x150   0x6800             LDR      R0,[R0, #+0]
   \      0x152   0xF010 0x0007      ANDS     R0,R0,#0x7
   \      0x156   0x2800             CMP      R0,#+0
   \      0x158   0xD008             BEQ.N    ??UART_SetConfig_29
   \      0x15A   0x2802             CMP      R0,#+2
   \      0x15C   0xD00A             BEQ.N    ??UART_SetConfig_30
   \      0x15E   0xD307             BCC.N    ??UART_SetConfig_31
   \      0x160   0x2804             CMP      R0,#+4
   \      0x162   0xD00B             BEQ.N    ??UART_SetConfig_32
   \      0x164   0xD308             BCC.N    ??UART_SetConfig_33
   \      0x166   0x2805             CMP      R0,#+5
   \      0x168   0xD00A             BEQ.N    ??UART_SetConfig_34
   \      0x16A   0xE00B             B.N      ??UART_SetConfig_35
   \                     ??UART_SetConfig_29: (+1)
   \      0x16C   0x2000             MOVS     R0,#+0
   \      0x16E   0xE105             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_31: (+1)
   \      0x170   0x2004             MOVS     R0,#+4
   \      0x172   0xE103             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_30: (+1)
   \      0x174   0x2008             MOVS     R0,#+8
   \      0x176   0xE101             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_33: (+1)
   \      0x178   0x2010             MOVS     R0,#+16
   \      0x17A   0xE0FF             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_32: (+1)
   \      0x17C   0x2020             MOVS     R0,#+32
   \      0x17E   0xE0FD             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_34: (+1)
   \      0x180   0x2040             MOVS     R0,#+64
   \      0x182   0xE0FB             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_35: (+1)
   \      0x184   0x2080             MOVS     R0,#+128
   \      0x186   0xE0F9             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_28: (+1)
   \      0x188   0x6820             LDR      R0,[R4, #+0]
   \      0x18A   0x.... 0x....      LDR.W    R2,??DataTable15_7
   \      0x18E   0x4290             CMP      R0,R2
   \      0x190   0xD11D             BNE.N    ??UART_SetConfig_36
   \      0x192   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \      0x196   0x6800             LDR      R0,[R0, #+0]
   \      0x198   0xF010 0x0007      ANDS     R0,R0,#0x7
   \      0x19C   0x2800             CMP      R0,#+0
   \      0x19E   0xD008             BEQ.N    ??UART_SetConfig_37
   \      0x1A0   0x2802             CMP      R0,#+2
   \      0x1A2   0xD00A             BEQ.N    ??UART_SetConfig_38
   \      0x1A4   0xD307             BCC.N    ??UART_SetConfig_39
   \      0x1A6   0x2804             CMP      R0,#+4
   \      0x1A8   0xD00B             BEQ.N    ??UART_SetConfig_40
   \      0x1AA   0xD308             BCC.N    ??UART_SetConfig_41
   \      0x1AC   0x2805             CMP      R0,#+5
   \      0x1AE   0xD00A             BEQ.N    ??UART_SetConfig_42
   \      0x1B0   0xE00B             B.N      ??UART_SetConfig_43
   \                     ??UART_SetConfig_37: (+1)
   \      0x1B2   0x2000             MOVS     R0,#+0
   \      0x1B4   0xE0E2             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_39: (+1)
   \      0x1B6   0x2004             MOVS     R0,#+4
   \      0x1B8   0xE0E0             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_38: (+1)
   \      0x1BA   0x2008             MOVS     R0,#+8
   \      0x1BC   0xE0DE             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_41: (+1)
   \      0x1BE   0x2010             MOVS     R0,#+16
   \      0x1C0   0xE0DC             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_40: (+1)
   \      0x1C2   0x2020             MOVS     R0,#+32
   \      0x1C4   0xE0DA             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_42: (+1)
   \      0x1C6   0x2040             MOVS     R0,#+64
   \      0x1C8   0xE0D8             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_43: (+1)
   \      0x1CA   0x2080             MOVS     R0,#+128
   \      0x1CC   0xE0D6             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_36: (+1)
   \      0x1CE   0x6820             LDR      R0,[R4, #+0]
   \      0x1D0   0x.... 0x....      LDR.W    R2,??DataTable15_8
   \      0x1D4   0x4290             CMP      R0,R2
   \      0x1D6   0xD11F             BNE.N    ??UART_SetConfig_44
   \      0x1D8   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \      0x1DC   0x6800             LDR      R0,[R0, #+0]
   \      0x1DE   0xF010 0x0038      ANDS     R0,R0,#0x38
   \      0x1E2   0x2800             CMP      R0,#+0
   \      0x1E4   0xD00A             BEQ.N    ??UART_SetConfig_45
   \      0x1E6   0x2808             CMP      R0,#+8
   \      0x1E8   0xD00A             BEQ.N    ??UART_SetConfig_46
   \      0x1EA   0x2810             CMP      R0,#+16
   \      0x1EC   0xD00A             BEQ.N    ??UART_SetConfig_47
   \      0x1EE   0x2818             CMP      R0,#+24
   \      0x1F0   0xD00A             BEQ.N    ??UART_SetConfig_48
   \      0x1F2   0x2820             CMP      R0,#+32
   \      0x1F4   0xD00A             BEQ.N    ??UART_SetConfig_49
   \      0x1F6   0x2828             CMP      R0,#+40
   \      0x1F8   0xD00A             BEQ.N    ??UART_SetConfig_50
   \      0x1FA   0xE00B             B.N      ??UART_SetConfig_51
   \                     ??UART_SetConfig_45: (+1)
   \      0x1FC   0x2001             MOVS     R0,#+1
   \      0x1FE   0xE0BD             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_46: (+1)
   \      0x200   0x2004             MOVS     R0,#+4
   \      0x202   0xE0BB             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_47: (+1)
   \      0x204   0x2008             MOVS     R0,#+8
   \      0x206   0xE0B9             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_48: (+1)
   \      0x208   0x2010             MOVS     R0,#+16
   \      0x20A   0xE0B7             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_49: (+1)
   \      0x20C   0x2020             MOVS     R0,#+32
   \      0x20E   0xE0B5             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_50: (+1)
   \      0x210   0x2040             MOVS     R0,#+64
   \      0x212   0xE0B3             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_51: (+1)
   \      0x214   0x2080             MOVS     R0,#+128
   \      0x216   0xE0B1             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_44: (+1)
   \      0x218   0x6820             LDR      R0,[R4, #+0]
   \      0x21A   0x.... 0x....      LDR.W    R2,??DataTable15_9
   \      0x21E   0x4290             CMP      R0,R2
   \      0x220   0xD11D             BNE.N    ??UART_SetConfig_52
   \      0x222   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \      0x226   0x6800             LDR      R0,[R0, #+0]
   \      0x228   0xF010 0x0007      ANDS     R0,R0,#0x7
   \      0x22C   0x2800             CMP      R0,#+0
   \      0x22E   0xD008             BEQ.N    ??UART_SetConfig_53
   \      0x230   0x2802             CMP      R0,#+2
   \      0x232   0xD00A             BEQ.N    ??UART_SetConfig_54
   \      0x234   0xD307             BCC.N    ??UART_SetConfig_55
   \      0x236   0x2804             CMP      R0,#+4
   \      0x238   0xD00B             BEQ.N    ??UART_SetConfig_56
   \      0x23A   0xD308             BCC.N    ??UART_SetConfig_57
   \      0x23C   0x2805             CMP      R0,#+5
   \      0x23E   0xD00A             BEQ.N    ??UART_SetConfig_58
   \      0x240   0xE00B             B.N      ??UART_SetConfig_59
   \                     ??UART_SetConfig_53: (+1)
   \      0x242   0x2000             MOVS     R0,#+0
   \      0x244   0xE09A             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_55: (+1)
   \      0x246   0x2004             MOVS     R0,#+4
   \      0x248   0xE098             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_54: (+1)
   \      0x24A   0x2008             MOVS     R0,#+8
   \      0x24C   0xE096             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_57: (+1)
   \      0x24E   0x2010             MOVS     R0,#+16
   \      0x250   0xE094             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_56: (+1)
   \      0x252   0x2020             MOVS     R0,#+32
   \      0x254   0xE092             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_58: (+1)
   \      0x256   0x2040             MOVS     R0,#+64
   \      0x258   0xE090             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_59: (+1)
   \      0x25A   0x2080             MOVS     R0,#+128
   \      0x25C   0xE08E             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_52: (+1)
   \      0x25E   0x6820             LDR      R0,[R4, #+0]
   \      0x260   0x.... 0x....      LDR.W    R2,??DataTable15_10
   \      0x264   0x4290             CMP      R0,R2
   \      0x266   0xD11D             BNE.N    ??UART_SetConfig_60
   \      0x268   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \      0x26C   0x6800             LDR      R0,[R0, #+0]
   \      0x26E   0xF010 0x0007      ANDS     R0,R0,#0x7
   \      0x272   0x2800             CMP      R0,#+0
   \      0x274   0xD008             BEQ.N    ??UART_SetConfig_61
   \      0x276   0x2802             CMP      R0,#+2
   \      0x278   0xD00A             BEQ.N    ??UART_SetConfig_62
   \      0x27A   0xD307             BCC.N    ??UART_SetConfig_63
   \      0x27C   0x2804             CMP      R0,#+4
   \      0x27E   0xD00B             BEQ.N    ??UART_SetConfig_64
   \      0x280   0xD308             BCC.N    ??UART_SetConfig_65
   \      0x282   0x2805             CMP      R0,#+5
   \      0x284   0xD00A             BEQ.N    ??UART_SetConfig_66
   \      0x286   0xE00B             B.N      ??UART_SetConfig_67
   \                     ??UART_SetConfig_61: (+1)
   \      0x288   0x2000             MOVS     R0,#+0
   \      0x28A   0xE077             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_63: (+1)
   \      0x28C   0x2004             MOVS     R0,#+4
   \      0x28E   0xE075             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_62: (+1)
   \      0x290   0x2008             MOVS     R0,#+8
   \      0x292   0xE073             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_65: (+1)
   \      0x294   0x2010             MOVS     R0,#+16
   \      0x296   0xE071             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_64: (+1)
   \      0x298   0x2020             MOVS     R0,#+32
   \      0x29A   0xE06F             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_66: (+1)
   \      0x29C   0x2040             MOVS     R0,#+64
   \      0x29E   0xE06D             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_67: (+1)
   \      0x2A0   0x2080             MOVS     R0,#+128
   \      0x2A2   0xE06B             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_60: (+1)
   \      0x2A4   0x6820             LDR      R0,[R4, #+0]
   \      0x2A6   0x.... 0x....      LDR.W    R2,??DataTable15_11
   \      0x2AA   0x4290             CMP      R0,R2
   \      0x2AC   0xD11F             BNE.N    ??UART_SetConfig_68
   \      0x2AE   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \      0x2B2   0x6800             LDR      R0,[R0, #+0]
   \      0x2B4   0xF010 0x0038      ANDS     R0,R0,#0x38
   \      0x2B8   0x2800             CMP      R0,#+0
   \      0x2BA   0xD00A             BEQ.N    ??UART_SetConfig_69
   \      0x2BC   0x2808             CMP      R0,#+8
   \      0x2BE   0xD00A             BEQ.N    ??UART_SetConfig_70
   \      0x2C0   0x2810             CMP      R0,#+16
   \      0x2C2   0xD00A             BEQ.N    ??UART_SetConfig_71
   \      0x2C4   0x2818             CMP      R0,#+24
   \      0x2C6   0xD00A             BEQ.N    ??UART_SetConfig_72
   \      0x2C8   0x2820             CMP      R0,#+32
   \      0x2CA   0xD00A             BEQ.N    ??UART_SetConfig_73
   \      0x2CC   0x2828             CMP      R0,#+40
   \      0x2CE   0xD00A             BEQ.N    ??UART_SetConfig_74
   \      0x2D0   0xE00B             B.N      ??UART_SetConfig_75
   \                     ??UART_SetConfig_69: (+1)
   \      0x2D2   0x2001             MOVS     R0,#+1
   \      0x2D4   0xE052             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_70: (+1)
   \      0x2D6   0x2004             MOVS     R0,#+4
   \      0x2D8   0xE050             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_71: (+1)
   \      0x2DA   0x2008             MOVS     R0,#+8
   \      0x2DC   0xE04E             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_72: (+1)
   \      0x2DE   0x2010             MOVS     R0,#+16
   \      0x2E0   0xE04C             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_73: (+1)
   \      0x2E2   0x2020             MOVS     R0,#+32
   \      0x2E4   0xE04A             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_74: (+1)
   \      0x2E6   0x2040             MOVS     R0,#+64
   \      0x2E8   0xE048             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_75: (+1)
   \      0x2EA   0x2080             MOVS     R0,#+128
   \      0x2EC   0xE046             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_68: (+1)
   \      0x2EE   0x6820             LDR      R0,[R4, #+0]
   \      0x2F0   0x.... 0x....      LDR.W    R2,??DataTable15_12
   \      0x2F4   0x4290             CMP      R0,R2
   \      0x2F6   0xD11F             BNE.N    ??UART_SetConfig_76
   \      0x2F8   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \      0x2FC   0x6800             LDR      R0,[R0, #+0]
   \      0x2FE   0xF010 0x0038      ANDS     R0,R0,#0x38
   \      0x302   0x2800             CMP      R0,#+0
   \      0x304   0xD00A             BEQ.N    ??UART_SetConfig_77
   \      0x306   0x2808             CMP      R0,#+8
   \      0x308   0xD00A             BEQ.N    ??UART_SetConfig_78
   \      0x30A   0x2810             CMP      R0,#+16
   \      0x30C   0xD00A             BEQ.N    ??UART_SetConfig_79
   \      0x30E   0x2818             CMP      R0,#+24
   \      0x310   0xD00A             BEQ.N    ??UART_SetConfig_80
   \      0x312   0x2820             CMP      R0,#+32
   \      0x314   0xD00A             BEQ.N    ??UART_SetConfig_81
   \      0x316   0x2828             CMP      R0,#+40
   \      0x318   0xD00A             BEQ.N    ??UART_SetConfig_82
   \      0x31A   0xE00B             B.N      ??UART_SetConfig_83
   \                     ??UART_SetConfig_77: (+1)
   \      0x31C   0x2001             MOVS     R0,#+1
   \      0x31E   0xE02D             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_78: (+1)
   \      0x320   0x2004             MOVS     R0,#+4
   \      0x322   0xE02B             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_79: (+1)
   \      0x324   0x2008             MOVS     R0,#+8
   \      0x326   0xE029             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_80: (+1)
   \      0x328   0x2010             MOVS     R0,#+16
   \      0x32A   0xE027             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_81: (+1)
   \      0x32C   0x2020             MOVS     R0,#+32
   \      0x32E   0xE025             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_82: (+1)
   \      0x330   0x2040             MOVS     R0,#+64
   \      0x332   0xE023             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_83: (+1)
   \      0x334   0x2080             MOVS     R0,#+128
   \      0x336   0xE021             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_76: (+1)
   \      0x338   0x6820             LDR      R0,[R4, #+0]
   \      0x33A   0x4288             CMP      R0,R1
   \      0x33C   0xD11D             BNE.N    ??UART_SetConfig_84
   \      0x33E   0x.... 0x....      LDR.W    R0,??DataTable15_13
   \      0x342   0x6800             LDR      R0,[R0, #+0]
   \      0x344   0xF010 0x0007      ANDS     R0,R0,#0x7
   \      0x348   0x2800             CMP      R0,#+0
   \      0x34A   0xD008             BEQ.N    ??UART_SetConfig_85
   \      0x34C   0x2802             CMP      R0,#+2
   \      0x34E   0xD00A             BEQ.N    ??UART_SetConfig_86
   \      0x350   0xD307             BCC.N    ??UART_SetConfig_87
   \      0x352   0x2804             CMP      R0,#+4
   \      0x354   0xD00B             BEQ.N    ??UART_SetConfig_88
   \      0x356   0xD308             BCC.N    ??UART_SetConfig_89
   \      0x358   0x2805             CMP      R0,#+5
   \      0x35A   0xD00A             BEQ.N    ??UART_SetConfig_90
   \      0x35C   0xE00B             B.N      ??UART_SetConfig_91
   \                     ??UART_SetConfig_85: (+1)
   \      0x35E   0x2002             MOVS     R0,#+2
   \      0x360   0xE00C             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_87: (+1)
   \      0x362   0x2004             MOVS     R0,#+4
   \      0x364   0xE00A             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_86: (+1)
   \      0x366   0x2008             MOVS     R0,#+8
   \      0x368   0xE008             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_89: (+1)
   \      0x36A   0x2010             MOVS     R0,#+16
   \      0x36C   0xE006             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_88: (+1)
   \      0x36E   0x2020             MOVS     R0,#+32
   \      0x370   0xE004             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_90: (+1)
   \      0x372   0x2040             MOVS     R0,#+64
   \      0x374   0xE002             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_91: (+1)
   \      0x376   0x2080             MOVS     R0,#+128
   \      0x378   0xE000             B.N      ??UART_SetConfig_11
   \                     ??UART_SetConfig_84: (+1)
   \      0x37A   0x2080             MOVS     R0,#+128
   3090          
   3091            /* Check LPUART instance */
   3092            if (UART_INSTANCE_LOWPOWER(huart))
   \                     ??UART_SetConfig_11: (+1)
   \      0x37C   0x6822             LDR      R2,[R4, #+0]
   \      0x37E   0x428A             CMP      R2,R1
   \      0x380   0xD163             BNE.N    ??UART_SetConfig_92
   3093            {
   3094              /* Retrieve frequency clock */
   3095              switch (clocksource)
   \      0x382   0xB2C0             UXTB     R0,R0
   \      0x384   0x2802             CMP      R0,#+2
   \      0x386   0xD00A             BEQ.N    ??UART_SetConfig_93
   \      0x388   0x2804             CMP      R0,#+4
   \      0x38A   0xD00B             BEQ.N    ??UART_SetConfig_94
   \      0x38C   0x2808             CMP      R0,#+8
   \      0x38E   0xD00E             BEQ.N    ??UART_SetConfig_95
   \      0x390   0x2810             CMP      R0,#+16
   \      0x392   0xD011             BEQ.N    ??UART_SetConfig_96
   \      0x394   0x2820             CMP      R0,#+32
   \      0x396   0xD01E             BEQ.N    ??UART_SetConfig_97
   \      0x398   0x2840             CMP      R0,#+64
   \      0x39A   0xD01F             BEQ.N    ??UART_SetConfig_98
   \      0x39C   0xE021             B.N      ??UART_SetConfig_99
   3096              {
   3097                case UART_CLOCKSOURCE_D3PCLK1:
   3098                  pclk = HAL_RCCEx_GetD3PCLK1Freq();
   \                     ??UART_SetConfig_93: (+1)
   \      0x39E   0x.... 0x....      BL       HAL_RCCEx_GetD3PCLK1Freq
   3099                  break;
   \      0x3A2   0xE020             B.N      ??UART_SetConfig_100
   3100                case UART_CLOCKSOURCE_PLL2:
   3101                  HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \                     ??UART_SetConfig_94: (+1)
   \      0x3A4   0xA803             ADD      R0,SP,#+12
   \      0x3A6   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3102                  pclk = pll2_clocks.PLL2_Q_Frequency;
   \      0x3AA   0x9804             LDR      R0,[SP, #+16]
   3103                  break;
   \      0x3AC   0xE01B             B.N      ??UART_SetConfig_100
   3104                case UART_CLOCKSOURCE_PLL3:
   3105                  HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \                     ??UART_SetConfig_95: (+1)
   \      0x3AE   0x4668             MOV      R0,SP
   \      0x3B0   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3106                  pclk = pll3_clocks.PLL3_Q_Frequency;
   \      0x3B4   0x9801             LDR      R0,[SP, #+4]
   3107                  break;
   \      0x3B6   0xE016             B.N      ??UART_SetConfig_100
   3108                case UART_CLOCKSOURCE_HSI:
   3109                  if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
   \                     ??UART_SetConfig_96: (+1)
   \      0x3B8   0x.... 0x....      LDR.W    R1,??DataTable15_14
   \      0x3BC   0x6808             LDR      R0,[R1, #+0]
   \      0x3BE   0x0680             LSLS     R0,R0,#+26
   \      0x3C0   0xD506             BPL.N    ??UART_SetConfig_101
   3110                  {
   3111                    pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
   \      0x3C2   0x.... 0x....      LDR.W    R0,??DataTable15_15
   \      0x3C6   0x6809             LDR      R1,[R1, #+0]
   \      0x3C8   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x3CC   0x40C8             LSRS     R0,R0,R1
   \      0x3CE   0xE001             B.N      ??UART_SetConfig_102
   3112                  }
   3113                  else
   3114                  {
   3115                    pclk = (uint32_t) HSI_VALUE;
   \                     ??UART_SetConfig_101: (+1)
   \      0x3D0   0x.... 0x....      LDR.W    R0,??DataTable15_15
   3116                  }
   3117                  break;
   \                     ??UART_SetConfig_102: (+1)
   \      0x3D4   0xE007             B.N      ??UART_SetConfig_100
   3118                case UART_CLOCKSOURCE_CSI:
   3119                  pclk = (uint32_t) CSI_VALUE;
   \                     ??UART_SetConfig_97: (+1)
   \      0x3D6   0x.... 0x....      LDR.W    R0,??DataTable15_16
   3120                  break;
   \      0x3DA   0xE004             B.N      ??UART_SetConfig_100
   3121                case UART_CLOCKSOURCE_LSE:
   3122                  pclk = (uint32_t) LSE_VALUE;
   \                     ??UART_SetConfig_98: (+1)
   \      0x3DC   0xF44F 0x4000      MOV      R0,#+32768
   3123                  break;
   \      0x3E0   0xE001             B.N      ??UART_SetConfig_100
   3124                default:
   3125                  pclk = 0U;
   \                     ??UART_SetConfig_99: (+1)
   \      0x3E2   0x2000             MOVS     R0,#+0
   3126                  ret = HAL_ERROR;
   \      0x3E4   0x2501             MOVS     R5,#+1
   3127                  break;
   3128              }
   3129          
   3130              /* If proper clock source reported */
   3131              if (pclk != 0U)
   \                     ??UART_SetConfig_100: (+1)
   \      0x3E6   0x2800             CMP      R0,#+0
   \      0x3E8   0xF000 0x80DB      BEQ.W    ??UART_SetConfig_103
   3132              {
   3133                /* Compute clock after Prescaler */
   3134                lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
   \      0x3EC   0x.... 0x....      LDR.W    R3,??DataTable15_17
   \      0x3F0   0x6A61             LDR      R1,[R4, #+36]
   \      0x3F2   0xF833 0x1011      LDRH     R1,[R3, R1, LSL #+1]
   \      0x3F6   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   3135          
   3136                /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
   3137                if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
   3138                    (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
   \      0x3FA   0x6866             LDR      R6,[R4, #+4]
   \      0x3FC   0x2103             MOVS     R1,#+3
   \      0x3FE   0x434E             MULS     R6,R1,R6
   \      0x400   0x42B2             CMP      R2,R6
   \      0x402   0xD305             BCC.N    ??UART_SetConfig_104
   \      0x404   0x6866             LDR      R6,[R4, #+4]
   \      0x406   0xF44F 0x5180      MOV      R1,#+4096
   \      0x40A   0x434E             MULS     R6,R1,R6
   \      0x40C   0x4296             CMP      R6,R2
   \      0x40E   0xD201             BCS.N    ??UART_SetConfig_105
   3139                {
   3140                  ret = HAL_ERROR;
   \                     ??UART_SetConfig_104: (+1)
   \      0x410   0x2501             MOVS     R5,#+1
   \      0x412   0xE0C6             B.N      ??UART_SetConfig_103
   3141                }
   3142                else
   3143                {
   3144                  /* Check computed UsartDiv value is in allocated range
   3145                     (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
   3146                  usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
   \                     ??UART_SetConfig_105: (+1)
   \      0x414   0x6A61             LDR      R1,[R4, #+36]
   \      0x416   0xF833 0x1011      LDRH     R1,[R3, R1, LSL #+1]
   \      0x41A   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \      0x41E   0xF44F 0x7380      MOV      R3,#+256
   \      0x422   0x6860             LDR      R0,[R4, #+4]
   \      0x424   0x0840             LSRS     R0,R0,#+1
   \      0x426   0x2100             MOVS     R1,#+0
   \      0x428   0xFBE3 0x0102      UMLAL    R0,R1,R3,R2
   \      0x42C   0x6862             LDR      R2,[R4, #+4]
   \      0x42E   0x2300             MOVS     R3,#+0
   \      0x430   0x.... 0x....      BL       __aeabi_uldivmod
   3147                  if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
   \      0x434   0xF5B0 0x7140      SUBS     R1,R0,#+768
   \      0x438   0x.... 0x....      LDR.W    R2,??DataTable15_18
   \      0x43C   0x4291             CMP      R1,R2
   \      0x43E   0xD202             BCS.N    ??UART_SetConfig_106
   3148                  {
   3149                    huart->Instance->BRR = usartdiv;
   \      0x440   0x6821             LDR      R1,[R4, #+0]
   \      0x442   0x60C8             STR      R0,[R1, #+12]
   \      0x444   0xE0AD             B.N      ??UART_SetConfig_103
   3150                  }
   3151                  else
   3152                  {
   3153                    ret = HAL_ERROR;
   \                     ??UART_SetConfig_106: (+1)
   \      0x446   0x2501             MOVS     R5,#+1
   \      0x448   0xE0AB             B.N      ??UART_SetConfig_103
   3154                  }
   3155                } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
   3156                          (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
   3157              } /* if (pclk != 0) */
   3158            }
   3159            /* Check UART Over Sampling to set Baud Rate Register */
   3160            else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
   \                     ??UART_SetConfig_92: (+1)
   \      0x44A   0x69E1             LDR      R1,[R4, #+28]
   \      0x44C   0xF5B1 0x4F00      CMP      R1,#+32768
   \      0x450   0xD156             BNE.N    ??UART_SetConfig_107
   3161            {
   3162              switch (clocksource)
   \      0x452   0xB2C0             UXTB     R0,R0
   \      0x454   0x2800             CMP      R0,#+0
   \      0x456   0xD00C             BEQ.N    ??UART_SetConfig_108
   \      0x458   0x2801             CMP      R0,#+1
   \      0x45A   0xD00D             BEQ.N    ??UART_SetConfig_109
   \      0x45C   0x2804             CMP      R0,#+4
   \      0x45E   0xD00E             BEQ.N    ??UART_SetConfig_110
   \      0x460   0x2808             CMP      R0,#+8
   \      0x462   0xD011             BEQ.N    ??UART_SetConfig_111
   \      0x464   0x2810             CMP      R0,#+16
   \      0x466   0xD014             BEQ.N    ??UART_SetConfig_112
   \      0x468   0x2820             CMP      R0,#+32
   \      0x46A   0xD021             BEQ.N    ??UART_SetConfig_113
   \      0x46C   0x2840             CMP      R0,#+64
   \      0x46E   0xD022             BEQ.N    ??UART_SetConfig_114
   \      0x470   0xE024             B.N      ??UART_SetConfig_115
   3163              {
   3164                case UART_CLOCKSOURCE_D2PCLK1:
   3165                  pclk = HAL_RCC_GetPCLK1Freq();
   \                     ??UART_SetConfig_108: (+1)
   \      0x472   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   3166                  break;
   \      0x476   0xE023             B.N      ??UART_SetConfig_116
   3167                case UART_CLOCKSOURCE_D2PCLK2:
   3168                  pclk = HAL_RCC_GetPCLK2Freq();
   \                     ??UART_SetConfig_109: (+1)
   \      0x478   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   3169                  break;
   \      0x47C   0xE020             B.N      ??UART_SetConfig_116
   3170                case UART_CLOCKSOURCE_PLL2:
   3171                  HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \                     ??UART_SetConfig_110: (+1)
   \      0x47E   0xA803             ADD      R0,SP,#+12
   \      0x480   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3172                  pclk = pll2_clocks.PLL2_Q_Frequency;
   \      0x484   0x9804             LDR      R0,[SP, #+16]
   3173                  break;
   \      0x486   0xE01B             B.N      ??UART_SetConfig_116
   3174                case UART_CLOCKSOURCE_PLL3:
   3175                  HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \                     ??UART_SetConfig_111: (+1)
   \      0x488   0x4668             MOV      R0,SP
   \      0x48A   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3176                  pclk = pll3_clocks.PLL3_Q_Frequency;
   \      0x48E   0x9801             LDR      R0,[SP, #+4]
   3177                  break;
   \      0x490   0xE016             B.N      ??UART_SetConfig_116
   3178                case UART_CLOCKSOURCE_HSI:
   3179                  if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
   \                     ??UART_SetConfig_112: (+1)
   \      0x492   0x.... 0x....      LDR.W    R1,??DataTable15_14
   \      0x496   0x6808             LDR      R0,[R1, #+0]
   \      0x498   0x0680             LSLS     R0,R0,#+26
   \      0x49A   0xD506             BPL.N    ??UART_SetConfig_117
   3180                  {
   3181                    pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
   \      0x49C   0x.... 0x....      LDR.W    R0,??DataTable15_15
   \      0x4A0   0x6809             LDR      R1,[R1, #+0]
   \      0x4A2   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x4A6   0x40C8             LSRS     R0,R0,R1
   \      0x4A8   0xE001             B.N      ??UART_SetConfig_118
   3182                  }
   3183                  else
   3184                  {
   3185                    pclk = (uint32_t) HSI_VALUE;
   \                     ??UART_SetConfig_117: (+1)
   \      0x4AA   0x.... 0x....      LDR.W    R0,??DataTable15_15
   3186                  }
   3187                  break;
   \                     ??UART_SetConfig_118: (+1)
   \      0x4AE   0xE007             B.N      ??UART_SetConfig_116
   3188                case UART_CLOCKSOURCE_CSI:
   3189                  pclk = (uint32_t) CSI_VALUE;
   \                     ??UART_SetConfig_113: (+1)
   \      0x4B0   0x.... 0x....      LDR.W    R0,??DataTable15_16
   3190                  break;
   \      0x4B4   0xE004             B.N      ??UART_SetConfig_116
   3191                case UART_CLOCKSOURCE_LSE:
   3192                  pclk = (uint32_t) LSE_VALUE;
   \                     ??UART_SetConfig_114: (+1)
   \      0x4B6   0xF44F 0x4000      MOV      R0,#+32768
   3193                  break;
   \      0x4BA   0xE001             B.N      ??UART_SetConfig_116
   3194                default:
   3195                  pclk = 0U;
   \                     ??UART_SetConfig_115: (+1)
   \      0x4BC   0x2000             MOVS     R0,#+0
   3196                  ret = HAL_ERROR;
   \      0x4BE   0x2501             MOVS     R5,#+1
   3197                  break;
   3198              }
   3199          
   3200              /* USARTDIV must be greater than or equal to 0d16 */
   3201              if (pclk != 0U)
   \                     ??UART_SetConfig_116: (+1)
   \      0x4C0   0x2800             CMP      R0,#+0
   \      0x4C2   0xD06E             BEQ.N    ??UART_SetConfig_103
   3202              {
   3203                usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
   \      0x4C4   0x.... 0x....      LDR.W    R1,??DataTable15_17
   \      0x4C8   0x6A62             LDR      R2,[R4, #+36]
   \      0x4CA   0xF831 0x1012      LDRH     R1,[R1, R2, LSL #+1]
   \      0x4CE   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \      0x4D2   0x6861             LDR      R1,[R4, #+4]
   \      0x4D4   0x0849             LSRS     R1,R1,#+1
   \      0x4D6   0xEB11 0x0140      ADDS     R1,R1,R0, LSL #+1
   \      0x4DA   0x6860             LDR      R0,[R4, #+4]
   \      0x4DC   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   3204                if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
   \      0x4E0   0xF64F 0x71F0      MOVW     R1,#+65520
   \      0x4E4   0xF1B0 0x0210      SUBS     R2,R0,#+16
   \      0x4E8   0x428A             CMP      R2,R1
   \      0x4EA   0xD207             BCS.N    ??UART_SetConfig_119
   3205                {
   3206                  brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
   \      0x4EC   0x4001             ANDS     R1,R1,R0
   3207                  brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
   \      0x4EE   0xF3C0 0x0042      UBFX     R0,R0,#+1,#+3
   \      0x4F2   0x4301             ORRS     R1,R0,R1
   3208                  huart->Instance->BRR = brrtemp;
   \      0x4F4   0xB289             UXTH     R1,R1
   \      0x4F6   0x6820             LDR      R0,[R4, #+0]
   \      0x4F8   0x60C1             STR      R1,[R0, #+12]
   \      0x4FA   0xE052             B.N      ??UART_SetConfig_103
   3209                }
   3210                else
   3211                {
   3212                  ret = HAL_ERROR;
   \                     ??UART_SetConfig_119: (+1)
   \      0x4FC   0x2501             MOVS     R5,#+1
   \      0x4FE   0xE050             B.N      ??UART_SetConfig_103
   3213                }
   3214              }
   3215            }
   3216            else
   3217            {
   3218              switch (clocksource)
   \                     ??UART_SetConfig_107: (+1)
   \      0x500   0xB2C0             UXTB     R0,R0
   \      0x502   0x2800             CMP      R0,#+0
   \      0x504   0xD00C             BEQ.N    ??UART_SetConfig_120
   \      0x506   0x2801             CMP      R0,#+1
   \      0x508   0xD00D             BEQ.N    ??UART_SetConfig_121
   \      0x50A   0x2804             CMP      R0,#+4
   \      0x50C   0xD00E             BEQ.N    ??UART_SetConfig_122
   \      0x50E   0x2808             CMP      R0,#+8
   \      0x510   0xD011             BEQ.N    ??UART_SetConfig_123
   \      0x512   0x2810             CMP      R0,#+16
   \      0x514   0xD014             BEQ.N    ??UART_SetConfig_124
   \      0x516   0x2820             CMP      R0,#+32
   \      0x518   0xD021             BEQ.N    ??UART_SetConfig_125
   \      0x51A   0x2840             CMP      R0,#+64
   \      0x51C   0xD022             BEQ.N    ??UART_SetConfig_126
   \      0x51E   0xE024             B.N      ??UART_SetConfig_127
   3219              {
   3220                case UART_CLOCKSOURCE_D2PCLK1:
   3221                  pclk = HAL_RCC_GetPCLK1Freq();
   \                     ??UART_SetConfig_120: (+1)
   \      0x520   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   3222                  break;
   \      0x524   0xE023             B.N      ??UART_SetConfig_128
   3223                case UART_CLOCKSOURCE_D2PCLK2:
   3224                  pclk = HAL_RCC_GetPCLK2Freq();
   \                     ??UART_SetConfig_121: (+1)
   \      0x526   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   3225                  break;
   \      0x52A   0xE020             B.N      ??UART_SetConfig_128
   3226                case UART_CLOCKSOURCE_PLL2:
   3227                  HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
   \                     ??UART_SetConfig_122: (+1)
   \      0x52C   0xA803             ADD      R0,SP,#+12
   \      0x52E   0x.... 0x....      BL       HAL_RCCEx_GetPLL2ClockFreq
   3228                  pclk = pll2_clocks.PLL2_Q_Frequency;
   \      0x532   0x9804             LDR      R0,[SP, #+16]
   3229                  break;
   \      0x534   0xE01B             B.N      ??UART_SetConfig_128
   3230                case UART_CLOCKSOURCE_PLL3:
   3231                  HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
   \                     ??UART_SetConfig_123: (+1)
   \      0x536   0x4668             MOV      R0,SP
   \      0x538   0x.... 0x....      BL       HAL_RCCEx_GetPLL3ClockFreq
   3232                  pclk = pll3_clocks.PLL3_Q_Frequency;
   \      0x53C   0x9801             LDR      R0,[SP, #+4]
   3233                  break;
   \      0x53E   0xE016             B.N      ??UART_SetConfig_128
   3234                case UART_CLOCKSOURCE_HSI:
   3235                  if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
   \                     ??UART_SetConfig_124: (+1)
   \      0x540   0x.... 0x....      LDR.W    R1,??DataTable15_14
   \      0x544   0x6808             LDR      R0,[R1, #+0]
   \      0x546   0x0680             LSLS     R0,R0,#+26
   \      0x548   0xD506             BPL.N    ??UART_SetConfig_129
   3236                  {
   3237                    pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
   \      0x54A   0x.... 0x....      LDR.W    R0,??DataTable15_15
   \      0x54E   0x6809             LDR      R1,[R1, #+0]
   \      0x550   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \      0x554   0x40C8             LSRS     R0,R0,R1
   \      0x556   0xE001             B.N      ??UART_SetConfig_130
   3238                  }
   3239                  else
   3240                  {
   3241                    pclk = (uint32_t) HSI_VALUE;
   \                     ??UART_SetConfig_129: (+1)
   \      0x558   0x.... 0x....      LDR.W    R0,??DataTable15_15
   3242                  }
   3243                  break;
   \                     ??UART_SetConfig_130: (+1)
   \      0x55C   0xE007             B.N      ??UART_SetConfig_128
   3244                case UART_CLOCKSOURCE_CSI:
   3245                  pclk = (uint32_t) CSI_VALUE;
   \                     ??UART_SetConfig_125: (+1)
   \      0x55E   0x.... 0x....      LDR.W    R0,??DataTable15_16
   3246                  break;
   \      0x562   0xE004             B.N      ??UART_SetConfig_128
   3247                case UART_CLOCKSOURCE_LSE:
   3248                  pclk = (uint32_t) LSE_VALUE;
   \                     ??UART_SetConfig_126: (+1)
   \      0x564   0xF44F 0x4000      MOV      R0,#+32768
   3249                  break;
   \      0x568   0xE001             B.N      ??UART_SetConfig_128
   3250                default:
   3251                  pclk = 0U;
   \                     ??UART_SetConfig_127: (+1)
   \      0x56A   0x2000             MOVS     R0,#+0
   3252                  ret = HAL_ERROR;
   \      0x56C   0x2501             MOVS     R5,#+1
   3253                  break;
   3254              }
   3255          
   3256              if (pclk != 0U)
   \                     ??UART_SetConfig_128: (+1)
   \      0x56E   0x2800             CMP      R0,#+0
   \      0x570   0xD017             BEQ.N    ??UART_SetConfig_103
   3257              {
   3258                /* USARTDIV must be greater than or equal to 0d16 */
   3259                usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
   \      0x572   0x.... 0x....      LDR.W    R1,??DataTable15_17
   \      0x576   0x6A62             LDR      R2,[R4, #+36]
   \      0x578   0xF831 0x1012      LDRH     R1,[R1, R2, LSL #+1]
   \      0x57C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \      0x580   0x6861             LDR      R1,[R4, #+4]
   \      0x582   0xEB10 0x0051      ADDS     R0,R0,R1, LSR #+1
   \      0x586   0x6861             LDR      R1,[R4, #+4]
   \      0x588   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   3260                if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
   \      0x58C   0xF1B0 0x0110      SUBS     R1,R0,#+16
   \      0x590   0xF64F 0x72F0      MOVW     R2,#+65520
   \      0x594   0x4291             CMP      R1,R2
   \      0x596   0xD203             BCS.N    ??UART_SetConfig_131
   3261                {
   3262                  huart->Instance->BRR = (uint16_t)usartdiv;
   \      0x598   0xB280             UXTH     R0,R0
   \      0x59A   0x6821             LDR      R1,[R4, #+0]
   \      0x59C   0x60C8             STR      R0,[R1, #+12]
   \      0x59E   0xE000             B.N      ??UART_SetConfig_103
   3263                }
   3264                else
   3265                {
   3266                  ret = HAL_ERROR;
   \                     ??UART_SetConfig_131: (+1)
   \      0x5A0   0x2501             MOVS     R5,#+1
   3267                }
   3268              }
   3269            }
   3270          
   3271            /* Initialize the number of data to process during RX/TX ISR execution */
   3272            huart->NbTxDataToProcess = 1;
   \                     ??UART_SetConfig_103: (+1)
   \      0x5A2   0x2001             MOVS     R0,#+1
   \      0x5A4   0xF8A4 0x006A      STRH     R0,[R4, #+106]
   3273            huart->NbRxDataToProcess = 1;
   \      0x5A8   0x2001             MOVS     R0,#+1
   \      0x5AA   0xF8A4 0x0068      STRH     R0,[R4, #+104]
   3274          
   3275            /* Clear ISR function pointers */
   3276            huart->RxISR = NULL;
   \      0x5AE   0x2000             MOVS     R0,#+0
   \      0x5B0   0x6720             STR      R0,[R4, #+112]
   3277            huart->TxISR = NULL;
   \      0x5B2   0x2000             MOVS     R0,#+0
   \      0x5B4   0x6760             STR      R0,[R4, #+116]
   3278          
   3279            return ret;
   \      0x5B6   0x0028             MOVS     R0,R5
   \      0x5B8   0xB2C0             UXTB     R0,R0
   \      0x5BA   0xB006             ADD      SP,SP,#+24
   \      0x5BC   0xBD70             POP      {R4-R6,PC}
   3280          }
   3281          
   3282          /**
   3283            * @brief Configure the UART peripheral advanced features.
   3284            * @param huart UART handle.
   3285            * @retval None
   3286            */

   \                                 In section .text, align 2, keep-with-next
   3287          void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
   3288          {
   3289            /* Check whether the set of advanced features to configure is properly set */
   3290            assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
   3291          
   3292            /* if required, configure TX pin active level inversion */
   3293            if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
   \                     UART_AdvFeatureConfig: (+1)
   \        0x0   0xF890 0x1028      LDRB     R1,[R0, #+40]
   \        0x4   0x07C9             LSLS     R1,R1,#+31
   \        0x6   0xD507             BPL.N    ??UART_AdvFeatureConfig_0
   3294            {
   3295              assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
   3296              MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0x684A             LDR      R2,[R1, #+4]
   \        0xC   0xF432 0x3200      BICS     R2,R2,#0x20000
   \       0x10   0x6AC1             LDR      R1,[R0, #+44]
   \       0x12   0x430A             ORRS     R2,R1,R2
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0x604A             STR      R2,[R1, #+4]
   3297            }
   3298          
   3299            /* if required, configure RX pin active level inversion */
   3300            if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
   \                     ??UART_AdvFeatureConfig_0: (+1)
   \       0x18   0xF890 0x1028      LDRB     R1,[R0, #+40]
   \       0x1C   0x0789             LSLS     R1,R1,#+30
   \       0x1E   0xD507             BPL.N    ??UART_AdvFeatureConfig_1
   3301            {
   3302              assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
   3303              MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
   \       0x20   0x6801             LDR      R1,[R0, #+0]
   \       0x22   0x684A             LDR      R2,[R1, #+4]
   \       0x24   0xF432 0x3280      BICS     R2,R2,#0x10000
   \       0x28   0x6B01             LDR      R1,[R0, #+48]
   \       0x2A   0x430A             ORRS     R2,R1,R2
   \       0x2C   0x6801             LDR      R1,[R0, #+0]
   \       0x2E   0x604A             STR      R2,[R1, #+4]
   3304            }
   3305          
   3306            /* if required, configure data inversion */
   3307            if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
   \                     ??UART_AdvFeatureConfig_1: (+1)
   \       0x30   0xF890 0x1028      LDRB     R1,[R0, #+40]
   \       0x34   0x0749             LSLS     R1,R1,#+29
   \       0x36   0xD507             BPL.N    ??UART_AdvFeatureConfig_2
   3308            {
   3309              assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
   3310              MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0x684A             LDR      R2,[R1, #+4]
   \       0x3C   0xF432 0x2280      BICS     R2,R2,#0x40000
   \       0x40   0x6B41             LDR      R1,[R0, #+52]
   \       0x42   0x430A             ORRS     R2,R1,R2
   \       0x44   0x6801             LDR      R1,[R0, #+0]
   \       0x46   0x604A             STR      R2,[R1, #+4]
   3311            }
   3312          
   3313            /* if required, configure RX/TX pins swap */
   3314            if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
   \                     ??UART_AdvFeatureConfig_2: (+1)
   \       0x48   0xF890 0x1028      LDRB     R1,[R0, #+40]
   \       0x4C   0x0709             LSLS     R1,R1,#+28
   \       0x4E   0xD507             BPL.N    ??UART_AdvFeatureConfig_3
   3315            {
   3316              assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
   3317              MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
   \       0x50   0x6801             LDR      R1,[R0, #+0]
   \       0x52   0x684A             LDR      R2,[R1, #+4]
   \       0x54   0xF432 0x4200      BICS     R2,R2,#0x8000
   \       0x58   0x6B81             LDR      R1,[R0, #+56]
   \       0x5A   0x430A             ORRS     R2,R1,R2
   \       0x5C   0x6801             LDR      R1,[R0, #+0]
   \       0x5E   0x604A             STR      R2,[R1, #+4]
   3318            }
   3319          
   3320            /* if required, configure RX overrun detection disabling */
   3321            if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
   \                     ??UART_AdvFeatureConfig_3: (+1)
   \       0x60   0xF890 0x1028      LDRB     R1,[R0, #+40]
   \       0x64   0x06C9             LSLS     R1,R1,#+27
   \       0x66   0xD507             BPL.N    ??UART_AdvFeatureConfig_4
   3322            {
   3323              assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
   3324              MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
   \       0x68   0x6801             LDR      R1,[R0, #+0]
   \       0x6A   0x688A             LDR      R2,[R1, #+8]
   \       0x6C   0xF432 0x5280      BICS     R2,R2,#0x1000
   \       0x70   0x6BC1             LDR      R1,[R0, #+60]
   \       0x72   0x430A             ORRS     R2,R1,R2
   \       0x74   0x6801             LDR      R1,[R0, #+0]
   \       0x76   0x608A             STR      R2,[R1, #+8]
   3325            }
   3326          
   3327            /* if required, configure DMA disabling on reception error */
   3328            if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
   \                     ??UART_AdvFeatureConfig_4: (+1)
   \       0x78   0xF890 0x1028      LDRB     R1,[R0, #+40]
   \       0x7C   0x0689             LSLS     R1,R1,#+26
   \       0x7E   0xD507             BPL.N    ??UART_AdvFeatureConfig_5
   3329            {
   3330              assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
   3331              MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
   \       0x80   0x6801             LDR      R1,[R0, #+0]
   \       0x82   0x688A             LDR      R2,[R1, #+8]
   \       0x84   0xF432 0x5200      BICS     R2,R2,#0x2000
   \       0x88   0x6C01             LDR      R1,[R0, #+64]
   \       0x8A   0x430A             ORRS     R2,R1,R2
   \       0x8C   0x6801             LDR      R1,[R0, #+0]
   \       0x8E   0x608A             STR      R2,[R1, #+8]
   3332            }
   3333          
   3334            /* if required, configure auto Baud rate detection scheme */
   3335            if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
   \                     ??UART_AdvFeatureConfig_5: (+1)
   \       0x90   0xF890 0x1028      LDRB     R1,[R0, #+40]
   \       0x94   0x0649             LSLS     R1,R1,#+25
   \       0x96   0xD513             BPL.N    ??UART_AdvFeatureConfig_6
   3336            {
   3337              assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
   3338              assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
   3339              MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
   \       0x98   0x6801             LDR      R1,[R0, #+0]
   \       0x9A   0x684A             LDR      R2,[R1, #+4]
   \       0x9C   0xF432 0x1280      BICS     R2,R2,#0x100000
   \       0xA0   0x6C41             LDR      R1,[R0, #+68]
   \       0xA2   0x430A             ORRS     R2,R1,R2
   \       0xA4   0x6801             LDR      R1,[R0, #+0]
   \       0xA6   0x604A             STR      R2,[R1, #+4]
   3340              /* set auto Baudrate detection parameters if detection is enabled */
   3341              if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
   \       0xA8   0x6C41             LDR      R1,[R0, #+68]
   \       0xAA   0xF5B1 0x1F80      CMP      R1,#+1048576
   \       0xAE   0xD107             BNE.N    ??UART_AdvFeatureConfig_6
   3342              {
   3343                assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
   3344                MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
   \       0xB0   0x6801             LDR      R1,[R0, #+0]
   \       0xB2   0x684A             LDR      R2,[R1, #+4]
   \       0xB4   0xF432 0x02C0      BICS     R2,R2,#0x600000
   \       0xB8   0x6C81             LDR      R1,[R0, #+72]
   \       0xBA   0x430A             ORRS     R2,R1,R2
   \       0xBC   0x6801             LDR      R1,[R0, #+0]
   \       0xBE   0x604A             STR      R2,[R1, #+4]
   3345              }
   3346            }
   3347          
   3348            /* if required, configure MSB first on communication line */
   3349            if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
   \                     ??UART_AdvFeatureConfig_6: (+1)
   \       0xC0   0xF890 0x1028      LDRB     R1,[R0, #+40]
   \       0xC4   0x0609             LSLS     R1,R1,#+24
   \       0xC6   0xD507             BPL.N    ??UART_AdvFeatureConfig_7
   3350            {
   3351              assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
   3352              MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
   \       0xC8   0x6801             LDR      R1,[R0, #+0]
   \       0xCA   0x684A             LDR      R2,[R1, #+4]
   \       0xCC   0xF432 0x2200      BICS     R2,R2,#0x80000
   \       0xD0   0x6CC1             LDR      R1,[R0, #+76]
   \       0xD2   0x430A             ORRS     R2,R1,R2
   \       0xD4   0x6800             LDR      R0,[R0, #+0]
   \       0xD6   0x6042             STR      R2,[R0, #+4]
   3353            }
   3354          }
   \                     ??UART_AdvFeatureConfig_7: (+1)
   \       0xD8   0x4770             BX       LR
   3355          
   3356          /**
   3357            * @brief Check the UART Idle State.
   3358            * @param huart UART handle.
   3359            * @retval HAL status
   3360            */

   \                                 In section .text, align 2, keep-with-next
   3361          HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
   3362          {
   \                     UART_CheckIdleState: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3363            uint32_t tickstart;
   3364          
   3365            /* Initialize the UART ErrorCode */
   3366            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xF8C4 0x008C      STR      R0,[R4, #+140]
   3367          
   3368            /* Init tickstart for timeout management */
   3369            tickstart = HAL_GetTick();
   \        0xA   0x.... 0x....      BL       HAL_GetTick
   \        0xE   0x0005             MOVS     R5,R0
   3370          
   3371            /* Check if the Transmitter is enabled */
   3372            if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x0700             LSLS     R0,R0,#+28
   \       0x16   0xD50D             BPL.N    ??UART_CheckIdleState_0
   3373            {
   3374              /* Wait until TEACK flag is set */
   3375              if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
   \       0x18   0xF07F 0x407E      MVNS     R0,#+4261412864
   \       0x1C   0x9000             STR      R0,[SP, #+0]
   \       0x1E   0x002B             MOVS     R3,R5
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0xF45F 0x1100      MOVS     R1,#+2097152
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD001             BEQ.N    ??UART_CheckIdleState_0
   3376              {
   3377                /* Timeout occurred */
   3378                return HAL_TIMEOUT;
   \       0x30   0x2003             MOVS     R0,#+3
   \       0x32   0xE01D             B.N      ??UART_CheckIdleState_1
   3379              }
   3380            }
   3381          
   3382            /* Check if the Receiver is enabled */
   3383            if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
   \                     ??UART_CheckIdleState_0: (+1)
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x6800             LDR      R0,[R0, #+0]
   \       0x38   0x0740             LSLS     R0,R0,#+29
   \       0x3A   0xD50D             BPL.N    ??UART_CheckIdleState_2
   3384            {
   3385              /* Wait until REACK flag is set */
   3386              if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
   \       0x3C   0xF07F 0x407E      MVNS     R0,#+4261412864
   \       0x40   0x9000             STR      R0,[SP, #+0]
   \       0x42   0x002B             MOVS     R3,R5
   \       0x44   0x2200             MOVS     R2,#+0
   \       0x46   0xF45F 0x0180      MOVS     R1,#+4194304
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD001             BEQ.N    ??UART_CheckIdleState_2
   3387              {
   3388                /* Timeout occurred */
   3389                return HAL_TIMEOUT;
   \       0x54   0x2003             MOVS     R0,#+3
   \       0x56   0xE00B             B.N      ??UART_CheckIdleState_1
   3390              }
   3391            }
   3392          
   3393            /* Initialize the UART State */
   3394            huart->gState = HAL_UART_STATE_READY;
   \                     ??UART_CheckIdleState_2: (+1)
   \       0x58   0x2020             MOVS     R0,#+32
   \       0x5A   0xF8C4 0x0084      STR      R0,[R4, #+132]
   3395            huart->RxState = HAL_UART_STATE_READY;
   \       0x5E   0x2020             MOVS     R0,#+32
   \       0x60   0xF8C4 0x0088      STR      R0,[R4, #+136]
   3396            huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x66E0             STR      R0,[R4, #+108]
   3397          
   3398            __HAL_UNLOCK(huart);
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xF884 0x0080      STRB     R0,[R4, #+128]
   3399          
   3400            return HAL_OK;
   \       0x6E   0x2000             MOVS     R0,#+0
   \                     ??UART_CheckIdleState_1: (+1)
   \       0x70   0xBD32             POP      {R1,R4,R5,PC}
   3401          }
   3402          
   3403          /**
   3404            * @brief  This function handles UART Communication Timeout. It waits
   3405            *                  until a flag is no longer in the specified status.
   3406            * @param huart     UART handle.
   3407            * @param Flag      Specifies the UART flag to check
   3408            * @param Status    The actual Flag status (SET or RESET)
   3409            * @param Tickstart Tick start value
   3410            * @param Timeout   Timeout duration
   3411            * @retval HAL status
   3412            */

   \                                 In section .text, align 2, keep-with-next
   3413          HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
   3414                                                        uint32_t Tickstart, uint32_t Timeout)
   3415          {
   \                     UART_WaitOnFlagUntilTimeout: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0x9C06             LDR      R4,[SP, #+24]
   3416            /* Wait until flag is set */
   3417            while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
   \                     ??UART_WaitOnFlagUntilTimeout_0: (+1)
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x69C0             LDR      R0,[R0, #+28]
   \       0x12   0x4030             ANDS     R0,R6,R0
   \       0x14   0x42B0             CMP      R0,R6
   \       0x16   0xD101             BNE.N    ??UART_WaitOnFlagUntilTimeout_1
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE000             B.N      ??UART_WaitOnFlagUntilTimeout_2
   \                     ??UART_WaitOnFlagUntilTimeout_1: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??UART_WaitOnFlagUntilTimeout_2: (+1)
   \       0x1E   0x4641             MOV      R1,R8
   \       0x20   0xB2C9             UXTB     R1,R1
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD15C             BNE.N    ??UART_WaitOnFlagUntilTimeout_3
   3418            {
   3419              /* Check for the Timeout */
   3420              if (Timeout != HAL_MAX_DELAY)
   \       0x26   0xF114 0x0F01      CMN      R4,#+1
   \       0x2A   0xD0F0             BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
   3421              {
   3422                if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x2C   0x.... 0x....      BL       HAL_GetTick
   \       0x30   0x1BC0             SUBS     R0,R0,R7
   \       0x32   0x4284             CMP      R4,R0
   \       0x34   0xD301             BCC.N    ??UART_WaitOnFlagUntilTimeout_4
   \       0x36   0x2C00             CMP      R4,#+0
   \       0x38   0xD121             BNE.N    ??UART_WaitOnFlagUntilTimeout_5
   3423                {
   3424                  /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
   3425                     interrupts for the interrupt process */
   3426                  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
   3427                                                          USART_CR1_TXEIE_TXFNFIE));
   \                     ??UART_WaitOnFlagUntilTimeout_4: (+1)
   \                     ??UART_WaitOnFlagUntilTimeout_6: (+1)
   \       0x3A   0x6828             LDR      R0,[R5, #+0]
   \       0x3C   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x40   0xF431 0x71D0      BICS     R1,R1,#0x1A0
   \       0x44   0x682A             LDR      R2,[R5, #+0]
   \       0x46   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD1F5             BNE.N    ??UART_WaitOnFlagUntilTimeout_6
   3428                  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \                     ??UART_WaitOnFlagUntilTimeout_7: (+1)
   \       0x4E   0x6828             LDR      R0,[R5, #+0]
   \       0x50   0x3008             ADDS     R0,R0,#+8
   \       0x52   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x56   0x0849             LSRS     R1,R1,#+1
   \       0x58   0x0049             LSLS     R1,R1,#+1
   \       0x5A   0x6828             LDR      R0,[R5, #+0]
   \       0x5C   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0x60   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD1F2             BNE.N    ??UART_WaitOnFlagUntilTimeout_7
   3429          
   3430                  huart->gState = HAL_UART_STATE_READY;
   \       0x68   0x2020             MOVS     R0,#+32
   \       0x6A   0xF8C5 0x0084      STR      R0,[R5, #+132]
   3431                  huart->RxState = HAL_UART_STATE_READY;
   \       0x6E   0x2020             MOVS     R0,#+32
   \       0x70   0xF8C5 0x0088      STR      R0,[R5, #+136]
   3432          
   3433                  __HAL_UNLOCK(huart);
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xF885 0x0080      STRB     R0,[R5, #+128]
   3434          
   3435                  return HAL_TIMEOUT;
   \       0x7A   0x2003             MOVS     R0,#+3
   \       0x7C   0xE031             B.N      ??UART_WaitOnFlagUntilTimeout_8
   3436                }
   3437          
   3438                if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
   \                     ??UART_WaitOnFlagUntilTimeout_5: (+1)
   \       0x7E   0x6828             LDR      R0,[R5, #+0]
   \       0x80   0x6800             LDR      R0,[R0, #+0]
   \       0x82   0x0740             LSLS     R0,R0,#+29
   \       0x84   0xD5C3             BPL.N    ??UART_WaitOnFlagUntilTimeout_0
   3439                {
   3440                  if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
   \       0x86   0x6828             LDR      R0,[R5, #+0]
   \       0x88   0x69C0             LDR      R0,[R0, #+28]
   \       0x8A   0x0500             LSLS     R0,R0,#+20
   \       0x8C   0xD5BF             BPL.N    ??UART_WaitOnFlagUntilTimeout_0
   3441                  {
   3442                    /* Clear Receiver Timeout flag*/
   3443                    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
   \       0x8E   0xF44F 0x6000      MOV      R0,#+2048
   \       0x92   0x6829             LDR      R1,[R5, #+0]
   \       0x94   0x6208             STR      R0,[R1, #+32]
   3444          
   3445                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
   3446                       interrupts for the interrupt process */
   3447                    ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
   3448                                                            USART_CR1_TXEIE_TXFNFIE));
   \                     ??UART_WaitOnFlagUntilTimeout_9: (+1)
   \       0x96   0x6828             LDR      R0,[R5, #+0]
   \       0x98   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x9C   0xF431 0x71D0      BICS     R1,R1,#0x1A0
   \       0xA0   0x682A             LDR      R2,[R5, #+0]
   \       0xA2   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD1F5             BNE.N    ??UART_WaitOnFlagUntilTimeout_9
   3449                    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \                     ??UART_WaitOnFlagUntilTimeout_10: (+1)
   \       0xAA   0x6828             LDR      R0,[R5, #+0]
   \       0xAC   0x3008             ADDS     R0,R0,#+8
   \       0xAE   0xE850 0x1F00      LDREX    R1,[R0]
   \       0xB2   0x0849             LSRS     R1,R1,#+1
   \       0xB4   0x0049             LSLS     R1,R1,#+1
   \       0xB6   0x6828             LDR      R0,[R5, #+0]
   \       0xB8   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0xBC   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xD1F2             BNE.N    ??UART_WaitOnFlagUntilTimeout_10
   3450          
   3451                    huart->gState = HAL_UART_STATE_READY;
   \       0xC4   0x2020             MOVS     R0,#+32
   \       0xC6   0xF8C5 0x0084      STR      R0,[R5, #+132]
   3452                    huart->RxState = HAL_UART_STATE_READY;
   \       0xCA   0x2020             MOVS     R0,#+32
   \       0xCC   0xF8C5 0x0088      STR      R0,[R5, #+136]
   3453                    huart->ErrorCode = HAL_UART_ERROR_RTO;
   \       0xD0   0x2020             MOVS     R0,#+32
   \       0xD2   0xF8C5 0x008C      STR      R0,[R5, #+140]
   3454          
   3455                    /* Process Unlocked */
   3456                    __HAL_UNLOCK(huart);
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0xF885 0x0080      STRB     R0,[R5, #+128]
   3457          
   3458                    return HAL_TIMEOUT;
   \       0xDC   0x2003             MOVS     R0,#+3
   \       0xDE   0xE000             B.N      ??UART_WaitOnFlagUntilTimeout_8
   3459                  }
   3460                }
   3461              }
   3462            }
   3463            return HAL_OK;
   \                     ??UART_WaitOnFlagUntilTimeout_3: (+1)
   \       0xE0   0x2000             MOVS     R0,#+0
   \                     ??UART_WaitOnFlagUntilTimeout_8: (+1)
   \       0xE2   0xE8BD 0x81F0      POP      {R4-R8,PC}
   3464          }
   3465          
   3466          /**
   3467            * @brief  Start Receive operation in interrupt mode.
   3468            * @note   This function could be called by all HAL UART API providing reception in Interrupt mode.
   3469            * @note   When calling this function, parameters validity is considered as already checked,
   3470            *         i.e. Rx State, buffer address, ...
   3471            *         UART Handle is assumed as Locked.
   3472            * @param  huart UART handle.
   3473            * @param  pData Pointer to data buffer (u8 or u16 data elements).
   3474            * @param  Size  Amount of data elements (u8 or u16) to be received.
   3475            * @retval HAL status
   3476            */

   \                                 In section .text, align 2, keep-with-next
   3477          HAL_StatusTypeDef UART_Start_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
   3478          {
   \                     UART_Start_Receive_IT: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0003             MOVS     R3,R0
   3479            huart->pRxBuffPtr  = pData;
   \        0x4   0x6599             STR      R1,[R3, #+88]
   3480            huart->RxXferSize  = Size;
   \        0x6   0xF8A3 0x205C      STRH     R2,[R3, #+92]
   3481            huart->RxXferCount = Size;
   \        0xA   0xF8A3 0x205E      STRH     R2,[R3, #+94]
   3482            huart->RxISR       = NULL;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x6718             STR      R0,[R3, #+112]
   3483          
   3484            /* Computation of UART mask to apply to RDR register */
   3485            UART_MASK_COMPUTATION(huart);
   \       0x12   0x6898             LDR      R0,[R3, #+8]
   \       0x14   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x18   0xD10B             BNE.N    ??UART_Start_Receive_IT_0
   \       0x1A   0x6918             LDR      R0,[R3, #+16]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD104             BNE.N    ??UART_Start_Receive_IT_1
   \       0x20   0xF240 0x10FF      MOVW     R0,#+511
   \       0x24   0xF8A3 0x0060      STRH     R0,[R3, #+96]
   \       0x28   0xE023             B.N      ??UART_Start_Receive_IT_2
   \                     ??UART_Start_Receive_IT_1: (+1)
   \       0x2A   0x20FF             MOVS     R0,#+255
   \       0x2C   0xF8A3 0x0060      STRH     R0,[R3, #+96]
   \       0x30   0xE01F             B.N      ??UART_Start_Receive_IT_2
   \                     ??UART_Start_Receive_IT_0: (+1)
   \       0x32   0x6898             LDR      R0,[R3, #+8]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD10A             BNE.N    ??UART_Start_Receive_IT_3
   \       0x38   0x6918             LDR      R0,[R3, #+16]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD103             BNE.N    ??UART_Start_Receive_IT_4
   \       0x3E   0x20FF             MOVS     R0,#+255
   \       0x40   0xF8A3 0x0060      STRH     R0,[R3, #+96]
   \       0x44   0xE015             B.N      ??UART_Start_Receive_IT_2
   \                     ??UART_Start_Receive_IT_4: (+1)
   \       0x46   0x207F             MOVS     R0,#+127
   \       0x48   0xF8A3 0x0060      STRH     R0,[R3, #+96]
   \       0x4C   0xE011             B.N      ??UART_Start_Receive_IT_2
   \                     ??UART_Start_Receive_IT_3: (+1)
   \       0x4E   0x6898             LDR      R0,[R3, #+8]
   \       0x50   0xF1B0 0x5F80      CMP      R0,#+268435456
   \       0x54   0xD10A             BNE.N    ??UART_Start_Receive_IT_5
   \       0x56   0x6918             LDR      R0,[R3, #+16]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD103             BNE.N    ??UART_Start_Receive_IT_6
   \       0x5C   0x207F             MOVS     R0,#+127
   \       0x5E   0xF8A3 0x0060      STRH     R0,[R3, #+96]
   \       0x62   0xE006             B.N      ??UART_Start_Receive_IT_2
   \                     ??UART_Start_Receive_IT_6: (+1)
   \       0x64   0x203F             MOVS     R0,#+63
   \       0x66   0xF8A3 0x0060      STRH     R0,[R3, #+96]
   \       0x6A   0xE002             B.N      ??UART_Start_Receive_IT_2
   \                     ??UART_Start_Receive_IT_5: (+1)
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0xF8A3 0x0060      STRH     R0,[R3, #+96]
   3486          
   3487            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \                     ??UART_Start_Receive_IT_2: (+1)
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0xF8C3 0x008C      STR      R0,[R3, #+140]
   3488            huart->RxState = HAL_UART_STATE_BUSY_RX;
   \       0x78   0x2022             MOVS     R0,#+34
   \       0x7A   0xF8C3 0x0088      STR      R0,[R3, #+136]
   3489          
   3490            /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   3491            ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \                     ??UART_Start_Receive_IT_7: (+1)
   \       0x7E   0x6818             LDR      R0,[R3, #+0]
   \       0x80   0x3008             ADDS     R0,R0,#+8
   \       0x82   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x86   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x8A   0x6818             LDR      R0,[R3, #+0]
   \       0x8C   0xF110 0x0408      ADDS     R4,R0,#+8
   \       0x90   0xE844 0x1000      STREX    R0,R1,[R4]
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD1F2             BNE.N    ??UART_Start_Receive_IT_7
   3492          
   3493            /* Configure Rx interrupt processing */
   3494            if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
   \       0x98   0x6E58             LDR      R0,[R3, #+100]
   \       0x9A   0xF1B0 0x5F00      CMP      R0,#+536870912
   \       0x9E   0xD130             BNE.N    ??UART_Start_Receive_IT_8
   \       0xA0   0xF8B3 0x0068      LDRH     R0,[R3, #+104]
   \       0xA4   0xB292             UXTH     R2,R2
   \       0xA6   0x4282             CMP      R2,R0
   \       0xA8   0xD32B             BCC.N    ??UART_Start_Receive_IT_8
   3495            {
   3496              /* Set the Rx ISR function pointer according to the data word length */
   3497              if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
   \       0xAA   0x6898             LDR      R0,[R3, #+8]
   \       0xAC   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0xB0   0xD106             BNE.N    ??UART_Start_Receive_IT_9
   \       0xB2   0x6918             LDR      R0,[R3, #+16]
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD103             BNE.N    ??UART_Start_Receive_IT_9
   3498              {
   3499                huart->RxISR = UART_RxISR_16BIT_FIFOEN;
   \       0xB8   0x.... 0x....      ADR.W    R0,UART_RxISR_16BIT_FIFOEN
   \       0xBC   0x6718             STR      R0,[R3, #+112]
   \       0xBE   0xE002             B.N      ??UART_Start_Receive_IT_10
   3500              }
   3501              else
   3502              {
   3503                huart->RxISR = UART_RxISR_8BIT_FIFOEN;
   \                     ??UART_Start_Receive_IT_9: (+1)
   \       0xC0   0x.... 0x....      ADR.W    R0,UART_RxISR_8BIT_FIFOEN
   \       0xC4   0x6718             STR      R0,[R3, #+112]
   3504              }
   3505          
   3506              __HAL_UNLOCK(huart);
   \                     ??UART_Start_Receive_IT_10: (+1)
   \       0xC6   0x2000             MOVS     R0,#+0
   \       0xC8   0xF883 0x0080      STRB     R0,[R3, #+128]
   3507          
   3508              /* Enable the UART Parity Error interrupt and RX FIFO Threshold interrupt */
   3509              if (huart->Init.Parity != UART_PARITY_NONE)
   \       0xCC   0x6918             LDR      R0,[R3, #+16]
   \       0xCE   0x2800             CMP      R0,#+0
   \       0xD0   0xD009             BEQ.N    ??UART_Start_Receive_IT_11
   3510              {
   3511                ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \                     ??UART_Start_Receive_IT_12: (+1)
   \       0xD2   0x6818             LDR      R0,[R3, #+0]
   \       0xD4   0xE850 0x1F00      LDREX    R1,[R0]
   \       0xD8   0xF451 0x7180      ORRS     R1,R1,#0x100
   \       0xDC   0x681A             LDR      R2,[R3, #+0]
   \       0xDE   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0xE2   0x2800             CMP      R0,#+0
   \       0xE4   0xD1F5             BNE.N    ??UART_Start_Receive_IT_12
   3512              }
   3513              ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
   \                     ??UART_Start_Receive_IT_11: (+1)
   \                     ??UART_Start_Receive_IT_13: (+1)
   \       0xE6   0x6818             LDR      R0,[R3, #+0]
   \       0xE8   0x3008             ADDS     R0,R0,#+8
   \       0xEA   0xE850 0x1F00      LDREX    R1,[R0]
   \       0xEE   0xF051 0x5180      ORRS     R1,R1,#0x10000000
   \       0xF2   0x6818             LDR      R0,[R3, #+0]
   \       0xF4   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0xF8   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0xFC   0x2800             CMP      R0,#+0
   \       0xFE   0xD1F2             BNE.N    ??UART_Start_Receive_IT_13
   \      0x100   0xE028             B.N      ??UART_Start_Receive_IT_14
   3514            }
   3515            else
   3516            {
   3517              /* Set the Rx ISR function pointer according to the data word length */
   3518              if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
   \                     ??UART_Start_Receive_IT_8: (+1)
   \      0x102   0x6898             LDR      R0,[R3, #+8]
   \      0x104   0xF5B0 0x5F80      CMP      R0,#+4096
   \      0x108   0xD106             BNE.N    ??UART_Start_Receive_IT_15
   \      0x10A   0x6918             LDR      R0,[R3, #+16]
   \      0x10C   0x2800             CMP      R0,#+0
   \      0x10E   0xD103             BNE.N    ??UART_Start_Receive_IT_15
   3519              {
   3520                huart->RxISR = UART_RxISR_16BIT;
   \      0x110   0x.... 0x....      ADR.W    R0,UART_RxISR_16BIT
   \      0x114   0x6718             STR      R0,[R3, #+112]
   \      0x116   0xE002             B.N      ??UART_Start_Receive_IT_16
   3521              }
   3522              else
   3523              {
   3524                huart->RxISR = UART_RxISR_8BIT;
   \                     ??UART_Start_Receive_IT_15: (+1)
   \      0x118   0x.... 0x....      ADR.W    R0,UART_RxISR_8BIT
   \      0x11C   0x6718             STR      R0,[R3, #+112]
   3525              }
   3526          
   3527              __HAL_UNLOCK(huart);
   \                     ??UART_Start_Receive_IT_16: (+1)
   \      0x11E   0x2000             MOVS     R0,#+0
   \      0x120   0xF883 0x0080      STRB     R0,[R3, #+128]
   3528          
   3529              /* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt */
   3530              if (huart->Init.Parity != UART_PARITY_NONE)
   \      0x124   0x6918             LDR      R0,[R3, #+16]
   \      0x126   0x2800             CMP      R0,#+0
   \      0x128   0xD00A             BEQ.N    ??UART_Start_Receive_IT_17
   3531              {
   3532                ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
   \                     ??UART_Start_Receive_IT_18: (+1)
   \      0x12A   0x6818             LDR      R0,[R3, #+0]
   \      0x12C   0xE850 0x1F00      LDREX    R1,[R0]
   \      0x130   0xF451 0x7190      ORRS     R1,R1,#0x120
   \      0x134   0x681A             LDR      R2,[R3, #+0]
   \      0x136   0xE842 0x1000      STREX    R0,R1,[R2]
   \      0x13A   0x2800             CMP      R0,#+0
   \      0x13C   0xD1F5             BNE.N    ??UART_Start_Receive_IT_18
   \      0x13E   0xE009             B.N      ??UART_Start_Receive_IT_14
   3533              }
   3534              else
   3535              {
   3536                ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
   \                     ??UART_Start_Receive_IT_17: (+1)
   \                     ??UART_Start_Receive_IT_19: (+1)
   \      0x140   0x6818             LDR      R0,[R3, #+0]
   \      0x142   0xE850 0x1F00      LDREX    R1,[R0]
   \      0x146   0xF051 0x0120      ORRS     R1,R1,#0x20
   \      0x14A   0x681A             LDR      R2,[R3, #+0]
   \      0x14C   0xE842 0x1000      STREX    R0,R1,[R2]
   \      0x150   0x2800             CMP      R0,#+0
   \      0x152   0xD1F5             BNE.N    ??UART_Start_Receive_IT_19
   3537              }  
   3538            }
   3539            return HAL_OK;
   \                     ??UART_Start_Receive_IT_14: (+1)
   \      0x154   0x2000             MOVS     R0,#+0
   \      0x156   0xBC10             POP      {R4}
   \      0x158   0x4770             BX       LR
   3540          }
   3541          
   3542          /**
   3543            * @brief  Start Receive operation in DMA mode.
   3544            * @note   This function could be called by all HAL UART API providing reception in DMA mode.
   3545            * @note   When calling this function, parameters validity is considered as already checked,
   3546            *         i.e. Rx State, buffer address, ...
   3547            *         UART Handle is assumed as Locked.
   3548            * @param  huart UART handle.
   3549            * @param  pData Pointer to data buffer (u8 or u16 data elements).
   3550            * @param  Size  Amount of data elements (u8 or u16) to be received.
   3551            * @retval HAL status
   3552            */

   \                                 In section .text, align 2, keep-with-next
   3553          HAL_StatusTypeDef UART_Start_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
   3554          {
   \                     UART_Start_Receive_DMA: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0013             MOVS     R3,R2
   3555            huart->pRxBuffPtr = pData;
   \        0x6   0x65A1             STR      R1,[R4, #+88]
   3556            huart->RxXferSize = Size;
   \        0x8   0xF8A4 0x305C      STRH     R3,[R4, #+92]
   3557          
   3558            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xF8C4 0x008C      STR      R0,[R4, #+140]
   3559            huart->RxState = HAL_UART_STATE_BUSY_RX;
   \       0x12   0x2022             MOVS     R0,#+34
   \       0x14   0xF8C4 0x0088      STR      R0,[R4, #+136]
   3560          
   3561            if (huart->hdmarx != NULL)
   \       0x18   0x6FE0             LDR      R0,[R4, #+124]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD023             BEQ.N    ??UART_Start_Receive_DMA_0
   3562            {
   3563              /* Set the UART DMA transfer complete callback */
   3564              huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
   \       0x1E   0x.... 0x....      ADR.W    R0,UART_DMAReceiveCplt
   \       0x22   0x6FE1             LDR      R1,[R4, #+124]
   \       0x24   0x63C8             STR      R0,[R1, #+60]
   3565          
   3566              /* Set the UART DMA Half transfer complete callback */
   3567              huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
   \       0x26   0x.... 0x....      ADR.W    R0,UART_DMARxHalfCplt
   \       0x2A   0x6FE1             LDR      R1,[R4, #+124]
   \       0x2C   0x6408             STR      R0,[R1, #+64]
   3568          
   3569              /* Set the DMA error callback */
   3570              huart->hdmarx->XferErrorCallback = UART_DMAError;
   \       0x2E   0x.... 0x....      ADR.W    R0,UART_DMAError
   \       0x32   0x6FE1             LDR      R1,[R4, #+124]
   \       0x34   0x64C8             STR      R0,[R1, #+76]
   3571          
   3572              /* Set the DMA abort callback */
   3573              huart->hdmarx->XferAbortCallback = NULL;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x6FE1             LDR      R1,[R4, #+124]
   \       0x3A   0x6508             STR      R0,[R1, #+80]
   3574          
   3575              /* Enable the DMA channel */
   3576              if (HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size) != HAL_OK)
   \       0x3C   0xB29B             UXTH     R3,R3
   \       0x3E   0x6DA2             LDR      R2,[R4, #+88]
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0xF110 0x0124      ADDS     R1,R0,#+36
   \       0x46   0x6FE0             LDR      R0,[R4, #+124]
   \       0x48   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD00A             BEQ.N    ??UART_Start_Receive_DMA_0
   3577              {
   3578                /* Set error code to DMA */
   3579                huart->ErrorCode = HAL_UART_ERROR_DMA;
   \       0x50   0x2010             MOVS     R0,#+16
   \       0x52   0xF8C4 0x008C      STR      R0,[R4, #+140]
   3580          
   3581                __HAL_UNLOCK(huart);
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xF884 0x0080      STRB     R0,[R4, #+128]
   3582          
   3583                /* Restore huart->RxState to ready */
   3584                huart->RxState = HAL_UART_STATE_READY;
   \       0x5C   0x2020             MOVS     R0,#+32
   \       0x5E   0xF8C4 0x0088      STR      R0,[R4, #+136]
   3585          
   3586                return HAL_ERROR;
   \       0x62   0x2001             MOVS     R0,#+1
   \       0x64   0xE02A             B.N      ??UART_Start_Receive_DMA_1
   3587              }
   3588            }
   3589            __HAL_UNLOCK(huart);
   \                     ??UART_Start_Receive_DMA_0: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xF884 0x0080      STRB     R0,[R4, #+128]
   3590          
   3591            /* Enable the UART Parity Error Interrupt */
   3592            if (huart->Init.Parity != UART_PARITY_NONE)
   \       0x6C   0x6920             LDR      R0,[R4, #+16]
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD009             BEQ.N    ??UART_Start_Receive_DMA_2
   3593            {
   3594              ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \                     ??UART_Start_Receive_DMA_3: (+1)
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x78   0xF451 0x7180      ORRS     R1,R1,#0x100
   \       0x7C   0x6822             LDR      R2,[R4, #+0]
   \       0x7E   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD1F5             BNE.N    ??UART_Start_Receive_DMA_3
   3595            }
   3596          
   3597            /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   3598            ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \                     ??UART_Start_Receive_DMA_2: (+1)
   \                     ??UART_Start_Receive_DMA_4: (+1)
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x3008             ADDS     R0,R0,#+8
   \       0x8A   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x8E   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0x98   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD1F2             BNE.N    ??UART_Start_Receive_DMA_4
   3599          
   3600            /* Enable the DMA transfer for the receiver request by setting the DMAR bit
   3601            in the UART CR3 register */
   3602            ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??UART_Start_Receive_DMA_5: (+1)
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x3008             ADDS     R0,R0,#+8
   \       0xA4   0xE850 0x1F00      LDREX    R1,[R0]
   \       0xA8   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0xAC   0x6820             LDR      R0,[R4, #+0]
   \       0xAE   0xF110 0x0208      ADDS     R2,R0,#+8
   \       0xB2   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD1F2             BNE.N    ??UART_Start_Receive_DMA_5
   3603          
   3604            return HAL_OK;
   \       0xBA   0x2000             MOVS     R0,#+0
   \                     ??UART_Start_Receive_DMA_1: (+1)
   \       0xBC   0xBD10             POP      {R4,PC}
   3605          }
   3606          
   3607          
   3608          /**
   3609            * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit completion).
   3610            * @param  huart UART handle.
   3611            * @retval None
   3612            */

   \                                 In section .text, align 2, keep-with-next
   3613          static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
   3614          {
   3615            /* Disable TXEIE, TCIE, TXFT interrupts */
   3616            ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
   \                     UART_EndTxTransfer: (+1)
   \                     ??UART_EndTxTransfer_0: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0xE851 0x2F00      LDREX    R2,[R1]
   \        0x6   0xF032 0x02C0      BICS     R2,R2,#0xC0
   \        0xA   0x6803             LDR      R3,[R0, #+0]
   \        0xC   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x10   0x2900             CMP      R1,#+0
   \       0x12   0xD1F5             BNE.N    ??UART_EndTxTransfer_0
   3617            ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));
   \                     ??UART_EndTxTransfer_1: (+1)
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0x3108             ADDS     R1,R1,#+8
   \       0x18   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x1C   0xF432 0x0200      BICS     R2,R2,#0x800000
   \       0x20   0x6801             LDR      R1,[R0, #+0]
   \       0x22   0xF111 0x0308      ADDS     R3,R1,#+8
   \       0x26   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x2A   0x2900             CMP      R1,#+0
   \       0x2C   0xD1F2             BNE.N    ??UART_EndTxTransfer_1
   3618          
   3619            /* At end of Tx process, restore huart->gState to Ready */
   3620            huart->gState = HAL_UART_STATE_READY;
   \       0x2E   0x2120             MOVS     R1,#+32
   \       0x30   0xF8C0 0x1084      STR      R1,[R0, #+132]
   3621          }
   \       0x34   0x4770             BX       LR
   3622          
   3623          
   3624          /**
   3625            * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
   3626            * @param  huart UART handle.
   3627            * @retval None
   3628            */

   \                                 In section .text, align 2, keep-with-next
   3629          static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
   3630          {
   3631            /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   3632            ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
   \                     UART_EndRxTransfer: (+1)
   \                     ??UART_EndRxTransfer_0: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0xE851 0x2F00      LDREX    R2,[R1]
   \        0x6   0xF432 0x7290      BICS     R2,R2,#0x120
   \        0xA   0x6803             LDR      R3,[R0, #+0]
   \        0xC   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x10   0x2900             CMP      R1,#+0
   \       0x12   0xD1F5             BNE.N    ??UART_EndRxTransfer_0
   3633            ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
   \                     ??UART_EndRxTransfer_1: (+1)
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0x3108             ADDS     R1,R1,#+8
   \       0x18   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x1C   0x.... 0x....      LDR.W    R1,??DataTable17
   \       0x20   0x400A             ANDS     R2,R1,R2
   \       0x22   0x6801             LDR      R1,[R0, #+0]
   \       0x24   0xF111 0x0308      ADDS     R3,R1,#+8
   \       0x28   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x2C   0x2900             CMP      R1,#+0
   \       0x2E   0xD1F1             BNE.N    ??UART_EndRxTransfer_1
   3634          
   3635            /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
   3636            if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
   \       0x30   0x6EC1             LDR      R1,[R0, #+108]
   \       0x32   0x2901             CMP      R1,#+1
   \       0x34   0xD109             BNE.N    ??UART_EndRxTransfer_2
   3637            {
   3638              ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
   \                     ??UART_EndRxTransfer_3: (+1)
   \       0x36   0x6801             LDR      R1,[R0, #+0]
   \       0x38   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x3C   0xF032 0x0210      BICS     R2,R2,#0x10
   \       0x40   0x6803             LDR      R3,[R0, #+0]
   \       0x42   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x46   0x2900             CMP      R1,#+0
   \       0x48   0xD1F5             BNE.N    ??UART_EndRxTransfer_3
   3639            }
   3640          
   3641            /* At end of Rx process, restore huart->RxState to Ready */
   3642            huart->RxState = HAL_UART_STATE_READY;
   \                     ??UART_EndRxTransfer_2: (+1)
   \       0x4A   0x2120             MOVS     R1,#+32
   \       0x4C   0xF8C0 0x1088      STR      R1,[R0, #+136]
   3643            huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \       0x50   0x2100             MOVS     R1,#+0
   \       0x52   0x66C1             STR      R1,[R0, #+108]
   3644          
   3645            /* Reset RxIsr function pointer */
   3646            huart->RxISR = NULL;
   \       0x54   0x2100             MOVS     R1,#+0
   \       0x56   0x6701             STR      R1,[R0, #+112]
   3647          }
   \       0x58   0x4770             BX       LR
   3648          
   3649          
   3650          /**
   3651            * @brief DMA UART transmit process complete callback.
   3652            * @param hdma DMA handle.
   3653            * @retval None
   3654            */

   \                                 In section .text, align 2, keep-with-next
   3655          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
   3656          {
   \                     UART_DMATransmitCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x0001             MOVS     R1,R0
   3657            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
   \        0x4   0x6B88             LDR      R0,[R1, #+56]
   3658          
   3659            /* DMA Normal mode */
   3660            if (hdma->Init.Mode != DMA_CIRCULAR)
   \        0x6   0x69C9             LDR      R1,[R1, #+28]
   \        0x8   0xF5B1 0x7F80      CMP      R1,#+256
   \        0xC   0xD01A             BEQ.N    ??UART_DMATransmitCplt_0
   3661            {
   3662              huart->TxXferCount = 0U;
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0xF8A0 0x1056      STRH     R1,[R0, #+86]
   3663          
   3664              /* Disable the DMA transfer for transmit request by resetting the DMAT bit
   3665                 in the UART CR3 register */
   3666              ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \                     ??UART_DMATransmitCplt_1: (+1)
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0x3108             ADDS     R1,R1,#+8
   \       0x18   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x1C   0xF032 0x0280      BICS     R2,R2,#0x80
   \       0x20   0x6801             LDR      R1,[R0, #+0]
   \       0x22   0xF111 0x0308      ADDS     R3,R1,#+8
   \       0x26   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x2A   0x2900             CMP      R1,#+0
   \       0x2C   0xD1F2             BNE.N    ??UART_DMATransmitCplt_1
   3667          
   3668              /* Enable the UART Transmit Complete Interrupt */
   3669              ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
   \                     ??UART_DMATransmitCplt_2: (+1)
   \       0x2E   0x6801             LDR      R1,[R0, #+0]
   \       0x30   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x34   0xF052 0x0240      ORRS     R2,R2,#0x40
   \       0x38   0x6803             LDR      R3,[R0, #+0]
   \       0x3A   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x3E   0x2900             CMP      R1,#+0
   \       0x40   0xD1F5             BNE.N    ??UART_DMATransmitCplt_2
   \       0x42   0xE001             B.N      ??UART_DMATransmitCplt_3
   3670            }
   3671            /* DMA Circular mode */
   3672            else
   3673            {
   3674          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   3675              /*Call registered Tx complete callback*/
   3676              huart->TxCpltCallback(huart);
   3677          #else
   3678              /*Call legacy weak Tx complete callback*/
   3679              HAL_UART_TxCpltCallback(huart);
   \                     ??UART_DMATransmitCplt_0: (+1)
   \       0x44   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   3680          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   3681            }
   3682          }
   \                     ??UART_DMATransmitCplt_3: (+1)
   \       0x48   0xBD01             POP      {R0,PC}
   3683          
   3684          /**
   3685            * @brief DMA UART transmit process half complete callback.
   3686            * @param hdma DMA handle.
   3687            * @retval None
   3688            */

   \                                 In section .text, align 2, keep-with-next
   3689          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   3690          {
   \                     UART_DMATxHalfCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3691            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
   \        0x2   0x6B80             LDR      R0,[R0, #+56]
   3692          
   3693          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   3694            /*Call registered Tx Half complete callback*/
   3695            huart->TxHalfCpltCallback(huart);
   3696          #else
   3697            /*Call legacy weak Tx Half complete callback*/
   3698            HAL_UART_TxHalfCpltCallback(huart);
   \        0x4   0x.... 0x....      BL       HAL_UART_TxHalfCpltCallback
   3699          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   3700          }
   \        0x8   0xBD01             POP      {R0,PC}
   3701          
   3702          /**
   3703            * @brief DMA UART receive process complete callback.
   3704            * @param hdma DMA handle.
   3705            * @retval None
   3706            */

   \                                 In section .text, align 4, keep-with-next
   3707          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
   3708          {
   \                     UART_DMAReceiveCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x0001             MOVS     R1,R0
   3709            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
   \        0x4   0x6B88             LDR      R0,[R1, #+56]
   3710          
   3711            /* DMA Normal mode */
   3712            if (hdma->Init.Mode != DMA_CIRCULAR)
   \        0x6   0x69C9             LDR      R1,[R1, #+28]
   \        0x8   0xF5B1 0x7F80      CMP      R1,#+256
   \        0xC   0xD036             BEQ.N    ??UART_DMAReceiveCplt_0
   3713            {
   3714              huart->RxXferCount = 0U;
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0xF8A0 0x105E      STRH     R1,[R0, #+94]
   3715          
   3716              /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
   3717              ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \                     ??UART_DMAReceiveCplt_1: (+1)
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x1A   0xF432 0x7280      BICS     R2,R2,#0x100
   \       0x1E   0x6803             LDR      R3,[R0, #+0]
   \       0x20   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x24   0x2900             CMP      R1,#+0
   \       0x26   0xD1F5             BNE.N    ??UART_DMAReceiveCplt_1
   3718              ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \                     ??UART_DMAReceiveCplt_2: (+1)
   \       0x28   0x6801             LDR      R1,[R0, #+0]
   \       0x2A   0x3108             ADDS     R1,R1,#+8
   \       0x2C   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x30   0x0852             LSRS     R2,R2,#+1
   \       0x32   0x0052             LSLS     R2,R2,#+1
   \       0x34   0x6801             LDR      R1,[R0, #+0]
   \       0x36   0xF111 0x0308      ADDS     R3,R1,#+8
   \       0x3A   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x3E   0x2900             CMP      R1,#+0
   \       0x40   0xD1F2             BNE.N    ??UART_DMAReceiveCplt_2
   3719          
   3720              /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
   3721                 in the UART CR3 register */
   3722              ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??UART_DMAReceiveCplt_3: (+1)
   \       0x42   0x6801             LDR      R1,[R0, #+0]
   \       0x44   0x3108             ADDS     R1,R1,#+8
   \       0x46   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x4A   0xF032 0x0240      BICS     R2,R2,#0x40
   \       0x4E   0x6801             LDR      R1,[R0, #+0]
   \       0x50   0xF111 0x0308      ADDS     R3,R1,#+8
   \       0x54   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x58   0x2900             CMP      R1,#+0
   \       0x5A   0xD1F2             BNE.N    ??UART_DMAReceiveCplt_3
   3723          
   3724              /* At end of Rx process, restore huart->RxState to Ready */
   3725              huart->RxState = HAL_UART_STATE_READY;
   \       0x5C   0x2120             MOVS     R1,#+32
   \       0x5E   0xF8C0 0x1088      STR      R1,[R0, #+136]
   3726          
   3727              /* If Reception till IDLE event has been selected, Disable IDLE Interrupt */
   3728              if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
   \       0x62   0x6EC1             LDR      R1,[R0, #+108]
   \       0x64   0x2901             CMP      R1,#+1
   \       0x66   0xD109             BNE.N    ??UART_DMAReceiveCplt_0
   3729              {
   3730                ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
   \                     ??UART_DMAReceiveCplt_4: (+1)
   \       0x68   0x6801             LDR      R1,[R0, #+0]
   \       0x6A   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x6E   0xF032 0x0210      BICS     R2,R2,#0x10
   \       0x72   0x6803             LDR      R3,[R0, #+0]
   \       0x74   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x78   0x2900             CMP      R1,#+0
   \       0x7A   0xD1F5             BNE.N    ??UART_DMAReceiveCplt_4
   3731              }
   3732            }
   3733          
   3734            /* Check current reception Mode :
   3735               If Reception till IDLE event has been selected : use Rx Event callback */
   3736            if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
   \                     ??UART_DMAReceiveCplt_0: (+1)
   \       0x7C   0x6EC1             LDR      R1,[R0, #+108]
   \       0x7E   0x2901             CMP      R1,#+1
   \       0x80   0xD104             BNE.N    ??UART_DMAReceiveCplt_5
   3737            {
   3738          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   3739              /*Call registered Rx Event callback*/
   3740              huart->RxEventCallback(huart, huart->RxXferSize);
   3741          #else
   3742              /*Call legacy weak Rx Event callback*/
   3743              HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
   \       0x82   0xF8B0 0x105C      LDRH     R1,[R0, #+92]
   \       0x86   0x.... 0x....      BL       HAL_UARTEx_RxEventCallback
   \       0x8A   0xE001             B.N      ??UART_DMAReceiveCplt_6
   3744          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   3745            }
   3746            else
   3747            {
   3748              /* In other cases : use Rx Complete callback */
   3749          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   3750              /*Call registered Rx complete callback*/
   3751              huart->RxCpltCallback(huart);
   3752          #else
   3753              /*Call legacy weak Rx complete callback*/
   3754              HAL_UART_RxCpltCallback(huart);
   \                     ??UART_DMAReceiveCplt_5: (+1)
   \       0x8C   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   3755          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   3756            }
   3757          }
   \                     ??UART_DMAReceiveCplt_6: (+1)
   \       0x90   0xBD01             POP      {R0,PC}
   3758          
   3759          /**
   3760            * @brief DMA UART receive process half complete callback.
   3761            * @param hdma DMA handle.
   3762            * @retval None
   3763            */

   \                                 In section .text, align 4, keep-with-next
   3764          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   3765          {
   \                     UART_DMARxHalfCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3766            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
   \        0x2   0x6B80             LDR      R0,[R0, #+56]
   3767          
   3768            /* Check current reception Mode :
   3769               If Reception till IDLE event has been selected : use Rx Event callback */
   3770            if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
   \        0x4   0x6EC1             LDR      R1,[R0, #+108]
   \        0x6   0x2901             CMP      R1,#+1
   \        0x8   0xD106             BNE.N    ??UART_DMARxHalfCplt_0
   3771            {
   3772          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   3773              /*Call registered Rx Event callback*/
   3774              huart->RxEventCallback(huart, huart->RxXferSize / 2U);
   3775          #else
   3776              /*Call legacy weak Rx Event callback*/
   3777              HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize / 2U);
   \        0xA   0xF8B0 0x105C      LDRH     R1,[R0, #+92]
   \        0xE   0x0849             LSRS     R1,R1,#+1
   \       0x10   0xB289             UXTH     R1,R1
   \       0x12   0x.... 0x....      BL       HAL_UARTEx_RxEventCallback
   \       0x16   0xE001             B.N      ??UART_DMARxHalfCplt_1
   3778          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   3779            }
   3780            else
   3781            {
   3782              /* In other cases : use Rx Half Complete callback */
   3783          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   3784              /*Call registered Rx Half complete callback*/
   3785              huart->RxHalfCpltCallback(huart);
   3786          #else
   3787              /*Call legacy weak Rx Half complete callback*/
   3788              HAL_UART_RxHalfCpltCallback(huart);
   \                     ??UART_DMARxHalfCplt_0: (+1)
   \       0x18   0x.... 0x....      BL       HAL_UART_RxHalfCpltCallback
   3789          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   3790            }
   3791          }
   \                     ??UART_DMARxHalfCplt_1: (+1)
   \       0x1C   0xBD01             POP      {R0,PC}
   3792          
   3793          /**
   3794            * @brief DMA UART communication error callback.
   3795            * @param hdma DMA handle.
   3796            * @retval None
   3797            */

   \                                 In section .text, align 4, keep-with-next
   3798          static void UART_DMAError(DMA_HandleTypeDef *hdma)
   3799          {
   \                     UART_DMAError: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   3800            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
   \        0x2   0x6B84             LDR      R4,[R0, #+56]
   3801          
   3802            const HAL_UART_StateTypeDef gstate = huart->gState;
   \        0x4   0xF8D4 0x0084      LDR      R0,[R4, #+132]
   3803            const HAL_UART_StateTypeDef rxstate = huart->RxState;
   \        0x8   0xF8D4 0x5088      LDR      R5,[R4, #+136]
   3804          
   3805            /* Stop UART DMA Tx request if ongoing */
   3806            if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
   3807                (gstate == HAL_UART_STATE_BUSY_TX))
   \        0xC   0x6821             LDR      R1,[R4, #+0]
   \        0xE   0x6889             LDR      R1,[R1, #+8]
   \       0x10   0x0609             LSLS     R1,R1,#+24
   \       0x12   0xD507             BPL.N    ??UART_DMAError_0
   \       0x14   0x2821             CMP      R0,#+33
   \       0x16   0xD105             BNE.N    ??UART_DMAError_0
   3808            {
   3809              huart->TxXferCount = 0U;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF8A4 0x0056      STRH     R0,[R4, #+86]
   3810              UART_EndTxTransfer(huart);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       UART_EndTxTransfer
   3811            }
   3812          
   3813            /* Stop UART DMA Rx request if ongoing */
   3814            if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
   3815                (rxstate == HAL_UART_STATE_BUSY_RX))
   \                     ??UART_DMAError_0: (+1)
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6880             LDR      R0,[R0, #+8]
   \       0x28   0x0640             LSLS     R0,R0,#+25
   \       0x2A   0xD507             BPL.N    ??UART_DMAError_1
   \       0x2C   0x2D22             CMP      R5,#+34
   \       0x2E   0xD105             BNE.N    ??UART_DMAError_1
   3816            {
   3817              huart->RxXferCount = 0U;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xF8A4 0x005E      STRH     R0,[R4, #+94]
   3818              UART_EndRxTransfer(huart);
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x.... 0x....      BL       UART_EndRxTransfer
   3819            }
   3820          
   3821            huart->ErrorCode |= HAL_UART_ERROR_DMA;
   \                     ??UART_DMAError_1: (+1)
   \       0x3C   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   \       0x40   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x44   0xF8C4 0x008C      STR      R0,[R4, #+140]
   3822          
   3823          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   3824            /*Call registered error callback*/
   3825            huart->ErrorCallback(huart);
   3826          #else
   3827            /*Call legacy weak error callback*/
   3828            HAL_UART_ErrorCallback(huart);
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x.... 0x....      BL       HAL_UART_ErrorCallback
   3829          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   3830          }
   \       0x4E   0xBD31             POP      {R0,R4,R5,PC}
   3831          
   3832          /**
   3833            * @brief  DMA UART communication abort callback, when initiated by HAL services on Error
   3834            *         (To be called at end of DMA Abort procedure following error occurrence).
   3835            * @param  hdma DMA handle.
   3836            * @retval None
   3837            */

   \                                 In section .text, align 2, keep-with-next
   3838          static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
   3839          {
   \                     UART_DMAAbortOnError: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3840            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
   \        0x2   0x6B80             LDR      R0,[R0, #+56]
   3841            huart->RxXferCount = 0U;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0xF8A0 0x105E      STRH     R1,[R0, #+94]
   3842            huart->TxXferCount = 0U;
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0xF8A0 0x1056      STRH     R1,[R0, #+86]
   3843          
   3844          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   3845            /*Call registered error callback*/
   3846            huart->ErrorCallback(huart);
   3847          #else
   3848            /*Call legacy weak error callback*/
   3849            HAL_UART_ErrorCallback(huart);
   \       0x10   0x.... 0x....      BL       HAL_UART_ErrorCallback
   3850          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   3851          }
   \       0x14   0xBD01             POP      {R0,PC}
   3852          
   3853          /**
   3854            * @brief  DMA UART Tx communication abort callback, when initiated by user
   3855            *         (To be called at end of DMA Tx Abort procedure following user abort request).
   3856            * @note   When this callback is executed, User Abort complete call back is called only if no
   3857            *         Abort still ongoing for Rx DMA Handle.
   3858            * @param  hdma DMA handle.
   3859            * @retval None
   3860            */

   \                                 In section .text, align 2, keep-with-next
   3861          static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
   3862          {
   \                     UART_DMATxAbortCallback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3863            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
   \        0x2   0x6B80             LDR      R0,[R0, #+56]
   3864          
   3865            huart->hdmatx->XferAbortCallback = NULL;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6F82             LDR      R2,[R0, #+120]
   \        0x8   0x6511             STR      R1,[R2, #+80]
   3866          
   3867            /* Check if an Abort process is still ongoing */
   3868            if (huart->hdmarx != NULL)
   \        0xA   0x6FC1             LDR      R1,[R0, #+124]
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD003             BEQ.N    ??UART_DMATxAbortCallback_0
   3869            {
   3870              if (huart->hdmarx->XferAbortCallback != NULL)
   \       0x10   0x6FC1             LDR      R1,[R0, #+124]
   \       0x12   0x6D09             LDR      R1,[R1, #+80]
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD11F             BNE.N    ??UART_DMATxAbortCallback_1
   3871              {
   3872                return;
   3873              }
   3874            }
   3875          
   3876            /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
   3877            huart->TxXferCount = 0U;
   \                     ??UART_DMATxAbortCallback_0: (+1)
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0xF8A0 0x1056      STRH     R1,[R0, #+86]
   3878            huart->RxXferCount = 0U;
   \       0x1E   0x2100             MOVS     R1,#+0
   \       0x20   0xF8A0 0x105E      STRH     R1,[R0, #+94]
   3879          
   3880            /* Reset errorCode */
   3881            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0xF8C0 0x108C      STR      R1,[R0, #+140]
   3882          
   3883            /* Clear the Error flags in the ICR register */
   3884            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
   \       0x2A   0x210F             MOVS     R1,#+15
   \       0x2C   0x6802             LDR      R2,[R0, #+0]
   \       0x2E   0x6211             STR      R1,[R2, #+32]
   3885          
   3886            /* Flush the whole TX FIFO (if needed) */
   3887            if (huart->FifoMode == UART_FIFOMODE_ENABLE)
   \       0x30   0x6E41             LDR      R1,[R0, #+100]
   \       0x32   0xF1B1 0x5F00      CMP      R1,#+536870912
   \       0x36   0xD105             BNE.N    ??UART_DMATxAbortCallback_2
   3888            {
   3889              __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0x6989             LDR      R1,[R1, #+24]
   \       0x3C   0xF051 0x0110      ORRS     R1,R1,#0x10
   \       0x40   0x6802             LDR      R2,[R0, #+0]
   \       0x42   0x6191             STR      R1,[R2, #+24]
   3890            }
   3891          
   3892            /* Restore huart->gState and huart->RxState to Ready */
   3893            huart->gState  = HAL_UART_STATE_READY;
   \                     ??UART_DMATxAbortCallback_2: (+1)
   \       0x44   0x2120             MOVS     R1,#+32
   \       0x46   0xF8C0 0x1084      STR      R1,[R0, #+132]
   3894            huart->RxState = HAL_UART_STATE_READY;
   \       0x4A   0x2120             MOVS     R1,#+32
   \       0x4C   0xF8C0 0x1088      STR      R1,[R0, #+136]
   3895            huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \       0x50   0x2100             MOVS     R1,#+0
   \       0x52   0x66C1             STR      R1,[R0, #+108]
   3896          
   3897            /* Call user Abort complete callback */
   3898          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   3899            /* Call registered Abort complete callback */
   3900            huart->AbortCpltCallback(huart);
   3901          #else
   3902            /* Call legacy weak Abort complete callback */
   3903            HAL_UART_AbortCpltCallback(huart);
   \       0x54   0x.... 0x....      BL       HAL_UART_AbortCpltCallback
   3904          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   3905          }
   \                     ??UART_DMATxAbortCallback_1: (+1)
   \       0x58   0xBD01             POP      {R0,PC}
   3906          
   3907          
   3908          /**
   3909            * @brief  DMA UART Rx communication abort callback, when initiated by user
   3910            *         (To be called at end of DMA Rx Abort procedure following user abort request).
   3911            * @note   When this callback is executed, User Abort complete call back is called only if no
   3912            *         Abort still ongoing for Tx DMA Handle.
   3913            * @param  hdma DMA handle.
   3914            * @retval None
   3915            */

   \                                 In section .text, align 2, keep-with-next
   3916          static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
   3917          {
   \                     UART_DMARxAbortCallback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3918            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
   \        0x2   0x6B80             LDR      R0,[R0, #+56]
   3919          
   3920            huart->hdmarx->XferAbortCallback = NULL;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6FC2             LDR      R2,[R0, #+124]
   \        0x8   0x6511             STR      R1,[R2, #+80]
   3921          
   3922            /* Check if an Abort process is still ongoing */
   3923            if (huart->hdmatx != NULL)
   \        0xA   0x6F81             LDR      R1,[R0, #+120]
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD003             BEQ.N    ??UART_DMARxAbortCallback_0
   3924            {
   3925              if (huart->hdmatx->XferAbortCallback != NULL)
   \       0x10   0x6F81             LDR      R1,[R0, #+120]
   \       0x12   0x6D09             LDR      R1,[R1, #+80]
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD11B             BNE.N    ??UART_DMARxAbortCallback_1
   3926              {
   3927                return;
   3928              }
   3929            }
   3930          
   3931            /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
   3932            huart->TxXferCount = 0U;
   \                     ??UART_DMARxAbortCallback_0: (+1)
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0xF8A0 0x1056      STRH     R1,[R0, #+86]
   3933            huart->RxXferCount = 0U;
   \       0x1E   0x2100             MOVS     R1,#+0
   \       0x20   0xF8A0 0x105E      STRH     R1,[R0, #+94]
   3934          
   3935            /* Reset errorCode */
   3936            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0xF8C0 0x108C      STR      R1,[R0, #+140]
   3937          
   3938            /* Clear the Error flags in the ICR register */
   3939            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
   \       0x2A   0x210F             MOVS     R1,#+15
   \       0x2C   0x6802             LDR      R2,[R0, #+0]
   \       0x2E   0x6211             STR      R1,[R2, #+32]
   3940          
   3941            /* Discard the received data */
   3942            __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
   \       0x30   0x6801             LDR      R1,[R0, #+0]
   \       0x32   0x6989             LDR      R1,[R1, #+24]
   \       0x34   0xF051 0x0108      ORRS     R1,R1,#0x8
   \       0x38   0x6802             LDR      R2,[R0, #+0]
   \       0x3A   0x6191             STR      R1,[R2, #+24]
   3943          
   3944            /* Restore huart->gState and huart->RxState to Ready */
   3945            huart->gState  = HAL_UART_STATE_READY;
   \       0x3C   0x2120             MOVS     R1,#+32
   \       0x3E   0xF8C0 0x1084      STR      R1,[R0, #+132]
   3946            huart->RxState = HAL_UART_STATE_READY;
   \       0x42   0x2120             MOVS     R1,#+32
   \       0x44   0xF8C0 0x1088      STR      R1,[R0, #+136]
   3947            huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \       0x48   0x2100             MOVS     R1,#+0
   \       0x4A   0x66C1             STR      R1,[R0, #+108]
   3948          
   3949            /* Call user Abort complete callback */
   3950          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   3951            /* Call registered Abort complete callback */
   3952            huart->AbortCpltCallback(huart);
   3953          #else
   3954            /* Call legacy weak Abort complete callback */
   3955            HAL_UART_AbortCpltCallback(huart);
   \       0x4C   0x.... 0x....      BL       HAL_UART_AbortCpltCallback
   3956          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   3957          }
   \                     ??UART_DMARxAbortCallback_1: (+1)
   \       0x50   0xBD01             POP      {R0,PC}
   3958          
   3959          
   3960          /**
   3961            * @brief  DMA UART Tx communication abort callback, when initiated by user by a call to
   3962            *         HAL_UART_AbortTransmit_IT API (Abort only Tx transfer)
   3963            *         (This callback is executed at end of DMA Tx Abort procedure following user abort request,
   3964            *         and leads to user Tx Abort Complete callback execution).
   3965            * @param  hdma DMA handle.
   3966            * @retval None
   3967            */

   \                                 In section .text, align 2, keep-with-next
   3968          static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
   3969          {
   \                     UART_DMATxOnlyAbortCallback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3970            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
   \        0x2   0x6B80             LDR      R0,[R0, #+56]
   3971          
   3972            huart->TxXferCount = 0U;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0xF8A0 0x1056      STRH     R1,[R0, #+86]
   3973          
   3974            /* Flush the whole TX FIFO (if needed) */
   3975            if (huart->FifoMode == UART_FIFOMODE_ENABLE)
   \        0xA   0x6E41             LDR      R1,[R0, #+100]
   \        0xC   0xF1B1 0x5F00      CMP      R1,#+536870912
   \       0x10   0xD105             BNE.N    ??UART_DMATxOnlyAbortCallback_0
   3976            {
   3977              __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
   \       0x12   0x6801             LDR      R1,[R0, #+0]
   \       0x14   0x6989             LDR      R1,[R1, #+24]
   \       0x16   0xF051 0x0110      ORRS     R1,R1,#0x10
   \       0x1A   0x6802             LDR      R2,[R0, #+0]
   \       0x1C   0x6191             STR      R1,[R2, #+24]
   3978            }
   3979          
   3980            /* Restore huart->gState to Ready */
   3981            huart->gState = HAL_UART_STATE_READY;
   \                     ??UART_DMATxOnlyAbortCallback_0: (+1)
   \       0x1E   0x2120             MOVS     R1,#+32
   \       0x20   0xF8C0 0x1084      STR      R1,[R0, #+132]
   3982          
   3983            /* Call user Abort complete callback */
   3984          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   3985            /* Call registered Abort Transmit Complete Callback */
   3986            huart->AbortTransmitCpltCallback(huart);
   3987          #else
   3988            /* Call legacy weak Abort Transmit Complete Callback */
   3989            HAL_UART_AbortTransmitCpltCallback(huart);
   \       0x24   0x.... 0x....      BL       HAL_UART_AbortTransmitCpltCallback
   3990          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   3991          }
   \       0x28   0xBD01             POP      {R0,PC}
   3992          
   3993          /**
   3994            * @brief  DMA UART Rx communication abort callback, when initiated by user by a call to
   3995            *         HAL_UART_AbortReceive_IT API (Abort only Rx transfer)
   3996            *         (This callback is executed at end of DMA Rx Abort procedure following user abort request,
   3997            *         and leads to user Rx Abort Complete callback execution).
   3998            * @param  hdma DMA handle.
   3999            * @retval None
   4000            */

   \                                 In section .text, align 2, keep-with-next
   4001          static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
   4002          {
   \                     UART_DMARxOnlyAbortCallback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   4003            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x6B80             LDR      R0,[R0, #+56]
   4004          
   4005            huart->RxXferCount = 0U;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0xF8A0 0x105E      STRH     R1,[R0, #+94]
   4006          
   4007            /* Clear the Error flags in the ICR register */
   4008            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
   \        0xA   0x210F             MOVS     R1,#+15
   \        0xC   0x6802             LDR      R2,[R0, #+0]
   \        0xE   0x6211             STR      R1,[R2, #+32]
   4009          
   4010            /* Discard the received data */
   4011            __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0x6989             LDR      R1,[R1, #+24]
   \       0x14   0xF051 0x0108      ORRS     R1,R1,#0x8
   \       0x18   0x6802             LDR      R2,[R0, #+0]
   \       0x1A   0x6191             STR      R1,[R2, #+24]
   4012          
   4013            /* Restore huart->RxState to Ready */
   4014            huart->RxState = HAL_UART_STATE_READY;
   \       0x1C   0x2120             MOVS     R1,#+32
   \       0x1E   0xF8C0 0x1088      STR      R1,[R0, #+136]
   4015            huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x66C1             STR      R1,[R0, #+108]
   4016          
   4017            /* Call user Abort complete callback */
   4018          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   4019            /* Call registered Abort Receive Complete Callback */
   4020            huart->AbortReceiveCpltCallback(huart);
   4021          #else
   4022            /* Call legacy weak Abort Receive Complete Callback */
   4023            HAL_UART_AbortReceiveCpltCallback(huart);
   \       0x26   0x.... 0x....      BL       HAL_UART_AbortReceiveCpltCallback
   4024          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   4025          }
   \       0x2A   0xBD01             POP      {R0,PC}
   4026          
   4027          /**
   4028            * @brief TX interrupt handler for 7 or 8 bits data word length .
   4029            * @note   Function is called under interruption only, once
   4030            *         interruptions have been enabled by HAL_UART_Transmit_IT().
   4031            * @param huart UART handle.
   4032            * @retval None
   4033            */

   \                                 In section .text, align 2, keep-with-next
   4034          static void UART_TxISR_8BIT(UART_HandleTypeDef *huart)
   4035          {
   4036            /* Check that a Tx process is ongoing */
   4037            if (huart->gState == HAL_UART_STATE_BUSY_TX)
   \                     UART_TxISR_8BIT: (+1)
   \        0x0   0xF8D0 0x1084      LDR      R1,[R0, #+132]
   \        0x4   0x2921             CMP      R1,#+33
   \        0x6   0xD124             BNE.N    ??UART_TxISR_8BIT_0
   4038            {
   4039              if (huart->TxXferCount == 0U)
   \        0x8   0xF8B0 0x1056      LDRH     R1,[R0, #+86]
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD114             BNE.N    ??UART_TxISR_8BIT_1
   4040              {
   4041                /* Disable the UART Transmit Data Register Empty Interrupt */
   4042                ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
   \                     ??UART_TxISR_8BIT_2: (+1)
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x16   0xF032 0x0280      BICS     R2,R2,#0x80
   \       0x1A   0x6803             LDR      R3,[R0, #+0]
   \       0x1C   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x20   0x2900             CMP      R1,#+0
   \       0x22   0xD1F5             BNE.N    ??UART_TxISR_8BIT_2
   4043          
   4044                /* Enable the UART Transmit Complete Interrupt */
   4045                ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
   \                     ??UART_TxISR_8BIT_3: (+1)
   \       0x24   0x6801             LDR      R1,[R0, #+0]
   \       0x26   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x2A   0xF052 0x0240      ORRS     R2,R2,#0x40
   \       0x2E   0x6803             LDR      R3,[R0, #+0]
   \       0x30   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x34   0x2900             CMP      R1,#+0
   \       0x36   0xD1F5             BNE.N    ??UART_TxISR_8BIT_3
   \       0x38   0xE00B             B.N      ??UART_TxISR_8BIT_0
   4046              }
   4047              else
   4048              {
   4049                huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
   \                     ??UART_TxISR_8BIT_1: (+1)
   \       0x3A   0x6D01             LDR      R1,[R0, #+80]
   \       0x3C   0x7809             LDRB     R1,[R1, #+0]
   \       0x3E   0x6802             LDR      R2,[R0, #+0]
   \       0x40   0x6291             STR      R1,[R2, #+40]
   4050                huart->pTxBuffPtr++;
   \       0x42   0x6D01             LDR      R1,[R0, #+80]
   \       0x44   0x1C49             ADDS     R1,R1,#+1
   \       0x46   0x6501             STR      R1,[R0, #+80]
   4051                huart->TxXferCount--;
   \       0x48   0xF8B0 0x1056      LDRH     R1,[R0, #+86]
   \       0x4C   0x1E49             SUBS     R1,R1,#+1
   \       0x4E   0xF8A0 0x1056      STRH     R1,[R0, #+86]
   4052              }
   4053            }
   4054          }
   \                     ??UART_TxISR_8BIT_0: (+1)
   \       0x52   0x4770             BX       LR
   4055          
   4056          /**
   4057            * @brief TX interrupt handler for 9 bits data word length.
   4058            * @note   Function is called under interruption only, once
   4059            *         interruptions have been enabled by HAL_UART_Transmit_IT().
   4060            * @param huart UART handle.
   4061            * @retval None
   4062            */

   \                                 In section .text, align 2, keep-with-next
   4063          static void UART_TxISR_16BIT(UART_HandleTypeDef *huart)
   4064          {
   4065            const uint16_t *tmp;
   4066          
   4067            /* Check that a Tx process is ongoing */
   4068            if (huart->gState == HAL_UART_STATE_BUSY_TX)
   \                     UART_TxISR_16BIT: (+1)
   \        0x0   0xF8D0 0x1084      LDR      R1,[R0, #+132]
   \        0x4   0x2921             CMP      R1,#+33
   \        0x6   0xD126             BNE.N    ??UART_TxISR_16BIT_0
   4069            {
   4070              if (huart->TxXferCount == 0U)
   \        0x8   0xF8B0 0x1056      LDRH     R1,[R0, #+86]
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD114             BNE.N    ??UART_TxISR_16BIT_1
   4071              {
   4072                /* Disable the UART Transmit Data Register Empty Interrupt */
   4073                ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE_TXFNFIE);
   \                     ??UART_TxISR_16BIT_2: (+1)
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x16   0xF032 0x0280      BICS     R2,R2,#0x80
   \       0x1A   0x6803             LDR      R3,[R0, #+0]
   \       0x1C   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x20   0x2900             CMP      R1,#+0
   \       0x22   0xD1F5             BNE.N    ??UART_TxISR_16BIT_2
   4074          
   4075                /* Enable the UART Transmit Complete Interrupt */
   4076                ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
   \                     ??UART_TxISR_16BIT_3: (+1)
   \       0x24   0x6801             LDR      R1,[R0, #+0]
   \       0x26   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x2A   0xF052 0x0240      ORRS     R2,R2,#0x40
   \       0x2E   0x6803             LDR      R3,[R0, #+0]
   \       0x30   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x34   0x2900             CMP      R1,#+0
   \       0x36   0xD1F5             BNE.N    ??UART_TxISR_16BIT_3
   \       0x38   0xE00D             B.N      ??UART_TxISR_16BIT_0
   4077              }
   4078              else
   4079              {
   4080                tmp = (const uint16_t *) huart->pTxBuffPtr;
   \                     ??UART_TxISR_16BIT_1: (+1)
   \       0x3A   0x6D01             LDR      R1,[R0, #+80]
   4081                huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
   \       0x3C   0x8809             LDRH     R1,[R1, #+0]
   \       0x3E   0x05C9             LSLS     R1,R1,#+23
   \       0x40   0x0DC9             LSRS     R1,R1,#+23
   \       0x42   0x6802             LDR      R2,[R0, #+0]
   \       0x44   0x6291             STR      R1,[R2, #+40]
   4082                huart->pTxBuffPtr += 2U;
   \       0x46   0x6D01             LDR      R1,[R0, #+80]
   \       0x48   0x1C89             ADDS     R1,R1,#+2
   \       0x4A   0x6501             STR      R1,[R0, #+80]
   4083                huart->TxXferCount--;
   \       0x4C   0xF8B0 0x1056      LDRH     R1,[R0, #+86]
   \       0x50   0x1E49             SUBS     R1,R1,#+1
   \       0x52   0xF8A0 0x1056      STRH     R1,[R0, #+86]
   4084              }
   4085            }
   4086          }
   \                     ??UART_TxISR_16BIT_0: (+1)
   \       0x56   0x4770             BX       LR
   4087          
   4088          /**
   4089            * @brief TX interrupt handler for 7 or 8 bits data word length and FIFO mode is enabled.
   4090            * @note   Function is called under interruption only, once
   4091            *         interruptions have been enabled by HAL_UART_Transmit_IT().
   4092            * @param huart UART handle.
   4093            * @retval None
   4094            */

   \                                 In section .text, align 2, keep-with-next
   4095          static void UART_TxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
   4096          {
   4097            uint16_t  nb_tx_data;
   4098          
   4099            /* Check that a Tx process is ongoing */
   4100            if (huart->gState == HAL_UART_STATE_BUSY_TX)
   \                     UART_TxISR_8BIT_FIFOEN: (+1)
   \        0x0   0xF8D0 0x1084      LDR      R1,[R0, #+132]
   \        0x4   0x2921             CMP      R1,#+33
   \        0x6   0xD132             BNE.N    ??UART_TxISR_8BIT_FIFOEN_0
   4101            {
   4102              for (nb_tx_data = huart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)
   \        0x8   0xF8B0 0x206A      LDRH     R2,[R0, #+106]
   \        0xC   0xE010             B.N      ??UART_TxISR_8BIT_FIFOEN_1
   4103              {
   4104                if (huart->TxXferCount == 0U)
   4105                {
   4106                  /* Disable the TX FIFO threshold interrupt */
   4107                  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
   4108          
   4109                  /* Enable the UART Transmit Complete Interrupt */
   4110                  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
   4111          
   4112                  break; /* force exit loop */
   4113                }
   4114                else if (READ_BIT(huart->Instance->ISR, USART_ISR_TXE_TXFNF) != 0U)
   \                     ??UART_TxISR_8BIT_FIFOEN_2: (+1)
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x69C9             LDR      R1,[R1, #+28]
   \       0x12   0x0609             LSLS     R1,R1,#+24
   \       0x14   0xD50B             BPL.N    ??UART_TxISR_8BIT_FIFOEN_3
   4115                {
   4116                  huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
   \       0x16   0x6D01             LDR      R1,[R0, #+80]
   \       0x18   0x7809             LDRB     R1,[R1, #+0]
   \       0x1A   0x6803             LDR      R3,[R0, #+0]
   \       0x1C   0x6299             STR      R1,[R3, #+40]
   4117                  huart->pTxBuffPtr++;
   \       0x1E   0x6D01             LDR      R1,[R0, #+80]
   \       0x20   0x1C49             ADDS     R1,R1,#+1
   \       0x22   0x6501             STR      R1,[R0, #+80]
   4118                  huart->TxXferCount--;
   \       0x24   0xF8B0 0x1056      LDRH     R1,[R0, #+86]
   \       0x28   0x1E49             SUBS     R1,R1,#+1
   \       0x2A   0xF8A0 0x1056      STRH     R1,[R0, #+86]
   4119                }
   \                     ??UART_TxISR_8BIT_FIFOEN_3: (+1)
   \       0x2E   0x1E52             SUBS     R2,R2,#+1
   \                     ??UART_TxISR_8BIT_FIFOEN_1: (+1)
   \       0x30   0x0011             MOVS     R1,R2
   \       0x32   0xB289             UXTH     R1,R1
   \       0x34   0x2900             CMP      R1,#+0
   \       0x36   0xD01A             BEQ.N    ??UART_TxISR_8BIT_FIFOEN_0
   \       0x38   0xF8B0 0x1056      LDRH     R1,[R0, #+86]
   \       0x3C   0x2900             CMP      R1,#+0
   \       0x3E   0xD1E6             BNE.N    ??UART_TxISR_8BIT_FIFOEN_2
   \                     ??UART_TxISR_8BIT_FIFOEN_4: (+1)
   \       0x40   0x6801             LDR      R1,[R0, #+0]
   \       0x42   0x3108             ADDS     R1,R1,#+8
   \       0x44   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x48   0xF432 0x0200      BICS     R2,R2,#0x800000
   \       0x4C   0x6801             LDR      R1,[R0, #+0]
   \       0x4E   0xF111 0x0308      ADDS     R3,R1,#+8
   \       0x52   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x56   0x2900             CMP      R1,#+0
   \       0x58   0xD1F2             BNE.N    ??UART_TxISR_8BIT_FIFOEN_4
   \                     ??UART_TxISR_8BIT_FIFOEN_5: (+1)
   \       0x5A   0x6801             LDR      R1,[R0, #+0]
   \       0x5C   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x60   0xF052 0x0240      ORRS     R2,R2,#0x40
   \       0x64   0x6803             LDR      R3,[R0, #+0]
   \       0x66   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x6A   0x2900             CMP      R1,#+0
   \       0x6C   0xD1F5             BNE.N    ??UART_TxISR_8BIT_FIFOEN_5
   4120                else
   4121                {
   4122                  /* Nothing to do */
   4123                }
   4124              }
   4125            }
   4126          }
   \                     ??UART_TxISR_8BIT_FIFOEN_0: (+1)
   \       0x6E   0x4770             BX       LR
   4127          
   4128          /**
   4129            * @brief TX interrupt handler for 9 bits data word length and FIFO mode is enabled.
   4130            * @note   Function is called under interruption only, once
   4131            *         interruptions have been enabled by HAL_UART_Transmit_IT().
   4132            * @param huart UART handle.
   4133            * @retval None
   4134            */

   \                                 In section .text, align 2, keep-with-next
   4135          static void UART_TxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)
   4136          {
   4137            const uint16_t *tmp;
   4138            uint16_t  nb_tx_data;
   4139          
   4140            /* Check that a Tx process is ongoing */
   4141            if (huart->gState == HAL_UART_STATE_BUSY_TX)
   \                     UART_TxISR_16BIT_FIFOEN: (+1)
   \        0x0   0xF8D0 0x1084      LDR      R1,[R0, #+132]
   \        0x4   0x2921             CMP      R1,#+33
   \        0x6   0xD134             BNE.N    ??UART_TxISR_16BIT_FIFOEN_0
   4142            {
   4143              for (nb_tx_data = huart->NbTxDataToProcess ; nb_tx_data > 0U ; nb_tx_data--)
   \        0x8   0xF8B0 0x206A      LDRH     R2,[R0, #+106]
   \        0xC   0xE012             B.N      ??UART_TxISR_16BIT_FIFOEN_1
   4144              {
   4145                if (huart->TxXferCount == 0U)
   4146                {
   4147                  /* Disable the TX FIFO threshold interrupt */
   4148                  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_TXFTIE);
   4149          
   4150                  /* Enable the UART Transmit Complete Interrupt */
   4151                  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
   4152          
   4153                  break; /* force exit loop */
   4154                }
   4155                else if (READ_BIT(huart->Instance->ISR, USART_ISR_TXE_TXFNF) != 0U)
   \                     ??UART_TxISR_16BIT_FIFOEN_2: (+1)
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x69C9             LDR      R1,[R1, #+28]
   \       0x12   0x0609             LSLS     R1,R1,#+24
   \       0x14   0xD50D             BPL.N    ??UART_TxISR_16BIT_FIFOEN_3
   4156                {
   4157                  tmp = (const uint16_t *) huart->pTxBuffPtr;
   \       0x16   0x6D01             LDR      R1,[R0, #+80]
   4158                  huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
   \       0x18   0x8809             LDRH     R1,[R1, #+0]
   \       0x1A   0x05C9             LSLS     R1,R1,#+23
   \       0x1C   0x0DC9             LSRS     R1,R1,#+23
   \       0x1E   0x6803             LDR      R3,[R0, #+0]
   \       0x20   0x6299             STR      R1,[R3, #+40]
   4159                  huart->pTxBuffPtr += 2U;
   \       0x22   0x6D01             LDR      R1,[R0, #+80]
   \       0x24   0x1C89             ADDS     R1,R1,#+2
   \       0x26   0x6501             STR      R1,[R0, #+80]
   4160                  huart->TxXferCount--;
   \       0x28   0xF8B0 0x1056      LDRH     R1,[R0, #+86]
   \       0x2C   0x1E49             SUBS     R1,R1,#+1
   \       0x2E   0xF8A0 0x1056      STRH     R1,[R0, #+86]
   4161                }
   \                     ??UART_TxISR_16BIT_FIFOEN_3: (+1)
   \       0x32   0x1E52             SUBS     R2,R2,#+1
   \                     ??UART_TxISR_16BIT_FIFOEN_1: (+1)
   \       0x34   0x0011             MOVS     R1,R2
   \       0x36   0xB289             UXTH     R1,R1
   \       0x38   0x2900             CMP      R1,#+0
   \       0x3A   0xD01A             BEQ.N    ??UART_TxISR_16BIT_FIFOEN_0
   \       0x3C   0xF8B0 0x1056      LDRH     R1,[R0, #+86]
   \       0x40   0x2900             CMP      R1,#+0
   \       0x42   0xD1E4             BNE.N    ??UART_TxISR_16BIT_FIFOEN_2
   \                     ??UART_TxISR_16BIT_FIFOEN_4: (+1)
   \       0x44   0x6801             LDR      R1,[R0, #+0]
   \       0x46   0x3108             ADDS     R1,R1,#+8
   \       0x48   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x4C   0xF432 0x0200      BICS     R2,R2,#0x800000
   \       0x50   0x6801             LDR      R1,[R0, #+0]
   \       0x52   0xF111 0x0308      ADDS     R3,R1,#+8
   \       0x56   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x5A   0x2900             CMP      R1,#+0
   \       0x5C   0xD1F2             BNE.N    ??UART_TxISR_16BIT_FIFOEN_4
   \                     ??UART_TxISR_16BIT_FIFOEN_5: (+1)
   \       0x5E   0x6801             LDR      R1,[R0, #+0]
   \       0x60   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x64   0xF052 0x0240      ORRS     R2,R2,#0x40
   \       0x68   0x6803             LDR      R3,[R0, #+0]
   \       0x6A   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x6E   0x2900             CMP      R1,#+0
   \       0x70   0xD1F5             BNE.N    ??UART_TxISR_16BIT_FIFOEN_5
   4162                else
   4163                {
   4164                  /* Nothing to do */
   4165                }
   4166              }
   4167            }
   4168          }
   \                     ??UART_TxISR_16BIT_FIFOEN_0: (+1)
   \       0x72   0x4770             BX       LR
   4169          
   4170          /**
   4171            * @brief  Wrap up transmission in non-blocking mode.
   4172            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   4173            *                the configuration information for the specified UART module.
   4174            * @retval None
   4175            */

   \                                 In section .text, align 2, keep-with-next
   4176          static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
   4177          {
   \                     UART_EndTransmit_IT: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   4178            /* Disable the UART Transmit Complete Interrupt */
   4179            ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
   \                     ??UART_EndTransmit_IT_0: (+1)
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xE851 0x2F00      LDREX    R2,[R1]
   \        0x8   0xF032 0x0240      BICS     R2,R2,#0x40
   \        0xC   0x6803             LDR      R3,[R0, #+0]
   \        0xE   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD1F5             BNE.N    ??UART_EndTransmit_IT_0
   4180          
   4181            /* Tx process is ended, restore huart->gState to Ready */
   4182            huart->gState = HAL_UART_STATE_READY;
   \       0x16   0x2120             MOVS     R1,#+32
   \       0x18   0xF8C0 0x1084      STR      R1,[R0, #+132]
   4183          
   4184            /* Cleat TxISR function pointer */
   4185            huart->TxISR = NULL;
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x6741             STR      R1,[R0, #+116]
   4186          
   4187          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   4188            /*Call registered Tx complete callback*/
   4189            huart->TxCpltCallback(huart);
   4190          #else
   4191            /*Call legacy weak Tx complete callback*/
   4192            HAL_UART_TxCpltCallback(huart);
   \       0x20   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   4193          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   4194          }
   \       0x24   0xBD01             POP      {R0,PC}
   4195          
   4196          /**
   4197            * @brief RX interrupt handler for 7 or 8 bits data word length .
   4198            * @param huart UART handle.
   4199            * @retval None
   4200            */

   \                                 In section .text, align 4, keep-with-next
   4201          static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
   4202          {
   \                     UART_RxISR_8BIT: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   4203            uint16_t uhMask = huart->Mask;
   \        0x2   0xF8B0 0x1060      LDRH     R1,[R0, #+96]
   4204            uint16_t  uhdata;
   4205          
   4206            /* Check that a Rx process is ongoing */
   4207            if (huart->RxState == HAL_UART_STATE_BUSY_RX)
   \        0x6   0xF8D0 0x2088      LDR      R2,[R0, #+136]
   \        0xA   0x2A22             CMP      R2,#+34
   \        0xC   0xD14A             BNE.N    ??UART_RxISR_8BIT_0
   4208            {
   4209              uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
   \        0xE   0x6802             LDR      R2,[R0, #+0]
   \       0x10   0x6A52             LDR      R2,[R2, #+36]
   4210              *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
   \       0x12   0x4011             ANDS     R1,R1,R2
   \       0x14   0x6D82             LDR      R2,[R0, #+88]
   \       0x16   0x7011             STRB     R1,[R2, #+0]
   4211              huart->pRxBuffPtr++;
   \       0x18   0x6D81             LDR      R1,[R0, #+88]
   \       0x1A   0x1C49             ADDS     R1,R1,#+1
   \       0x1C   0x6581             STR      R1,[R0, #+88]
   4212              huart->RxXferCount--;
   \       0x1E   0xF8B0 0x105E      LDRH     R1,[R0, #+94]
   \       0x22   0x1E49             SUBS     R1,R1,#+1
   \       0x24   0xF8A0 0x105E      STRH     R1,[R0, #+94]
   4213          
   4214              if (huart->RxXferCount == 0U)
   \       0x28   0xF8B0 0x105E      LDRH     R1,[R0, #+94]
   \       0x2C   0x2900             CMP      R1,#+0
   \       0x2E   0xD13F             BNE.N    ??UART_RxISR_8BIT_1
   4215              {
   4216                /* Disable the UART Parity Error Interrupt and RXNE interrupts */
   4217                ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
   \                     ??UART_RxISR_8BIT_2: (+1)
   \       0x30   0x6801             LDR      R1,[R0, #+0]
   \       0x32   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x36   0xF432 0x7290      BICS     R2,R2,#0x120
   \       0x3A   0x6803             LDR      R3,[R0, #+0]
   \       0x3C   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x40   0x2900             CMP      R1,#+0
   \       0x42   0xD1F5             BNE.N    ??UART_RxISR_8BIT_2
   4218          
   4219                /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   4220                ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \                     ??UART_RxISR_8BIT_3: (+1)
   \       0x44   0x6801             LDR      R1,[R0, #+0]
   \       0x46   0x3108             ADDS     R1,R1,#+8
   \       0x48   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x4C   0x0852             LSRS     R2,R2,#+1
   \       0x4E   0x0052             LSLS     R2,R2,#+1
   \       0x50   0x6801             LDR      R1,[R0, #+0]
   \       0x52   0xF111 0x0308      ADDS     R3,R1,#+8
   \       0x56   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x5A   0x2900             CMP      R1,#+0
   \       0x5C   0xD1F2             BNE.N    ??UART_RxISR_8BIT_3
   4221          
   4222                /* Rx process is completed, restore huart->RxState to Ready */
   4223                huart->RxState = HAL_UART_STATE_READY;
   \       0x5E   0x2120             MOVS     R1,#+32
   \       0x60   0xF8C0 0x1088      STR      R1,[R0, #+136]
   4224          
   4225                /* Clear RxISR function pointer */
   4226                huart->RxISR = NULL;
   \       0x64   0x2100             MOVS     R1,#+0
   \       0x66   0x6701             STR      R1,[R0, #+112]
   4227          
   4228                /* Check current reception Mode :
   4229                   If Reception till IDLE event has been selected : */
   4230                if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
   \       0x68   0x6EC1             LDR      R1,[R0, #+108]
   \       0x6A   0x2901             CMP      R1,#+1
   \       0x6C   0xD117             BNE.N    ??UART_RxISR_8BIT_4
   4231                {
   4232                  /* Set reception type to Standard */
   4233                  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \       0x6E   0x2100             MOVS     R1,#+0
   \       0x70   0x66C1             STR      R1,[R0, #+108]
   4234          
   4235                  /* Disable IDLE interrupt */
   4236                  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
   \                     ??UART_RxISR_8BIT_5: (+1)
   \       0x72   0x6801             LDR      R1,[R0, #+0]
   \       0x74   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x78   0xF032 0x0210      BICS     R2,R2,#0x10
   \       0x7C   0x6803             LDR      R3,[R0, #+0]
   \       0x7E   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x82   0x2900             CMP      R1,#+0
   \       0x84   0xD1F5             BNE.N    ??UART_RxISR_8BIT_5
   4237          
   4238                  if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
   \       0x86   0x6801             LDR      R1,[R0, #+0]
   \       0x88   0x69C9             LDR      R1,[R1, #+28]
   \       0x8A   0x06C9             LSLS     R1,R1,#+27
   \       0x8C   0xD502             BPL.N    ??UART_RxISR_8BIT_6
   4239                  {
   4240                    /* Clear IDLE Flag */
   4241                    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
   \       0x8E   0x2110             MOVS     R1,#+16
   \       0x90   0x6802             LDR      R2,[R0, #+0]
   \       0x92   0x6211             STR      R1,[R2, #+32]
   4242                  }
   4243          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   4244                  /*Call registered Rx Event callback*/
   4245                  huart->RxEventCallback(huart, huart->RxXferSize);
   4246          #else
   4247                  /*Call legacy weak Rx Event callback*/
   4248                  HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
   \                     ??UART_RxISR_8BIT_6: (+1)
   \       0x94   0xF8B0 0x105C      LDRH     R1,[R0, #+92]
   \       0x98   0x.... 0x....      BL       HAL_UARTEx_RxEventCallback
   \       0x9C   0xE008             B.N      ??UART_RxISR_8BIT_1
   4249          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
   4250                }
   4251                else
   4252                {
   4253                  /* Standard reception API called */
   4254          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   4255                  /*Call registered Rx complete callback*/
   4256                  huart->RxCpltCallback(huart);
   4257          #else
   4258                  /*Call legacy weak Rx complete callback*/
   4259                  HAL_UART_RxCpltCallback(huart);
   \                     ??UART_RxISR_8BIT_4: (+1)
   \       0x9E   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   \       0xA2   0xE005             B.N      ??UART_RxISR_8BIT_1
   4260          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   4261                }
   4262              }
   4263            }
   4264            else
   4265            {
   4266              /* Clear RXNE interrupt flag */
   4267              __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
   \                     ??UART_RxISR_8BIT_0: (+1)
   \       0xA4   0x6801             LDR      R1,[R0, #+0]
   \       0xA6   0x6989             LDR      R1,[R1, #+24]
   \       0xA8   0xF051 0x0108      ORRS     R1,R1,#0x8
   \       0xAC   0x6800             LDR      R0,[R0, #+0]
   \       0xAE   0x6181             STR      R1,[R0, #+24]
   4268            }
   4269          }
   \                     ??UART_RxISR_8BIT_1: (+1)
   \       0xB0   0xBD01             POP      {R0,PC}
   4270          
   4271          /**
   4272            * @brief RX interrupt handler for 9 bits data word length .
   4273            * @note   Function is called under interruption only, once
   4274            *         interruptions have been enabled by HAL_UART_Receive_IT()
   4275            * @param huart UART handle.
   4276            * @retval None
   4277            */

   \                                 In section .text, align 4, keep-with-next
   4278          static void UART_RxISR_16BIT(UART_HandleTypeDef *huart)
   4279          {
   \                     UART_RxISR_16BIT: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   4280            uint16_t *tmp;
   4281            uint16_t uhMask = huart->Mask;
   \        0x2   0xF8B0 0x2060      LDRH     R2,[R0, #+96]
   4282            uint16_t  uhdata;
   4283          
   4284            /* Check that a Rx process is ongoing */
   4285            if (huart->RxState == HAL_UART_STATE_BUSY_RX)
   \        0x6   0xF8D0 0x1088      LDR      R1,[R0, #+136]
   \        0xA   0x2922             CMP      R1,#+34
   \        0xC   0xD14A             BNE.N    ??UART_RxISR_16BIT_0
   4286            {
   4287              uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x6A4B             LDR      R3,[R1, #+36]
   4288              tmp = (uint16_t *) huart->pRxBuffPtr ;
   \       0x12   0x6D81             LDR      R1,[R0, #+88]
   4289              *tmp = (uint16_t)(uhdata & uhMask);
   \       0x14   0x401A             ANDS     R2,R2,R3
   \       0x16   0x800A             STRH     R2,[R1, #+0]
   4290              huart->pRxBuffPtr += 2U;
   \       0x18   0x6D81             LDR      R1,[R0, #+88]
   \       0x1A   0x1C89             ADDS     R1,R1,#+2
   \       0x1C   0x6581             STR      R1,[R0, #+88]
   4291              huart->RxXferCount--;
   \       0x1E   0xF8B0 0x105E      LDRH     R1,[R0, #+94]
   \       0x22   0x1E49             SUBS     R1,R1,#+1
   \       0x24   0xF8A0 0x105E      STRH     R1,[R0, #+94]
   4292          
   4293              if (huart->RxXferCount == 0U)
   \       0x28   0xF8B0 0x105E      LDRH     R1,[R0, #+94]
   \       0x2C   0x2900             CMP      R1,#+0
   \       0x2E   0xD13F             BNE.N    ??UART_RxISR_16BIT_1
   4294              {
   4295                /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
   4296                ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
   \                     ??UART_RxISR_16BIT_2: (+1)
   \       0x30   0x6801             LDR      R1,[R0, #+0]
   \       0x32   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x36   0xF432 0x7290      BICS     R2,R2,#0x120
   \       0x3A   0x6803             LDR      R3,[R0, #+0]
   \       0x3C   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x40   0x2900             CMP      R1,#+0
   \       0x42   0xD1F5             BNE.N    ??UART_RxISR_16BIT_2
   4297          
   4298                /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   4299                ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \                     ??UART_RxISR_16BIT_3: (+1)
   \       0x44   0x6801             LDR      R1,[R0, #+0]
   \       0x46   0x3108             ADDS     R1,R1,#+8
   \       0x48   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x4C   0x0852             LSRS     R2,R2,#+1
   \       0x4E   0x0052             LSLS     R2,R2,#+1
   \       0x50   0x6801             LDR      R1,[R0, #+0]
   \       0x52   0xF111 0x0308      ADDS     R3,R1,#+8
   \       0x56   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x5A   0x2900             CMP      R1,#+0
   \       0x5C   0xD1F2             BNE.N    ??UART_RxISR_16BIT_3
   4300          
   4301                /* Rx process is completed, restore huart->RxState to Ready */
   4302                huart->RxState = HAL_UART_STATE_READY;
   \       0x5E   0x2120             MOVS     R1,#+32
   \       0x60   0xF8C0 0x1088      STR      R1,[R0, #+136]
   4303          
   4304                /* Clear RxISR function pointer */
   4305                huart->RxISR = NULL;
   \       0x64   0x2100             MOVS     R1,#+0
   \       0x66   0x6701             STR      R1,[R0, #+112]
   4306          
   4307                /* Check current reception Mode :
   4308                   If Reception till IDLE event has been selected : */
   4309                if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
   \       0x68   0x6EC1             LDR      R1,[R0, #+108]
   \       0x6A   0x2901             CMP      R1,#+1
   \       0x6C   0xD117             BNE.N    ??UART_RxISR_16BIT_4
   4310                {
   4311                  /* Set reception type to Standard */
   4312                  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \       0x6E   0x2100             MOVS     R1,#+0
   \       0x70   0x66C1             STR      R1,[R0, #+108]
   4313          
   4314                  /* Disable IDLE interrupt */
   4315                  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
   \                     ??UART_RxISR_16BIT_5: (+1)
   \       0x72   0x6801             LDR      R1,[R0, #+0]
   \       0x74   0xE851 0x2F00      LDREX    R2,[R1]
   \       0x78   0xF032 0x0210      BICS     R2,R2,#0x10
   \       0x7C   0x6803             LDR      R3,[R0, #+0]
   \       0x7E   0xE843 0x2100      STREX    R1,R2,[R3]
   \       0x82   0x2900             CMP      R1,#+0
   \       0x84   0xD1F5             BNE.N    ??UART_RxISR_16BIT_5
   4316          
   4317                  if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
   \       0x86   0x6801             LDR      R1,[R0, #+0]
   \       0x88   0x69C9             LDR      R1,[R1, #+28]
   \       0x8A   0x06C9             LSLS     R1,R1,#+27
   \       0x8C   0xD502             BPL.N    ??UART_RxISR_16BIT_6
   4318                  {
   4319                    /* Clear IDLE Flag */
   4320                    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
   \       0x8E   0x2110             MOVS     R1,#+16
   \       0x90   0x6802             LDR      R2,[R0, #+0]
   \       0x92   0x6211             STR      R1,[R2, #+32]
   4321                  }
   4322          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   4323                  /*Call registered Rx Event callback*/
   4324                  huart->RxEventCallback(huart, huart->RxXferSize);
   4325          #else
   4326                  /*Call legacy weak Rx Event callback*/
   4327                  HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
   \                     ??UART_RxISR_16BIT_6: (+1)
   \       0x94   0xF8B0 0x105C      LDRH     R1,[R0, #+92]
   \       0x98   0x.... 0x....      BL       HAL_UARTEx_RxEventCallback
   \       0x9C   0xE008             B.N      ??UART_RxISR_16BIT_1
   4328          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
   4329                }
   4330                else
   4331                {
   4332                  /* Standard reception API called */
   4333          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   4334                  /*Call registered Rx complete callback*/
   4335                  huart->RxCpltCallback(huart);
   4336          #else
   4337                  /*Call legacy weak Rx complete callback*/
   4338                  HAL_UART_RxCpltCallback(huart);
   \                     ??UART_RxISR_16BIT_4: (+1)
   \       0x9E   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   \       0xA2   0xE005             B.N      ??UART_RxISR_16BIT_1
   4339          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   4340                }
   4341              }
   4342            }
   4343            else
   4344            {
   4345              /* Clear RXNE interrupt flag */
   4346              __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
   \                     ??UART_RxISR_16BIT_0: (+1)
   \       0xA4   0x6801             LDR      R1,[R0, #+0]
   \       0xA6   0x6989             LDR      R1,[R1, #+24]
   \       0xA8   0xF051 0x0108      ORRS     R1,R1,#0x8
   \       0xAC   0x6800             LDR      R0,[R0, #+0]
   \       0xAE   0x6181             STR      R1,[R0, #+24]
   4347            }
   4348          }
   \                     ??UART_RxISR_16BIT_1: (+1)
   \       0xB0   0xBD01             POP      {R0,PC}
   4349          
   4350          /**
   4351            * @brief RX interrupt handler for 7 or 8  bits data word length and FIFO mode is enabled.
   4352            * @note   Function is called under interruption only, once
   4353            *         interruptions have been enabled by HAL_UART_Receive_IT()
   4354            * @param huart UART handle.
   4355            * @retval None
   4356            */

   \                                 In section .text, align 4, keep-with-next
   4357          static void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
   4358          {
   \                     UART_RxISR_8BIT_FIFOEN: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   4359            uint16_t  uhMask = huart->Mask;
   \        0x6   0xF8B4 0x5060      LDRH     R5,[R4, #+96]
   4360            uint16_t  uhdata;
   4361            uint16_t  nb_rx_data;
   4362            uint16_t  rxdatacount;
   4363            uint32_t  isrflags = READ_REG(huart->Instance->ISR);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x69C6             LDR      R6,[R0, #+28]
   4364            uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x6807             LDR      R7,[R0, #+0]
   4365            uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0xF8D0 0x8008      LDR      R8,[R0, #+8]
   4366          
   4367            /* Check that a Rx process is ongoing */
   4368            if (huart->RxState == HAL_UART_STATE_BUSY_RX)
   \       0x18   0xF8D4 0x0088      LDR      R0,[R4, #+136]
   \       0x1C   0x2822             CMP      R0,#+34
   \       0x1E   0xF040 0x80BA      BNE.W    ??UART_RxISR_8BIT_FIFOEN_0
   4369            {
   4370              nb_rx_data = huart->NbRxDataToProcess;
   \       0x22   0xF8B4 0x9068      LDRH     R9,[R4, #+104]
   \       0x26   0xE017             B.N      ??UART_RxISR_8BIT_FIFOEN_1
   4371              while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
   4372              {
   4373                uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
   4374                *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
   4375                huart->pRxBuffPtr++;
   4376                huart->RxXferCount--;
   4377                isrflags = READ_REG(huart->Instance->ISR);
   4378          
   4379                /* If some non blocking errors occurred */
   4380                if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
   4381                {
   4382                  /* UART parity error interrupt occurred -------------------------------------*/
   4383                  if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
   4384                  {
   4385                    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
   4386          
   4387                    huart->ErrorCode |= HAL_UART_ERROR_PE;
   4388                  }
   4389          
   4390                  /* UART frame error interrupt occurred --------------------------------------*/
   4391                  if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
   4392                  {
   4393                    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
   4394          
   4395                    huart->ErrorCode |= HAL_UART_ERROR_FE;
   4396                  }
   4397          
   4398                  /* UART noise error interrupt occurred --------------------------------------*/
   4399                  if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
   4400                  {
   4401                    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
   4402          
   4403                    huart->ErrorCode |= HAL_UART_ERROR_NE;
   4404                  }
   4405          
   4406                  /* Call UART Error Call back function if need be ----------------------------*/
   4407                  if (huart->ErrorCode != HAL_UART_ERROR_NONE)
   4408                  {
   4409                    /* Non Blocking error : transfer could go on.
   4410                    Error is notified to user through user error callback */
   4411          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   4412                    /*Call registered error callback*/
   4413                    huart->ErrorCallback(huart);
   4414          #else
   4415                    /*Call legacy weak error callback*/
   4416                    HAL_UART_ErrorCallback(huart);
   4417          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   4418                    huart->ErrorCode = HAL_UART_ERROR_NONE;
   4419                  }
   4420                }
   4421          
   4422                if (huart->RxXferCount == 0U)
   4423                {
   4424                  /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
   4425                  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   4426          
   4427                  /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
   4428                     and RX FIFO Threshold interrupt */
   4429                  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
   4430          
   4431                  /* Rx process is completed, restore huart->RxState to Ready */
   4432                  huart->RxState = HAL_UART_STATE_READY;
   4433          
   4434                  /* Clear RxISR function pointer */
   4435                  huart->RxISR = NULL;
   4436          
   4437                  /* Check current reception Mode :
   4438                     If Reception till IDLE event has been selected : */
   4439                  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
   4440                  {
   4441                    /* Set reception type to Standard */
   4442                    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \                     ??UART_RxISR_8BIT_FIFOEN_2: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x66E0             STR      R0,[R4, #+108]
   4443          
   4444                    /* Disable IDLE interrupt */
   4445                    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
   \                     ??UART_RxISR_8BIT_FIFOEN_3: (+1)
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x32   0xF031 0x0110      BICS     R1,R1,#0x10
   \       0x36   0x6822             LDR      R2,[R4, #+0]
   \       0x38   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD1F5             BNE.N    ??UART_RxISR_8BIT_FIFOEN_3
   4446          
   4447                    if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x69C0             LDR      R0,[R0, #+28]
   \       0x44   0x06C0             LSLS     R0,R0,#+27
   \       0x46   0xD502             BPL.N    ??UART_RxISR_8BIT_FIFOEN_4
   4448                    {
   4449                      /* Clear IDLE Flag */
   4450                      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
   \       0x48   0x2010             MOVS     R0,#+16
   \       0x4A   0x6821             LDR      R1,[R4, #+0]
   \       0x4C   0x6208             STR      R0,[R1, #+32]
   4451                    }
   4452          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   4453                    /*Call registered Rx Event callback*/
   4454                    huart->RxEventCallback(huart, huart->RxXferSize);
   4455          #else
   4456                    /*Call legacy weak Rx Event callback*/
   4457                    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
   \                     ??UART_RxISR_8BIT_FIFOEN_4: (+1)
   \       0x4E   0xF8B4 0x105C      LDRH     R1,[R4, #+92]
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x.... 0x....      BL       HAL_UARTEx_RxEventCallback
   4458          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
   4459                  }
   \                     ??UART_RxISR_8BIT_FIFOEN_1: (+1)
   \       0x58   0x4648             MOV      R0,R9
   \       0x5A   0xB280             UXTH     R0,R0
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD075             BEQ.N    ??UART_RxISR_8BIT_FIFOEN_5
   \       0x60   0x06B0             LSLS     R0,R6,#+26
   \       0x62   0xD573             BPL.N    ??UART_RxISR_8BIT_FIFOEN_5
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x6A40             LDR      R0,[R0, #+36]
   \       0x68   0x4028             ANDS     R0,R5,R0
   \       0x6A   0x6DA1             LDR      R1,[R4, #+88]
   \       0x6C   0x7008             STRB     R0,[R1, #+0]
   \       0x6E   0x6DA0             LDR      R0,[R4, #+88]
   \       0x70   0x1C40             ADDS     R0,R0,#+1
   \       0x72   0x65A0             STR      R0,[R4, #+88]
   \       0x74   0xF8B4 0x005E      LDRH     R0,[R4, #+94]
   \       0x78   0x1E40             SUBS     R0,R0,#+1
   \       0x7A   0xF8A4 0x005E      STRH     R0,[R4, #+94]
   \       0x7E   0x6820             LDR      R0,[R4, #+0]
   \       0x80   0x69C6             LDR      R6,[R0, #+28]
   \       0x82   0xF016 0x0F07      TST      R6,#0x7
   \       0x86   0xD039             BEQ.N    ??UART_RxISR_8BIT_FIFOEN_6
   \       0x88   0xF016 0x0001      ANDS     R0,R6,#0x1
   \       0x8C   0xB2C0             UXTB     R0,R0
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD00A             BEQ.N    ??UART_RxISR_8BIT_FIFOEN_7
   \       0x92   0x05F8             LSLS     R0,R7,#+23
   \       0x94   0xD508             BPL.N    ??UART_RxISR_8BIT_FIFOEN_7
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0x6821             LDR      R1,[R4, #+0]
   \       0x9A   0x6208             STR      R0,[R1, #+32]
   \       0x9C   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   \       0xA0   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xA4   0xF8C4 0x008C      STR      R0,[R4, #+140]
   \                     ??UART_RxISR_8BIT_FIFOEN_7: (+1)
   \       0xA8   0x07B0             LSLS     R0,R6,#+30
   \       0xAA   0xD50D             BPL.N    ??UART_RxISR_8BIT_FIFOEN_8
   \       0xAC   0xF018 0x0001      ANDS     R0,R8,#0x1
   \       0xB0   0xB2C0             UXTB     R0,R0
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD008             BEQ.N    ??UART_RxISR_8BIT_FIFOEN_8
   \       0xB6   0x2002             MOVS     R0,#+2
   \       0xB8   0x6821             LDR      R1,[R4, #+0]
   \       0xBA   0x6208             STR      R0,[R1, #+32]
   \       0xBC   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   \       0xC0   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0xC4   0xF8C4 0x008C      STR      R0,[R4, #+140]
   \                     ??UART_RxISR_8BIT_FIFOEN_8: (+1)
   \       0xC8   0x0770             LSLS     R0,R6,#+29
   \       0xCA   0xD50D             BPL.N    ??UART_RxISR_8BIT_FIFOEN_9
   \       0xCC   0xF018 0x0001      ANDS     R0,R8,#0x1
   \       0xD0   0xB2C0             UXTB     R0,R0
   \       0xD2   0x2800             CMP      R0,#+0
   \       0xD4   0xD008             BEQ.N    ??UART_RxISR_8BIT_FIFOEN_9
   \       0xD6   0x2004             MOVS     R0,#+4
   \       0xD8   0x6821             LDR      R1,[R4, #+0]
   \       0xDA   0x6208             STR      R0,[R1, #+32]
   \       0xDC   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   \       0xE0   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0xE4   0xF8C4 0x008C      STR      R0,[R4, #+140]
   \                     ??UART_RxISR_8BIT_FIFOEN_9: (+1)
   \       0xE8   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD005             BEQ.N    ??UART_RxISR_8BIT_FIFOEN_6
   \       0xF0   0x0020             MOVS     R0,R4
   \       0xF2   0x.... 0x....      BL       HAL_UART_ErrorCallback
   \       0xF6   0x2000             MOVS     R0,#+0
   \       0xF8   0xF8C4 0x008C      STR      R0,[R4, #+140]
   \                     ??UART_RxISR_8BIT_FIFOEN_6: (+1)
   \       0xFC   0xF8B4 0x005E      LDRH     R0,[R4, #+94]
   \      0x100   0x2800             CMP      R0,#+0
   \      0x102   0xD1A9             BNE.N    ??UART_RxISR_8BIT_FIFOEN_1
   \                     ??UART_RxISR_8BIT_FIFOEN_10: (+1)
   \      0x104   0x6820             LDR      R0,[R4, #+0]
   \      0x106   0xE850 0x1F00      LDREX    R1,[R0]
   \      0x10A   0xF431 0x7180      BICS     R1,R1,#0x100
   \      0x10E   0x6822             LDR      R2,[R4, #+0]
   \      0x110   0xE842 0x1000      STREX    R0,R1,[R2]
   \      0x114   0x2800             CMP      R0,#+0
   \      0x116   0xD1F5             BNE.N    ??UART_RxISR_8BIT_FIFOEN_10
   \                     ??UART_RxISR_8BIT_FIFOEN_11: (+1)
   \      0x118   0x6820             LDR      R0,[R4, #+0]
   \      0x11A   0x3008             ADDS     R0,R0,#+8
   \      0x11C   0xE850 0x1F00      LDREX    R1,[R0]
   \      0x120   0x....             LDR.N    R0,??DataTable17
   \      0x122   0x4001             ANDS     R1,R0,R1
   \      0x124   0x6820             LDR      R0,[R4, #+0]
   \      0x126   0xF110 0x0208      ADDS     R2,R0,#+8
   \      0x12A   0xE842 0x1000      STREX    R0,R1,[R2]
   \      0x12E   0x2800             CMP      R0,#+0
   \      0x130   0xD1F2             BNE.N    ??UART_RxISR_8BIT_FIFOEN_11
   \      0x132   0x2020             MOVS     R0,#+32
   \      0x134   0xF8C4 0x0088      STR      R0,[R4, #+136]
   \      0x138   0x2000             MOVS     R0,#+0
   \      0x13A   0x6720             STR      R0,[R4, #+112]
   \      0x13C   0x6EE0             LDR      R0,[R4, #+108]
   \      0x13E   0x2801             CMP      R0,#+1
   \      0x140   0xF43F 0xAF72      BEQ.W    ??UART_RxISR_8BIT_FIFOEN_2
   4460                  else
   4461                  {
   4462                    /* Standard reception API called */
   4463          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   4464                    /*Call registered Rx complete callback*/
   4465                    huart->RxCpltCallback(huart);
   4466          #else
   4467                    /*Call legacy weak Rx complete callback*/
   4468                    HAL_UART_RxCpltCallback(huart);
   \      0x144   0x0020             MOVS     R0,R4
   \      0x146   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   \      0x14A   0xE785             B.N      ??UART_RxISR_8BIT_FIFOEN_1
   4469          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   4470                  }
   4471                }
   4472              }
   4473          
   4474              /* When remaining number of bytes to receive is less than the RX FIFO
   4475              threshold, next incoming frames are processed as if FIFO mode was
   4476              disabled (i.e. one interrupt per received frame).
   4477              */
   4478              rxdatacount = huart->RxXferCount;
   \                     ??UART_RxISR_8BIT_FIFOEN_5: (+1)
   \      0x14C   0xF8B4 0x105E      LDRH     R1,[R4, #+94]
   4479              if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
   \      0x150   0x0008             MOVS     R0,R1
   \      0x152   0xB280             UXTH     R0,R0
   \      0x154   0x2800             CMP      R0,#+0
   \      0x156   0xD024             BEQ.N    ??UART_RxISR_8BIT_FIFOEN_12
   \      0x158   0xF8B4 0x0068      LDRH     R0,[R4, #+104]
   \      0x15C   0xB289             UXTH     R1,R1
   \      0x15E   0x4281             CMP      R1,R0
   \      0x160   0xD21F             BCS.N    ??UART_RxISR_8BIT_FIFOEN_12
   4480              {
   4481                /* Disable the UART RXFT interrupt*/
   4482                ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
   \                     ??UART_RxISR_8BIT_FIFOEN_13: (+1)
   \      0x162   0x6820             LDR      R0,[R4, #+0]
   \      0x164   0x3008             ADDS     R0,R0,#+8
   \      0x166   0xE850 0x1F00      LDREX    R1,[R0]
   \      0x16A   0xF031 0x5180      BICS     R1,R1,#0x10000000
   \      0x16E   0x6820             LDR      R0,[R4, #+0]
   \      0x170   0xF110 0x0208      ADDS     R2,R0,#+8
   \      0x174   0xE842 0x1000      STREX    R0,R1,[R2]
   \      0x178   0x2800             CMP      R0,#+0
   \      0x17A   0xD1F2             BNE.N    ??UART_RxISR_8BIT_FIFOEN_13
   4483          
   4484                /* Update the RxISR function pointer */
   4485                huart->RxISR = UART_RxISR_8BIT;
   \      0x17C   0x....             LDR.N    R0,??DataTable17_1
   \      0x17E   0x6720             STR      R0,[R4, #+112]
   4486          
   4487                /* Enable the UART Data Register Not Empty interrupt */
   4488                ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
   \                     ??UART_RxISR_8BIT_FIFOEN_14: (+1)
   \      0x180   0x6820             LDR      R0,[R4, #+0]
   \      0x182   0xE850 0x1F00      LDREX    R1,[R0]
   \      0x186   0xF051 0x0120      ORRS     R1,R1,#0x20
   \      0x18A   0x6822             LDR      R2,[R4, #+0]
   \      0x18C   0xE842 0x1000      STREX    R0,R1,[R2]
   \      0x190   0x2800             CMP      R0,#+0
   \      0x192   0xD1F5             BNE.N    ??UART_RxISR_8BIT_FIFOEN_14
   \      0x194   0xE005             B.N      ??UART_RxISR_8BIT_FIFOEN_12
   4489              }
   4490            }
   4491            else
   4492            {
   4493              /* Clear RXNE interrupt flag */
   4494              __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
   \                     ??UART_RxISR_8BIT_FIFOEN_0: (+1)
   \      0x196   0x6820             LDR      R0,[R4, #+0]
   \      0x198   0x6980             LDR      R0,[R0, #+24]
   \      0x19A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x19E   0x6821             LDR      R1,[R4, #+0]
   \      0x1A0   0x6188             STR      R0,[R1, #+24]
   4495            }
   4496          }
   \                     ??UART_RxISR_8BIT_FIFOEN_12: (+1)
   \      0x1A2   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}
   4497          
   4498          /**
   4499            * @brief RX interrupt handler for 9 bits data word length and FIFO mode is enabled.
   4500            * @note   Function is called under interruption only, once
   4501            *         interruptions have been enabled by HAL_UART_Receive_IT()
   4502            * @param huart UART handle.
   4503            * @retval None
   4504            */

   \                                 In section .text, align 4, keep-with-next
   4505          static void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)
   4506          {
   \                     UART_RxISR_16BIT_FIFOEN: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   4507            uint16_t *tmp;
   4508            uint16_t  uhMask = huart->Mask;
   \        0x6   0xF8B4 0x5060      LDRH     R5,[R4, #+96]
   4509            uint16_t  uhdata;
   4510            uint16_t  nb_rx_data;
   4511            uint16_t  rxdatacount;
   4512            uint32_t  isrflags = READ_REG(huart->Instance->ISR);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x69C6             LDR      R6,[R0, #+28]
   4513            uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x6807             LDR      R7,[R0, #+0]
   4514            uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0xF8D0 0x8008      LDR      R8,[R0, #+8]
   4515          
   4516            /* Check that a Rx process is ongoing */
   4517            if (huart->RxState == HAL_UART_STATE_BUSY_RX)
   \       0x18   0xF8D4 0x0088      LDR      R0,[R4, #+136]
   \       0x1C   0x2822             CMP      R0,#+34
   \       0x1E   0xF040 0x80BA      BNE.W    ??UART_RxISR_16BIT_FIFOEN_0
   4518            {
   4519              nb_rx_data = huart->NbRxDataToProcess;
   \       0x22   0xF8B4 0x9068      LDRH     R9,[R4, #+104]
   \       0x26   0xE017             B.N      ??UART_RxISR_16BIT_FIFOEN_1
   4520              while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
   4521              {
   4522                uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
   4523                tmp = (uint16_t *) huart->pRxBuffPtr ;
   4524                *tmp = (uint16_t)(uhdata & uhMask);
   4525                huart->pRxBuffPtr += 2U;
   4526                huart->RxXferCount--;
   4527                isrflags = READ_REG(huart->Instance->ISR);
   4528          
   4529                /* If some non blocking errors occurred */
   4530                if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
   4531                {
   4532                  /* UART parity error interrupt occurred -------------------------------------*/
   4533                  if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
   4534                  {
   4535                    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
   4536          
   4537                    huart->ErrorCode |= HAL_UART_ERROR_PE;
   4538                  }
   4539          
   4540                  /* UART frame error interrupt occurred --------------------------------------*/
   4541                  if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
   4542                  {
   4543                    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
   4544          
   4545                    huart->ErrorCode |= HAL_UART_ERROR_FE;
   4546                  }
   4547          
   4548                  /* UART noise error interrupt occurred --------------------------------------*/
   4549                  if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
   4550                  {
   4551                    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
   4552          
   4553                    huart->ErrorCode |= HAL_UART_ERROR_NE;
   4554                  }
   4555          
   4556                  /* Call UART Error Call back function if need be ----------------------------*/
   4557                  if (huart->ErrorCode != HAL_UART_ERROR_NONE)
   4558                  {
   4559                    /* Non Blocking error : transfer could go on.
   4560                    Error is notified to user through user error callback */
   4561          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   4562                    /*Call registered error callback*/
   4563                    huart->ErrorCallback(huart);
   4564          #else
   4565                    /*Call legacy weak error callback*/
   4566                    HAL_UART_ErrorCallback(huart);
   4567          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   4568                    huart->ErrorCode = HAL_UART_ERROR_NONE;
   4569                  }
   4570                }
   4571          
   4572                if (huart->RxXferCount == 0U)
   4573                {
   4574                  /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
   4575                  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   4576          
   4577                  /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
   4578                     and RX FIFO Threshold interrupt */
   4579                  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
   4580          
   4581                  /* Rx process is completed, restore huart->RxState to Ready */
   4582                  huart->RxState = HAL_UART_STATE_READY;
   4583          
   4584                  /* Clear RxISR function pointer */
   4585                  huart->RxISR = NULL;
   4586          
   4587                  /* Check current reception Mode :
   4588                     If Reception till IDLE event has been selected : */
   4589                  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
   4590                  {
   4591                    /* Set reception type to Standard */
   4592                    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
   \                     ??UART_RxISR_16BIT_FIFOEN_2: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x66E0             STR      R0,[R4, #+108]
   4593          
   4594                    /* Disable IDLE interrupt */
   4595                    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
   \                     ??UART_RxISR_16BIT_FIFOEN_3: (+1)
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0xE850 0x1F00      LDREX    R1,[R0]
   \       0x32   0xF031 0x0110      BICS     R1,R1,#0x10
   \       0x36   0x6822             LDR      R2,[R4, #+0]
   \       0x38   0xE842 0x1000      STREX    R0,R1,[R2]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD1F5             BNE.N    ??UART_RxISR_16BIT_FIFOEN_3
   4596          
   4597                    if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x69C0             LDR      R0,[R0, #+28]
   \       0x44   0x06C0             LSLS     R0,R0,#+27
   \       0x46   0xD502             BPL.N    ??UART_RxISR_16BIT_FIFOEN_4
   4598                    {
   4599                      /* Clear IDLE Flag */
   4600                      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
   \       0x48   0x2010             MOVS     R0,#+16
   \       0x4A   0x6821             LDR      R1,[R4, #+0]
   \       0x4C   0x6208             STR      R0,[R1, #+32]
   4601                    }
   4602          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   4603                    /*Call registered Rx Event callback*/
   4604                    huart->RxEventCallback(huart, huart->RxXferSize);
   4605          #else
   4606                    /*Call legacy weak Rx Event callback*/
   4607                    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
   \                     ??UART_RxISR_16BIT_FIFOEN_4: (+1)
   \       0x4E   0xF8B4 0x105C      LDRH     R1,[R4, #+92]
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x.... 0x....      BL       HAL_UARTEx_RxEventCallback
   4608          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
   4609                  }
   \                     ??UART_RxISR_16BIT_FIFOEN_1: (+1)
   \       0x58   0x4648             MOV      R0,R9
   \       0x5A   0xB280             UXTH     R0,R0
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD075             BEQ.N    ??UART_RxISR_16BIT_FIFOEN_5
   \       0x60   0x06B0             LSLS     R0,R6,#+26
   \       0x62   0xD573             BPL.N    ??UART_RxISR_16BIT_FIFOEN_5
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x6A41             LDR      R1,[R0, #+36]
   \       0x68   0x6DA0             LDR      R0,[R4, #+88]
   \       0x6A   0x4029             ANDS     R1,R5,R1
   \       0x6C   0x8001             STRH     R1,[R0, #+0]
   \       0x6E   0x6DA0             LDR      R0,[R4, #+88]
   \       0x70   0x1C80             ADDS     R0,R0,#+2
   \       0x72   0x65A0             STR      R0,[R4, #+88]
   \       0x74   0xF8B4 0x005E      LDRH     R0,[R4, #+94]
   \       0x78   0x1E40             SUBS     R0,R0,#+1
   \       0x7A   0xF8A4 0x005E      STRH     R0,[R4, #+94]
   \       0x7E   0x6820             LDR      R0,[R4, #+0]
   \       0x80   0x69C6             LDR      R6,[R0, #+28]
   \       0x82   0xF016 0x0F07      TST      R6,#0x7
   \       0x86   0xD039             BEQ.N    ??UART_RxISR_16BIT_FIFOEN_6
   \       0x88   0xF016 0x0001      ANDS     R0,R6,#0x1
   \       0x8C   0xB2C0             UXTB     R0,R0
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD00A             BEQ.N    ??UART_RxISR_16BIT_FIFOEN_7
   \       0x92   0x05F8             LSLS     R0,R7,#+23
   \       0x94   0xD508             BPL.N    ??UART_RxISR_16BIT_FIFOEN_7
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0x6821             LDR      R1,[R4, #+0]
   \       0x9A   0x6208             STR      R0,[R1, #+32]
   \       0x9C   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   \       0xA0   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xA4   0xF8C4 0x008C      STR      R0,[R4, #+140]
   \                     ??UART_RxISR_16BIT_FIFOEN_7: (+1)
   \       0xA8   0x07B0             LSLS     R0,R6,#+30
   \       0xAA   0xD50D             BPL.N    ??UART_RxISR_16BIT_FIFOEN_8
   \       0xAC   0xF018 0x0001      ANDS     R0,R8,#0x1
   \       0xB0   0xB2C0             UXTB     R0,R0
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD008             BEQ.N    ??UART_RxISR_16BIT_FIFOEN_8
   \       0xB6   0x2002             MOVS     R0,#+2
   \       0xB8   0x6821             LDR      R1,[R4, #+0]
   \       0xBA   0x6208             STR      R0,[R1, #+32]
   \       0xBC   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   \       0xC0   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0xC4   0xF8C4 0x008C      STR      R0,[R4, #+140]
   \                     ??UART_RxISR_16BIT_FIFOEN_8: (+1)
   \       0xC8   0x0770             LSLS     R0,R6,#+29
   \       0xCA   0xD50D             BPL.N    ??UART_RxISR_16BIT_FIFOEN_9
   \       0xCC   0xF018 0x0001      ANDS     R0,R8,#0x1
   \       0xD0   0xB2C0             UXTB     R0,R0
   \       0xD2   0x2800             CMP      R0,#+0
   \       0xD4   0xD008             BEQ.N    ??UART_RxISR_16BIT_FIFOEN_9
   \       0xD6   0x2004             MOVS     R0,#+4
   \       0xD8   0x6821             LDR      R1,[R4, #+0]
   \       0xDA   0x6208             STR      R0,[R1, #+32]
   \       0xDC   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   \       0xE0   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0xE4   0xF8C4 0x008C      STR      R0,[R4, #+140]
   \                     ??UART_RxISR_16BIT_FIFOEN_9: (+1)
   \       0xE8   0xF8D4 0x008C      LDR      R0,[R4, #+140]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD005             BEQ.N    ??UART_RxISR_16BIT_FIFOEN_6
   \       0xF0   0x0020             MOVS     R0,R4
   \       0xF2   0x.... 0x....      BL       HAL_UART_ErrorCallback
   \       0xF6   0x2000             MOVS     R0,#+0
   \       0xF8   0xF8C4 0x008C      STR      R0,[R4, #+140]
   \                     ??UART_RxISR_16BIT_FIFOEN_6: (+1)
   \       0xFC   0xF8B4 0x005E      LDRH     R0,[R4, #+94]
   \      0x100   0x2800             CMP      R0,#+0
   \      0x102   0xD1A9             BNE.N    ??UART_RxISR_16BIT_FIFOEN_1
   \                     ??UART_RxISR_16BIT_FIFOEN_10: (+1)
   \      0x104   0x6820             LDR      R0,[R4, #+0]
   \      0x106   0xE850 0x1F00      LDREX    R1,[R0]
   \      0x10A   0xF431 0x7180      BICS     R1,R1,#0x100
   \      0x10E   0x6822             LDR      R2,[R4, #+0]
   \      0x110   0xE842 0x1000      STREX    R0,R1,[R2]
   \      0x114   0x2800             CMP      R0,#+0
   \      0x116   0xD1F5             BNE.N    ??UART_RxISR_16BIT_FIFOEN_10
   \                     ??UART_RxISR_16BIT_FIFOEN_11: (+1)
   \      0x118   0x6820             LDR      R0,[R4, #+0]
   \      0x11A   0x3008             ADDS     R0,R0,#+8
   \      0x11C   0xE850 0x1F00      LDREX    R1,[R0]
   \      0x120   0x....             LDR.N    R0,??DataTable17
   \      0x122   0x4001             ANDS     R1,R0,R1
   \      0x124   0x6820             LDR      R0,[R4, #+0]
   \      0x126   0xF110 0x0208      ADDS     R2,R0,#+8
   \      0x12A   0xE842 0x1000      STREX    R0,R1,[R2]
   \      0x12E   0x2800             CMP      R0,#+0
   \      0x130   0xD1F2             BNE.N    ??UART_RxISR_16BIT_FIFOEN_11
   \      0x132   0x2020             MOVS     R0,#+32
   \      0x134   0xF8C4 0x0088      STR      R0,[R4, #+136]
   \      0x138   0x2000             MOVS     R0,#+0
   \      0x13A   0x6720             STR      R0,[R4, #+112]
   \      0x13C   0x6EE0             LDR      R0,[R4, #+108]
   \      0x13E   0x2801             CMP      R0,#+1
   \      0x140   0xF43F 0xAF72      BEQ.W    ??UART_RxISR_16BIT_FIFOEN_2
   4610                  else
   4611                  {
   4612                    /* Standard reception API called */
   4613          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   4614                    /*Call registered Rx complete callback*/
   4615                    huart->RxCpltCallback(huart);
   4616          #else
   4617                    /*Call legacy weak Rx complete callback*/
   4618                    HAL_UART_RxCpltCallback(huart);
   \      0x144   0x0020             MOVS     R0,R4
   \      0x146   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   \      0x14A   0xE785             B.N      ??UART_RxISR_16BIT_FIFOEN_1
   4619          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   4620                  }
   4621                }
   4622              }
   4623          
   4624              /* When remaining number of bytes to receive is less than the RX FIFO
   4625              threshold, next incoming frames are processed as if FIFO mode was
   4626              disabled (i.e. one interrupt per received frame).
   4627              */
   4628              rxdatacount = huart->RxXferCount;
   \                     ??UART_RxISR_16BIT_FIFOEN_5: (+1)
   \      0x14C   0xF8B4 0x105E      LDRH     R1,[R4, #+94]
   4629              if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
   \      0x150   0x0008             MOVS     R0,R1
   \      0x152   0xB280             UXTH     R0,R0
   \      0x154   0x2800             CMP      R0,#+0
   \      0x156   0xD024             BEQ.N    ??UART_RxISR_16BIT_FIFOEN_12
   \      0x158   0xF8B4 0x0068      LDRH     R0,[R4, #+104]
   \      0x15C   0xB289             UXTH     R1,R1
   \      0x15E   0x4281             CMP      R1,R0
   \      0x160   0xD21F             BCS.N    ??UART_RxISR_16BIT_FIFOEN_12
   4630              {
   4631                /* Disable the UART RXFT interrupt*/
   4632                ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
   \                     ??UART_RxISR_16BIT_FIFOEN_13: (+1)
   \      0x162   0x6820             LDR      R0,[R4, #+0]
   \      0x164   0x3008             ADDS     R0,R0,#+8
   \      0x166   0xE850 0x1F00      LDREX    R1,[R0]
   \      0x16A   0xF031 0x5180      BICS     R1,R1,#0x10000000
   \      0x16E   0x6820             LDR      R0,[R4, #+0]
   \      0x170   0xF110 0x0208      ADDS     R2,R0,#+8
   \      0x174   0xE842 0x1000      STREX    R0,R1,[R2]
   \      0x178   0x2800             CMP      R0,#+0
   \      0x17A   0xD1F2             BNE.N    ??UART_RxISR_16BIT_FIFOEN_13
   4633          
   4634                /* Update the RxISR function pointer */
   4635                huart->RxISR = UART_RxISR_16BIT;
   \      0x17C   0x....             LDR.N    R0,??DataTable17_2
   \      0x17E   0x6720             STR      R0,[R4, #+112]
   4636          
   4637                /* Enable the UART Data Register Not Empty interrupt */
   4638                ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
   \                     ??UART_RxISR_16BIT_FIFOEN_14: (+1)
   \      0x180   0x6820             LDR      R0,[R4, #+0]
   \      0x182   0xE850 0x1F00      LDREX    R1,[R0]
   \      0x186   0xF051 0x0120      ORRS     R1,R1,#0x20
   \      0x18A   0x6822             LDR      R2,[R4, #+0]
   \      0x18C   0xE842 0x1000      STREX    R0,R1,[R2]
   \      0x190   0x2800             CMP      R0,#+0
   \      0x192   0xD1F5             BNE.N    ??UART_RxISR_16BIT_FIFOEN_14
   \      0x194   0xE005             B.N      ??UART_RxISR_16BIT_FIFOEN_12
   4639              }
   4640            }
   4641            else
   4642            {
   4643              /* Clear RXNE interrupt flag */
   4644              __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
   \                     ??UART_RxISR_16BIT_FIFOEN_0: (+1)
   \      0x196   0x6820             LDR      R0,[R4, #+0]
   \      0x198   0x6980             LDR      R0,[R0, #+24]
   \      0x19A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x19E   0x6821             LDR      R1,[R4, #+0]
   \      0x1A0   0x6188             STR      R0,[R1, #+24]
   4645            }
   4646          }
   \                     ??UART_RxISR_16BIT_FIFOEN_12: (+1)
   \      0x1A2   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     UART_TxISR_16BIT_FIFOEN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x....'....        DC32     UART_TxISR_8BIT_FIFOEN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x....'....        DC32     UART_TxISR_16BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x....'....        DC32     UART_TxISR_8BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \        0x0   0x5800'0C00        DC32     0x58000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \        0x0   0x....'....        DC32     UART_DMATransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \        0x0   0x....'....        DC32     UART_DMATxHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x....'....        DC32     UART_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0xEF7F'FFFE        DC32     0xef7ffffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0xEFFF'FFFE        DC32     0xeffffffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x....'....        DC32     UART_DMATxAbortCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \        0x0   0x....'....        DC32     UART_DMARxAbortCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \        0x0   0x....'....        DC32     UART_DMATxOnlyAbortCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \        0x0   0x....'....        DC32     UART_DMARxOnlyAbortCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \        0x0   0x1000'0001        DC32     0x10000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \        0x0   0x0400'0120        DC32     0x4000120

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \        0x0   0x....'....        DC32     UART_DMAAbortOnError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x4002'0010        DC32     0x40020010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x4002'0028        DC32     0x40020028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x4002'0040        DC32     0x40020040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0x4002'0058        DC32     0x40020058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \        0x0   0x4002'0070        DC32     0x40020070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \        0x0   0x4002'0088        DC32     0x40020088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \        0x0   0x4002'00A0        DC32     0x400200a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \        0x0   0x4002'00B8        DC32     0x400200b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \        0x0   0x4002'0410        DC32     0x40020410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \        0x0   0x4002'0428        DC32     0x40020428

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \        0x0   0x4002'0440        DC32     0x40020440

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \        0x0   0x4002'0458        DC32     0x40020458

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \        0x0   0x4002'0470        DC32     0x40020470

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \        0x0   0x4002'0488        DC32     0x40020488

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \        0x0   0x4002'04A0        DC32     0x400204a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_15:
   \        0x0   0x4002'04B8        DC32     0x400204b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_16:
   \        0x0   0x5800'0C00        DC32     0x58000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0xCFFF'69F3        DC32     0xcfff69f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x11FF'F4FF        DC32     0x11fff4ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0x4001'1000        DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \        0x0   0x5802'4454        DC32     0x58024454

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \        0x0   0x4000'4400        DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \        0x0   0x4000'4800        DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \        0x0   0x4000'4C00        DC32     0x40004c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \        0x0   0x4000'5000        DC32     0x40005000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \        0x0   0x4001'1400        DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \        0x0   0x4000'7800        DC32     0x40007800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \        0x0   0x4000'7C00        DC32     0x40007c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \        0x0   0x4001'1800        DC32     0x40011800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \        0x0   0x4001'1C00        DC32     0x40011c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \        0x0   0x5802'4458        DC32     0x58024458

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \        0x0   0x5802'4400        DC32     0x58024400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \        0x0   0x03D0'9000        DC32     0x3d09000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \        0x0   0x003D'0900        DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \        0x0   0x....'....        DC32     UARTPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \        0x0   0x000F'FD00        DC32     0xffd00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0xEFFF'FFFE        DC32     0xeffffffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \        0x0   0x....'....        DC32     UART_RxISR_8BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \        0x0   0x....'....        DC32     UART_RxISR_16BIT
   4647          
   4648          /**
   4649            * @}
   4650            */
   4651          
   4652          #endif /* HAL_UART_MODULE_ENABLED */
   4653          /**
   4654            * @}
   4655            */
   4656          
   4657          /**
   4658            * @}
   4659            */
   4660          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HalfDuplex_EnableReceiver
       0   HAL_HalfDuplex_EnableTransmitter
       8   HAL_HalfDuplex_Init
         8   -> HAL_UART_MspInit
         8   -> UART_AdvFeatureConfig
         8   -> UART_CheckIdleState
         8   -> UART_SetConfig
      16   HAL_LIN_Init
        16   -> HAL_UART_MspInit
        16   -> UART_AdvFeatureConfig
        16   -> UART_CheckIdleState
        16   -> UART_SetConfig
       0   HAL_LIN_SendBreak
       8   HAL_MultiProcessor_DisableMuteMode
         8   -> UART_CheckIdleState
       8   HAL_MultiProcessor_EnableMuteMode
         8   -> UART_CheckIdleState
       0   HAL_MultiProcessor_EnterMuteMode
      16   HAL_MultiProcessor_Init
        16   -> HAL_UART_MspInit
        16   -> UART_AdvFeatureConfig
        16   -> UART_CheckIdleState
        16   -> UART_SetConfig
       0   HAL_UARTEx_RxEventCallback
       8   HAL_UART_Abort
         8   -> HAL_DMA_Abort
         8   -> HAL_DMA_GetError
       0   HAL_UART_AbortCpltCallback
       8   HAL_UART_AbortReceive
         8   -> HAL_DMA_Abort
         8   -> HAL_DMA_GetError
       0   HAL_UART_AbortReceiveCpltCallback
       8   HAL_UART_AbortReceive_IT
         8   -- Indirect call
         8   -> HAL_DMA_Abort_IT
         8   -> HAL_UART_AbortReceiveCpltCallback
       8   HAL_UART_AbortTransmit
         8   -> HAL_DMA_Abort
         8   -> HAL_DMA_GetError
       0   HAL_UART_AbortTransmitCpltCallback
       8   HAL_UART_AbortTransmit_IT
         8   -- Indirect call
         8   -> HAL_DMA_Abort_IT
         8   -> HAL_UART_AbortTransmitCpltCallback
      16   HAL_UART_Abort_IT
        16   -> HAL_DMA_Abort_IT
        16   -> HAL_UART_AbortCpltCallback
       4   HAL_UART_DMAPause
       0   HAL_UART_DMAResume
      16   HAL_UART_DMAStop
        16   -> HAL_DMA_Abort
        16   -> HAL_DMA_GetError
        16   -> UART_EndRxTransfer
        16   -> UART_EndTxTransfer
       8   HAL_UART_DeInit
         8   -> HAL_UART_MspDeInit
       0   HAL_UART_DisableReceiverTimeout
       0   HAL_UART_EnableReceiverTimeout
       0   HAL_UART_ErrorCallback
       0   HAL_UART_GetError
       0   HAL_UART_GetState
      16   HAL_UART_IRQHandler
        16   -- Indirect call
        16   -> HAL_DMA_Abort
        16   -> HAL_DMA_Abort_IT
        16   -> HAL_UARTEx_RxEventCallback
        16   -> HAL_UARTEx_RxFifoFullCallback
        16   -> HAL_UARTEx_TxFifoEmptyCallback
        16   -> HAL_UARTEx_WakeupCallback
        16   -> HAL_UART_ErrorCallback
        16   -> UART_EndRxTransfer
        16   -> UART_EndTransmit_IT
       8   HAL_UART_Init
         8   -> HAL_UART_MspInit
         8   -> UART_AdvFeatureConfig
         8   -> UART_CheckIdleState
         8   -> UART_SetConfig
       0   HAL_UART_MspDeInit
       0   HAL_UART_MspInit
      32   HAL_UART_Receive
        32   -> HAL_GetTick
        32   -> UART_WaitOnFlagUntilTimeout
      16   HAL_UART_Receive_DMA
        16   -> UART_Start_Receive_DMA
      16   HAL_UART_Receive_IT
        16   -> UART_Start_Receive_IT
       0   HAL_UART_ReceiverTimeout_Config
       0   HAL_UART_RxCpltCallback
       0   HAL_UART_RxHalfCpltCallback
      32   HAL_UART_Transmit
        32   -> HAL_GetTick
        32   -> UART_WaitOnFlagUntilTimeout
       8   HAL_UART_Transmit_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_UART_Transmit_IT
       0   HAL_UART_TxCpltCallback
       0   HAL_UART_TxHalfCpltCallback
       0   UART_AdvFeatureConfig
      16   UART_CheckIdleState
        16   -> HAL_GetTick
        16   -> UART_WaitOnFlagUntilTimeout
       8   UART_DMAAbortOnError
         8   -> HAL_UART_ErrorCallback
      16   UART_DMAError
        16   -> HAL_UART_ErrorCallback
        16   -> UART_EndRxTransfer
        16   -> UART_EndTxTransfer
       8   UART_DMAReceiveCplt
         8   -> HAL_UARTEx_RxEventCallback
         8   -> HAL_UART_RxCpltCallback
       8   UART_DMARxAbortCallback
         8   -> HAL_UART_AbortCpltCallback
       8   UART_DMARxHalfCplt
         8   -> HAL_UARTEx_RxEventCallback
         8   -> HAL_UART_RxHalfCpltCallback
       8   UART_DMARxOnlyAbortCallback
         8   -> HAL_UART_AbortReceiveCpltCallback
       8   UART_DMATransmitCplt
         8   -> HAL_UART_TxCpltCallback
       8   UART_DMATxAbortCallback
         8   -> HAL_UART_AbortCpltCallback
       8   UART_DMATxHalfCplt
         8   -> HAL_UART_TxHalfCpltCallback
       8   UART_DMATxOnlyAbortCallback
         8   -> HAL_UART_AbortTransmitCpltCallback
       0   UART_EndRxTransfer
       8   UART_EndTransmit_IT
         8   -> HAL_UART_TxCpltCallback
       0   UART_EndTxTransfer
       8   UART_RxISR_16BIT
         8   -> HAL_UARTEx_RxEventCallback
         8   -> HAL_UART_RxCpltCallback
      32   UART_RxISR_16BIT_FIFOEN
        32   -> HAL_UARTEx_RxEventCallback
        32   -> HAL_UART_ErrorCallback
        32   -> HAL_UART_RxCpltCallback
       8   UART_RxISR_8BIT
         8   -> HAL_UARTEx_RxEventCallback
         8   -> HAL_UART_RxCpltCallback
      32   UART_RxISR_8BIT_FIFOEN
        32   -> HAL_UARTEx_RxEventCallback
        32   -> HAL_UART_ErrorCallback
        32   -> HAL_UART_RxCpltCallback
      40   UART_SetConfig
        40   -> HAL_RCCEx_GetD3PCLK1Freq
        40   -> HAL_RCCEx_GetPLL2ClockFreq
        40   -> HAL_RCCEx_GetPLL3ClockFreq
        40   -> HAL_RCC_GetPCLK1Freq
        40   -> HAL_RCC_GetPCLK2Freq
        40 __aeabi_uldivmod
       8   UART_Start_Receive_DMA
         8   -> HAL_DMA_Start_IT
       4   UART_Start_Receive_IT
       0   UART_TxISR_16BIT
       0   UART_TxISR_16BIT_FIFOEN
       0   UART_TxISR_8BIT
       0   UART_TxISR_8BIT_FIFOEN
      24   UART_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_16
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
      80  HAL_HalfDuplex_EnableReceiver
      80  HAL_HalfDuplex_EnableTransmitter
     132  HAL_HalfDuplex_Init
     170  HAL_LIN_Init
      52  HAL_LIN_SendBreak
      58  HAL_MultiProcessor_DisableMuteMode
      58  HAL_MultiProcessor_EnableMuteMode
      14  HAL_MultiProcessor_EnterMuteMode
     156  HAL_MultiProcessor_Init
       2  HAL_UARTEx_RxEventCallback
     306  HAL_UART_Abort
       2  HAL_UART_AbortCpltCallback
     192  HAL_UART_AbortReceive
       2  HAL_UART_AbortReceiveCpltCallback
     228  HAL_UART_AbortReceive_IT
     162  HAL_UART_AbortTransmit
       2  HAL_UART_AbortTransmitCpltCallback
     188  HAL_UART_AbortTransmit_IT
     356  HAL_UART_Abort_IT
     164  HAL_UART_DMAPause
     154  HAL_UART_DMAResume
     176  HAL_UART_DMAStop
      86  HAL_UART_DeInit
      78  HAL_UART_DisableReceiverTimeout
      78  HAL_UART_EnableReceiverTimeout
       2  HAL_UART_ErrorCallback
       6  HAL_UART_GetError
      14  HAL_UART_GetState
   1'004  HAL_UART_IRQHandler
     126  HAL_UART_Init
       2  HAL_UART_MspDeInit
       2  HAL_UART_MspInit
     302  HAL_UART_Receive
     102  HAL_UART_Receive_DMA
     102  HAL_UART_Receive_IT
      26  HAL_UART_ReceiverTimeout_Config
       2  HAL_UART_RxCpltCallback
       2  HAL_UART_RxHalfCpltCallback
     214  HAL_UART_Transmit
     194  HAL_UART_Transmit_DMA
     200  HAL_UART_Transmit_IT
       2  HAL_UART_TxCpltCallback
       2  HAL_UART_TxHalfCpltCallback
      24  UARTPrescTable
     218  UART_AdvFeatureConfig
     114  UART_CheckIdleState
      22  UART_DMAAbortOnError
      80  UART_DMAError
     146  UART_DMAReceiveCplt
      82  UART_DMARxAbortCallback
      30  UART_DMARxHalfCplt
      44  UART_DMARxOnlyAbortCallback
      74  UART_DMATransmitCplt
      90  UART_DMATxAbortCallback
      10  UART_DMATxHalfCplt
      42  UART_DMATxOnlyAbortCallback
      90  UART_EndRxTransfer
      38  UART_EndTransmit_IT
      54  UART_EndTxTransfer
     178  UART_RxISR_16BIT
     422  UART_RxISR_16BIT_FIFOEN
     178  UART_RxISR_8BIT
     422  UART_RxISR_8BIT_FIFOEN
   1'470  UART_SetConfig
     190  UART_Start_Receive_DMA
     346  UART_Start_Receive_IT
      88  UART_TxISR_16BIT
     116  UART_TxISR_16BIT_FIFOEN
      84  UART_TxISR_8BIT
     112  UART_TxISR_8BIT_FIFOEN
     230  UART_WaitOnFlagUntilTimeout

 
     24 bytes in section .rodata
 10'474 bytes in section .text
 
 10'452 bytes of CODE  memory (+ 22 bytes shared)
     24 bytes of CONST memory

Errors: none
Warnings: none
