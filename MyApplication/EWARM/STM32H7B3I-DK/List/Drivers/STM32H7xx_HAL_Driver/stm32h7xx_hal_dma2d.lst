###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         07/Feb/2022  20:39:45
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_dma2d.c
#        [UTF-8]
#    Command line      =
#        -f
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_dma2d.o.rsp
#        (D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_dma2d.c
#        -D USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver
#        -lA
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver
#        -o
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Core/Inc\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/App\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_dma2d.o.d
#    Locale            =  C
#    List file         =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_dma2d.lst
#    Object file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_dma2d.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_dma2d.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32h7xx_hal_dma2d.c
      4            * @author  MCD Application Team
      5            * @brief   DMA2D HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the DMA2D peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *           + Peripheral Control functions
     11            *           + Peripheral State and Errors functions
     12            *
     13            ******************************************************************************
     14            * @attention
     15            *
     16            * Copyright (c) 2017 STMicroelectronics.
     17            * All rights reserved.
     18            *
     19            * This software is licensed under terms that can be found in the LICENSE file
     20            * in the root directory of this software component.
     21            * If no LICENSE file comes with this software, it is provided AS-IS.
     22            *
     23            ******************************************************************************
     24            @verbatim
     25            ==============================================================================
     26                                  ##### How to use this driver #####
     27            ==============================================================================
     28              [..]
     29                (#) Program the required configuration through the following parameters:
     30                    the transfer mode, the output color mode and the output offset using
     31                    HAL_DMA2D_Init() function.
     32          
     33                (#) Program the required configuration through the following parameters:
     34                    the input color mode, the input color, the input alpha value, the alpha mode,
     35                    the red/blue swap mode, the inverted alpha mode and the input offset using
     36                    HAL_DMA2D_ConfigLayer() function for foreground or/and background layer.
     37          
     38               *** Polling mode IO operation ***
     39               =================================
     40              [..]
     41                 (#) Configure pdata parameter (explained hereafter), destination and data length
     42                     and enable the transfer using HAL_DMA2D_Start().
     43                 (#) Wait for end of transfer using HAL_DMA2D_PollForTransfer(), at this stage
     44                     user can specify the value of timeout according to his end application.
     45          
     46               *** Interrupt mode IO operation ***
     47               ===================================
     48               [..]
     49                 (#) Configure pdata parameter, destination and data length and enable
     50                     the transfer using HAL_DMA2D_Start_IT().
     51                 (#) Use HAL_DMA2D_IRQHandler() called under DMA2D_IRQHandler() interrupt subroutine.
     52                 (#) At the end of data transfer HAL_DMA2D_IRQHandler() function is executed and user can
     53                     add his own function by customization of function pointer XferCpltCallback (member
     54                     of DMA2D handle structure).
     55                 (#) In case of error, the HAL_DMA2D_IRQHandler() function calls the callback
     56                     XferErrorCallback.
     57          
     58                   -@-   In Register-to-Memory transfer mode, pdata parameter is the register
     59                         color, in Memory-to-memory or Memory-to-Memory with pixel format
     60                         conversion pdata is the source address.
     61          
     62                   -@-   Configure the foreground source address, the background source address,
     63                         the destination and data length then Enable the transfer using
     64                         HAL_DMA2D_BlendingStart() in polling mode and HAL_DMA2D_BlendingStart_IT()
     65                         in interrupt mode.
     66          
     67                   -@-   HAL_DMA2D_BlendingStart() and HAL_DMA2D_BlendingStart_IT() functions
     68                         are used if the memory to memory with blending transfer mode is selected.
     69          
     70                (#) Optionally, configure and enable the CLUT using HAL_DMA2D_CLUTLoad() in polling
     71                    mode or HAL_DMA2D_CLUTLoad_IT() in interrupt mode.
     72          
     73                (#) Optionally, configure the line watermark in using the API HAL_DMA2D_ProgramLineEvent().
     74          
     75                (#) Optionally, configure the dead time value in the AHB clock cycle inserted between two
     76                    consecutive accesses on the AHB master port in using the API HAL_DMA2D_ConfigDeadTime()
     77                    and enable/disable the functionality  with the APIs HAL_DMA2D_EnableDeadTime() or
     78                    HAL_DMA2D_DisableDeadTime().
     79          
     80                (#) The transfer can be suspended, resumed and aborted using the following
     81                    functions: HAL_DMA2D_Suspend(), HAL_DMA2D_Resume(), HAL_DMA2D_Abort().
     82          
     83                (#) The CLUT loading can be suspended, resumed and aborted using the following
     84                    functions: HAL_DMA2D_CLUTLoading_Suspend(), HAL_DMA2D_CLUTLoading_Resume(),
     85                    HAL_DMA2D_CLUTLoading_Abort().
     86          
     87                (#) To control the DMA2D state, use the following function: HAL_DMA2D_GetState().
     88          
     89                (#) To read the DMA2D error code, use the following function: HAL_DMA2D_GetError().
     90          
     91               *** DMA2D HAL driver macros list ***
     92               =============================================
     93               [..]
     94                 Below the list of most used macros in DMA2D HAL driver :
     95          
     96                (+) __HAL_DMA2D_ENABLE: Enable the DMA2D peripheral.
     97                (+) __HAL_DMA2D_GET_FLAG: Get the DMA2D pending flags.
     98                (+) __HAL_DMA2D_CLEAR_FLAG: Clear the DMA2D pending flags.
     99                (+) __HAL_DMA2D_ENABLE_IT: Enable the specified DMA2D interrupts.
    100                (+) __HAL_DMA2D_DISABLE_IT: Disable the specified DMA2D interrupts.
    101                (+) __HAL_DMA2D_GET_IT_SOURCE: Check whether the specified DMA2D interrupt is enabled or not.
    102          
    103               *** Callback registration ***
    104               ===================================
    105               [..]
    106                (#) The compilation define  USE_HAL_DMA2D_REGISTER_CALLBACKS when set to 1
    107                    allows the user to configure dynamically the driver callbacks.
    108                    Use function @ref HAL_DMA2D_RegisterCallback() to register a user callback.
    109          
    110                (#) Function @ref HAL_DMA2D_RegisterCallback() allows to register following callbacks:
    111                      (+) XferCpltCallback : callback for transfer complete.
    112                      (+) XferErrorCallback : callback for transfer error.
    113                      (+) LineEventCallback : callback for line event.
    114                      (+) CLUTLoadingCpltCallback : callback for CLUT loading completion.
    115                      (+) MspInitCallback    : DMA2D MspInit.
    116                      (+) MspDeInitCallback  : DMA2D MspDeInit.
    117                    This function takes as parameters the HAL peripheral handle, the Callback ID
    118                    and a pointer to the user callback function.
    119          
    120                (#) Use function @ref HAL_DMA2D_UnRegisterCallback() to reset a callback to the default
    121                    weak (surcharged) function.
    122                    @ref HAL_DMA2D_UnRegisterCallback() takes as parameters the HAL peripheral handle,
    123                    and the Callback ID.
    124                    This function allows to reset following callbacks:
    125                      (+) XferCpltCallback : callback for transfer complete.
    126                      (+) XferErrorCallback : callback for transfer error.
    127                      (+) LineEventCallback : callback for line event.
    128                      (+) CLUTLoadingCpltCallback : callback for CLUT loading completion.
    129                      (+) MspInitCallback    : DMA2D MspInit.
    130                      (+) MspDeInitCallback  : DMA2D MspDeInit.
    131          
    132                (#) By default, after the @ref HAL_DMA2D_Init and if the state is HAL_DMA2D_STATE_RESET
    133                    all callbacks are reset to the corresponding legacy weak (surcharged) functions:
    134                    examples @ref HAL_DMA2D_LineEventCallback(), @ref HAL_DMA2D_CLUTLoadingCpltCallback()
    135                    Exception done for MspInit and MspDeInit callbacks that are respectively
    136                    reset to the legacy weak (surcharged) functions in the @ref HAL_DMA2D_Init
    137                    and @ref HAL_DMA2D_DeInit only when these callbacks are null (not registered beforehand)
    138                    If not, MspInit or MspDeInit are not null, the @ref HAL_DMA2D_Init and @ref HAL_DMA2D_DeInit
    139                    keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
    140          
    141                    Exception as well for Transfer Completion and Transfer Error callbacks that are not defined
    142                    as weak (surcharged) functions. They must be defined by the user to be resorted to.
    143          
    144                    Callbacks can be registered/unregistered in READY state only.
    145                    Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
    146                    in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
    147                    during the Init/DeInit.
    148                    In that case first register the MspInit/MspDeInit user callbacks
    149                    using @ref HAL_DMA2D_RegisterCallback before calling @ref HAL_DMA2D_DeInit
    150                    or @ref HAL_DMA2D_Init function.
    151          
    152                    When The compilation define USE_HAL_DMA2D_REGISTER_CALLBACKS is set to 0 or
    153                    not defined, the callback registering feature is not available
    154                    and weak (surcharged) callbacks are used.
    155          
    156               [..]
    157                (@) You can refer to the DMA2D HAL driver header file for more useful macros
    158          
    159            @endverbatim
    160            ******************************************************************************
    161            */
    162          
    163          /* Includes ------------------------------------------------------------------*/
    164          #include "stm32h7xx_hal.h"
    165          
    166          #ifdef HAL_DMA2D_MODULE_ENABLED
    167          #if defined (DMA2D)
    168          
    169          /** @addtogroup STM32H7xx_HAL_Driver
    170            * @{
    171            */
    172          
    173          /** @defgroup DMA2D  DMA2D
    174            * @brief DMA2D HAL module driver
    175            * @{
    176            */
    177          
    178          /* Private types -------------------------------------------------------------*/
    179          /* Private define ------------------------------------------------------------*/
    180          /** @defgroup DMA2D_Private_Constants DMA2D Private Constants
    181            * @{
    182            */
    183          
    184          /** @defgroup DMA2D_TimeOut DMA2D Time Out
    185            * @{
    186            */
    187          #define DMA2D_TIMEOUT_ABORT           (1000U)  /*!<  1s  */
    188          #define DMA2D_TIMEOUT_SUSPEND         (1000U)  /*!<  1s  */
    189          /**
    190            * @}
    191            */
    192          
    193          /**
    194            * @}
    195            */
    196          
    197          /* Private variables ---------------------------------------------------------*/
    198          /* Private constants ---------------------------------------------------------*/
    199          /* Private macro -------------------------------------------------------------*/
    200          /* Private function prototypes -----------------------------------------------*/
    201          /** @addtogroup DMA2D_Private_Functions DMA2D Private Functions
    202            * @{
    203            */
    204          static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
    205                                      uint32_t Height);
    206          /**
    207            * @}
    208            */
    209          
    210          /* Private functions ---------------------------------------------------------*/
    211          /* Exported functions --------------------------------------------------------*/
    212          /** @defgroup DMA2D_Exported_Functions DMA2D Exported Functions
    213            * @{
    214            */
    215          
    216          /** @defgroup DMA2D_Exported_Functions_Group1 Initialization and de-initialization functions
    217            *  @brief   Initialization and Configuration functions
    218            *
    219          @verbatim
    220           ===============================================================================
    221                          ##### Initialization and Configuration functions #####
    222           ===============================================================================
    223              [..]  This section provides functions allowing to:
    224                (+) Initialize and configure the DMA2D
    225                (+) De-initialize the DMA2D
    226          
    227          @endverbatim
    228            * @{
    229            */
    230          
    231          /**
    232            * @brief  Initialize the DMA2D according to the specified
    233            *         parameters in the DMA2D_InitTypeDef and create the associated handle.
    234            * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
    235            *                 the configuration information for the DMA2D.
    236            * @retval HAL status
    237            */

   \                                 In section .text, align 2, keep-with-next
    238          HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
    239          {
   \                     HAL_DMA2D_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    240            /* Check the DMA2D peripheral state */
    241            if (hdma2d == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_DMA2D_Init_0
    242            {
    243              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE03C             B.N      ??HAL_DMA2D_Init_1
    244            }
    245          
    246            /* Check the parameters */
    247            assert_param(IS_DMA2D_ALL_INSTANCE(hdma2d->Instance));
    248            assert_param(IS_DMA2D_MODE(hdma2d->Init.Mode));
    249            assert_param(IS_DMA2D_CMODE(hdma2d->Init.ColorMode));
    250            assert_param(IS_DMA2D_OFFSET(hdma2d->Init.OutputOffset));
    251            assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->Init.AlphaInverted));
    252            assert_param(IS_DMA2D_RB_SWAP(hdma2d->Init.RedBlueSwap));
    253            assert_param(IS_DMA2D_LOM_MODE(hdma2d->Init.LineOffsetMode));
    254            assert_param(IS_DMA2D_BYTES_SWAP(hdma2d->Init.BytesSwap));
    255          
    256          #if (USE_HAL_DMA2D_REGISTER_CALLBACKS == 1)
    257            if (hdma2d->State == HAL_DMA2D_STATE_RESET)
    258            {
    259              /* Reset Callback pointers in HAL_DMA2D_STATE_RESET only */
    260              hdma2d->LineEventCallback       = HAL_DMA2D_LineEventCallback;
    261              hdma2d->CLUTLoadingCpltCallback = HAL_DMA2D_CLUTLoadingCpltCallback;
    262              if (hdma2d->MspInitCallback == NULL)
    263              {
    264                hdma2d->MspInitCallback = HAL_DMA2D_MspInit;
    265              }
    266          
    267              /* Init the low level hardware */
    268              hdma2d->MspInitCallback(hdma2d);
    269            }
    270          #else
    271            if (hdma2d->State == HAL_DMA2D_STATE_RESET)
   \                     ??HAL_DMA2D_Init_0: (+1)
   \        0xC   0xF894 0x0061      LDRB     R0,[R4, #+97]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD105             BNE.N    ??HAL_DMA2D_Init_2
    272            {
    273              /* Allocate lock resource and initialize it */
    274              hdma2d->Lock = HAL_UNLOCKED;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xF884 0x0060      STRB     R0,[R4, #+96]
    275              /* Init the low level hardware */
    276              HAL_DMA2D_MspInit(hdma2d);
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       HAL_DMA2D_MspInit
    277            }
    278          #endif /* (USE_HAL_DMA2D_REGISTER_CALLBACKS) */
    279          
    280            /* Change DMA2D peripheral state */
    281            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \                     ??HAL_DMA2D_Init_2: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xF884 0x0061      STRB     R0,[R4, #+97]
    282          
    283            /* DMA2D CR register configuration -------------------------------------------*/
    284            MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE | DMA2D_CR_LOM, hdma2d->Init.Mode | hdma2d->Init.LineOffsetMode);
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6801             LDR      R1,[R0, #+0]
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0x2E   0x4001             ANDS     R1,R0,R1
   \       0x30   0x6860             LDR      R0,[R4, #+4]
   \       0x32   0x4301             ORRS     R1,R0,R1
   \       0x34   0x69E0             LDR      R0,[R4, #+28]
   \       0x36   0x4301             ORRS     R1,R0,R1
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x6001             STR      R1,[R0, #+0]
    285          
    286            /* DMA2D OPFCCR register configuration ---------------------------------------*/
    287            MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM | DMA2D_OPFCCR_SB,
    288                       hdma2d->Init.ColorMode | hdma2d->Init.BytesSwap);
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6B41             LDR      R1,[R0, #+52]
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \       0x44   0x4001             ANDS     R1,R0,R1
   \       0x46   0x68A0             LDR      R0,[R4, #+8]
   \       0x48   0x4301             ORRS     R1,R0,R1
   \       0x4A   0x69A0             LDR      R0,[R4, #+24]
   \       0x4C   0x4301             ORRS     R1,R0,R1
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x6341             STR      R1,[R0, #+52]
    289          
    290            /* DMA2D OOR register configuration ------------------------------------------*/
    291            MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x6C01             LDR      R1,[R0, #+64]
   \       0x56   0x0C09             LSRS     R1,R1,#+16
   \       0x58   0x0409             LSLS     R1,R1,#+16
   \       0x5A   0x68E0             LDR      R0,[R4, #+12]
   \       0x5C   0x4301             ORRS     R1,R0,R1
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6401             STR      R1,[R0, #+64]
    292            /* DMA2D OPFCCR AI and RBS fields setting (Output Alpha Inversion)*/
    293            MODIFY_REG(hdma2d->Instance->OPFCCR, (DMA2D_OPFCCR_AI | DMA2D_OPFCCR_RBS),
    294                       ((hdma2d->Init.AlphaInverted << DMA2D_OPFCCR_AI_Pos) | \
    295                        (hdma2d->Init.RedBlueSwap << DMA2D_OPFCCR_RBS_Pos)));
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x6B40             LDR      R0,[R0, #+52]
   \       0x66   0xF430 0x1040      BICS     R0,R0,#0x300000
   \       0x6A   0x6921             LDR      R1,[R4, #+16]
   \       0x6C   0xEA50 0x5001      ORRS     R0,R0,R1, LSL #+20
   \       0x70   0x6961             LDR      R1,[R4, #+20]
   \       0x72   0xEA50 0x5041      ORRS     R0,R0,R1, LSL #+21
   \       0x76   0x6821             LDR      R1,[R4, #+0]
   \       0x78   0x6348             STR      R0,[R1, #+52]
    296          
    297          
    298            /* Update error code */
    299            hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0x6660             STR      R0,[R4, #+100]
    300          
    301            /* Initialize the DMA2D state*/
    302            hdma2d->State  = HAL_DMA2D_STATE_READY;
   \       0x7E   0x2001             MOVS     R0,#+1
   \       0x80   0xF884 0x0061      STRB     R0,[R4, #+97]
    303          
    304            return HAL_OK;
   \       0x84   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_Init_1: (+1)
   \       0x86   0xBD10             POP      {R4,PC}
    305          }
    306          
    307          /**
    308            * @brief  Deinitializes the DMA2D peripheral registers to their default reset
    309            *         values.
    310            * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
    311            *                 the configuration information for the DMA2D.
    312            * @retval None
    313            */
    314          

   \                                 In section .text, align 2, keep-with-next
    315          HAL_StatusTypeDef HAL_DMA2D_DeInit(DMA2D_HandleTypeDef *hdma2d)
    316          {
   \                     HAL_DMA2D_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    317          
    318            /* Check the DMA2D peripheral state */
    319            if (hdma2d == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_DMA2D_DeInit_0
    320            {
    321              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE048             B.N      ??HAL_DMA2D_DeInit_1
    322            }
    323          
    324            /* Before aborting any DMA2D transfer or CLUT loading, check
    325               first whether or not DMA2D clock is enabled */
    326            if (__HAL_RCC_DMA2D_IS_CLK_ENABLED())
   \                     ??HAL_DMA2D_DeInit_0: (+1)
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x06C0             LSLS     R0,R0,#+27
   \       0x14   0xD522             BPL.N    ??HAL_DMA2D_DeInit_2
    327            {
    328              /* Abort DMA2D transfer if any */
    329              if ((hdma2d->Instance->CR & DMA2D_CR_START) == DMA2D_CR_START)
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x07C0             LSLS     R0,R0,#+31
   \       0x1C   0xD506             BPL.N    ??HAL_DMA2D_DeInit_3
    330              {
    331                if (HAL_DMA2D_Abort(hdma2d) != HAL_OK)
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       HAL_DMA2D_Abort
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD019             BEQ.N    ??HAL_DMA2D_DeInit_2
    332                {
    333                  /* Issue when aborting DMA2D transfer */
    334                  return HAL_ERROR;
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE038             B.N      ??HAL_DMA2D_DeInit_1
    335                }
    336              }
    337              else
    338              {
    339                /* Abort background CLUT loading if any */
    340                if ((hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START) == DMA2D_BGPFCCR_START)
   \                     ??HAL_DMA2D_DeInit_3: (+1)
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6A40             LDR      R0,[R0, #+36]
   \       0x30   0x0680             LSLS     R0,R0,#+26
   \       0x32   0xD507             BPL.N    ??HAL_DMA2D_DeInit_4
    341                {
    342                  if (HAL_DMA2D_CLUTLoading_Abort(hdma2d, 0U) != HAL_OK)
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x.... 0x....      BL       HAL_DMA2D_CLUTLoading_Abort
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD00D             BEQ.N    ??HAL_DMA2D_DeInit_2
    343                  {
    344                    /* Issue when aborting background CLUT loading */
    345                    return HAL_ERROR;
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0xE02C             B.N      ??HAL_DMA2D_DeInit_1
    346                  }
    347                }
    348                else
    349                {
    350                  /* Abort foreground CLUT loading if any */
    351                  if ((hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START) == DMA2D_FGPFCCR_START)
   \                     ??HAL_DMA2D_DeInit_4: (+1)
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x69C0             LDR      R0,[R0, #+28]
   \       0x48   0x0680             LSLS     R0,R0,#+26
   \       0x4A   0xD507             BPL.N    ??HAL_DMA2D_DeInit_2
    352                  {
    353                    if (HAL_DMA2D_CLUTLoading_Abort(hdma2d, 1U) != HAL_OK)
   \       0x4C   0x2101             MOVS     R1,#+1
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x.... 0x....      BL       HAL_DMA2D_CLUTLoading_Abort
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD001             BEQ.N    ??HAL_DMA2D_DeInit_2
    354                    {
    355                      /* Issue when aborting foreground CLUT loading */
    356                      return HAL_ERROR;
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0xE020             B.N      ??HAL_DMA2D_DeInit_1
    357                    }
    358                  }
    359                }
    360              }
    361            }
    362          
    363            /* Reset DMA2D control registers*/
    364            hdma2d->Instance->CR       =    0U;
   \                     ??HAL_DMA2D_DeInit_2: (+1)
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x6821             LDR      R1,[R4, #+0]
   \       0x60   0x6008             STR      R0,[R1, #+0]
    365            hdma2d->Instance->IFCR     = 0x3FU;
   \       0x62   0x203F             MOVS     R0,#+63
   \       0x64   0x6821             LDR      R1,[R4, #+0]
   \       0x66   0x6088             STR      R0,[R1, #+8]
    366            hdma2d->Instance->FGOR     =    0U;
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0x6821             LDR      R1,[R4, #+0]
   \       0x6C   0x6108             STR      R0,[R1, #+16]
    367            hdma2d->Instance->BGOR     =    0U;
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0x6821             LDR      R1,[R4, #+0]
   \       0x72   0x6188             STR      R0,[R1, #+24]
    368            hdma2d->Instance->FGPFCCR  =    0U;
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x6821             LDR      R1,[R4, #+0]
   \       0x78   0x61C8             STR      R0,[R1, #+28]
    369            hdma2d->Instance->BGPFCCR  =    0U;
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0x6821             LDR      R1,[R4, #+0]
   \       0x7E   0x6248             STR      R0,[R1, #+36]
    370            hdma2d->Instance->OPFCCR   =    0U;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0x6821             LDR      R1,[R4, #+0]
   \       0x84   0x6348             STR      R0,[R1, #+52]
    371          
    372          #if (USE_HAL_DMA2D_REGISTER_CALLBACKS == 1)
    373          
    374            if (hdma2d->MspDeInitCallback == NULL)
    375            {
    376              hdma2d->MspDeInitCallback = HAL_DMA2D_MspDeInit;
    377            }
    378          
    379            /* DeInit the low level hardware */
    380            hdma2d->MspDeInitCallback(hdma2d);
    381          
    382          #else
    383            /* Carry on with de-initialization of low level hardware */
    384            HAL_DMA2D_MspDeInit(hdma2d);
   \       0x86   0x0020             MOVS     R0,R4
   \       0x88   0x.... 0x....      BL       HAL_DMA2D_MspDeInit
    385          #endif /* (USE_HAL_DMA2D_REGISTER_CALLBACKS) */
    386          
    387            /* Update error code */
    388            hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0x6660             STR      R0,[R4, #+100]
    389          
    390            /* Initialize the DMA2D state*/
    391            hdma2d->State  = HAL_DMA2D_STATE_RESET;
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0xF884 0x0061      STRB     R0,[R4, #+97]
    392          
    393            /* Release Lock */
    394            __HAL_UNLOCK(hdma2d);
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0xF884 0x0060      STRB     R0,[R4, #+96]
    395          
    396            return HAL_OK;
   \       0x9C   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_DeInit_1: (+1)
   \       0x9E   0xBD10             POP      {R4,PC}
    397          }
    398          
    399          /**
    400            * @brief  Initializes the DMA2D MSP.
    401            * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
    402            *                 the configuration information for the DMA2D.
    403            * @retval None
    404            */

   \                                 In section .text, align 2
    405          __weak void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef *hdma2d)
    406          {
    407            /* Prevent unused argument(s) compilation warning */
    408            UNUSED(hdma2d);
    409          
    410            /* NOTE : This function should not be modified; when the callback is needed,
    411                      the HAL_DMA2D_MspInit can be implemented in the user file.
    412             */
    413          }
   \                     HAL_DMA2D_MspInit: (+1)
   \        0x0   0x4770             BX       LR
    414          
    415          /**
    416            * @brief  DeInitializes the DMA2D MSP.
    417            * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
    418            *                 the configuration information for the DMA2D.
    419            * @retval None
    420            */

   \                                 In section .text, align 2
    421          __weak void HAL_DMA2D_MspDeInit(DMA2D_HandleTypeDef *hdma2d)
    422          {
    423            /* Prevent unused argument(s) compilation warning */
    424            UNUSED(hdma2d);
    425          
    426            /* NOTE : This function should not be modified; when the callback is needed,
    427                      the HAL_DMA2D_MspDeInit can be implemented in the user file.
    428             */
    429          }
   \                     HAL_DMA2D_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
    430          
    431          #if (USE_HAL_DMA2D_REGISTER_CALLBACKS == 1)
    432          /**
    433            * @brief  Register a User DMA2D Callback
    434            *         To be used instead of the weak (surcharged) predefined callback
    435            * @param hdma2d DMA2D handle
    436            * @param CallbackID ID of the callback to be registered
    437            *        This parameter can be one of the following values:
    438            *          @arg @ref HAL_DMA2D_TRANSFERCOMPLETE_CB_ID DMA2D transfer complete Callback ID
    439            *          @arg @ref HAL_DMA2D_TRANSFERERROR_CB_ID DMA2D transfer error Callback ID
    440            *          @arg @ref HAL_DMA2D_LINEEVENT_CB_ID DMA2D line event Callback ID
    441            *          @arg @ref HAL_DMA2D_CLUTLOADINGCPLT_CB_ID DMA2D CLUT loading completion Callback ID
    442            *          @arg @ref HAL_DMA2D_MSPINIT_CB_ID DMA2D MspInit callback ID
    443            *          @arg @ref HAL_DMA2D_MSPDEINIT_CB_ID DMA2D MspDeInit callback ID
    444            * @param pCallback pointer to the Callback function
    445            * @note No weak predefined callbacks are defined for HAL_DMA2D_TRANSFERCOMPLETE_CB_ID or HAL_DMA2D_TRANSFERERROR_CB_ID
    446            * @retval status
    447            */
    448          HAL_StatusTypeDef HAL_DMA2D_RegisterCallback(DMA2D_HandleTypeDef *hdma2d, HAL_DMA2D_CallbackIDTypeDef CallbackID,
    449                                                       pDMA2D_CallbackTypeDef pCallback)
    450          {
    451            HAL_StatusTypeDef status = HAL_OK;
    452          
    453            if (pCallback == NULL)
    454            {
    455              /* Update the error code */
    456              hdma2d->ErrorCode |= HAL_DMA2D_ERROR_INVALID_CALLBACK;
    457              return HAL_ERROR;
    458            }
    459            /* Process locked */
    460            __HAL_LOCK(hdma2d);
    461          
    462            if (HAL_DMA2D_STATE_READY == hdma2d->State)
    463            {
    464              switch (CallbackID)
    465              {
    466                case HAL_DMA2D_TRANSFERCOMPLETE_CB_ID :
    467                  hdma2d->XferCpltCallback = pCallback;
    468                  break;
    469          
    470                case HAL_DMA2D_TRANSFERERROR_CB_ID :
    471                  hdma2d->XferErrorCallback = pCallback;
    472                  break;
    473          
    474                case HAL_DMA2D_LINEEVENT_CB_ID :
    475                  hdma2d->LineEventCallback = pCallback;
    476                  break;
    477          
    478                case HAL_DMA2D_CLUTLOADINGCPLT_CB_ID :
    479                  hdma2d->CLUTLoadingCpltCallback = pCallback;
    480                  break;
    481          
    482                case HAL_DMA2D_MSPINIT_CB_ID :
    483                  hdma2d->MspInitCallback = pCallback;
    484                  break;
    485          
    486                case HAL_DMA2D_MSPDEINIT_CB_ID :
    487                  hdma2d->MspDeInitCallback = pCallback;
    488                  break;
    489          
    490                default :
    491                  /* Update the error code */
    492                  hdma2d->ErrorCode |= HAL_DMA2D_ERROR_INVALID_CALLBACK;
    493                  /* update return status */
    494                  status =  HAL_ERROR;
    495                  break;
    496              }
    497            }
    498            else if (HAL_DMA2D_STATE_RESET == hdma2d->State)
    499            {
    500              switch (CallbackID)
    501              {
    502                case HAL_DMA2D_MSPINIT_CB_ID :
    503                  hdma2d->MspInitCallback = pCallback;
    504                  break;
    505          
    506                case HAL_DMA2D_MSPDEINIT_CB_ID :
    507                  hdma2d->MspDeInitCallback = pCallback;
    508                  break;
    509          
    510                default :
    511                  /* Update the error code */
    512                  hdma2d->ErrorCode |= HAL_DMA2D_ERROR_INVALID_CALLBACK;
    513                  /* update return status */
    514                  status =  HAL_ERROR;
    515                  break;
    516              }
    517            }
    518            else
    519            {
    520              /* Update the error code */
    521              hdma2d->ErrorCode |= HAL_DMA2D_ERROR_INVALID_CALLBACK;
    522              /* update return status */
    523              status =  HAL_ERROR;
    524            }
    525          
    526            /* Release Lock */
    527            __HAL_UNLOCK(hdma2d);
    528            return status;
    529          }
    530          
    531          /**
    532            * @brief  Unregister a DMA2D Callback
    533            *         DMA2D Callback is redirected to the weak (surcharged) predefined callback
    534            * @param hdma2d DMA2D handle
    535            * @param CallbackID ID of the callback to be unregistered
    536            *        This parameter can be one of the following values:
    537            *          @arg @ref HAL_DMA2D_TRANSFERCOMPLETE_CB_ID DMA2D transfer complete Callback ID
    538            *          @arg @ref HAL_DMA2D_TRANSFERERROR_CB_ID DMA2D transfer error Callback ID
    539            *          @arg @ref HAL_DMA2D_LINEEVENT_CB_ID DMA2D line event Callback ID
    540            *          @arg @ref HAL_DMA2D_CLUTLOADINGCPLT_CB_ID DMA2D CLUT loading completion Callback ID
    541            *          @arg @ref HAL_DMA2D_MSPINIT_CB_ID DMA2D MspInit callback ID
    542            *          @arg @ref HAL_DMA2D_MSPDEINIT_CB_ID DMA2D MspDeInit callback ID
    543            * @note No weak predefined callbacks are defined for HAL_DMA2D_TRANSFERCOMPLETE_CB_ID or HAL_DMA2D_TRANSFERERROR_CB_ID
    544            * @retval status
    545            */
    546          HAL_StatusTypeDef HAL_DMA2D_UnRegisterCallback(DMA2D_HandleTypeDef *hdma2d, HAL_DMA2D_CallbackIDTypeDef CallbackID)
    547          {
    548            HAL_StatusTypeDef status = HAL_OK;
    549          
    550            /* Process locked */
    551            __HAL_LOCK(hdma2d);
    552          
    553            if (HAL_DMA2D_STATE_READY == hdma2d->State)
    554            {
    555              switch (CallbackID)
    556              {
    557                case HAL_DMA2D_TRANSFERCOMPLETE_CB_ID :
    558                  hdma2d->XferCpltCallback = NULL;
    559                  break;
    560          
    561                case HAL_DMA2D_TRANSFERERROR_CB_ID :
    562                  hdma2d->XferErrorCallback = NULL;
    563                  break;
    564          
    565                case HAL_DMA2D_LINEEVENT_CB_ID :
    566                  hdma2d->LineEventCallback = HAL_DMA2D_LineEventCallback;
    567                  break;
    568          
    569                case HAL_DMA2D_CLUTLOADINGCPLT_CB_ID :
    570                  hdma2d->CLUTLoadingCpltCallback = HAL_DMA2D_CLUTLoadingCpltCallback;
    571                  break;
    572          
    573                case HAL_DMA2D_MSPINIT_CB_ID :
    574                  hdma2d->MspInitCallback = HAL_DMA2D_MspInit; /* Legacy weak (surcharged) Msp Init */
    575                  break;
    576          
    577                case HAL_DMA2D_MSPDEINIT_CB_ID :
    578                  hdma2d->MspDeInitCallback = HAL_DMA2D_MspDeInit; /* Legacy weak (surcharged) Msp DeInit */
    579                  break;
    580          
    581                default :
    582                  /* Update the error code */
    583                  hdma2d->ErrorCode |= HAL_DMA2D_ERROR_INVALID_CALLBACK;
    584                  /* update return status */
    585                  status =  HAL_ERROR;
    586                  break;
    587              }
    588            }
    589            else if (HAL_DMA2D_STATE_RESET == hdma2d->State)
    590            {
    591              switch (CallbackID)
    592              {
    593                case HAL_DMA2D_MSPINIT_CB_ID :
    594                  hdma2d->MspInitCallback = HAL_DMA2D_MspInit;   /* Legacy weak (surcharged) Msp Init */
    595                  break;
    596          
    597                case HAL_DMA2D_MSPDEINIT_CB_ID :
    598                  hdma2d->MspDeInitCallback = HAL_DMA2D_MspDeInit;  /* Legacy weak (surcharged) Msp DeInit */
    599                  break;
    600          
    601                default :
    602                  /* Update the error code */
    603                  hdma2d->ErrorCode |= HAL_DMA2D_ERROR_INVALID_CALLBACK;
    604                  /* update return status */
    605                  status =  HAL_ERROR;
    606                  break;
    607              }
    608            }
    609            else
    610            {
    611              /* Update the error code */
    612              hdma2d->ErrorCode |= HAL_DMA2D_ERROR_INVALID_CALLBACK;
    613              /* update return status */
    614              status =  HAL_ERROR;
    615            }
    616          
    617            /* Release Lock */
    618            __HAL_UNLOCK(hdma2d);
    619            return status;
    620          }
    621          #endif /* USE_HAL_DMA2D_REGISTER_CALLBACKS */
    622          
    623          /**
    624            * @}
    625            */
    626          
    627          
    628          /** @defgroup DMA2D_Exported_Functions_Group2 IO operation functions
    629            *  @brief   IO operation functions
    630            *
    631          @verbatim
    632           ===============================================================================
    633                                #####  IO operation functions  #####
    634           ===============================================================================
    635              [..]  This section provides functions allowing to:
    636                (+) Configure the pdata, destination address and data size then
    637                    start the DMA2D transfer.
    638                (+) Configure the source for foreground and background, destination address
    639                    and data size then start a MultiBuffer DMA2D transfer.
    640                (+) Configure the pdata, destination address and data size then
    641                    start the DMA2D transfer with interrupt.
    642                (+) Configure the source for foreground and background, destination address
    643                    and data size then start a MultiBuffer DMA2D transfer with interrupt.
    644                (+) Abort DMA2D transfer.
    645                (+) Suspend DMA2D transfer.
    646                (+) Resume DMA2D transfer.
    647                (+) Enable CLUT transfer.
    648                (+) Configure CLUT loading then start transfer in polling mode.
    649                (+) Configure CLUT loading then start transfer in interrupt mode.
    650                (+) Abort DMA2D CLUT loading.
    651                (+) Suspend DMA2D CLUT loading.
    652                (+) Resume DMA2D CLUT loading.
    653                (+) Poll for transfer complete.
    654                (+) handle DMA2D interrupt request.
    655                (+) Transfer watermark callback.
    656                (+) CLUT Transfer Complete callback.
    657          
    658          
    659          @endverbatim
    660            * @{
    661            */
    662          
    663          /**
    664            * @brief  Start the DMA2D Transfer.
    665            * @param  hdma2d     Pointer to a DMA2D_HandleTypeDef structure that contains
    666            *                     the configuration information for the DMA2D.
    667            * @param  pdata      Configure the source memory Buffer address if
    668            *                     Memory-to-Memory or Memory-to-Memory with pixel format
    669            *                     conversion mode is selected, or configure
    670            *                     the color value if Register-to-Memory mode is selected.
    671            * @param  DstAddress The destination memory Buffer address.
    672            * @param  Width      The width of data to be transferred from source
    673            *                    to destination (expressed in number of pixels per line).
    674            * @param  Height     The height of data to be transferred from source to destination (expressed in number of lines).
    675            * @retval HAL status
    676            */

   \                                 In section .text, align 2, keep-with-next
    677          HAL_StatusTypeDef HAL_DMA2D_Start(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
    678                                            uint32_t Height)
    679          {
   \                     HAL_DMA2D_Start: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    680            /* Check the parameters */
    681            assert_param(IS_DMA2D_LINE(Height));
    682            assert_param(IS_DMA2D_PIXEL(Width));
    683          
    684            /* Process locked */
    685            __HAL_LOCK(hdma2d);
   \        0x4   0xF894 0x0060      LDRB     R0,[R4, #+96]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??HAL_DMA2D_Start_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE011             B.N      ??HAL_DMA2D_Start_1
   \                     ??HAL_DMA2D_Start_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xF884 0x0060      STRB     R0,[R4, #+96]
    686          
    687            /* Change DMA2D peripheral state */
    688            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0xF884 0x0061      STRB     R0,[R4, #+97]
    689          
    690            /* Configure the source, destination address and the data size */
    691            DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
   \       0x1C   0x9804             LDR      R0,[SP, #+16]
   \       0x1E   0x9000             STR      R0,[SP, #+0]
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       DMA2D_SetConfig
    692          
    693            /* Enable the Peripheral */
    694            __HAL_DMA2D_ENABLE(hdma2d);
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x2E   0x6821             LDR      R1,[R4, #+0]
   \       0x30   0x6008             STR      R0,[R1, #+0]
    695          
    696            return HAL_OK;
   \       0x32   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_Start_1: (+1)
   \       0x34   0xBD16             POP      {R1,R2,R4,PC}
    697          }
    698          
    699          /**
    700            * @brief  Start the DMA2D Transfer with interrupt enabled.
    701            * @param  hdma2d     Pointer to a DMA2D_HandleTypeDef structure that contains
    702            *                     the configuration information for the DMA2D.
    703            * @param  pdata      Configure the source memory Buffer address if
    704            *                     the Memory-to-Memory or Memory-to-Memory with pixel format
    705            *                     conversion mode is selected, or configure
    706            *                     the color value if Register-to-Memory mode is selected.
    707            * @param  DstAddress The destination memory Buffer address.
    708            * @param  Width      The width of data to be transferred from source
    709            *                    to destination (expressed in number of pixels per line).
    710            * @param  Height     The height of data to be transferred from source to destination (expressed in number of lines).
    711            * @retval HAL status
    712            */

   \                                 In section .text, align 2, keep-with-next
    713          HAL_StatusTypeDef HAL_DMA2D_Start_IT(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
    714                                               uint32_t Height)
    715          {
   \                     HAL_DMA2D_Start_IT: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    716            /* Check the parameters */
    717            assert_param(IS_DMA2D_LINE(Height));
    718            assert_param(IS_DMA2D_PIXEL(Width));
    719          
    720            /* Process locked */
    721            __HAL_LOCK(hdma2d);
   \        0x4   0xF894 0x0060      LDRB     R0,[R4, #+96]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??HAL_DMA2D_Start_IT_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE017             B.N      ??HAL_DMA2D_Start_IT_1
   \                     ??HAL_DMA2D_Start_IT_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xF884 0x0060      STRB     R0,[R4, #+96]
    722          
    723            /* Change DMA2D peripheral state */
    724            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0xF884 0x0061      STRB     R0,[R4, #+97]
    725          
    726            /* Configure the source, destination address and the data size */
    727            DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
   \       0x1C   0x9804             LDR      R0,[SP, #+16]
   \       0x1E   0x9000             STR      R0,[SP, #+0]
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       DMA2D_SetConfig
    728          
    729            /* Enable the transfer complete, transfer error and configuration error interrupts */
    730            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TC | DMA2D_IT_TE | DMA2D_IT_CE);
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0xF450 0x500C      ORRS     R0,R0,#0x2300
   \       0x2E   0x6821             LDR      R1,[R4, #+0]
   \       0x30   0x6008             STR      R0,[R1, #+0]
    731          
    732            /* Enable the Peripheral */
    733            __HAL_DMA2D_ENABLE(hdma2d);
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x3A   0x6821             LDR      R1,[R4, #+0]
   \       0x3C   0x6008             STR      R0,[R1, #+0]
    734          
    735            return HAL_OK;
   \       0x3E   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_Start_IT_1: (+1)
   \       0x40   0xBD16             POP      {R1,R2,R4,PC}
    736          }
    737          
    738          /**
    739            * @brief  Start the multi-source DMA2D Transfer.
    740            * @param  hdma2d      Pointer to a DMA2D_HandleTypeDef structure that contains
    741            *                      the configuration information for the DMA2D.
    742            * @param  SrcAddress1 The source memory Buffer address for the foreground layer.
    743            * @param  SrcAddress2 The source memory Buffer address for the background layer.
    744            * @param  DstAddress  The destination memory Buffer address.
    745            * @param  Width       The width of data to be transferred from source
    746            *                     to destination (expressed in number of pixels per line).
    747            * @param  Height      The height of data to be transferred from source to destination (expressed in number of lines).
    748            * @retval HAL status
    749            */

   \                                 In section .text, align 2, keep-with-next
    750          HAL_StatusTypeDef HAL_DMA2D_BlendingStart(DMA2D_HandleTypeDef *hdma2d, uint32_t SrcAddress1, uint32_t  SrcAddress2,
    751                                                    uint32_t DstAddress, uint32_t Width,  uint32_t Height)
    752          {
   \                     HAL_DMA2D_BlendingStart: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0010             MOVS     R0,R2
   \        0x6   0x001A             MOVS     R2,R3
    753            /* Check the parameters */
    754            assert_param(IS_DMA2D_LINE(Height));
    755            assert_param(IS_DMA2D_PIXEL(Width));
    756          
    757            /* Process locked */
    758            __HAL_LOCK(hdma2d);
   \        0x8   0xF894 0x3060      LDRB     R3,[R4, #+96]
   \        0xC   0x2B01             CMP      R3,#+1
   \        0xE   0xD101             BNE.N    ??HAL_DMA2D_BlendingStart_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE02B             B.N      ??HAL_DMA2D_BlendingStart_1
   \                     ??HAL_DMA2D_BlendingStart_0: (+1)
   \       0x14   0x2301             MOVS     R3,#+1
   \       0x16   0xF884 0x3060      STRB     R3,[R4, #+96]
    759          
    760            /* Change DMA2D peripheral state */
    761            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x1A   0x2302             MOVS     R3,#+2
   \       0x1C   0xF884 0x3061      STRB     R3,[R4, #+97]
   \       0x20   0x9B06             LDR      R3,[SP, #+24]
   \       0x22   0x9D07             LDR      R5,[SP, #+28]
    762          
    763            if (hdma2d->Init.Mode == DMA2D_M2M_BLEND_FG)
   \       0x24   0x6866             LDR      R6,[R4, #+4]
   \       0x26   0xF5B6 0x2F80      CMP      R6,#+262144
   \       0x2A   0xD107             BNE.N    ??HAL_DMA2D_BlendingStart_2
    764            {
    765              /*blending & fixed FG*/
    766              WRITE_REG(hdma2d->Instance->FGCOLR, SrcAddress1);
   \       0x2C   0x6826             LDR      R6,[R4, #+0]
   \       0x2E   0x6231             STR      R1,[R6, #+32]
    767              /* Configure the source, destination address and the data size */
    768              DMA2D_SetConfig(hdma2d, SrcAddress2, DstAddress, Width, Height);
   \       0x30   0x9500             STR      R5,[SP, #+0]
   \       0x32   0x0001             MOVS     R1,R0
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       DMA2D_SetConfig
   \       0x3A   0xE010             B.N      ??HAL_DMA2D_BlendingStart_3
    769            }
    770            else if (hdma2d->Init.Mode == DMA2D_M2M_BLEND_BG)
   \                     ??HAL_DMA2D_BlendingStart_2: (+1)
   \       0x3C   0x6866             LDR      R6,[R4, #+4]
   \       0x3E   0xF5B6 0x2FA0      CMP      R6,#+327680
   \       0x42   0xD106             BNE.N    ??HAL_DMA2D_BlendingStart_4
    771            {
    772              /*blending & fixed BG*/
    773              WRITE_REG(hdma2d->Instance->BGCOLR, SrcAddress2);
   \       0x44   0x6826             LDR      R6,[R4, #+0]
   \       0x46   0x62B0             STR      R0,[R6, #+40]
    774              /* Configure the source, destination address and the data size */
    775              DMA2D_SetConfig(hdma2d, SrcAddress1, DstAddress, Width, Height);
   \       0x48   0x9500             STR      R5,[SP, #+0]
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x.... 0x....      BL       DMA2D_SetConfig
   \       0x50   0xE005             B.N      ??HAL_DMA2D_BlendingStart_3
    776            }
    777            else
    778            {
    779              /* Configure DMA2D Stream source2 address */
    780              WRITE_REG(hdma2d->Instance->BGMAR, SrcAddress2);
   \                     ??HAL_DMA2D_BlendingStart_4: (+1)
   \       0x52   0x6826             LDR      R6,[R4, #+0]
   \       0x54   0x6170             STR      R0,[R6, #+20]
    781          
    782              /* Configure the source, destination address and the data size */
    783              DMA2D_SetConfig(hdma2d, SrcAddress1, DstAddress, Width, Height);
   \       0x56   0x9500             STR      R5,[SP, #+0]
   \       0x58   0x0020             MOVS     R0,R4
   \       0x5A   0x.... 0x....      BL       DMA2D_SetConfig
    784            }
    785          
    786            /* Enable the Peripheral */
    787            __HAL_DMA2D_ENABLE(hdma2d);
   \                     ??HAL_DMA2D_BlendingStart_3: (+1)
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6800             LDR      R0,[R0, #+0]
   \       0x62   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x66   0x6821             LDR      R1,[R4, #+0]
   \       0x68   0x6008             STR      R0,[R1, #+0]
    788          
    789            return HAL_OK;
   \       0x6A   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_BlendingStart_1: (+1)
   \       0x6C   0xBD76             POP      {R1,R2,R4-R6,PC}
    790          }
    791          
    792          /**
    793            * @brief  Start the multi-source DMA2D Transfer with interrupt enabled.
    794            * @param  hdma2d     Pointer to a DMA2D_HandleTypeDef structure that contains
    795            *                     the configuration information for the DMA2D.
    796            * @param  SrcAddress1 The source memory Buffer address for the foreground layer.
    797            * @param  SrcAddress2 The source memory Buffer address for the background layer.
    798            * @param  DstAddress  The destination memory Buffer address.
    799            * @param  Width       The width of data to be transferred from source
    800            *                     to destination (expressed in number of pixels per line).
    801            * @param  Height      The height of data to be transferred from source to destination (expressed in number of lines).
    802            * @retval HAL status
    803            */

   \                                 In section .text, align 2, keep-with-next
    804          HAL_StatusTypeDef HAL_DMA2D_BlendingStart_IT(DMA2D_HandleTypeDef *hdma2d, uint32_t SrcAddress1, uint32_t  SrcAddress2,
    805                                                       uint32_t DstAddress, uint32_t Width,  uint32_t Height)
    806          {
   \                     HAL_DMA2D_BlendingStart_IT: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0010             MOVS     R0,R2
   \        0x6   0x001A             MOVS     R2,R3
    807            /* Check the parameters */
    808            assert_param(IS_DMA2D_LINE(Height));
    809            assert_param(IS_DMA2D_PIXEL(Width));
    810          
    811            /* Process locked */
    812            __HAL_LOCK(hdma2d);
   \        0x8   0xF894 0x3060      LDRB     R3,[R4, #+96]
   \        0xC   0x2B01             CMP      R3,#+1
   \        0xE   0xD101             BNE.N    ??HAL_DMA2D_BlendingStart_IT_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE031             B.N      ??HAL_DMA2D_BlendingStart_IT_1
   \                     ??HAL_DMA2D_BlendingStart_IT_0: (+1)
   \       0x14   0x2301             MOVS     R3,#+1
   \       0x16   0xF884 0x3060      STRB     R3,[R4, #+96]
    813          
    814            /* Change DMA2D peripheral state */
    815            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x1A   0x2302             MOVS     R3,#+2
   \       0x1C   0xF884 0x3061      STRB     R3,[R4, #+97]
   \       0x20   0x9B06             LDR      R3,[SP, #+24]
   \       0x22   0x9D07             LDR      R5,[SP, #+28]
    816          
    817            if (hdma2d->Init.Mode == DMA2D_M2M_BLEND_FG)
   \       0x24   0x6866             LDR      R6,[R4, #+4]
   \       0x26   0xF5B6 0x2F80      CMP      R6,#+262144
   \       0x2A   0xD107             BNE.N    ??HAL_DMA2D_BlendingStart_IT_2
    818            {
    819              /*blending & fixed FG*/
    820              WRITE_REG(hdma2d->Instance->FGCOLR, SrcAddress1);
   \       0x2C   0x6826             LDR      R6,[R4, #+0]
   \       0x2E   0x6231             STR      R1,[R6, #+32]
    821              /* Configure the source, destination address and the data size */
    822              DMA2D_SetConfig(hdma2d, SrcAddress2, DstAddress, Width, Height);
   \       0x30   0x9500             STR      R5,[SP, #+0]
   \       0x32   0x0001             MOVS     R1,R0
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       DMA2D_SetConfig
   \       0x3A   0xE010             B.N      ??HAL_DMA2D_BlendingStart_IT_3
    823            }
    824            else if (hdma2d->Init.Mode == DMA2D_M2M_BLEND_BG)
   \                     ??HAL_DMA2D_BlendingStart_IT_2: (+1)
   \       0x3C   0x6866             LDR      R6,[R4, #+4]
   \       0x3E   0xF5B6 0x2FA0      CMP      R6,#+327680
   \       0x42   0xD106             BNE.N    ??HAL_DMA2D_BlendingStart_IT_4
    825            {
    826              /*blending & fixed BG*/
    827              WRITE_REG(hdma2d->Instance->BGCOLR, SrcAddress2);
   \       0x44   0x6826             LDR      R6,[R4, #+0]
   \       0x46   0x62B0             STR      R0,[R6, #+40]
    828              /* Configure the source, destination address and the data size */
    829              DMA2D_SetConfig(hdma2d, SrcAddress1, DstAddress, Width, Height);
   \       0x48   0x9500             STR      R5,[SP, #+0]
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x.... 0x....      BL       DMA2D_SetConfig
   \       0x50   0xE005             B.N      ??HAL_DMA2D_BlendingStart_IT_3
    830            }
    831            else
    832            {
    833              WRITE_REG(hdma2d->Instance->BGMAR, SrcAddress2);
   \                     ??HAL_DMA2D_BlendingStart_IT_4: (+1)
   \       0x52   0x6826             LDR      R6,[R4, #+0]
   \       0x54   0x6170             STR      R0,[R6, #+20]
    834          
    835              /* Configure the source, destination address and the data size */
    836              DMA2D_SetConfig(hdma2d, SrcAddress1, DstAddress, Width, Height);
   \       0x56   0x9500             STR      R5,[SP, #+0]
   \       0x58   0x0020             MOVS     R0,R4
   \       0x5A   0x.... 0x....      BL       DMA2D_SetConfig
    837            }
    838          
    839            /* Enable the transfer complete, transfer error and configuration error interrupts */
    840            __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TC | DMA2D_IT_TE | DMA2D_IT_CE);
   \                     ??HAL_DMA2D_BlendingStart_IT_3: (+1)
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6800             LDR      R0,[R0, #+0]
   \       0x62   0xF450 0x500C      ORRS     R0,R0,#0x2300
   \       0x66   0x6821             LDR      R1,[R4, #+0]
   \       0x68   0x6008             STR      R0,[R1, #+0]
    841          
    842            /* Enable the Peripheral */
    843            __HAL_DMA2D_ENABLE(hdma2d);
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6800             LDR      R0,[R0, #+0]
   \       0x6E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x72   0x6821             LDR      R1,[R4, #+0]
   \       0x74   0x6008             STR      R0,[R1, #+0]
    844          
    845            return HAL_OK;
   \       0x76   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_BlendingStart_IT_1: (+1)
   \       0x78   0xBD76             POP      {R1,R2,R4-R6,PC}
    846          }
    847          
    848          /**
    849            * @brief  Abort the DMA2D Transfer.
    850            * @param  hdma2d  pointer to a DMA2D_HandleTypeDef structure that contains
    851            *                  the configuration information for the DMA2D.
    852            * @retval HAL status
    853            */

   \                                 In section .text, align 2, keep-with-next
    854          HAL_StatusTypeDef HAL_DMA2D_Abort(DMA2D_HandleTypeDef *hdma2d)
    855          {
   \                     HAL_DMA2D_Abort: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    856            uint32_t tickstart;
    857          
    858            /* Abort the DMA2D transfer */
    859            /* START bit is reset to make sure not to set it again, in the event the HW clears it
    860               between the register read and the register write by the CPU (writing 0 has no
    861               effect on START bitvalue) */
    862            MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_ABORT | DMA2D_CR_START, DMA2D_CR_ABORT);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0xF030 0x0005      BICS     R0,R0,#0x5
   \        0xC   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x10   0x6821             LDR      R1,[R4, #+0]
   \       0x12   0x6008             STR      R0,[R1, #+0]
    863          
    864            /* Get tick */
    865            tickstart = HAL_GetTick();
   \       0x14   0x.... 0x....      BL       HAL_GetTick
   \       0x18   0x0005             MOVS     R5,R0
    866          
    867            /* Check if the DMA2D is effectively disabled */
    868            while ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
   \                     ??HAL_DMA2D_Abort_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x6800             LDR      R0,[R0, #+0]
   \       0x1E   0x07C0             LSLS     R0,R0,#+31
   \       0x20   0xD512             BPL.N    ??HAL_DMA2D_Abort_1
    869            {
    870              if ((HAL_GetTick() - tickstart) > DMA2D_TIMEOUT_ABORT)
   \       0x22   0x.... 0x....      BL       HAL_GetTick
   \       0x26   0x1B40             SUBS     R0,R0,R5
   \       0x28   0xF240 0x31E9      MOVW     R1,#+1001
   \       0x2C   0x4288             CMP      R0,R1
   \       0x2E   0xD3F4             BCC.N    ??HAL_DMA2D_Abort_0
    871              {
    872                /* Update error code */
    873                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   \       0x30   0x6E60             LDR      R0,[R4, #+100]
   \       0x32   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x36   0x6660             STR      R0,[R4, #+100]
    874          
    875                /* Change the DMA2D state */
    876                hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
   \       0x38   0x2003             MOVS     R0,#+3
   \       0x3A   0xF884 0x0061      STRB     R0,[R4, #+97]
    877          
    878                /* Process Unlocked */
    879                __HAL_UNLOCK(hdma2d);
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xF884 0x0060      STRB     R0,[R4, #+96]
    880          
    881                return HAL_TIMEOUT;
   \       0x44   0x2003             MOVS     R0,#+3
   \       0x46   0xE00C             B.N      ??HAL_DMA2D_Abort_2
    882              }
    883            }
    884          
    885            /* Disable the Transfer Complete, Transfer Error and Configuration Error interrupts */
    886            __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TC | DMA2D_IT_TE | DMA2D_IT_CE);
   \                     ??HAL_DMA2D_Abort_1: (+1)
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x6800             LDR      R0,[R0, #+0]
   \       0x4C   0xF430 0x500C      BICS     R0,R0,#0x2300
   \       0x50   0x6821             LDR      R1,[R4, #+0]
   \       0x52   0x6008             STR      R0,[R1, #+0]
    887          
    888            /* Change the DMA2D state*/
    889            hdma2d->State = HAL_DMA2D_STATE_READY;
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0xF884 0x0061      STRB     R0,[R4, #+97]
    890          
    891            /* Process Unlocked */
    892            __HAL_UNLOCK(hdma2d);
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xF884 0x0060      STRB     R0,[R4, #+96]
    893          
    894            return HAL_OK;
   \       0x60   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_Abort_2: (+1)
   \       0x62   0xBD32             POP      {R1,R4,R5,PC}
    895          }
    896          
    897          /**
    898            * @brief  Suspend the DMA2D Transfer.
    899            * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
    900            *                 the configuration information for the DMA2D.
    901            * @retval HAL status
    902            */

   \                                 In section .text, align 2, keep-with-next
    903          HAL_StatusTypeDef HAL_DMA2D_Suspend(DMA2D_HandleTypeDef *hdma2d)
    904          {
   \                     HAL_DMA2D_Suspend: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    905            uint32_t tickstart;
    906          
    907            /* Suspend the DMA2D transfer */
    908            /* START bit is reset to make sure not to set it again, in the event the HW clears it
    909               between the register read and the register write by the CPU (writing 0 has no
    910               effect on START bitvalue). */
    911            MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_SUSP | DMA2D_CR_START, DMA2D_CR_SUSP);
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x6821             LDR      R1,[R4, #+0]
   \        0x8   0x6809             LDR      R1,[R1, #+0]
   \        0xA   0xF360 0x0101      BFI      R1,R0,#+0,#+2
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x6001             STR      R1,[R0, #+0]
    912          
    913            /* Get tick */
    914            tickstart = HAL_GetTick();
   \       0x12   0x.... 0x....      BL       HAL_GetTick
   \       0x16   0x0005             MOVS     R5,R0
    915          
    916            /* Check if the DMA2D is effectively suspended */
    917            while ((hdma2d->Instance->CR & (DMA2D_CR_SUSP | DMA2D_CR_START)) == DMA2D_CR_START)
   \                     ??HAL_DMA2D_Suspend_0: (+1)
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0xF010 0x0003      ANDS     R0,R0,#0x3
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD10F             BNE.N    ??HAL_DMA2D_Suspend_1
    918            {
    919              if ((HAL_GetTick() - tickstart) > DMA2D_TIMEOUT_SUSPEND)
   \       0x24   0x.... 0x....      BL       HAL_GetTick
   \       0x28   0x1B40             SUBS     R0,R0,R5
   \       0x2A   0xF240 0x31E9      MOVW     R1,#+1001
   \       0x2E   0x4288             CMP      R0,R1
   \       0x30   0xD3F2             BCC.N    ??HAL_DMA2D_Suspend_0
    920              {
    921                /* Update error code */
    922                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   \       0x32   0x6E60             LDR      R0,[R4, #+100]
   \       0x34   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x38   0x6660             STR      R0,[R4, #+100]
    923          
    924                /* Change the DMA2D state */
    925                hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
   \       0x3A   0x2003             MOVS     R0,#+3
   \       0x3C   0xF884 0x0061      STRB     R0,[R4, #+97]
    926          
    927                return HAL_TIMEOUT;
   \       0x40   0x2003             MOVS     R0,#+3
   \       0x42   0xE00E             B.N      ??HAL_DMA2D_Suspend_2
    928              }
    929            }
    930          
    931            /* Check whether or not a transfer is actually suspended and change the DMA2D state accordingly */
    932            if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
   \                     ??HAL_DMA2D_Suspend_1: (+1)
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x6800             LDR      R0,[R0, #+0]
   \       0x48   0x07C0             LSLS     R0,R0,#+31
   \       0x4A   0xD503             BPL.N    ??HAL_DMA2D_Suspend_3
    933            {
    934              hdma2d->State = HAL_DMA2D_STATE_SUSPEND;
   \       0x4C   0x2005             MOVS     R0,#+5
   \       0x4E   0xF884 0x0061      STRB     R0,[R4, #+97]
   \       0x52   0xE005             B.N      ??HAL_DMA2D_Suspend_4
    935            }
    936            else
    937            {
    938              /* Make sure SUSP bit is cleared since it is meaningless
    939                 when no transfer is on-going */
    940              CLEAR_BIT(hdma2d->Instance->CR, DMA2D_CR_SUSP);
   \                     ??HAL_DMA2D_Suspend_3: (+1)
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6800             LDR      R0,[R0, #+0]
   \       0x58   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x5C   0x6821             LDR      R1,[R4, #+0]
   \       0x5E   0x6008             STR      R0,[R1, #+0]
    941            }
    942          
    943            return HAL_OK;
   \                     ??HAL_DMA2D_Suspend_4: (+1)
   \       0x60   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_Suspend_2: (+1)
   \       0x62   0xBD32             POP      {R1,R4,R5,PC}
    944          }
    945          
    946          /**
    947            * @brief  Resume the DMA2D Transfer.
    948            * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
    949            *                 the configuration information for the DMA2D.
    950            * @retval HAL status
    951            */

   \                                 In section .text, align 2, keep-with-next
    952          HAL_StatusTypeDef HAL_DMA2D_Resume(DMA2D_HandleTypeDef *hdma2d)
    953          {
    954            /* Check the SUSP and START bits */
    955            if ((hdma2d->Instance->CR & (DMA2D_CR_SUSP | DMA2D_CR_START)) == (DMA2D_CR_SUSP | DMA2D_CR_START))
   \                     HAL_DMA2D_Resume: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x6809             LDR      R1,[R1, #+0]
   \        0x4   0xF011 0x0103      ANDS     R1,R1,#0x3
   \        0x8   0x2903             CMP      R1,#+3
   \        0xA   0xD102             BNE.N    ??HAL_DMA2D_Resume_0
    956            {
    957              /* Ongoing transfer is suspended: change the DMA2D state before resuming */
    958              hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \        0xC   0x2102             MOVS     R1,#+2
   \        0xE   0xF880 0x1061      STRB     R1,[R0, #+97]
    959            }
    960          
    961            /* Resume the DMA2D transfer */
    962            /* START bit is reset to make sure not to set it again, in the event the HW clears it
    963               between the register read and the register write by the CPU (writing 0 has no
    964               effect on START bitvalue). */
    965            CLEAR_BIT(hdma2d->Instance->CR, (DMA2D_CR_SUSP | DMA2D_CR_START));
   \                     ??HAL_DMA2D_Resume_0: (+1)
   \       0x12   0x6801             LDR      R1,[R0, #+0]
   \       0x14   0x6809             LDR      R1,[R1, #+0]
   \       0x16   0x0889             LSRS     R1,R1,#+2
   \       0x18   0x0089             LSLS     R1,R1,#+2
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0x6001             STR      R1,[R0, #+0]
    966          
    967            return HAL_OK;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x4770             BX       LR
    968          }
    969          
    970          
    971          /**
    972            * @brief  Enable the DMA2D CLUT Transfer.
    973            * @param  hdma2d   Pointer to a DMA2D_HandleTypeDef structure that contains
    974            *                   the configuration information for the DMA2D.
    975            * @param  LayerIdx DMA2D Layer index.
    976            *                   This parameter can be one of the following values:
    977            *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
    978            * @retval HAL status
    979            */

   \                                 In section .text, align 2, keep-with-next
    980          HAL_StatusTypeDef HAL_DMA2D_EnableCLUT(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
    981          {
    982            /* Check the parameters */
    983            assert_param(IS_DMA2D_LAYER(LayerIdx));
    984          
    985            /* Process locked */
    986            __HAL_LOCK(hdma2d);
   \                     HAL_DMA2D_EnableCLUT: (+1)
   \        0x0   0xF890 0x2060      LDRB     R2,[R0, #+96]
   \        0x4   0x2A01             CMP      R2,#+1
   \        0x6   0xD101             BNE.N    ??HAL_DMA2D_EnableCLUT_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xE015             B.N      ??HAL_DMA2D_EnableCLUT_1
   \                     ??HAL_DMA2D_EnableCLUT_0: (+1)
   \        0xC   0x2201             MOVS     R2,#+1
   \        0xE   0xF880 0x2060      STRB     R2,[R0, #+96]
    987          
    988            /* Change DMA2D peripheral state */
    989            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x12   0x2202             MOVS     R2,#+2
   \       0x14   0xF880 0x2061      STRB     R2,[R0, #+97]
    990          
    991            if (LayerIdx == DMA2D_BACKGROUND_LAYER)
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xD106             BNE.N    ??HAL_DMA2D_EnableCLUT_2
    992            {
    993              /* Enable the background CLUT loading */
    994              SET_BIT(hdma2d->Instance->BGPFCCR, DMA2D_BGPFCCR_START);
   \       0x1C   0x6801             LDR      R1,[R0, #+0]
   \       0x1E   0x6A49             LDR      R1,[R1, #+36]
   \       0x20   0xF051 0x0120      ORRS     R1,R1,#0x20
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x6241             STR      R1,[R0, #+36]
   \       0x28   0xE005             B.N      ??HAL_DMA2D_EnableCLUT_3
    995            }
    996            else
    997            {
    998              /* Enable the foreground CLUT loading */
    999              SET_BIT(hdma2d->Instance->FGPFCCR, DMA2D_FGPFCCR_START);
   \                     ??HAL_DMA2D_EnableCLUT_2: (+1)
   \       0x2A   0x6801             LDR      R1,[R0, #+0]
   \       0x2C   0x69C9             LDR      R1,[R1, #+28]
   \       0x2E   0xF051 0x0120      ORRS     R1,R1,#0x20
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0x61C1             STR      R1,[R0, #+28]
   1000            }
   1001          
   1002            return HAL_OK;
   \                     ??HAL_DMA2D_EnableCLUT_3: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_EnableCLUT_1: (+1)
   \       0x38   0x4770             BX       LR
   1003          }
   1004          
   1005          /**
   1006            * @brief  Start DMA2D CLUT Loading.
   1007            * @param  hdma2d   Pointer to a DMA2D_HandleTypeDef structure that contains
   1008            *                   the configuration information for the DMA2D.
   1009            * @param  CLUTCfg  Pointer to a DMA2D_CLUTCfgTypeDef structure that contains
   1010            *                   the configuration information for the color look up table.
   1011            * @param  LayerIdx DMA2D Layer index.
   1012            *                   This parameter can be one of the following values:
   1013            *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
   1014            * @retval HAL status
   1015            */

   \                                 In section .text, align 2, keep-with-next
   1016          HAL_StatusTypeDef HAL_DMA2D_CLUTStartLoad(DMA2D_HandleTypeDef *hdma2d, DMA2D_CLUTCfgTypeDef *CLUTCfg, uint32_t LayerIdx)
   1017          {
   1018            /* Check the parameters */
   1019            assert_param(IS_DMA2D_LAYER(LayerIdx));
   1020            assert_param(IS_DMA2D_CLUT_CM(CLUTCfg->CLUTColorMode));
   1021            assert_param(IS_DMA2D_CLUT_SIZE(CLUTCfg->Size));
   1022          
   1023            /* Process locked */
   1024            __HAL_LOCK(hdma2d);
   \                     HAL_DMA2D_CLUTStartLoad: (+1)
   \        0x0   0xF890 0x3060      LDRB     R3,[R0, #+96]
   \        0x4   0x2B01             CMP      R3,#+1
   \        0x6   0xD101             BNE.N    ??HAL_DMA2D_CLUTStartLoad_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xE035             B.N      ??HAL_DMA2D_CLUTStartLoad_1
   \                     ??HAL_DMA2D_CLUTStartLoad_0: (+1)
   \        0xC   0x2301             MOVS     R3,#+1
   \        0xE   0xF880 0x3060      STRB     R3,[R0, #+96]
   1025          
   1026            /* Change DMA2D peripheral state */
   1027            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x12   0x2302             MOVS     R3,#+2
   \       0x14   0xF880 0x3061      STRB     R3,[R0, #+97]
   1028          
   1029            /* Configure the CLUT of the background DMA2D layer */
   1030            if (LayerIdx == DMA2D_BACKGROUND_LAYER)
   \       0x18   0x2A00             CMP      R2,#+0
   \       0x1A   0xD116             BNE.N    ??HAL_DMA2D_CLUTStartLoad_2
   1031            {
   1032              /* Write background CLUT memory address */
   1033              WRITE_REG(hdma2d->Instance->BGCMAR, (uint32_t)CLUTCfg->pCLUT);
   \       0x1C   0x680A             LDR      R2,[R1, #+0]
   \       0x1E   0x6803             LDR      R3,[R0, #+0]
   \       0x20   0x631A             STR      R2,[R3, #+48]
   1034          
   1035              /* Write background CLUT size and CLUT color mode */
   1036              MODIFY_REG(hdma2d->Instance->BGPFCCR, (DMA2D_BGPFCCR_CS | DMA2D_BGPFCCR_CCM),
   1037                         ((CLUTCfg->Size << DMA2D_BGPFCCR_CS_Pos) | (CLUTCfg->CLUTColorMode << DMA2D_BGPFCCR_CCM_Pos)));
   \       0x22   0x6802             LDR      R2,[R0, #+0]
   \       0x24   0x6A53             LDR      R3,[R2, #+36]
   \       0x26   0x.... 0x....      LDR.W    R2,??DataTable7_3
   \       0x2A   0x4013             ANDS     R3,R2,R3
   \       0x2C   0x688A             LDR      R2,[R1, #+8]
   \       0x2E   0xEA53 0x2302      ORRS     R3,R3,R2, LSL #+8
   \       0x32   0x6849             LDR      R1,[R1, #+4]
   \       0x34   0xEA53 0x1301      ORRS     R3,R3,R1, LSL #+4
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0x624B             STR      R3,[R1, #+36]
   1038          
   1039              /* Enable the CLUT loading for the background */
   1040              SET_BIT(hdma2d->Instance->BGPFCCR, DMA2D_BGPFCCR_START);
   \       0x3C   0x6801             LDR      R1,[R0, #+0]
   \       0x3E   0x6A49             LDR      R1,[R1, #+36]
   \       0x40   0xF051 0x0120      ORRS     R1,R1,#0x20
   \       0x44   0x6800             LDR      R0,[R0, #+0]
   \       0x46   0x6241             STR      R1,[R0, #+36]
   \       0x48   0xE015             B.N      ??HAL_DMA2D_CLUTStartLoad_3
   1041            }
   1042            /* Configure the CLUT of the foreground DMA2D layer */
   1043            else
   1044            {
   1045              /* Write foreground CLUT memory address */
   1046              WRITE_REG(hdma2d->Instance->FGCMAR, (uint32_t)CLUTCfg->pCLUT);
   \                     ??HAL_DMA2D_CLUTStartLoad_2: (+1)
   \       0x4A   0x680A             LDR      R2,[R1, #+0]
   \       0x4C   0x6803             LDR      R3,[R0, #+0]
   \       0x4E   0x62DA             STR      R2,[R3, #+44]
   1047          
   1048              /* Write foreground CLUT size and CLUT color mode */
   1049              MODIFY_REG(hdma2d->Instance->FGPFCCR, (DMA2D_FGPFCCR_CS | DMA2D_FGPFCCR_CCM),
   1050                         ((CLUTCfg->Size << DMA2D_FGPFCCR_CS_Pos) | (CLUTCfg->CLUTColorMode << DMA2D_FGPFCCR_CCM_Pos)));
   \       0x50   0x6802             LDR      R2,[R0, #+0]
   \       0x52   0x69D3             LDR      R3,[R2, #+28]
   \       0x54   0x.... 0x....      LDR.W    R2,??DataTable7_3
   \       0x58   0x4013             ANDS     R3,R2,R3
   \       0x5A   0x688A             LDR      R2,[R1, #+8]
   \       0x5C   0xEA53 0x2302      ORRS     R3,R3,R2, LSL #+8
   \       0x60   0x6849             LDR      R1,[R1, #+4]
   \       0x62   0xEA53 0x1301      ORRS     R3,R3,R1, LSL #+4
   \       0x66   0x6801             LDR      R1,[R0, #+0]
   \       0x68   0x61CB             STR      R3,[R1, #+28]
   1051          
   1052              /* Enable the CLUT loading for the foreground */
   1053              SET_BIT(hdma2d->Instance->FGPFCCR, DMA2D_FGPFCCR_START);
   \       0x6A   0x6801             LDR      R1,[R0, #+0]
   \       0x6C   0x69C9             LDR      R1,[R1, #+28]
   \       0x6E   0xF051 0x0120      ORRS     R1,R1,#0x20
   \       0x72   0x6800             LDR      R0,[R0, #+0]
   \       0x74   0x61C1             STR      R1,[R0, #+28]
   1054            }
   1055          
   1056            return HAL_OK;
   \                     ??HAL_DMA2D_CLUTStartLoad_3: (+1)
   \       0x76   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_CLUTStartLoad_1: (+1)
   \       0x78   0x4770             BX       LR
   1057          }
   1058          
   1059          /**
   1060            * @brief  Start DMA2D CLUT Loading with interrupt enabled.
   1061            * @param  hdma2d   Pointer to a DMA2D_HandleTypeDef structure that contains
   1062            *                   the configuration information for the DMA2D.
   1063            * @param  CLUTCfg  Pointer to a DMA2D_CLUTCfgTypeDef structure that contains
   1064            *                   the configuration information for the color look up table.
   1065            * @param  LayerIdx DMA2D Layer index.
   1066            *                   This parameter can be one of the following values:
   1067            *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
   1068            * @retval HAL status
   1069            */

   \                                 In section .text, align 2, keep-with-next
   1070          HAL_StatusTypeDef HAL_DMA2D_CLUTStartLoad_IT(DMA2D_HandleTypeDef *hdma2d, DMA2D_CLUTCfgTypeDef *CLUTCfg,
   1071                                                       uint32_t LayerIdx)
   1072          {
   1073            /* Check the parameters */
   1074            assert_param(IS_DMA2D_LAYER(LayerIdx));
   1075            assert_param(IS_DMA2D_CLUT_CM(CLUTCfg->CLUTColorMode));
   1076            assert_param(IS_DMA2D_CLUT_SIZE(CLUTCfg->Size));
   1077          
   1078            /* Process locked */
   1079            __HAL_LOCK(hdma2d);
   \                     HAL_DMA2D_CLUTStartLoad_IT: (+1)
   \        0x0   0xF890 0x3060      LDRB     R3,[R0, #+96]
   \        0x4   0x2B01             CMP      R3,#+1
   \        0x6   0xD101             BNE.N    ??HAL_DMA2D_CLUTStartLoad_IT_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xE041             B.N      ??HAL_DMA2D_CLUTStartLoad_IT_1
   \                     ??HAL_DMA2D_CLUTStartLoad_IT_0: (+1)
   \        0xC   0x2301             MOVS     R3,#+1
   \        0xE   0xF880 0x3060      STRB     R3,[R0, #+96]
   1080          
   1081            /* Change DMA2D peripheral state */
   1082            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x12   0x2302             MOVS     R3,#+2
   \       0x14   0xF880 0x3061      STRB     R3,[R0, #+97]
   1083          
   1084            /* Configure the CLUT of the background DMA2D layer */
   1085            if (LayerIdx == DMA2D_BACKGROUND_LAYER)
   \       0x18   0x2A00             CMP      R2,#+0
   \       0x1A   0xD11C             BNE.N    ??HAL_DMA2D_CLUTStartLoad_IT_2
   1086            {
   1087              /* Write background CLUT memory address */
   1088              WRITE_REG(hdma2d->Instance->BGCMAR, (uint32_t)CLUTCfg->pCLUT);
   \       0x1C   0x680A             LDR      R2,[R1, #+0]
   \       0x1E   0x6803             LDR      R3,[R0, #+0]
   \       0x20   0x631A             STR      R2,[R3, #+48]
   1089          
   1090              /* Write background CLUT size and CLUT color mode */
   1091              MODIFY_REG(hdma2d->Instance->BGPFCCR, (DMA2D_BGPFCCR_CS | DMA2D_BGPFCCR_CCM),
   1092                         ((CLUTCfg->Size << DMA2D_BGPFCCR_CS_Pos) | (CLUTCfg->CLUTColorMode << DMA2D_BGPFCCR_CCM_Pos)));
   \       0x22   0x6802             LDR      R2,[R0, #+0]
   \       0x24   0x6A53             LDR      R3,[R2, #+36]
   \       0x26   0x.... 0x....      LDR.W    R2,??DataTable7_3
   \       0x2A   0x4013             ANDS     R3,R2,R3
   \       0x2C   0x688A             LDR      R2,[R1, #+8]
   \       0x2E   0xEA53 0x2302      ORRS     R3,R3,R2, LSL #+8
   \       0x32   0x6849             LDR      R1,[R1, #+4]
   \       0x34   0xEA53 0x1301      ORRS     R3,R3,R1, LSL #+4
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0x624B             STR      R3,[R1, #+36]
   1093          
   1094              /* Enable the CLUT Transfer Complete, transfer Error, configuration Error and CLUT Access Error interrupts */
   1095              __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_CTC | DMA2D_IT_TE | DMA2D_IT_CE | DMA2D_IT_CAE);
   \       0x3C   0x6801             LDR      R1,[R0, #+0]
   \       0x3E   0x6809             LDR      R1,[R1, #+0]
   \       0x40   0xF451 0x5164      ORRS     R1,R1,#0x3900
   \       0x44   0x6802             LDR      R2,[R0, #+0]
   \       0x46   0x6011             STR      R1,[R2, #+0]
   1096          
   1097              /* Enable the CLUT loading for the background */
   1098              SET_BIT(hdma2d->Instance->BGPFCCR, DMA2D_BGPFCCR_START);
   \       0x48   0x6801             LDR      R1,[R0, #+0]
   \       0x4A   0x6A49             LDR      R1,[R1, #+36]
   \       0x4C   0xF051 0x0120      ORRS     R1,R1,#0x20
   \       0x50   0x6800             LDR      R0,[R0, #+0]
   \       0x52   0x6241             STR      R1,[R0, #+36]
   \       0x54   0xE01B             B.N      ??HAL_DMA2D_CLUTStartLoad_IT_3
   1099            }
   1100            /* Configure the CLUT of the foreground DMA2D layer */
   1101            else
   1102            {
   1103              /* Write foreground CLUT memory address */
   1104              WRITE_REG(hdma2d->Instance->FGCMAR, (uint32_t)CLUTCfg->pCLUT);
   \                     ??HAL_DMA2D_CLUTStartLoad_IT_2: (+1)
   \       0x56   0x680A             LDR      R2,[R1, #+0]
   \       0x58   0x6803             LDR      R3,[R0, #+0]
   \       0x5A   0x62DA             STR      R2,[R3, #+44]
   1105          
   1106              /* Write foreground CLUT size and CLUT color mode */
   1107              MODIFY_REG(hdma2d->Instance->FGPFCCR, (DMA2D_FGPFCCR_CS | DMA2D_FGPFCCR_CCM),
   1108                         ((CLUTCfg->Size << DMA2D_FGPFCCR_CS_Pos) | (CLUTCfg->CLUTColorMode << DMA2D_FGPFCCR_CCM_Pos)));
   \       0x5C   0x6802             LDR      R2,[R0, #+0]
   \       0x5E   0x69D3             LDR      R3,[R2, #+28]
   \       0x60   0x.... 0x....      LDR.W    R2,??DataTable7_3
   \       0x64   0x4013             ANDS     R3,R2,R3
   \       0x66   0x688A             LDR      R2,[R1, #+8]
   \       0x68   0xEA53 0x2302      ORRS     R3,R3,R2, LSL #+8
   \       0x6C   0x6849             LDR      R1,[R1, #+4]
   \       0x6E   0xEA53 0x1301      ORRS     R3,R3,R1, LSL #+4
   \       0x72   0x6801             LDR      R1,[R0, #+0]
   \       0x74   0x61CB             STR      R3,[R1, #+28]
   1109          
   1110              /* Enable the CLUT Transfer Complete, transfer Error, configuration Error and CLUT Access Error interrupts */
   1111              __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_CTC | DMA2D_IT_TE | DMA2D_IT_CE | DMA2D_IT_CAE);
   \       0x76   0x6801             LDR      R1,[R0, #+0]
   \       0x78   0x6809             LDR      R1,[R1, #+0]
   \       0x7A   0xF451 0x5164      ORRS     R1,R1,#0x3900
   \       0x7E   0x6802             LDR      R2,[R0, #+0]
   \       0x80   0x6011             STR      R1,[R2, #+0]
   1112          
   1113              /* Enable the CLUT loading for the foreground */
   1114              SET_BIT(hdma2d->Instance->FGPFCCR, DMA2D_FGPFCCR_START);
   \       0x82   0x6801             LDR      R1,[R0, #+0]
   \       0x84   0x69C9             LDR      R1,[R1, #+28]
   \       0x86   0xF051 0x0120      ORRS     R1,R1,#0x20
   \       0x8A   0x6800             LDR      R0,[R0, #+0]
   \       0x8C   0x61C1             STR      R1,[R0, #+28]
   1115            }
   1116          
   1117            return HAL_OK;
   \                     ??HAL_DMA2D_CLUTStartLoad_IT_3: (+1)
   \       0x8E   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_CLUTStartLoad_IT_1: (+1)
   \       0x90   0x4770             BX       LR
   1118          }
   1119          
   1120          /**
   1121            * @brief  Start DMA2D CLUT Loading.
   1122            * @param  hdma2d   Pointer to a DMA2D_HandleTypeDef structure that contains
   1123            *                   the configuration information for the DMA2D.
   1124            * @param  CLUTCfg  Pointer to a DMA2D_CLUTCfgTypeDef structure that contains
   1125            *                   the configuration information for the color look up table.
   1126            * @param  LayerIdx DMA2D Layer index.
   1127            *                   This parameter can be one of the following values:
   1128            *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
   1129            * @note API obsolete and maintained for compatibility with legacy. User is
   1130            *      invited to resort to HAL_DMA2D_CLUTStartLoad() instead to benefit from
   1131            *      code compactness, code size and improved heap usage.
   1132            * @retval HAL status
   1133            */

   \                                 In section .text, align 2, keep-with-next
   1134          HAL_StatusTypeDef HAL_DMA2D_CLUTLoad(DMA2D_HandleTypeDef *hdma2d, DMA2D_CLUTCfgTypeDef CLUTCfg, uint32_t LayerIdx)
   1135          {
   \                     HAL_DMA2D_CLUTLoad: (+1)
   \        0x0   0xB43E             PUSH     {R1-R5}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0xE9CD 0x1200      STRD     R1,R2,[SP, #+0]
   \        0x8   0x9302             STR      R3,[SP, #+8]
   \        0xA   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \        0xE   0x9A02             LDR      R2,[SP, #+8]
   1136            /* Check the parameters */
   1137            assert_param(IS_DMA2D_LAYER(LayerIdx));
   1138            assert_param(IS_DMA2D_CLUT_CM(CLUTCfg.CLUTColorMode));
   1139            assert_param(IS_DMA2D_CLUT_SIZE(CLUTCfg.Size));
   1140          
   1141            /* Process locked */
   1142            __HAL_LOCK(hdma2d);
   \       0x10   0xF894 0x3060      LDRB     R3,[R4, #+96]
   \       0x14   0x2B01             CMP      R3,#+1
   \       0x16   0xD101             BNE.N    ??HAL_DMA2D_CLUTLoad_0
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0xE030             B.N      ??HAL_DMA2D_CLUTLoad_1
   \                     ??HAL_DMA2D_CLUTLoad_0: (+1)
   \       0x1C   0x9B05             LDR      R3,[SP, #+20]
   \       0x1E   0x2501             MOVS     R5,#+1
   \       0x20   0xF884 0x5060      STRB     R5,[R4, #+96]
   1143          
   1144            /* Change DMA2D peripheral state */
   1145            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x24   0x2502             MOVS     R5,#+2
   \       0x26   0xF884 0x5061      STRB     R5,[R4, #+97]
   1146          
   1147            /* Configure the CLUT of the background DMA2D layer */
   1148            if (LayerIdx == DMA2D_BACKGROUND_LAYER)
   \       0x2A   0x2B00             CMP      R3,#+0
   \       0x2C   0xD113             BNE.N    ??HAL_DMA2D_CLUTLoad_2
   1149            {
   1150              /* Write background CLUT memory address */
   1151              WRITE_REG(hdma2d->Instance->BGCMAR, (uint32_t)CLUTCfg.pCLUT);
   \       0x2E   0x6823             LDR      R3,[R4, #+0]
   \       0x30   0x6318             STR      R0,[R3, #+48]
   1152          
   1153              /* Write background CLUT size and CLUT color mode */
   1154              MODIFY_REG(hdma2d->Instance->BGPFCCR, (DMA2D_BGPFCCR_CS | DMA2D_BGPFCCR_CCM),
   1155                         ((CLUTCfg.Size << DMA2D_BGPFCCR_CS_Pos) | (CLUTCfg.CLUTColorMode << DMA2D_BGPFCCR_CCM_Pos)));
   \       0x32   0x6823             LDR      R3,[R4, #+0]
   \       0x34   0x6A5D             LDR      R5,[R3, #+36]
   \       0x36   0x.... 0x....      LDR.W    R3,??DataTable7_3
   \       0x3A   0x401D             ANDS     R5,R3,R5
   \       0x3C   0xEA55 0x2502      ORRS     R5,R5,R2, LSL #+8
   \       0x40   0xEA55 0x1501      ORRS     R5,R5,R1, LSL #+4
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x6245             STR      R5,[R0, #+36]
   1156          
   1157              /* Enable the CLUT loading for the background */
   1158              SET_BIT(hdma2d->Instance->BGPFCCR, DMA2D_BGPFCCR_START);
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x6A40             LDR      R0,[R0, #+36]
   \       0x4C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x50   0x6821             LDR      R1,[R4, #+0]
   \       0x52   0x6248             STR      R0,[R1, #+36]
   \       0x54   0xE012             B.N      ??HAL_DMA2D_CLUTLoad_3
   1159            }
   1160            /* Configure the CLUT of the foreground DMA2D layer */
   1161            else
   1162            {
   1163              /* Write foreground CLUT memory address */
   1164              WRITE_REG(hdma2d->Instance->FGCMAR, (uint32_t)CLUTCfg.pCLUT);
   \                     ??HAL_DMA2D_CLUTLoad_2: (+1)
   \       0x56   0x6823             LDR      R3,[R4, #+0]
   \       0x58   0x62D8             STR      R0,[R3, #+44]
   1165          
   1166              /* Write foreground CLUT size and CLUT color mode */
   1167              MODIFY_REG(hdma2d->Instance->FGPFCCR, (DMA2D_FGPFCCR_CS | DMA2D_FGPFCCR_CCM),
   1168                         ((CLUTCfg.Size << DMA2D_FGPFCCR_CS_Pos) | (CLUTCfg.CLUTColorMode << DMA2D_FGPFCCR_CCM_Pos)));
   \       0x5A   0x6823             LDR      R3,[R4, #+0]
   \       0x5C   0x69DD             LDR      R5,[R3, #+28]
   \       0x5E   0x.... 0x....      LDR.W    R3,??DataTable7_3
   \       0x62   0x401D             ANDS     R5,R3,R5
   \       0x64   0xEA55 0x2502      ORRS     R5,R5,R2, LSL #+8
   \       0x68   0xEA55 0x1501      ORRS     R5,R5,R1, LSL #+4
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x61C5             STR      R5,[R0, #+28]
   1169          
   1170              /* Enable the CLUT loading for the foreground */
   1171              SET_BIT(hdma2d->Instance->FGPFCCR, DMA2D_FGPFCCR_START);
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x69C0             LDR      R0,[R0, #+28]
   \       0x74   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x78   0x6821             LDR      R1,[R4, #+0]
   \       0x7A   0x61C8             STR      R0,[R1, #+28]
   1172            }
   1173          
   1174            return HAL_OK;
   \                     ??HAL_DMA2D_CLUTLoad_3: (+1)
   \       0x7C   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_CLUTLoad_1: (+1)
   \       0x7E   0xBC3E             POP      {R1-R5}
   \       0x80   0x4770             BX       LR
   1175          }
   1176          
   1177          /**
   1178            * @brief  Start DMA2D CLUT Loading with interrupt enabled.
   1179            * @param  hdma2d   Pointer to a DMA2D_HandleTypeDef structure that contains
   1180            *                   the configuration information for the DMA2D.
   1181            * @param  CLUTCfg  Pointer to a DMA2D_CLUTCfgTypeDef structure that contains
   1182            *                   the configuration information for the color look up table.
   1183            * @param  LayerIdx DMA2D Layer index.
   1184            *                   This parameter can be one of the following values:
   1185            *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
   1186            * @note API obsolete and maintained for compatibility with legacy. User is
   1187            *      invited to resort to HAL_DMA2D_CLUTStartLoad_IT() instead to benefit
   1188            *      from code compactness, code size and improved heap usage.
   1189            * @retval HAL status
   1190            */

   \                                 In section .text, align 2, keep-with-next
   1191          HAL_StatusTypeDef HAL_DMA2D_CLUTLoad_IT(DMA2D_HandleTypeDef *hdma2d, DMA2D_CLUTCfgTypeDef CLUTCfg, uint32_t LayerIdx)
   1192          {
   \                     HAL_DMA2D_CLUTLoad_IT: (+1)
   \        0x0   0xB43E             PUSH     {R1-R5}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0xE9CD 0x1200      STRD     R1,R2,[SP, #+0]
   \        0x8   0x9302             STR      R3,[SP, #+8]
   \        0xA   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \        0xE   0x9A02             LDR      R2,[SP, #+8]
   1193            /* Check the parameters */
   1194            assert_param(IS_DMA2D_LAYER(LayerIdx));
   1195            assert_param(IS_DMA2D_CLUT_CM(CLUTCfg.CLUTColorMode));
   1196            assert_param(IS_DMA2D_CLUT_SIZE(CLUTCfg.Size));
   1197          
   1198            /* Process locked */
   1199            __HAL_LOCK(hdma2d);
   \       0x10   0xF894 0x3060      LDRB     R3,[R4, #+96]
   \       0x14   0x2B01             CMP      R3,#+1
   \       0x16   0xD101             BNE.N    ??HAL_DMA2D_CLUTLoad_IT_0
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0xE03C             B.N      ??HAL_DMA2D_CLUTLoad_IT_1
   \                     ??HAL_DMA2D_CLUTLoad_IT_0: (+1)
   \       0x1C   0x9B05             LDR      R3,[SP, #+20]
   \       0x1E   0x2501             MOVS     R5,#+1
   \       0x20   0xF884 0x5060      STRB     R5,[R4, #+96]
   1200          
   1201            /* Change DMA2D peripheral state */
   1202            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x24   0x2502             MOVS     R5,#+2
   \       0x26   0xF884 0x5061      STRB     R5,[R4, #+97]
   1203          
   1204            /* Configure the CLUT of the background DMA2D layer */
   1205            if (LayerIdx == DMA2D_BACKGROUND_LAYER)
   \       0x2A   0x2B00             CMP      R3,#+0
   \       0x2C   0xD119             BNE.N    ??HAL_DMA2D_CLUTLoad_IT_2
   1206            {
   1207              /* Write background CLUT memory address */
   1208              WRITE_REG(hdma2d->Instance->BGCMAR, (uint32_t)CLUTCfg.pCLUT);
   \       0x2E   0x6823             LDR      R3,[R4, #+0]
   \       0x30   0x6318             STR      R0,[R3, #+48]
   1209          
   1210              /* Write background CLUT size and CLUT color mode */
   1211              MODIFY_REG(hdma2d->Instance->BGPFCCR, (DMA2D_BGPFCCR_CS | DMA2D_BGPFCCR_CCM),
   1212                         ((CLUTCfg.Size << DMA2D_BGPFCCR_CS_Pos) | (CLUTCfg.CLUTColorMode << DMA2D_BGPFCCR_CCM_Pos)));
   \       0x32   0x6823             LDR      R3,[R4, #+0]
   \       0x34   0x6A5D             LDR      R5,[R3, #+36]
   \       0x36   0x.... 0x....      LDR.W    R3,??DataTable7_3
   \       0x3A   0x401D             ANDS     R5,R3,R5
   \       0x3C   0xEA55 0x2502      ORRS     R5,R5,R2, LSL #+8
   \       0x40   0xEA55 0x1501      ORRS     R5,R5,R1, LSL #+4
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x6245             STR      R5,[R0, #+36]
   1213          
   1214              /* Enable the CLUT Transfer Complete, transfer Error, configuration Error and CLUT Access Error interrupts */
   1215              __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_CTC | DMA2D_IT_TE | DMA2D_IT_CE | DMA2D_IT_CAE);
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x6800             LDR      R0,[R0, #+0]
   \       0x4C   0xF450 0x5064      ORRS     R0,R0,#0x3900
   \       0x50   0x6821             LDR      R1,[R4, #+0]
   \       0x52   0x6008             STR      R0,[R1, #+0]
   1216          
   1217              /* Enable the CLUT loading for the background */
   1218              SET_BIT(hdma2d->Instance->BGPFCCR, DMA2D_BGPFCCR_START);
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6A40             LDR      R0,[R0, #+36]
   \       0x58   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x5C   0x6821             LDR      R1,[R4, #+0]
   \       0x5E   0x6248             STR      R0,[R1, #+36]
   \       0x60   0xE018             B.N      ??HAL_DMA2D_CLUTLoad_IT_3
   1219            }
   1220            /* Configure the CLUT of the foreground DMA2D layer */
   1221            else
   1222            {
   1223              /* Write foreground CLUT memory address */
   1224              WRITE_REG(hdma2d->Instance->FGCMAR, (uint32_t)CLUTCfg.pCLUT);
   \                     ??HAL_DMA2D_CLUTLoad_IT_2: (+1)
   \       0x62   0x6823             LDR      R3,[R4, #+0]
   \       0x64   0x62D8             STR      R0,[R3, #+44]
   1225          
   1226              /* Write foreground CLUT size and CLUT color mode */
   1227              MODIFY_REG(hdma2d->Instance->FGPFCCR, (DMA2D_FGPFCCR_CS | DMA2D_FGPFCCR_CCM),
   1228                         ((CLUTCfg.Size << DMA2D_FGPFCCR_CS_Pos) | (CLUTCfg.CLUTColorMode << DMA2D_FGPFCCR_CCM_Pos)));
   \       0x66   0x6823             LDR      R3,[R4, #+0]
   \       0x68   0x69DD             LDR      R5,[R3, #+28]
   \       0x6A   0x.... 0x....      LDR.W    R3,??DataTable7_3
   \       0x6E   0x401D             ANDS     R5,R3,R5
   \       0x70   0xEA55 0x2502      ORRS     R5,R5,R2, LSL #+8
   \       0x74   0xEA55 0x1501      ORRS     R5,R5,R1, LSL #+4
   \       0x78   0x6820             LDR      R0,[R4, #+0]
   \       0x7A   0x61C5             STR      R5,[R0, #+28]
   1229          
   1230              /* Enable the CLUT Transfer Complete, transfer Error, configuration Error and CLUT Access Error interrupts */
   1231              __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_CTC | DMA2D_IT_TE | DMA2D_IT_CE | DMA2D_IT_CAE);
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x6800             LDR      R0,[R0, #+0]
   \       0x80   0xF450 0x5064      ORRS     R0,R0,#0x3900
   \       0x84   0x6821             LDR      R1,[R4, #+0]
   \       0x86   0x6008             STR      R0,[R1, #+0]
   1232          
   1233              /* Enable the CLUT loading for the foreground */
   1234              SET_BIT(hdma2d->Instance->FGPFCCR, DMA2D_FGPFCCR_START);
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x69C0             LDR      R0,[R0, #+28]
   \       0x8C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x90   0x6821             LDR      R1,[R4, #+0]
   \       0x92   0x61C8             STR      R0,[R1, #+28]
   1235            }
   1236          
   1237            return HAL_OK;
   \                     ??HAL_DMA2D_CLUTLoad_IT_3: (+1)
   \       0x94   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_CLUTLoad_IT_1: (+1)
   \       0x96   0xBC3E             POP      {R1-R5}
   \       0x98   0x4770             BX       LR
   1238          }
   1239          
   1240          /**
   1241            * @brief  Abort the DMA2D CLUT loading.
   1242            * @param  hdma2d  Pointer to a DMA2D_HandleTypeDef structure that contains
   1243            *                  the configuration information for the DMA2D.
   1244            * @param  LayerIdx DMA2D Layer index.
   1245            *                   This parameter can be one of the following values:
   1246            *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
   1247            * @retval HAL status
   1248            */

   \                                 In section .text, align 2, keep-with-next
   1249          HAL_StatusTypeDef HAL_DMA2D_CLUTLoading_Abort(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
   1250          {
   \                     HAL_DMA2D_CLUTLoading_Abort: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1251            uint32_t tickstart;
   1252            const __IO uint32_t *reg =  &(hdma2d->Instance->BGPFCCR);  /* by default, point at background register */
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0xF110 0x0524      ADDS     R5,R0,#+36
   1253          
   1254            /* Abort the CLUT loading */
   1255            SET_BIT(hdma2d->Instance->CR, DMA2D_CR_ABORT);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x12   0x6822             LDR      R2,[R4, #+0]
   \       0x14   0x6010             STR      R0,[R2, #+0]
   1256          
   1257            /* If foreground CLUT loading is considered, update local variables */
   1258            if (LayerIdx == DMA2D_FOREGROUND_LAYER)
   \       0x16   0x2901             CMP      R1,#+1
   \       0x18   0xD102             BNE.N    ??HAL_DMA2D_CLUTLoading_Abort_0
   1259            {
   1260              reg  = &(hdma2d->Instance->FGPFCCR);
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0xF110 0x051C      ADDS     R5,R0,#+28
   1261            }
   1262          
   1263          
   1264            /* Get tick */
   1265            tickstart = HAL_GetTick();
   \                     ??HAL_DMA2D_CLUTLoading_Abort_0: (+1)
   \       0x20   0x.... 0x....      BL       HAL_GetTick
   \       0x24   0x0006             MOVS     R6,R0
   1266          
   1267            /* Check if the CLUT loading is aborted */
   1268            while ((*reg & DMA2D_BGPFCCR_START) != 0U)
   \                     ??HAL_DMA2D_CLUTLoading_Abort_1: (+1)
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0x0680             LSLS     R0,R0,#+26
   \       0x2A   0xD512             BPL.N    ??HAL_DMA2D_CLUTLoading_Abort_2
   1269            {
   1270              if ((HAL_GetTick() - tickstart) > DMA2D_TIMEOUT_ABORT)
   \       0x2C   0x.... 0x....      BL       HAL_GetTick
   \       0x30   0x1B80             SUBS     R0,R0,R6
   \       0x32   0xF240 0x31E9      MOVW     R1,#+1001
   \       0x36   0x4288             CMP      R0,R1
   \       0x38   0xD3F5             BCC.N    ??HAL_DMA2D_CLUTLoading_Abort_1
   1271              {
   1272                /* Update error code */
   1273                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   \       0x3A   0x6E60             LDR      R0,[R4, #+100]
   \       0x3C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x40   0x6660             STR      R0,[R4, #+100]
   1274          
   1275                /* Change the DMA2D state */
   1276                hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
   \       0x42   0x2003             MOVS     R0,#+3
   \       0x44   0xF884 0x0061      STRB     R0,[R4, #+97]
   1277          
   1278                /* Process Unlocked */
   1279                __HAL_UNLOCK(hdma2d);
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xF884 0x0060      STRB     R0,[R4, #+96]
   1280          
   1281                return HAL_TIMEOUT;
   \       0x4E   0x2003             MOVS     R0,#+3
   \       0x50   0xE00C             B.N      ??HAL_DMA2D_CLUTLoading_Abort_3
   1282              }
   1283            }
   1284          
   1285            /* Disable the CLUT Transfer Complete, Transfer Error, Configuration Error and CLUT Access Error interrupts */
   1286            __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CTC | DMA2D_IT_TE | DMA2D_IT_CE | DMA2D_IT_CAE);
   \                     ??HAL_DMA2D_CLUTLoading_Abort_2: (+1)
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x6800             LDR      R0,[R0, #+0]
   \       0x56   0xF430 0x5064      BICS     R0,R0,#0x3900
   \       0x5A   0x6821             LDR      R1,[R4, #+0]
   \       0x5C   0x6008             STR      R0,[R1, #+0]
   1287          
   1288            /* Change the DMA2D state*/
   1289            hdma2d->State = HAL_DMA2D_STATE_READY;
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0xF884 0x0061      STRB     R0,[R4, #+97]
   1290          
   1291            /* Process Unlocked */
   1292            __HAL_UNLOCK(hdma2d);
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xF884 0x0060      STRB     R0,[R4, #+96]
   1293          
   1294            return HAL_OK;
   \       0x6A   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_CLUTLoading_Abort_3: (+1)
   \       0x6C   0xBD70             POP      {R4-R6,PC}
   1295          }
   1296          
   1297          /**
   1298            * @brief  Suspend the DMA2D CLUT loading.
   1299            * @param  hdma2d Pointer to a DMA2D_HandleTypeDef structure that contains
   1300            *                 the configuration information for the DMA2D.
   1301            * @param  LayerIdx DMA2D Layer index.
   1302            *                   This parameter can be one of the following values:
   1303            *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
   1304            * @retval HAL status
   1305            */

   \                                 In section .text, align 2, keep-with-next
   1306          HAL_StatusTypeDef HAL_DMA2D_CLUTLoading_Suspend(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
   1307          {
   \                     HAL_DMA2D_CLUTLoading_Suspend: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1308            uint32_t tickstart;
   1309            uint32_t loadsuspended;
   1310            const __IO uint32_t *reg =  &(hdma2d->Instance->BGPFCCR);  /* by default, point at background register */
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0xF110 0x0524      ADDS     R5,R0,#+36
   1311          
   1312            /* Suspend the CLUT loading */
   1313            SET_BIT(hdma2d->Instance->CR, DMA2D_CR_SUSP);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x12   0x6822             LDR      R2,[R4, #+0]
   \       0x14   0x6010             STR      R0,[R2, #+0]
   1314          
   1315            /* If foreground CLUT loading is considered, update local variables */
   1316            if (LayerIdx == DMA2D_FOREGROUND_LAYER)
   \       0x16   0x2901             CMP      R1,#+1
   \       0x18   0xD102             BNE.N    ??HAL_DMA2D_CLUTLoading_Suspend_0
   1317            {
   1318              reg  = &(hdma2d->Instance->FGPFCCR);
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0xF110 0x051C      ADDS     R5,R0,#+28
   1319            }
   1320          
   1321            /* Get tick */
   1322            tickstart = HAL_GetTick();
   \                     ??HAL_DMA2D_CLUTLoading_Suspend_0: (+1)
   \       0x20   0x.... 0x....      BL       HAL_GetTick
   \       0x24   0x0006             MOVS     R6,R0
   1323          
   1324            /* Check if the CLUT loading is suspended */
   1325            /* 1st condition: Suspend Check */
   1326            loadsuspended = ((hdma2d->Instance->CR & DMA2D_CR_SUSP) == DMA2D_CR_SUSP) ? 1UL : 0UL;
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \       0x2E   0xF010 0x0001      ANDS     R0,R0,#0x1
   1327            /* 2nd condition: Not Start Check */
   1328            loadsuspended |= ((*reg & DMA2D_BGPFCCR_START) != DMA2D_BGPFCCR_START) ? 1UL : 0UL;
   \       0x32   0x6829             LDR      R1,[R5, #+0]
   \       0x34   0x0949             LSRS     R1,R1,#+5
   \       0x36   0xF011 0x0101      ANDS     R1,R1,#0x1
   \       0x3A   0xF091 0x0101      EORS     R1,R1,#0x1
   \       0x3E   0x4308             ORRS     R0,R1,R0
   \       0x40   0xE00C             B.N      ??HAL_DMA2D_CLUTLoading_Suspend_1
   1329            while (loadsuspended == 0UL)
   1330            {
   1331              if ((HAL_GetTick() - tickstart) > DMA2D_TIMEOUT_SUSPEND)
   1332              {
   1333                /* Update error code */
   1334                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   1335          
   1336                /* Change the DMA2D state */
   1337                hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
   1338          
   1339                return HAL_TIMEOUT;
   1340              }
   1341              /* 1st condition: Suspend Check */
   1342              loadsuspended = ((hdma2d->Instance->CR & DMA2D_CR_SUSP) == DMA2D_CR_SUSP) ? 1UL : 0UL;
   \                     ??HAL_DMA2D_CLUTLoading_Suspend_2: (+1)
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x6800             LDR      R0,[R0, #+0]
   \       0x46   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \       0x4A   0xF010 0x0001      ANDS     R0,R0,#0x1
   1343              /* 2nd condition: Not Start Check */
   1344              loadsuspended |= ((*reg & DMA2D_BGPFCCR_START) != DMA2D_BGPFCCR_START) ? 1UL : 0UL;
   \       0x4E   0x6829             LDR      R1,[R5, #+0]
   \       0x50   0x0949             LSRS     R1,R1,#+5
   \       0x52   0xF011 0x0101      ANDS     R1,R1,#0x1
   \       0x56   0xF091 0x0101      EORS     R1,R1,#0x1
   \       0x5A   0x4308             ORRS     R0,R1,R0
   \                     ??HAL_DMA2D_CLUTLoading_Suspend_1: (+1)
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD10F             BNE.N    ??HAL_DMA2D_CLUTLoading_Suspend_3
   \       0x60   0x.... 0x....      BL       HAL_GetTick
   \       0x64   0x1B80             SUBS     R0,R0,R6
   \       0x66   0xF240 0x31E9      MOVW     R1,#+1001
   \       0x6A   0x4288             CMP      R0,R1
   \       0x6C   0xD3E9             BCC.N    ??HAL_DMA2D_CLUTLoading_Suspend_2
   \       0x6E   0x6E60             LDR      R0,[R4, #+100]
   \       0x70   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x74   0x6660             STR      R0,[R4, #+100]
   \       0x76   0x2003             MOVS     R0,#+3
   \       0x78   0xF884 0x0061      STRB     R0,[R4, #+97]
   \       0x7C   0x2003             MOVS     R0,#+3
   \       0x7E   0xE00D             B.N      ??HAL_DMA2D_CLUTLoading_Suspend_4
   1345            }
   1346          
   1347            /* Check whether or not a transfer is actually suspended and change the DMA2D state accordingly */
   1348            if ((*reg & DMA2D_BGPFCCR_START) != 0U)
   \                     ??HAL_DMA2D_CLUTLoading_Suspend_3: (+1)
   \       0x80   0x6828             LDR      R0,[R5, #+0]
   \       0x82   0x0680             LSLS     R0,R0,#+26
   \       0x84   0xD503             BPL.N    ??HAL_DMA2D_CLUTLoading_Suspend_5
   1349            {
   1350              hdma2d->State = HAL_DMA2D_STATE_SUSPEND;
   \       0x86   0x2005             MOVS     R0,#+5
   \       0x88   0xF884 0x0061      STRB     R0,[R4, #+97]
   \       0x8C   0xE005             B.N      ??HAL_DMA2D_CLUTLoading_Suspend_6
   1351            }
   1352            else
   1353            {
   1354              /* Make sure SUSP bit is cleared since it is meaningless
   1355                 when no transfer is on-going */
   1356              CLEAR_BIT(hdma2d->Instance->CR, DMA2D_CR_SUSP);
   \                     ??HAL_DMA2D_CLUTLoading_Suspend_5: (+1)
   \       0x8E   0x6820             LDR      R0,[R4, #+0]
   \       0x90   0x6800             LDR      R0,[R0, #+0]
   \       0x92   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x96   0x6821             LDR      R1,[R4, #+0]
   \       0x98   0x6008             STR      R0,[R1, #+0]
   1357            }
   1358          
   1359            return HAL_OK;
   \                     ??HAL_DMA2D_CLUTLoading_Suspend_6: (+1)
   \       0x9A   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_CLUTLoading_Suspend_4: (+1)
   \       0x9C   0xBD70             POP      {R4-R6,PC}
   1360          }
   1361          
   1362          /**
   1363            * @brief  Resume the DMA2D CLUT loading.
   1364            * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
   1365            *                 the configuration information for the DMA2D.
   1366            * @param  LayerIdx DMA2D Layer index.
   1367            *                   This parameter can be one of the following values:
   1368            *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
   1369            * @retval HAL status
   1370            */

   \                                 In section .text, align 2, keep-with-next
   1371          HAL_StatusTypeDef HAL_DMA2D_CLUTLoading_Resume(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
   1372          {
   1373            /* Check the SUSP and START bits for background or foreground CLUT loading */
   1374            if (LayerIdx == DMA2D_BACKGROUND_LAYER)
   \                     HAL_DMA2D_CLUTLoading_Resume: (+1)
   \        0x0   0x2900             CMP      R1,#+0
   \        0x2   0xD10B             BNE.N    ??HAL_DMA2D_CLUTLoading_Resume_0
   1375            {
   1376              /* Background CLUT loading suspension check */
   1377              if ((hdma2d->Instance->CR & DMA2D_CR_SUSP) == DMA2D_CR_SUSP)
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x6809             LDR      R1,[R1, #+0]
   \        0x8   0x0789             LSLS     R1,R1,#+30
   \        0xA   0xD512             BPL.N    ??HAL_DMA2D_CLUTLoading_Resume_1
   1378              {
   1379                if ((hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START) == DMA2D_BGPFCCR_START)
   \        0xC   0x6801             LDR      R1,[R0, #+0]
   \        0xE   0x6A49             LDR      R1,[R1, #+36]
   \       0x10   0x0689             LSLS     R1,R1,#+26
   \       0x12   0xD50E             BPL.N    ??HAL_DMA2D_CLUTLoading_Resume_1
   1380                {
   1381                  /* Ongoing CLUT loading is suspended: change the DMA2D state before resuming */
   1382                  hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x14   0x2102             MOVS     R1,#+2
   \       0x16   0xF880 0x1061      STRB     R1,[R0, #+97]
   \       0x1A   0xE00A             B.N      ??HAL_DMA2D_CLUTLoading_Resume_1
   1383                }
   1384              }
   1385            }
   1386            else
   1387            {
   1388              /* Foreground CLUT loading suspension check */
   1389              if ((hdma2d->Instance->CR & DMA2D_CR_SUSP) == DMA2D_CR_SUSP)
   \                     ??HAL_DMA2D_CLUTLoading_Resume_0: (+1)
   \       0x1C   0x6801             LDR      R1,[R0, #+0]
   \       0x1E   0x6809             LDR      R1,[R1, #+0]
   \       0x20   0x0789             LSLS     R1,R1,#+30
   \       0x22   0xD506             BPL.N    ??HAL_DMA2D_CLUTLoading_Resume_1
   1390              {
   1391                if ((hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START) == DMA2D_FGPFCCR_START)
   \       0x24   0x6801             LDR      R1,[R0, #+0]
   \       0x26   0x69C9             LDR      R1,[R1, #+28]
   \       0x28   0x0689             LSLS     R1,R1,#+26
   \       0x2A   0xD502             BPL.N    ??HAL_DMA2D_CLUTLoading_Resume_1
   1392                {
   1393                  /* Ongoing CLUT loading is suspended: change the DMA2D state before resuming */
   1394                  hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x2C   0x2102             MOVS     R1,#+2
   \       0x2E   0xF880 0x1061      STRB     R1,[R0, #+97]
   1395                }
   1396              }
   1397            }
   1398          
   1399            /* Resume the CLUT loading */
   1400            CLEAR_BIT(hdma2d->Instance->CR, DMA2D_CR_SUSP);
   \                     ??HAL_DMA2D_CLUTLoading_Resume_1: (+1)
   \       0x32   0x6801             LDR      R1,[R0, #+0]
   \       0x34   0x6809             LDR      R1,[R1, #+0]
   \       0x36   0xF031 0x0102      BICS     R1,R1,#0x2
   \       0x3A   0x6800             LDR      R0,[R0, #+0]
   \       0x3C   0x6001             STR      R1,[R0, #+0]
   1401          
   1402            return HAL_OK;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x4770             BX       LR
   1403          }
   1404          
   1405          
   1406          /**
   1407          
   1408            * @brief  Polling for transfer complete or CLUT loading.
   1409            * @param  hdma2d Pointer to a DMA2D_HandleTypeDef structure that contains
   1410            *                 the configuration information for the DMA2D.
   1411            * @param  Timeout Timeout duration
   1412            * @retval HAL status
   1413            */

   \                                 In section .text, align 2, keep-with-next
   1414          HAL_StatusTypeDef HAL_DMA2D_PollForTransfer(DMA2D_HandleTypeDef *hdma2d, uint32_t Timeout)
   1415          {
   \                     HAL_DMA2D_PollForTransfer: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1416            uint32_t tickstart;
   1417            uint32_t layer_start;
   1418            __IO uint32_t isrflags = 0x0U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9000             STR      R0,[SP, #+0]
   1419          
   1420            /* Polling for DMA2D transfer */
   1421            if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
   \        0xA   0x6828             LDR      R0,[R5, #+0]
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x07C0             LSLS     R0,R0,#+31
   \       0x10   0xD53C             BPL.N    ??HAL_DMA2D_PollForTransfer_0
   1422            {
   1423              /* Get tick */
   1424              tickstart = HAL_GetTick();
   \       0x12   0x.... 0x....      BL       HAL_GetTick
   \       0x16   0x0006             MOVS     R6,R0
   1425          
   1426              while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
   \                     ??HAL_DMA2D_PollForTransfer_1: (+1)
   \       0x18   0x6828             LDR      R0,[R5, #+0]
   \       0x1A   0x6840             LDR      R0,[R0, #+4]
   \       0x1C   0x0780             LSLS     R0,R0,#+30
   \       0x1E   0xD435             BMI.N    ??HAL_DMA2D_PollForTransfer_0
   1427              {
   1428                isrflags = READ_REG(hdma2d->Instance->ISR);
   \       0x20   0x6828             LDR      R0,[R5, #+0]
   \       0x22   0x6840             LDR      R0,[R0, #+4]
   \       0x24   0x9000             STR      R0,[SP, #+0]
   1429                if ((isrflags & (DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
   \       0x26   0x9800             LDR      R0,[SP, #+0]
   \       0x28   0xF010 0x0F21      TST      R0,#0x21
   \       0x2C   0xD018             BEQ.N    ??HAL_DMA2D_PollForTransfer_2
   1430                {
   1431                  if ((isrflags & DMA2D_FLAG_CE) != 0U)
   \       0x2E   0x9800             LDR      R0,[SP, #+0]
   \       0x30   0x0680             LSLS     R0,R0,#+26
   \       0x32   0xD503             BPL.N    ??HAL_DMA2D_PollForTransfer_3
   1432                  {
   1433                    hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
   \       0x34   0x6E68             LDR      R0,[R5, #+100]
   \       0x36   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x3A   0x6668             STR      R0,[R5, #+100]
   1434                  }
   1435                  if ((isrflags & DMA2D_FLAG_TE) != 0U)
   \                     ??HAL_DMA2D_PollForTransfer_3: (+1)
   \       0x3C   0x9800             LDR      R0,[SP, #+0]
   \       0x3E   0x07C0             LSLS     R0,R0,#+31
   \       0x40   0xD503             BPL.N    ??HAL_DMA2D_PollForTransfer_4
   1436                  {
   1437                    hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
   \       0x42   0x6E68             LDR      R0,[R5, #+100]
   \       0x44   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x48   0x6668             STR      R0,[R5, #+100]
   1438                  }
   1439                  /* Clear the transfer and configuration error flags */
   1440                  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
   \                     ??HAL_DMA2D_PollForTransfer_4: (+1)
   \       0x4A   0x2021             MOVS     R0,#+33
   \       0x4C   0x6829             LDR      R1,[R5, #+0]
   \       0x4E   0x6088             STR      R0,[R1, #+8]
   1441          
   1442                  /* Change DMA2D state */
   1443                  hdma2d->State = HAL_DMA2D_STATE_ERROR;
   \       0x50   0x2004             MOVS     R0,#+4
   \       0x52   0xF885 0x0061      STRB     R0,[R5, #+97]
   1444          
   1445                  /* Process unlocked */
   1446                  __HAL_UNLOCK(hdma2d);
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xF885 0x0060      STRB     R0,[R5, #+96]
   1447          
   1448                  return HAL_ERROR;
   \       0x5C   0x2001             MOVS     R0,#+1
   \       0x5E   0xE06E             B.N      ??HAL_DMA2D_PollForTransfer_5
   1449                }
   1450                /* Check for the Timeout */
   1451                if (Timeout != HAL_MAX_DELAY)
   \                     ??HAL_DMA2D_PollForTransfer_2: (+1)
   \       0x60   0xF114 0x0F01      CMN      R4,#+1
   \       0x64   0xD0D8             BEQ.N    ??HAL_DMA2D_PollForTransfer_1
   1452                {
   1453                  if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   \       0x66   0x.... 0x....      BL       HAL_GetTick
   \       0x6A   0x1B80             SUBS     R0,R0,R6
   \       0x6C   0x4284             CMP      R4,R0
   \       0x6E   0xD301             BCC.N    ??HAL_DMA2D_PollForTransfer_6
   \       0x70   0x2C00             CMP      R4,#+0
   \       0x72   0xD1D1             BNE.N    ??HAL_DMA2D_PollForTransfer_1
   1454                  {
   1455                    /* Update error code */
   1456                    hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   \                     ??HAL_DMA2D_PollForTransfer_6: (+1)
   \       0x74   0x6E68             LDR      R0,[R5, #+100]
   \       0x76   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x7A   0x6668             STR      R0,[R5, #+100]
   1457          
   1458                    /* Change the DMA2D state */
   1459                    hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
   \       0x7C   0x2003             MOVS     R0,#+3
   \       0x7E   0xF885 0x0061      STRB     R0,[R5, #+97]
   1460          
   1461                    /* Process unlocked */
   1462                    __HAL_UNLOCK(hdma2d);
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0xF885 0x0060      STRB     R0,[R5, #+96]
   1463          
   1464                    return HAL_TIMEOUT;
   \       0x88   0x2003             MOVS     R0,#+3
   \       0x8A   0xE058             B.N      ??HAL_DMA2D_PollForTransfer_5
   1465                  }
   1466                }
   1467              }
   1468            }
   1469            /* Polling for CLUT loading (foreground or background) */
   1470            layer_start = hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START;
   \                     ??HAL_DMA2D_PollForTransfer_0: (+1)
   \       0x8C   0x6828             LDR      R0,[R5, #+0]
   \       0x8E   0x69C0             LDR      R0,[R0, #+28]
   \       0x90   0xF010 0x0020      ANDS     R0,R0,#0x20
   1471            layer_start |= hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START;
   \       0x94   0x6829             LDR      R1,[R5, #+0]
   \       0x96   0x6A49             LDR      R1,[R1, #+36]
   \       0x98   0xF011 0x0120      ANDS     R1,R1,#0x20
   \       0x9C   0x4308             ORRS     R0,R1,R0
   1472            if (layer_start != 0U)
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD043             BEQ.N    ??HAL_DMA2D_PollForTransfer_7
   1473            {
   1474              /* Get tick */
   1475              tickstart = HAL_GetTick();
   \       0xA2   0x.... 0x....      BL       HAL_GetTick
   \       0xA6   0x0006             MOVS     R6,R0
   1476          
   1477              while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
   \                     ??HAL_DMA2D_PollForTransfer_8: (+1)
   \       0xA8   0x6828             LDR      R0,[R5, #+0]
   \       0xAA   0x6840             LDR      R0,[R0, #+4]
   \       0xAC   0x06C0             LSLS     R0,R0,#+27
   \       0xAE   0xD43C             BMI.N    ??HAL_DMA2D_PollForTransfer_7
   1478              {
   1479                isrflags = READ_REG(hdma2d->Instance->ISR);
   \       0xB0   0x6828             LDR      R0,[R5, #+0]
   \       0xB2   0x6840             LDR      R0,[R0, #+4]
   \       0xB4   0x9000             STR      R0,[SP, #+0]
   1480                if ((isrflags & (DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
   \       0xB6   0x9800             LDR      R0,[SP, #+0]
   \       0xB8   0xF010 0x0F29      TST      R0,#0x29
   \       0xBC   0xD01F             BEQ.N    ??HAL_DMA2D_PollForTransfer_9
   1481                {
   1482                  if ((isrflags & DMA2D_FLAG_CAE) != 0U)
   \       0xBE   0x9800             LDR      R0,[SP, #+0]
   \       0xC0   0x0700             LSLS     R0,R0,#+28
   \       0xC2   0xD503             BPL.N    ??HAL_DMA2D_PollForTransfer_10
   1483                  {
   1484                    hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
   \       0xC4   0x6E68             LDR      R0,[R5, #+100]
   \       0xC6   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0xCA   0x6668             STR      R0,[R5, #+100]
   1485                  }
   1486                  if ((isrflags & DMA2D_FLAG_CE) != 0U)
   \                     ??HAL_DMA2D_PollForTransfer_10: (+1)
   \       0xCC   0x9800             LDR      R0,[SP, #+0]
   \       0xCE   0x0680             LSLS     R0,R0,#+26
   \       0xD0   0xD503             BPL.N    ??HAL_DMA2D_PollForTransfer_11
   1487                  {
   1488                    hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
   \       0xD2   0x6E68             LDR      R0,[R5, #+100]
   \       0xD4   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0xD8   0x6668             STR      R0,[R5, #+100]
   1489                  }
   1490                  if ((isrflags & DMA2D_FLAG_TE) != 0U)
   \                     ??HAL_DMA2D_PollForTransfer_11: (+1)
   \       0xDA   0x9800             LDR      R0,[SP, #+0]
   \       0xDC   0x07C0             LSLS     R0,R0,#+31
   \       0xDE   0xD503             BPL.N    ??HAL_DMA2D_PollForTransfer_12
   1491                  {
   1492                    hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
   \       0xE0   0x6E68             LDR      R0,[R5, #+100]
   \       0xE2   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xE6   0x6668             STR      R0,[R5, #+100]
   1493                  }
   1494                  /* Clear the CLUT Access Error, Configuration Error and Transfer Error flags */
   1495                  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
   \                     ??HAL_DMA2D_PollForTransfer_12: (+1)
   \       0xE8   0x2029             MOVS     R0,#+41
   \       0xEA   0x6829             LDR      R1,[R5, #+0]
   \       0xEC   0x6088             STR      R0,[R1, #+8]
   1496          
   1497                  /* Change DMA2D state */
   1498                  hdma2d->State = HAL_DMA2D_STATE_ERROR;
   \       0xEE   0x2004             MOVS     R0,#+4
   \       0xF0   0xF885 0x0061      STRB     R0,[R5, #+97]
   1499          
   1500                  /* Process unlocked */
   1501                  __HAL_UNLOCK(hdma2d);
   \       0xF4   0x2000             MOVS     R0,#+0
   \       0xF6   0xF885 0x0060      STRB     R0,[R5, #+96]
   1502          
   1503                  return HAL_ERROR;
   \       0xFA   0x2001             MOVS     R0,#+1
   \       0xFC   0xE01F             B.N      ??HAL_DMA2D_PollForTransfer_5
   1504                }
   1505                /* Check for the Timeout */
   1506                if (Timeout != HAL_MAX_DELAY)
   \                     ??HAL_DMA2D_PollForTransfer_9: (+1)
   \       0xFE   0xF114 0x0F01      CMN      R4,#+1
   \      0x102   0xD0D1             BEQ.N    ??HAL_DMA2D_PollForTransfer_8
   1507                {
   1508                  if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   \      0x104   0x.... 0x....      BL       HAL_GetTick
   \      0x108   0x1B80             SUBS     R0,R0,R6
   \      0x10A   0x4284             CMP      R4,R0
   \      0x10C   0xD301             BCC.N    ??HAL_DMA2D_PollForTransfer_13
   \      0x10E   0x2C00             CMP      R4,#+0
   \      0x110   0xD1CA             BNE.N    ??HAL_DMA2D_PollForTransfer_8
   1509                  {
   1510                    /* Update error code */
   1511                    hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
   \                     ??HAL_DMA2D_PollForTransfer_13: (+1)
   \      0x112   0x6E68             LDR      R0,[R5, #+100]
   \      0x114   0xF050 0x0020      ORRS     R0,R0,#0x20
   \      0x118   0x6668             STR      R0,[R5, #+100]
   1512          
   1513                    /* Change the DMA2D state */
   1514                    hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
   \      0x11A   0x2003             MOVS     R0,#+3
   \      0x11C   0xF885 0x0061      STRB     R0,[R5, #+97]
   1515          
   1516                    /* Process unlocked */
   1517                    __HAL_UNLOCK(hdma2d);
   \      0x120   0x2000             MOVS     R0,#+0
   \      0x122   0xF885 0x0060      STRB     R0,[R5, #+96]
   1518          
   1519                    return HAL_TIMEOUT;
   \      0x126   0x2003             MOVS     R0,#+3
   \      0x128   0xE009             B.N      ??HAL_DMA2D_PollForTransfer_5
   1520                  }
   1521                }
   1522              }
   1523            }
   1524          
   1525            /* Clear the transfer complete and CLUT loading flags */
   1526            __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
   \                     ??HAL_DMA2D_PollForTransfer_7: (+1)
   \      0x12A   0x2012             MOVS     R0,#+18
   \      0x12C   0x6829             LDR      R1,[R5, #+0]
   \      0x12E   0x6088             STR      R0,[R1, #+8]
   1527          
   1528            /* Change DMA2D state */
   1529            hdma2d->State = HAL_DMA2D_STATE_READY;
   \      0x130   0x2001             MOVS     R0,#+1
   \      0x132   0xF885 0x0061      STRB     R0,[R5, #+97]
   1530          
   1531            /* Process unlocked */
   1532            __HAL_UNLOCK(hdma2d);
   \      0x136   0x2000             MOVS     R0,#+0
   \      0x138   0xF885 0x0060      STRB     R0,[R5, #+96]
   1533          
   1534            return HAL_OK;
   \      0x13C   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_PollForTransfer_5: (+1)
   \      0x13E   0xBD76             POP      {R1,R2,R4-R6,PC}
   1535          }
   1536          /**
   1537            * @brief  Handle DMA2D interrupt request.
   1538            * @param  hdma2d Pointer to a DMA2D_HandleTypeDef structure that contains
   1539            *                 the configuration information for the DMA2D.
   1540            * @retval HAL status
   1541            */

   \                                 In section .text, align 2, keep-with-next
   1542          void HAL_DMA2D_IRQHandler(DMA2D_HandleTypeDef *hdma2d)
   1543          {
   \                     HAL_DMA2D_IRQHandler: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1544            uint32_t isrflags = READ_REG(hdma2d->Instance->ISR);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6845             LDR      R5,[R0, #+4]
   1545            uint32_t crflags = READ_REG(hdma2d->Instance->CR);
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x6806             LDR      R6,[R0, #+0]
   1546          
   1547            /* Transfer Error Interrupt management ***************************************/
   1548            if ((isrflags & DMA2D_FLAG_TE) != 0U)
   \        0xC   0x07E8             LSLS     R0,R5,#+31
   \        0xE   0xD51A             BPL.N    ??HAL_DMA2D_IRQHandler_0
   1549            {
   1550              if ((crflags & DMA2D_IT_TE) != 0U)
   \       0x10   0x05F0             LSLS     R0,R6,#+23
   \       0x12   0xD518             BPL.N    ??HAL_DMA2D_IRQHandler_0
   1551              {
   1552                /* Disable the transfer Error interrupt */
   1553                __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TE);
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0xF430 0x7080      BICS     R0,R0,#0x100
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x6008             STR      R0,[R1, #+0]
   1554          
   1555                /* Update error code */
   1556                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
   \       0x20   0x6E60             LDR      R0,[R4, #+100]
   \       0x22   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x26   0x6660             STR      R0,[R4, #+100]
   1557          
   1558                /* Clear the transfer error flag */
   1559                __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TE);
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6088             STR      R0,[R1, #+8]
   1560          
   1561                /* Change DMA2D state */
   1562                hdma2d->State = HAL_DMA2D_STATE_ERROR;
   \       0x2E   0x2004             MOVS     R0,#+4
   \       0x30   0xF884 0x0061      STRB     R0,[R4, #+97]
   1563          
   1564                /* Process Unlocked */
   1565                __HAL_UNLOCK(hdma2d);
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF884 0x0060      STRB     R0,[R4, #+96]
   1566          
   1567                if (hdma2d->XferErrorCallback != NULL)
   \       0x3A   0x6A60             LDR      R0,[R4, #+36]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD002             BEQ.N    ??HAL_DMA2D_IRQHandler_0
   1568                {
   1569                  /* Transfer error Callback */
   1570                  hdma2d->XferErrorCallback(hdma2d);
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x6A61             LDR      R1,[R4, #+36]
   \       0x44   0x4788             BLX      R1
   1571                }
   1572              }
   1573            }
   1574            /* Configuration Error Interrupt management **********************************/
   1575            if ((isrflags & DMA2D_FLAG_CE) != 0U)
   \                     ??HAL_DMA2D_IRQHandler_0: (+1)
   \       0x46   0x06A8             LSLS     R0,R5,#+26
   \       0x48   0xD51A             BPL.N    ??HAL_DMA2D_IRQHandler_1
   1576            {
   1577              if ((crflags & DMA2D_IT_CE) != 0U)
   \       0x4A   0x04B0             LSLS     R0,R6,#+18
   \       0x4C   0xD518             BPL.N    ??HAL_DMA2D_IRQHandler_1
   1578              {
   1579                /* Disable the Configuration Error interrupt */
   1580                __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CE);
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x6800             LDR      R0,[R0, #+0]
   \       0x52   0xF430 0x5000      BICS     R0,R0,#0x2000
   \       0x56   0x6821             LDR      R1,[R4, #+0]
   \       0x58   0x6008             STR      R0,[R1, #+0]
   1581          
   1582                /* Clear the Configuration error flag */
   1583                __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE);
   \       0x5A   0x2020             MOVS     R0,#+32
   \       0x5C   0x6821             LDR      R1,[R4, #+0]
   \       0x5E   0x6088             STR      R0,[R1, #+8]
   1584          
   1585                /* Update error code */
   1586                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
   \       0x60   0x6E60             LDR      R0,[R4, #+100]
   \       0x62   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x66   0x6660             STR      R0,[R4, #+100]
   1587          
   1588                /* Change DMA2D state */
   1589                hdma2d->State = HAL_DMA2D_STATE_ERROR;
   \       0x68   0x2004             MOVS     R0,#+4
   \       0x6A   0xF884 0x0061      STRB     R0,[R4, #+97]
   1590          
   1591                /* Process Unlocked */
   1592                __HAL_UNLOCK(hdma2d);
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xF884 0x0060      STRB     R0,[R4, #+96]
   1593          
   1594                if (hdma2d->XferErrorCallback != NULL)
   \       0x74   0x6A60             LDR      R0,[R4, #+36]
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD002             BEQ.N    ??HAL_DMA2D_IRQHandler_1
   1595                {
   1596                  /* Transfer error Callback */
   1597                  hdma2d->XferErrorCallback(hdma2d);
   \       0x7A   0x0020             MOVS     R0,R4
   \       0x7C   0x6A61             LDR      R1,[R4, #+36]
   \       0x7E   0x4788             BLX      R1
   1598                }
   1599              }
   1600            }
   1601            /* CLUT access Error Interrupt management ***********************************/
   1602            if ((isrflags & DMA2D_FLAG_CAE) != 0U)
   \                     ??HAL_DMA2D_IRQHandler_1: (+1)
   \       0x80   0x0728             LSLS     R0,R5,#+28
   \       0x82   0xD51A             BPL.N    ??HAL_DMA2D_IRQHandler_2
   1603            {
   1604              if ((crflags & DMA2D_IT_CAE) != 0U)
   \       0x84   0x0530             LSLS     R0,R6,#+20
   \       0x86   0xD518             BPL.N    ??HAL_DMA2D_IRQHandler_2
   1605              {
   1606                /* Disable the CLUT access error interrupt */
   1607                __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CAE);
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6800             LDR      R0,[R0, #+0]
   \       0x8C   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x90   0x6821             LDR      R1,[R4, #+0]
   \       0x92   0x6008             STR      R0,[R1, #+0]
   1608          
   1609                /* Clear the CLUT access error flag */
   1610                __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE);
   \       0x94   0x2008             MOVS     R0,#+8
   \       0x96   0x6821             LDR      R1,[R4, #+0]
   \       0x98   0x6088             STR      R0,[R1, #+8]
   1611          
   1612                /* Update error code */
   1613                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
   \       0x9A   0x6E60             LDR      R0,[R4, #+100]
   \       0x9C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0xA0   0x6660             STR      R0,[R4, #+100]
   1614          
   1615                /* Change DMA2D state */
   1616                hdma2d->State = HAL_DMA2D_STATE_ERROR;
   \       0xA2   0x2004             MOVS     R0,#+4
   \       0xA4   0xF884 0x0061      STRB     R0,[R4, #+97]
   1617          
   1618                /* Process Unlocked */
   1619                __HAL_UNLOCK(hdma2d);
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0xF884 0x0060      STRB     R0,[R4, #+96]
   1620          
   1621                if (hdma2d->XferErrorCallback != NULL)
   \       0xAE   0x6A60             LDR      R0,[R4, #+36]
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD002             BEQ.N    ??HAL_DMA2D_IRQHandler_2
   1622                {
   1623                  /* Transfer error Callback */
   1624                  hdma2d->XferErrorCallback(hdma2d);
   \       0xB4   0x0020             MOVS     R0,R4
   \       0xB6   0x6A61             LDR      R1,[R4, #+36]
   \       0xB8   0x4788             BLX      R1
   1625                }
   1626              }
   1627            }
   1628            /* Transfer watermark Interrupt management **********************************/
   1629            if ((isrflags & DMA2D_FLAG_TW) != 0U)
   \                     ??HAL_DMA2D_IRQHandler_2: (+1)
   \       0xBA   0x0768             LSLS     R0,R5,#+29
   \       0xBC   0xD50D             BPL.N    ??HAL_DMA2D_IRQHandler_3
   1630            {
   1631              if ((crflags & DMA2D_IT_TW) != 0U)
   \       0xBE   0x0570             LSLS     R0,R6,#+21
   \       0xC0   0xD50B             BPL.N    ??HAL_DMA2D_IRQHandler_3
   1632              {
   1633                /* Disable the transfer watermark interrupt */
   1634                __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TW);
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0x6800             LDR      R0,[R0, #+0]
   \       0xC6   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0xCA   0x6821             LDR      R1,[R4, #+0]
   \       0xCC   0x6008             STR      R0,[R1, #+0]
   1635          
   1636                /* Clear the transfer watermark flag */
   1637                __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TW);
   \       0xCE   0x2004             MOVS     R0,#+4
   \       0xD0   0x6821             LDR      R1,[R4, #+0]
   \       0xD2   0x6088             STR      R0,[R1, #+8]
   1638          
   1639                /* Transfer watermark Callback */
   1640          #if (USE_HAL_DMA2D_REGISTER_CALLBACKS == 1)
   1641                hdma2d->LineEventCallback(hdma2d);
   1642          #else
   1643                HAL_DMA2D_LineEventCallback(hdma2d);
   \       0xD4   0x0020             MOVS     R0,R4
   \       0xD6   0x.... 0x....      BL       HAL_DMA2D_LineEventCallback
   1644          #endif /* USE_HAL_DMA2D_REGISTER_CALLBACKS */
   1645          
   1646              }
   1647            }
   1648            /* Transfer Complete Interrupt management ************************************/
   1649            if ((isrflags & DMA2D_FLAG_TC) != 0U)
   \                     ??HAL_DMA2D_IRQHandler_3: (+1)
   \       0xDA   0x07A8             LSLS     R0,R5,#+30
   \       0xDC   0xD518             BPL.N    ??HAL_DMA2D_IRQHandler_4
   1650            {
   1651              if ((crflags & DMA2D_IT_TC) != 0U)
   \       0xDE   0x05B0             LSLS     R0,R6,#+22
   \       0xE0   0xD516             BPL.N    ??HAL_DMA2D_IRQHandler_4
   1652              {
   1653                /* Disable the transfer complete interrupt */
   1654                __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TC);
   \       0xE2   0x6820             LDR      R0,[R4, #+0]
   \       0xE4   0x6800             LDR      R0,[R0, #+0]
   \       0xE6   0xF430 0x7000      BICS     R0,R0,#0x200
   \       0xEA   0x6821             LDR      R1,[R4, #+0]
   \       0xEC   0x6008             STR      R0,[R1, #+0]
   1655          
   1656                /* Clear the transfer complete flag */
   1657                __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC);
   \       0xEE   0x2002             MOVS     R0,#+2
   \       0xF0   0x6821             LDR      R1,[R4, #+0]
   \       0xF2   0x6088             STR      R0,[R1, #+8]
   1658          
   1659                /* Update error code */
   1660                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_NONE;
   \       0xF4   0x6E60             LDR      R0,[R4, #+100]
   \       0xF6   0x6660             STR      R0,[R4, #+100]
   1661          
   1662                /* Change DMA2D state */
   1663                hdma2d->State = HAL_DMA2D_STATE_READY;
   \       0xF8   0x2001             MOVS     R0,#+1
   \       0xFA   0xF884 0x0061      STRB     R0,[R4, #+97]
   1664          
   1665                /* Process Unlocked */
   1666                __HAL_UNLOCK(hdma2d);
   \       0xFE   0x2000             MOVS     R0,#+0
   \      0x100   0xF884 0x0060      STRB     R0,[R4, #+96]
   1667          
   1668                if (hdma2d->XferCpltCallback != NULL)
   \      0x104   0x6A20             LDR      R0,[R4, #+32]
   \      0x106   0x2800             CMP      R0,#+0
   \      0x108   0xD002             BEQ.N    ??HAL_DMA2D_IRQHandler_4
   1669                {
   1670                  /* Transfer complete Callback */
   1671                  hdma2d->XferCpltCallback(hdma2d);
   \      0x10A   0x0020             MOVS     R0,R4
   \      0x10C   0x6A21             LDR      R1,[R4, #+32]
   \      0x10E   0x4788             BLX      R1
   1672                }
   1673              }
   1674            }
   1675            /* CLUT Transfer Complete Interrupt management ******************************/
   1676            if ((isrflags & DMA2D_FLAG_CTC) != 0U)
   \                     ??HAL_DMA2D_IRQHandler_4: (+1)
   \      0x110   0x06E8             LSLS     R0,R5,#+27
   \      0x112   0xD515             BPL.N    ??HAL_DMA2D_IRQHandler_5
   1677            {
   1678              if ((crflags & DMA2D_IT_CTC) != 0U)
   \      0x114   0x04F0             LSLS     R0,R6,#+19
   \      0x116   0xD513             BPL.N    ??HAL_DMA2D_IRQHandler_5
   1679              {
   1680                /* Disable the CLUT transfer complete interrupt */
   1681                __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CTC);
   \      0x118   0x6820             LDR      R0,[R4, #+0]
   \      0x11A   0x6800             LDR      R0,[R0, #+0]
   \      0x11C   0xF430 0x5080      BICS     R0,R0,#0x1000
   \      0x120   0x6821             LDR      R1,[R4, #+0]
   \      0x122   0x6008             STR      R0,[R1, #+0]
   1682          
   1683                /* Clear the CLUT transfer complete flag */
   1684                __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CTC);
   \      0x124   0x2010             MOVS     R0,#+16
   \      0x126   0x6821             LDR      R1,[R4, #+0]
   \      0x128   0x6088             STR      R0,[R1, #+8]
   1685          
   1686                /* Update error code */
   1687                hdma2d->ErrorCode |= HAL_DMA2D_ERROR_NONE;
   \      0x12A   0x6E60             LDR      R0,[R4, #+100]
   \      0x12C   0x6660             STR      R0,[R4, #+100]
   1688          
   1689                /* Change DMA2D state */
   1690                hdma2d->State = HAL_DMA2D_STATE_READY;
   \      0x12E   0x2001             MOVS     R0,#+1
   \      0x130   0xF884 0x0061      STRB     R0,[R4, #+97]
   1691          
   1692                /* Process Unlocked */
   1693                __HAL_UNLOCK(hdma2d);
   \      0x134   0x2000             MOVS     R0,#+0
   \      0x136   0xF884 0x0060      STRB     R0,[R4, #+96]
   1694          
   1695                /* CLUT Transfer complete Callback */
   1696          #if (USE_HAL_DMA2D_REGISTER_CALLBACKS == 1)
   1697                hdma2d->CLUTLoadingCpltCallback(hdma2d);
   1698          #else
   1699                HAL_DMA2D_CLUTLoadingCpltCallback(hdma2d);
   \      0x13A   0x0020             MOVS     R0,R4
   \      0x13C   0x.... 0x....      BL       HAL_DMA2D_CLUTLoadingCpltCallback
   1700          #endif /* USE_HAL_DMA2D_REGISTER_CALLBACKS */
   1701              }
   1702            }
   1703          
   1704          }
   \                     ??HAL_DMA2D_IRQHandler_5: (+1)
   \      0x140   0xBD70             POP      {R4-R6,PC}
   1705          
   1706          /**
   1707            * @brief  Transfer watermark callback.
   1708            * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
   1709            *                 the configuration information for the DMA2D.
   1710            * @retval None
   1711            */

   \                                 In section .text, align 2
   1712          __weak void HAL_DMA2D_LineEventCallback(DMA2D_HandleTypeDef *hdma2d)
   1713          {
   1714            /* Prevent unused argument(s) compilation warning */
   1715            UNUSED(hdma2d);
   1716          
   1717            /* NOTE : This function should not be modified; when the callback is needed,
   1718                      the HAL_DMA2D_LineEventCallback can be implemented in the user file.
   1719             */
   1720          }
   \                     HAL_DMA2D_LineEventCallback: (+1)
   \        0x0   0x4770             BX       LR
   1721          
   1722          /**
   1723            * @brief  CLUT Transfer Complete callback.
   1724            * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
   1725            *                 the configuration information for the DMA2D.
   1726            * @retval None
   1727            */

   \                                 In section .text, align 2
   1728          __weak void HAL_DMA2D_CLUTLoadingCpltCallback(DMA2D_HandleTypeDef *hdma2d)
   1729          {
   1730            /* Prevent unused argument(s) compilation warning */
   1731            UNUSED(hdma2d);
   1732          
   1733            /* NOTE : This function should not be modified; when the callback is needed,
   1734                      the HAL_DMA2D_CLUTLoadingCpltCallback can be implemented in the user file.
   1735             */
   1736          }
   \                     HAL_DMA2D_CLUTLoadingCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   1737          
   1738          /**
   1739            * @}
   1740            */
   1741          
   1742          /** @defgroup DMA2D_Exported_Functions_Group3 Peripheral Control functions
   1743            *  @brief    Peripheral Control functions
   1744            *
   1745          @verbatim
   1746           ===============================================================================
   1747                              ##### Peripheral Control functions #####
   1748           ===============================================================================
   1749              [..]  This section provides functions allowing to:
   1750                (+) Configure the DMA2D foreground or background layer parameters.
   1751                (+) Configure the DMA2D CLUT transfer.
   1752                (+) Configure the line watermark
   1753                (+) Configure the dead time value.
   1754                (+) Enable or disable the dead time value functionality.
   1755          
   1756          
   1757          @endverbatim
   1758            * @{
   1759            */
   1760          
   1761          /**
   1762            * @brief  Configure the DMA2D Layer according to the specified
   1763            *         parameters in the DMA2D_HandleTypeDef.
   1764            * @param  hdma2d Pointer to a DMA2D_HandleTypeDef structure that contains
   1765            *                 the configuration information for the DMA2D.
   1766            * @param  LayerIdx DMA2D Layer index.
   1767            *                   This parameter can be one of the following values:
   1768            *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
   1769            * @retval HAL status
   1770            */

   \                                 In section .text, align 2, keep-with-next
   1771          HAL_StatusTypeDef HAL_DMA2D_ConfigLayer(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
   1772          {
   \                     HAL_DMA2D_ConfigLayer: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   1773            DMA2D_LayerCfgTypeDef *pLayerCfg;
   1774            uint32_t regMask;
   1775            uint32_t regValue;
   1776          
   1777            /* Check the parameters */
   1778            assert_param(IS_DMA2D_LAYER(LayerIdx));
   1779            assert_param(IS_DMA2D_OFFSET(hdma2d->LayerCfg[LayerIdx].InputOffset));
   1780            if (hdma2d->Init.Mode != DMA2D_R2M)
   \        0x2   0x6842             LDR      R2,[R0, #+4]
   \        0x4   0xF5B2 0x3F40      CMP      R2,#+196608
   \        0x8   0xD001             BEQ.N    ??HAL_DMA2D_ConfigLayer_0
   1781            {
   1782              assert_param(IS_DMA2D_INPUT_COLOR_MODE(hdma2d->LayerCfg[LayerIdx].InputColorMode));
   1783              if (hdma2d->Init.Mode != DMA2D_M2M)
   \        0xA   0x6842             LDR      R2,[R0, #+4]
   \        0xC   0x2A00             CMP      R2,#+0
   1784              {
   1785                assert_param(IS_DMA2D_ALPHA_MODE(hdma2d->LayerCfg[LayerIdx].AlphaMode));
   1786              }
   1787            }
   1788            assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->LayerCfg[LayerIdx].AlphaInverted));
   1789            assert_param(IS_DMA2D_RB_SWAP(hdma2d->LayerCfg[LayerIdx].RedBlueSwap));
   1790          
   1791            if ((LayerIdx == DMA2D_FOREGROUND_LAYER) && (hdma2d->LayerCfg[LayerIdx].InputColorMode == DMA2D_INPUT_YCBCR))
   \                     ??HAL_DMA2D_ConfigLayer_0: (+1)
   \        0xE   0x2901             CMP      R1,#+1
   \       0x10   0xD105             BNE.N    ??HAL_DMA2D_ConfigLayer_1
   \       0x12   0x221C             MOVS     R2,#+28
   \       0x14   0xFB02 0xF201      MUL      R2,R2,R1
   \       0x18   0x4402             ADD      R2,R0,R2
   \       0x1A   0x6AD2             LDR      R2,[R2, #+44]
   \       0x1C   0x2A0B             CMP      R2,#+11
   1792            {
   1793              assert_param(IS_DMA2D_CHROMA_SUB_SAMPLING(hdma2d->LayerCfg[LayerIdx].ChromaSubSampling));
   1794            }
   1795          
   1796            /* Process locked */
   1797            __HAL_LOCK(hdma2d);
   \                     ??HAL_DMA2D_ConfigLayer_1: (+1)
   \       0x1E   0xF890 0x2060      LDRB     R2,[R0, #+96]
   \       0x22   0x2A01             CMP      R2,#+1
   \       0x24   0xD101             BNE.N    ??HAL_DMA2D_ConfigLayer_2
   \       0x26   0x2002             MOVS     R0,#+2
   \       0x28   0xE05F             B.N      ??HAL_DMA2D_ConfigLayer_3
   \                     ??HAL_DMA2D_ConfigLayer_2: (+1)
   \       0x2A   0x2201             MOVS     R2,#+1
   \       0x2C   0xF880 0x2060      STRB     R2,[R0, #+96]
   1798          
   1799            /* Change DMA2D peripheral state */
   1800            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x30   0x2202             MOVS     R2,#+2
   \       0x32   0xF880 0x2061      STRB     R2,[R0, #+97]
   1801          
   1802            pLayerCfg = &hdma2d->LayerCfg[LayerIdx];
   \       0x36   0x221C             MOVS     R2,#+28
   \       0x38   0xFB02 0xF201      MUL      R2,R2,R1
   \       0x3C   0x4402             ADD      R2,R0,R2
   \       0x3E   0x3228             ADDS     R2,R2,#+40
   1803          
   1804            /* Prepare the value to be written to the BGPFCCR or FGPFCCR register */
   1805            regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
   1806                       (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
   \       0x40   0x6853             LDR      R3,[R2, #+4]
   \       0x42   0x6894             LDR      R4,[R2, #+8]
   \       0x44   0xEA53 0x4304      ORRS     R3,R3,R4, LSL #+16
   \       0x48   0x6914             LDR      R4,[R2, #+16]
   \       0x4A   0xEA53 0x5304      ORRS     R3,R3,R4, LSL #+20
   \       0x4E   0x6954             LDR      R4,[R2, #+20]
   \       0x50   0xEA53 0x5344      ORRS     R3,R3,R4, LSL #+21
   1807            regMask  = (DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_RBS);
   \       0x54   0x....             LDR.N    R4,??DataTable7_4
   1808          
   1809          
   1810            if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
   \       0x56   0x6855             LDR      R5,[R2, #+4]
   \       0x58   0x2D0A             CMP      R5,#+10
   \       0x5A   0xD002             BEQ.N    ??HAL_DMA2D_ConfigLayer_4
   \       0x5C   0x6855             LDR      R5,[R2, #+4]
   \       0x5E   0x2D09             CMP      R5,#+9
   \       0x60   0xD104             BNE.N    ??HAL_DMA2D_ConfigLayer_5
   1811            {
   1812              regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
   \                     ??HAL_DMA2D_ConfigLayer_4: (+1)
   \       0x62   0x68D5             LDR      R5,[R2, #+12]
   \       0x64   0xF015 0x457F      ANDS     R5,R5,#0xFF000000
   \       0x68   0x432B             ORRS     R3,R5,R3
   \       0x6A   0xE002             B.N      ??HAL_DMA2D_ConfigLayer_6
   1813            }
   1814            else
   1815            {
   1816              regValue |= (pLayerCfg->InputAlpha << DMA2D_BGPFCCR_ALPHA_Pos);
   \                     ??HAL_DMA2D_ConfigLayer_5: (+1)
   \       0x6C   0x68D5             LDR      R5,[R2, #+12]
   \       0x6E   0xEA53 0x6305      ORRS     R3,R3,R5, LSL #+24
   1817            }
   1818          
   1819            /* Configure the background DMA2D layer */
   1820            if (LayerIdx == DMA2D_BACKGROUND_LAYER)
   \                     ??HAL_DMA2D_ConfigLayer_6: (+1)
   \       0x72   0x2900             CMP      R1,#+0
   \       0x74   0xD115             BNE.N    ??HAL_DMA2D_ConfigLayer_7
   1821            {
   1822              /* Write DMA2D BGPFCCR register */
   1823              MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
   \       0x76   0x6801             LDR      R1,[R0, #+0]
   \       0x78   0x6A49             LDR      R1,[R1, #+36]
   \       0x7A   0xEA31 0x0404      BICS     R4,R1,R4
   \       0x7E   0x431C             ORRS     R4,R3,R4
   \       0x80   0x6801             LDR      R1,[R0, #+0]
   \       0x82   0x624C             STR      R4,[R1, #+36]
   1824          
   1825              /* DMA2D BGOR register configuration -------------------------------------*/
   1826              WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
   \       0x84   0x6811             LDR      R1,[R2, #+0]
   \       0x86   0x6803             LDR      R3,[R0, #+0]
   \       0x88   0x6199             STR      R1,[R3, #+24]
   1827          
   1828              /* DMA2D BGCOLR register configuration -------------------------------------*/
   1829              if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
   \       0x8A   0x6851             LDR      R1,[R2, #+4]
   \       0x8C   0x290A             CMP      R1,#+10
   \       0x8E   0xD002             BEQ.N    ??HAL_DMA2D_ConfigLayer_8
   \       0x90   0x6851             LDR      R1,[R2, #+4]
   \       0x92   0x2909             CMP      R1,#+9
   \       0x94   0xD122             BNE.N    ??HAL_DMA2D_ConfigLayer_9
   1830              {
   1831                WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | \
   1832                                                                             DMA2D_BGCOLR_RED));
   \                     ??HAL_DMA2D_ConfigLayer_8: (+1)
   \       0x96   0x68D1             LDR      R1,[R2, #+12]
   \       0x98   0xF021 0x417F      BIC      R1,R1,#0xFF000000
   \       0x9C   0x6802             LDR      R2,[R0, #+0]
   \       0x9E   0x6291             STR      R1,[R2, #+40]
   \       0xA0   0xE01C             B.N      ??HAL_DMA2D_ConfigLayer_9
   1833              }
   1834            }
   1835            /* Configure the foreground DMA2D layer */
   1836            else
   1837            {
   1838          
   1839              if (pLayerCfg->InputColorMode == DMA2D_INPUT_YCBCR)
   \                     ??HAL_DMA2D_ConfigLayer_7: (+1)
   \       0xA2   0x6851             LDR      R1,[R2, #+4]
   \       0xA4   0x290B             CMP      R1,#+11
   \       0xA6   0xD104             BNE.N    ??HAL_DMA2D_ConfigLayer_10
   1840              {
   1841                regValue |= (pLayerCfg->ChromaSubSampling << DMA2D_FGPFCCR_CSS_Pos);
   \       0xA8   0x6991             LDR      R1,[R2, #+24]
   \       0xAA   0xEA53 0x4381      ORRS     R3,R3,R1, LSL #+18
   1842                regMask  |= DMA2D_FGPFCCR_CSS;
   \       0xAE   0xF454 0x2440      ORRS     R4,R4,#0xC0000
   1843              }
   1844          
   1845              /* Write DMA2D FGPFCCR register */
   1846              MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
   \                     ??HAL_DMA2D_ConfigLayer_10: (+1)
   \       0xB2   0x6801             LDR      R1,[R0, #+0]
   \       0xB4   0x69C9             LDR      R1,[R1, #+28]
   \       0xB6   0xEA31 0x0404      BICS     R4,R1,R4
   \       0xBA   0x431C             ORRS     R4,R3,R4
   \       0xBC   0x6801             LDR      R1,[R0, #+0]
   \       0xBE   0x61CC             STR      R4,[R1, #+28]
   1847          
   1848              /* DMA2D FGOR register configuration -------------------------------------*/
   1849              WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
   \       0xC0   0x6811             LDR      R1,[R2, #+0]
   \       0xC2   0x6803             LDR      R3,[R0, #+0]
   \       0xC4   0x6119             STR      R1,[R3, #+16]
   1850          
   1851              /* DMA2D FGCOLR register configuration -------------------------------------*/
   1852              if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
   \       0xC6   0x6851             LDR      R1,[R2, #+4]
   \       0xC8   0x290A             CMP      R1,#+10
   \       0xCA   0xD002             BEQ.N    ??HAL_DMA2D_ConfigLayer_11
   \       0xCC   0x6851             LDR      R1,[R2, #+4]
   \       0xCE   0x2909             CMP      R1,#+9
   \       0xD0   0xD104             BNE.N    ??HAL_DMA2D_ConfigLayer_9
   1853              {
   1854                WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | \
   1855                                                                             DMA2D_FGCOLR_RED));
   \                     ??HAL_DMA2D_ConfigLayer_11: (+1)
   \       0xD2   0x68D1             LDR      R1,[R2, #+12]
   \       0xD4   0xF021 0x417F      BIC      R1,R1,#0xFF000000
   \       0xD8   0x6802             LDR      R2,[R0, #+0]
   \       0xDA   0x6211             STR      R1,[R2, #+32]
   1856              }
   1857            }
   1858            /* Initialize the DMA2D state*/
   1859            hdma2d->State = HAL_DMA2D_STATE_READY;
   \                     ??HAL_DMA2D_ConfigLayer_9: (+1)
   \       0xDC   0x2101             MOVS     R1,#+1
   \       0xDE   0xF880 0x1061      STRB     R1,[R0, #+97]
   1860          
   1861            /* Process unlocked */
   1862            __HAL_UNLOCK(hdma2d);
   \       0xE2   0x2100             MOVS     R1,#+0
   \       0xE4   0xF880 0x1060      STRB     R1,[R0, #+96]
   1863          
   1864            return HAL_OK;
   \       0xE8   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_ConfigLayer_3: (+1)
   \       0xEA   0xBC30             POP      {R4,R5}
   \       0xEC   0x4770             BX       LR
   1865          }
   1866          
   1867          /**
   1868            * @brief  Configure the DMA2D CLUT Transfer.
   1869            * @param  hdma2d   Pointer to a DMA2D_HandleTypeDef structure that contains
   1870            *                   the configuration information for the DMA2D.
   1871            * @param  CLUTCfg  Pointer to a DMA2D_CLUTCfgTypeDef structure that contains
   1872            *                   the configuration information for the color look up table.
   1873            * @param  LayerIdx DMA2D Layer index.
   1874            *                   This parameter can be one of the following values:
   1875            *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
   1876            * @note API obsolete and maintained for compatibility with legacy. User is invited
   1877            *      to resort to HAL_DMA2D_CLUTStartLoad() instead to benefit from code compactness,
   1878            *      code size and improved heap usage.
   1879            * @retval HAL status
   1880            */

   \                                 In section .text, align 2, keep-with-next
   1881          HAL_StatusTypeDef HAL_DMA2D_ConfigCLUT(DMA2D_HandleTypeDef *hdma2d, DMA2D_CLUTCfgTypeDef CLUTCfg, uint32_t LayerIdx)
   1882          {
   \                     HAL_DMA2D_ConfigCLUT: (+1)
   \        0x0   0xB43E             PUSH     {R1-R5}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0xE9CD 0x1200      STRD     R1,R2,[SP, #+0]
   \        0x8   0x9302             STR      R3,[SP, #+8]
   \        0xA   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \        0xE   0x9A02             LDR      R2,[SP, #+8]
   1883            /* Check the parameters */
   1884            assert_param(IS_DMA2D_LAYER(LayerIdx));
   1885            assert_param(IS_DMA2D_CLUT_CM(CLUTCfg.CLUTColorMode));
   1886            assert_param(IS_DMA2D_CLUT_SIZE(CLUTCfg.Size));
   1887          
   1888            /* Process locked */
   1889            __HAL_LOCK(hdma2d);
   \       0x10   0xF894 0x3060      LDRB     R3,[R4, #+96]
   \       0x14   0x2B01             CMP      R3,#+1
   \       0x16   0xD101             BNE.N    ??HAL_DMA2D_ConfigCLUT_0
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0xE028             B.N      ??HAL_DMA2D_ConfigCLUT_1
   \                     ??HAL_DMA2D_ConfigCLUT_0: (+1)
   \       0x1C   0x9B05             LDR      R3,[SP, #+20]
   \       0x1E   0x2501             MOVS     R5,#+1
   \       0x20   0xF884 0x5060      STRB     R5,[R4, #+96]
   1890          
   1891            /* Change DMA2D peripheral state */
   1892            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x24   0x2502             MOVS     R5,#+2
   \       0x26   0xF884 0x5061      STRB     R5,[R4, #+97]
   1893          
   1894            /* Configure the CLUT of the background DMA2D layer */
   1895            if (LayerIdx == DMA2D_BACKGROUND_LAYER)
   \       0x2A   0x2B00             CMP      R3,#+0
   \       0x2C   0xD10C             BNE.N    ??HAL_DMA2D_ConfigCLUT_2
   1896            {
   1897              /* Write background CLUT memory address */
   1898              WRITE_REG(hdma2d->Instance->BGCMAR, (uint32_t)CLUTCfg.pCLUT);
   \       0x2E   0x6823             LDR      R3,[R4, #+0]
   \       0x30   0x6318             STR      R0,[R3, #+48]
   1899          
   1900              /* Write background CLUT size and CLUT color mode */
   1901              MODIFY_REG(hdma2d->Instance->BGPFCCR, (DMA2D_BGPFCCR_CS | DMA2D_BGPFCCR_CCM),
   1902                         ((CLUTCfg.Size << DMA2D_BGPFCCR_CS_Pos) | (CLUTCfg.CLUTColorMode << DMA2D_BGPFCCR_CCM_Pos)));
   \       0x32   0x6823             LDR      R3,[R4, #+0]
   \       0x34   0x6A5D             LDR      R5,[R3, #+36]
   \       0x36   0x....             LDR.N    R3,??DataTable7_3
   \       0x38   0x401D             ANDS     R5,R3,R5
   \       0x3A   0xEA55 0x2502      ORRS     R5,R5,R2, LSL #+8
   \       0x3E   0xEA55 0x1501      ORRS     R5,R5,R1, LSL #+4
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x6245             STR      R5,[R0, #+36]
   \       0x46   0xE00B             B.N      ??HAL_DMA2D_ConfigCLUT_3
   1903            }
   1904            /* Configure the CLUT of the foreground DMA2D layer */
   1905            else
   1906            {
   1907              /* Write foreground CLUT memory address */
   1908              WRITE_REG(hdma2d->Instance->FGCMAR, (uint32_t)CLUTCfg.pCLUT);
   \                     ??HAL_DMA2D_ConfigCLUT_2: (+1)
   \       0x48   0x6823             LDR      R3,[R4, #+0]
   \       0x4A   0x62D8             STR      R0,[R3, #+44]
   1909          
   1910              /* Write foreground CLUT size and CLUT color mode */
   1911              MODIFY_REG(hdma2d->Instance->FGPFCCR, (DMA2D_FGPFCCR_CS | DMA2D_FGPFCCR_CCM),
   1912                         ((CLUTCfg.Size << DMA2D_FGPFCCR_CS_Pos) | (CLUTCfg.CLUTColorMode << DMA2D_FGPFCCR_CCM_Pos)));
   \       0x4C   0x6823             LDR      R3,[R4, #+0]
   \       0x4E   0x69DD             LDR      R5,[R3, #+28]
   \       0x50   0x....             LDR.N    R3,??DataTable7_3
   \       0x52   0x401D             ANDS     R5,R3,R5
   \       0x54   0xEA55 0x2502      ORRS     R5,R5,R2, LSL #+8
   \       0x58   0xEA55 0x1501      ORRS     R5,R5,R1, LSL #+4
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x61C5             STR      R5,[R0, #+28]
   1913            }
   1914          
   1915            /* Set the DMA2D state to Ready*/
   1916            hdma2d->State = HAL_DMA2D_STATE_READY;
   \                     ??HAL_DMA2D_ConfigCLUT_3: (+1)
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0xF884 0x0061      STRB     R0,[R4, #+97]
   1917          
   1918            /* Process unlocked */
   1919            __HAL_UNLOCK(hdma2d);
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xF884 0x0060      STRB     R0,[R4, #+96]
   1920          
   1921            return HAL_OK;
   \       0x6C   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_ConfigCLUT_1: (+1)
   \       0x6E   0xBC3E             POP      {R1-R5}
   \       0x70   0x4770             BX       LR
   1922          }
   1923          
   1924          
   1925          /**
   1926            * @brief  Configure the line watermark.
   1927            * @param  hdma2d Pointer to a DMA2D_HandleTypeDef structure that contains
   1928            *                 the configuration information for the DMA2D.
   1929            * @param  Line   Line Watermark configuration (maximum 16-bit long value expected).
   1930            * @note   HAL_DMA2D_ProgramLineEvent() API enables the transfer watermark interrupt.
   1931            * @note   The transfer watermark interrupt is disabled once it has occurred.
   1932            * @retval HAL status
   1933            */
   1934          

   \                                 In section .text, align 2, keep-with-next
   1935          HAL_StatusTypeDef HAL_DMA2D_ProgramLineEvent(DMA2D_HandleTypeDef *hdma2d, uint32_t Line)
   1936          {
   1937            /* Check the parameters */
   1938            if (Line > DMA2D_LWR_LW)
   \                     HAL_DMA2D_ProgramLineEvent: (+1)
   \        0x0   0xF5B1 0x3F80      CMP      R1,#+65536
   \        0x4   0xD301             BCC.N    ??HAL_DMA2D_ProgramLineEvent_0
   1939            {
   1940              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xE01A             B.N      ??HAL_DMA2D_ProgramLineEvent_1
   1941            }
   1942            else
   1943            {
   1944              /* Process locked */
   1945              __HAL_LOCK(hdma2d);
   \                     ??HAL_DMA2D_ProgramLineEvent_0: (+1)
   \        0xA   0xF890 0x2060      LDRB     R2,[R0, #+96]
   \        0xE   0x2A01             CMP      R2,#+1
   \       0x10   0xD101             BNE.N    ??HAL_DMA2D_ProgramLineEvent_2
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xE014             B.N      ??HAL_DMA2D_ProgramLineEvent_1
   \                     ??HAL_DMA2D_ProgramLineEvent_2: (+1)
   \       0x16   0x2201             MOVS     R2,#+1
   \       0x18   0xF880 0x2060      STRB     R2,[R0, #+96]
   1946          
   1947              /* Change DMA2D peripheral state */
   1948              hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x1C   0x2202             MOVS     R2,#+2
   \       0x1E   0xF880 0x2061      STRB     R2,[R0, #+97]
   1949          
   1950              /* Sets the Line watermark configuration */
   1951              WRITE_REG(hdma2d->Instance->LWR, Line);
   \       0x22   0x6802             LDR      R2,[R0, #+0]
   \       0x24   0x6491             STR      R1,[R2, #+72]
   1952          
   1953              /* Enable the Line interrupt */
   1954              __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TW);
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0x6809             LDR      R1,[R1, #+0]
   \       0x2A   0xF451 0x6180      ORRS     R1,R1,#0x400
   \       0x2E   0x6802             LDR      R2,[R0, #+0]
   \       0x30   0x6011             STR      R1,[R2, #+0]
   1955          
   1956              /* Initialize the DMA2D state*/
   1957              hdma2d->State = HAL_DMA2D_STATE_READY;
   \       0x32   0x2101             MOVS     R1,#+1
   \       0x34   0xF880 0x1061      STRB     R1,[R0, #+97]
   1958          
   1959              /* Process unlocked */
   1960              __HAL_UNLOCK(hdma2d);
   \       0x38   0x2100             MOVS     R1,#+0
   \       0x3A   0xF880 0x1060      STRB     R1,[R0, #+96]
   1961          
   1962              return HAL_OK;
   \       0x3E   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_ProgramLineEvent_1: (+1)
   \       0x40   0x4770             BX       LR
   1963            }
   1964          }
   1965          
   1966          /**
   1967            * @brief Enable DMA2D dead time feature.
   1968            * @param hdma2d DMA2D handle.
   1969            * @retval HAL status
   1970            */

   \                                 In section .text, align 2, keep-with-next
   1971          HAL_StatusTypeDef HAL_DMA2D_EnableDeadTime(DMA2D_HandleTypeDef *hdma2d)
   1972          {
   1973            /* Process Locked */
   1974            __HAL_LOCK(hdma2d);
   \                     HAL_DMA2D_EnableDeadTime: (+1)
   \        0x0   0xF890 0x1060      LDRB     R1,[R0, #+96]
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD101             BNE.N    ??HAL_DMA2D_EnableDeadTime_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xE012             B.N      ??HAL_DMA2D_EnableDeadTime_1
   \                     ??HAL_DMA2D_EnableDeadTime_0: (+1)
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0xF880 0x1060      STRB     R1,[R0, #+96]
   1975          
   1976            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x12   0x2102             MOVS     R1,#+2
   \       0x14   0xF880 0x1061      STRB     R1,[R0, #+97]
   1977          
   1978            /* Set DMA2D_AMTCR EN bit */
   1979            SET_BIT(hdma2d->Instance->AMTCR, DMA2D_AMTCR_EN);
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0x6CC9             LDR      R1,[R1, #+76]
   \       0x1C   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x20   0x6802             LDR      R2,[R0, #+0]
   \       0x22   0x64D1             STR      R1,[R2, #+76]
   1980          
   1981            hdma2d->State = HAL_DMA2D_STATE_READY;
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0xF880 0x1061      STRB     R1,[R0, #+97]
   1982          
   1983            /* Process Unlocked */
   1984            __HAL_UNLOCK(hdma2d);
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0xF880 0x1060      STRB     R1,[R0, #+96]
   1985          
   1986            return HAL_OK;
   \       0x30   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_EnableDeadTime_1: (+1)
   \       0x32   0x4770             BX       LR
   1987          }
   1988          
   1989          /**
   1990            * @brief Disable DMA2D dead time feature.
   1991            * @param hdma2d DMA2D handle.
   1992            * @retval HAL status
   1993            */

   \                                 In section .text, align 2, keep-with-next
   1994          HAL_StatusTypeDef HAL_DMA2D_DisableDeadTime(DMA2D_HandleTypeDef *hdma2d)
   1995          {
   1996            /* Process Locked */
   1997            __HAL_LOCK(hdma2d);
   \                     HAL_DMA2D_DisableDeadTime: (+1)
   \        0x0   0xF890 0x1060      LDRB     R1,[R0, #+96]
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD101             BNE.N    ??HAL_DMA2D_DisableDeadTime_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xE012             B.N      ??HAL_DMA2D_DisableDeadTime_1
   \                     ??HAL_DMA2D_DisableDeadTime_0: (+1)
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0xF880 0x1060      STRB     R1,[R0, #+96]
   1998          
   1999            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x12   0x2102             MOVS     R1,#+2
   \       0x14   0xF880 0x1061      STRB     R1,[R0, #+97]
   2000          
   2001            /* Clear DMA2D_AMTCR EN bit */
   2002            CLEAR_BIT(hdma2d->Instance->AMTCR, DMA2D_AMTCR_EN);
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0x6CC9             LDR      R1,[R1, #+76]
   \       0x1C   0x0849             LSRS     R1,R1,#+1
   \       0x1E   0x0049             LSLS     R1,R1,#+1
   \       0x20   0x6802             LDR      R2,[R0, #+0]
   \       0x22   0x64D1             STR      R1,[R2, #+76]
   2003          
   2004            hdma2d->State = HAL_DMA2D_STATE_READY;
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0xF880 0x1061      STRB     R1,[R0, #+97]
   2005          
   2006            /* Process Unlocked */
   2007            __HAL_UNLOCK(hdma2d);
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0xF880 0x1060      STRB     R1,[R0, #+96]
   2008          
   2009            return HAL_OK;
   \       0x30   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_DisableDeadTime_1: (+1)
   \       0x32   0x4770             BX       LR
   2010          }
   2011          
   2012          /**
   2013            * @brief Configure dead time.
   2014            * @note The dead time value represents the guaranteed minimum number of cycles between
   2015            *       two consecutive transactions on the AHB bus.
   2016            * @param hdma2d DMA2D handle.
   2017            * @param DeadTime dead time value.
   2018            * @retval HAL status
   2019            */

   \                                 In section .text, align 2, keep-with-next
   2020          HAL_StatusTypeDef HAL_DMA2D_ConfigDeadTime(DMA2D_HandleTypeDef *hdma2d, uint8_t DeadTime)
   2021          {
   2022            /* Process Locked */
   2023            __HAL_LOCK(hdma2d);
   \                     HAL_DMA2D_ConfigDeadTime: (+1)
   \        0x0   0xF890 0x2060      LDRB     R2,[R0, #+96]
   \        0x4   0x2A01             CMP      R2,#+1
   \        0x6   0xD101             BNE.N    ??HAL_DMA2D_ConfigDeadTime_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xE012             B.N      ??HAL_DMA2D_ConfigDeadTime_1
   \                     ??HAL_DMA2D_ConfigDeadTime_0: (+1)
   \        0xC   0x2201             MOVS     R2,#+1
   \        0xE   0xF880 0x2060      STRB     R2,[R0, #+96]
   2024          
   2025            hdma2d->State = HAL_DMA2D_STATE_BUSY;
   \       0x12   0x2202             MOVS     R2,#+2
   \       0x14   0xF880 0x2061      STRB     R2,[R0, #+97]
   2026          
   2027            /* Set DMA2D_AMTCR DT field */
   2028            MODIFY_REG(hdma2d->Instance->AMTCR, DMA2D_AMTCR_DT, (((uint32_t) DeadTime) << DMA2D_AMTCR_DT_Pos));
   \       0x18   0x6802             LDR      R2,[R0, #+0]
   \       0x1A   0x6CD2             LDR      R2,[R2, #+76]
   \       0x1C   0xF361 0x220F      BFI      R2,R1,#+8,#+8
   \       0x20   0x6801             LDR      R1,[R0, #+0]
   \       0x22   0x64CA             STR      R2,[R1, #+76]
   2029          
   2030            hdma2d->State = HAL_DMA2D_STATE_READY;
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0xF880 0x1061      STRB     R1,[R0, #+97]
   2031          
   2032            /* Process Unlocked */
   2033            __HAL_UNLOCK(hdma2d);
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0xF880 0x1060      STRB     R1,[R0, #+96]
   2034          
   2035            return HAL_OK;
   \       0x30   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA2D_ConfigDeadTime_1: (+1)
   \       0x32   0x4770             BX       LR
   2036          }
   2037          
   2038          /**
   2039            * @}
   2040            */
   2041          
   2042          
   2043          /** @defgroup DMA2D_Exported_Functions_Group4 Peripheral State and Error functions
   2044            *  @brief    Peripheral State functions
   2045            *
   2046          @verbatim
   2047           ===============================================================================
   2048                            ##### Peripheral State and Errors functions #####
   2049           ===============================================================================
   2050              [..]
   2051              This subsection provides functions allowing to:
   2052                (+) Get the DMA2D state
   2053                (+) Get the DMA2D error code
   2054          
   2055          @endverbatim
   2056            * @{
   2057            */
   2058          
   2059          /**
   2060            * @brief  Return the DMA2D state
   2061            * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
   2062            *                 the configuration information for the DMA2D.
   2063            * @retval HAL state
   2064            */

   \                                 In section .text, align 2, keep-with-next
   2065          HAL_DMA2D_StateTypeDef HAL_DMA2D_GetState(DMA2D_HandleTypeDef *hdma2d)
   2066          {
   2067            return hdma2d->State;
   \                     HAL_DMA2D_GetState: (+1)
   \        0x0   0xF890 0x0061      LDRB     R0,[R0, #+97]
   \        0x4   0x4770             BX       LR
   2068          }
   2069          
   2070          /**
   2071            * @brief  Return the DMA2D error code
   2072            * @param  hdma2d  pointer to a DMA2D_HandleTypeDef structure that contains
   2073            *               the configuration information for DMA2D.
   2074            * @retval DMA2D Error Code
   2075            */

   \                                 In section .text, align 2, keep-with-next
   2076          uint32_t HAL_DMA2D_GetError(DMA2D_HandleTypeDef *hdma2d)
   2077          {
   2078            return hdma2d->ErrorCode;
   \                     HAL_DMA2D_GetError: (+1)
   \        0x0   0x6E40             LDR      R0,[R0, #+100]
   \        0x2   0x4770             BX       LR
   2079          }
   2080          
   2081          /**
   2082            * @}
   2083            */
   2084          
   2085          /**
   2086            * @}
   2087            */
   2088          
   2089          
   2090          /** @defgroup DMA2D_Private_Functions DMA2D Private Functions
   2091            * @{
   2092            */
   2093          
   2094          /**
   2095            * @brief  Set the DMA2D transfer parameters.
   2096            * @param  hdma2d     Pointer to a DMA2D_HandleTypeDef structure that contains
   2097            *                     the configuration information for the specified DMA2D.
   2098            * @param  pdata      The source memory Buffer address
   2099            * @param  DstAddress The destination memory Buffer address
   2100            * @param  Width      The width of data to be transferred from source to destination.
   2101            * @param  Height     The height of data to be transferred from source to destination.
   2102            * @retval HAL status
   2103            */

   \                                 In section .text, align 2, keep-with-next
   2104          static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
   2105                                      uint32_t Height)
   2106          {
   \                     DMA2D_SetConfig: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x9C02             LDR      R4,[SP, #+8]
   2107            uint32_t tmp;
   2108            uint32_t tmp1;
   2109            uint32_t tmp2;
   2110            uint32_t tmp3;
   2111            uint32_t tmp4;
   2112          
   2113            /* Configure DMA2D data size */
   2114            MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
   \        0x4   0x6805             LDR      R5,[R0, #+0]
   \        0x6   0x6C6D             LDR      R5,[R5, #+68]
   \        0x8   0xF015 0x4540      ANDS     R5,R5,#0xC0000000
   \        0xC   0xEA54 0x4403      ORRS     R4,R4,R3, LSL #+16
   \       0x10   0x432C             ORRS     R4,R4,R5
   \       0x12   0x6803             LDR      R3,[R0, #+0]
   \       0x14   0x645C             STR      R4,[R3, #+68]
   2115          
   2116            /* Configure DMA2D destination address */
   2117            WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
   \       0x16   0x6803             LDR      R3,[R0, #+0]
   \       0x18   0x63DA             STR      R2,[R3, #+60]
   2118          
   2119            /* Register to memory DMA2D mode selected */
   2120            if (hdma2d->Init.Mode == DMA2D_R2M)
   \       0x1A   0x6842             LDR      R2,[R0, #+4]
   \       0x1C   0xF5B2 0x3F40      CMP      R2,#+196608
   \       0x20   0xD140             BNE.N    ??DMA2D_SetConfig_0
   2121            {
   2122              tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
   \       0x22   0xF011 0x447F      ANDS     R4,R1,#0xFF000000
   2123              tmp2 = pdata & DMA2D_OCOLR_RED_1;
   \       0x26   0xF411 0x057F      ANDS     R5,R1,#0xFF0000
   2124              tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
   \       0x2A   0xF411 0x437F      ANDS     R3,R1,#0xFF00
   2125              tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
   \       0x2E   0xF001 0x01FF      AND      R1,R1,#0xFF
   2126          
   2127              /* Prepare the value to be written to the OCOLR register according to the color mode */
   2128              if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
   \       0x32   0x6882             LDR      R2,[R0, #+8]
   \       0x34   0x2A00             CMP      R2,#+0
   \       0x36   0xD103             BNE.N    ??DMA2D_SetConfig_1
   2129              {
   2130                tmp = (tmp3 | tmp2 | tmp1 | tmp4);
   \       0x38   0x432B             ORRS     R3,R5,R3
   \       0x3A   0x4323             ORRS     R3,R4,R3
   \       0x3C   0x430B             ORRS     R3,R1,R3
   \       0x3E   0xE02E             B.N      ??DMA2D_SetConfig_2
   2131              }
   2132              else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
   \                     ??DMA2D_SetConfig_1: (+1)
   \       0x40   0x6882             LDR      R2,[R0, #+8]
   \       0x42   0x2A01             CMP      R2,#+1
   \       0x44   0xD102             BNE.N    ??DMA2D_SetConfig_3
   2133              {
   2134                tmp = (tmp3 | tmp2 | tmp4);
   \       0x46   0x432B             ORRS     R3,R5,R3
   \       0x48   0x430B             ORRS     R3,R1,R3
   \       0x4A   0xE028             B.N      ??DMA2D_SetConfig_2
   2135              }
   2136              else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
   \                     ??DMA2D_SetConfig_3: (+1)
   \       0x4C   0x6882             LDR      R2,[R0, #+8]
   \       0x4E   0x2A02             CMP      R2,#+2
   \       0x50   0xD109             BNE.N    ??DMA2D_SetConfig_4
   2137              {
   2138                tmp2 = (tmp2 >> 19U);
   \       0x52   0x0CED             LSRS     R5,R5,#+19
   2139                tmp3 = (tmp3 >> 10U);
   \       0x54   0x0A9B             LSRS     R3,R3,#+10
   2140                tmp4 = (tmp4 >> 3U);
   \       0x56   0x08C9             LSRS     R1,R1,#+3
   2141                tmp  = ((tmp3 << 5U) | (tmp2 << 11U) | tmp4);
   \       0x58   0x001A             MOVS     R2,R3
   \       0x5A   0x002B             MOVS     R3,R5
   \       0x5C   0x02DB             LSLS     R3,R3,#+11
   \       0x5E   0xEA53 0x1342      ORRS     R3,R3,R2, LSL #+5
   \       0x62   0x430B             ORRS     R3,R1,R3
   \       0x64   0xE01B             B.N      ??DMA2D_SetConfig_2
   2142              }
   2143              else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
   \                     ??DMA2D_SetConfig_4: (+1)
   \       0x66   0x6882             LDR      R2,[R0, #+8]
   \       0x68   0x2A03             CMP      R2,#+3
   \       0x6A   0xD10C             BNE.N    ??DMA2D_SetConfig_5
   2144              {
   2145                tmp1 = (tmp1 >> 31U);
   \       0x6C   0x0FE4             LSRS     R4,R4,#+31
   2146                tmp2 = (tmp2 >> 19U);
   \       0x6E   0x0CED             LSRS     R5,R5,#+19
   2147                tmp3 = (tmp3 >> 11U);
   \       0x70   0x0ADB             LSRS     R3,R3,#+11
   2148                tmp4 = (tmp4 >> 3U);
   \       0x72   0x08C9             LSRS     R1,R1,#+3
   2149                tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
   \       0x74   0x001A             MOVS     R2,R3
   \       0x76   0x002B             MOVS     R3,R5
   \       0x78   0x029B             LSLS     R3,R3,#+10
   \       0x7A   0xEA53 0x1342      ORRS     R3,R3,R2, LSL #+5
   \       0x7E   0xEA53 0x33C4      ORRS     R3,R3,R4, LSL #+15
   \       0x82   0x430B             ORRS     R3,R1,R3
   \       0x84   0xE00B             B.N      ??DMA2D_SetConfig_2
   2150              }
   2151              else /* Dhdma2d->Init.ColorMode = DMA2D_OUTPUT_ARGB4444 */
   2152              {
   2153                tmp1 = (tmp1 >> 28U);
   \                     ??DMA2D_SetConfig_5: (+1)
   \       0x86   0x0F24             LSRS     R4,R4,#+28
   2154                tmp2 = (tmp2 >> 20U);
   \       0x88   0x0D2D             LSRS     R5,R5,#+20
   2155                tmp3 = (tmp3 >> 12U);
   \       0x8A   0x0B1B             LSRS     R3,R3,#+12
   2156                tmp4 = (tmp4 >> 4U);
   \       0x8C   0x0909             LSRS     R1,R1,#+4
   2157                tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
   \       0x8E   0x001A             MOVS     R2,R3
   \       0x90   0x002B             MOVS     R3,R5
   \       0x92   0x021B             LSLS     R3,R3,#+8
   \       0x94   0xEA53 0x1302      ORRS     R3,R3,R2, LSL #+4
   \       0x98   0xEA53 0x3304      ORRS     R3,R3,R4, LSL #+12
   \       0x9C   0x430B             ORRS     R3,R1,R3
   2158              }
   2159              /* Write to DMA2D OCOLR register */
   2160              WRITE_REG(hdma2d->Instance->OCOLR, tmp);
   \                     ??DMA2D_SetConfig_2: (+1)
   \       0x9E   0x6800             LDR      R0,[R0, #+0]
   \       0xA0   0x6383             STR      R3,[R0, #+56]
   \       0xA2   0xE008             B.N      ??DMA2D_SetConfig_6
   2161            }
   2162            else if (hdma2d->Init.Mode == DMA2D_M2M_BLEND_FG) /*M2M_blending with fixed color FG DMA2D Mode selected*/
   \                     ??DMA2D_SetConfig_0: (+1)
   \       0xA4   0x6842             LDR      R2,[R0, #+4]
   \       0xA6   0xF5B2 0x2F80      CMP      R2,#+262144
   \       0xAA   0xD102             BNE.N    ??DMA2D_SetConfig_7
   2163            {
   2164              WRITE_REG(hdma2d->Instance->BGMAR, pdata);
   \       0xAC   0x6800             LDR      R0,[R0, #+0]
   \       0xAE   0x6141             STR      R1,[R0, #+20]
   \       0xB0   0xE001             B.N      ??DMA2D_SetConfig_6
   2165            }
   2166            else /* M2M, M2M_PFC,M2M_Blending or M2M_blending with fixed color BG DMA2D Mode */
   2167            {
   2168              /* Configure DMA2D source address */
   2169              WRITE_REG(hdma2d->Instance->FGMAR, pdata);
   \                     ??DMA2D_SetConfig_7: (+1)
   \       0xB2   0x6800             LDR      R0,[R0, #+0]
   \       0xB4   0x60C1             STR      R1,[R0, #+12]
   2170            }
   2171          }
   \                     ??DMA2D_SetConfig_6: (+1)
   \       0xB6   0xBC30             POP      {R4,R5}
   \       0xB8   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0xFFF8'FFBF        DC32     0xfff8ffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0xFFFF'FEF8        DC32     0xfffffef8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x5802'4534        DC32     0x58024534

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0xFFFF'00EF        DC32     0xffff00ef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0xFF33'000F        DC32     0xff33000f
   2172          
   2173          /**
   2174            * @}
   2175            */
   2176          
   2177          /**
   2178            * @}
   2179            */
   2180          
   2181          /**
   2182            * @}
   2183            */
   2184          #endif /* DMA2D */
   2185          #endif /* HAL_DMA2D_MODULE_ENABLED */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DMA2D_SetConfig
      16   HAL_DMA2D_Abort
        16   -> HAL_GetTick
      24   HAL_DMA2D_BlendingStart
        24   -> DMA2D_SetConfig
      24   HAL_DMA2D_BlendingStart_IT
        24   -> DMA2D_SetConfig
      20   HAL_DMA2D_CLUTLoad
      20   HAL_DMA2D_CLUTLoad_IT
       0   HAL_DMA2D_CLUTLoadingCpltCallback
      16   HAL_DMA2D_CLUTLoading_Abort
        16   -> HAL_GetTick
       0   HAL_DMA2D_CLUTLoading_Resume
      16   HAL_DMA2D_CLUTLoading_Suspend
        16   -> HAL_GetTick
       0   HAL_DMA2D_CLUTStartLoad
       0   HAL_DMA2D_CLUTStartLoad_IT
      20   HAL_DMA2D_ConfigCLUT
       0   HAL_DMA2D_ConfigDeadTime
       8   HAL_DMA2D_ConfigLayer
       8   HAL_DMA2D_DeInit
         8   -> HAL_DMA2D_Abort
         8   -> HAL_DMA2D_CLUTLoading_Abort
         8   -> HAL_DMA2D_MspDeInit
       0   HAL_DMA2D_DisableDeadTime
       0   HAL_DMA2D_EnableCLUT
       0   HAL_DMA2D_EnableDeadTime
       0   HAL_DMA2D_GetError
       0   HAL_DMA2D_GetState
      16   HAL_DMA2D_IRQHandler
        16   -- Indirect call
        16   -> HAL_DMA2D_CLUTLoadingCpltCallback
        16   -> HAL_DMA2D_LineEventCallback
       8   HAL_DMA2D_Init
         8   -> HAL_DMA2D_MspInit
       0   HAL_DMA2D_LineEventCallback
       0   HAL_DMA2D_MspDeInit
       0   HAL_DMA2D_MspInit
      24   HAL_DMA2D_PollForTransfer
        24   -> HAL_GetTick
       0   HAL_DMA2D_ProgramLineEvent
       0   HAL_DMA2D_Resume
      16   HAL_DMA2D_Start
        16   -> DMA2D_SetConfig
      16   HAL_DMA2D_Start_IT
        16   -> DMA2D_SetConfig
      16   HAL_DMA2D_Suspend
        16   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
     186  DMA2D_SetConfig
     100  HAL_DMA2D_Abort
     110  HAL_DMA2D_BlendingStart
     122  HAL_DMA2D_BlendingStart_IT
     130  HAL_DMA2D_CLUTLoad
     154  HAL_DMA2D_CLUTLoad_IT
       2  HAL_DMA2D_CLUTLoadingCpltCallback
     110  HAL_DMA2D_CLUTLoading_Abort
      66  HAL_DMA2D_CLUTLoading_Resume
     158  HAL_DMA2D_CLUTLoading_Suspend
     122  HAL_DMA2D_CLUTStartLoad
     146  HAL_DMA2D_CLUTStartLoad_IT
     114  HAL_DMA2D_ConfigCLUT
      52  HAL_DMA2D_ConfigDeadTime
     238  HAL_DMA2D_ConfigLayer
     160  HAL_DMA2D_DeInit
      52  HAL_DMA2D_DisableDeadTime
      58  HAL_DMA2D_EnableCLUT
      52  HAL_DMA2D_EnableDeadTime
       4  HAL_DMA2D_GetError
       6  HAL_DMA2D_GetState
     322  HAL_DMA2D_IRQHandler
     136  HAL_DMA2D_Init
       2  HAL_DMA2D_LineEventCallback
       2  HAL_DMA2D_MspDeInit
       2  HAL_DMA2D_MspInit
     320  HAL_DMA2D_PollForTransfer
      66  HAL_DMA2D_ProgramLineEvent
      34  HAL_DMA2D_Resume
      54  HAL_DMA2D_Start
      66  HAL_DMA2D_Start_IT
     100  HAL_DMA2D_Suspend

 
 3'266 bytes in section .text
 
 3'258 bytes of CODE memory (+ 8 bytes shared)

Errors: none
Warnings: none
