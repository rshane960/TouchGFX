###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         09/Feb/2022  10:51:18
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_gpio.c
#        [UTF-8]
#    Command line      =
#        -f
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_gpio.o.rsp
#        (D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_gpio.c
#        -D USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver
#        -lA
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver
#        -o
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Core/Inc\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/App\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_gpio.o.d
#    Locale            =  C
#    List file         =
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_gpio.lst
#    Object file       =
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_gpio.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32h7xx_hal_gpio.c
      4            * @author  MCD Application Team
      5            * @brief   GPIO HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the General Purpose Input/Output (GPIO) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *
     11            ******************************************************************************
     12            * @attention
     13            *
     14            * Copyright (c) 2017 STMicroelectronics.
     15            * All rights reserved.
     16            *
     17            * This software is licensed under terms that can be found in the LICENSE file
     18            * in the root directory of this software component.
     19            * If no LICENSE file comes with this software, it is provided AS-IS.
     20            *
     21            ******************************************************************************
     22            @verbatim
     23            ==============================================================================
     24                              ##### GPIO Peripheral features #####
     25            ==============================================================================
     26            [..]
     27              (+) Each port bit of the general-purpose I/O (GPIO) ports can be individually
     28                  configured by software in several modes:
     29                  (++) Input mode
     30                  (++) Analog mode
     31                  (++) Output mode
     32                  (++) Alternate function mode
     33                  (++) External interrupt/event lines
     34          
     35              (+) During and just after reset, the alternate functions and external interrupt
     36                  lines are not active and the I/O ports are configured in input floating mode.
     37          
     38              (+) All GPIO pins have weak internal pull-up and pull-down resistors, which can be
     39                  activated or not.
     40          
     41              (+) In Output or Alternate mode, each IO can be configured on open-drain or push-pull
     42                  type and the IO speed can be selected depending on the VDD value.
     43          
     44              (+) The microcontroller IO pins are connected to onboard peripherals/modules through a
     45                  multiplexer that allows only one peripheral alternate function (AF) connected
     46                 to an IO pin at a time. In this way, there can be no conflict between peripherals
     47                 sharing the same IO pin.
     48          
     49              (+) All ports have external interrupt/event capability. To use external interrupt
     50                  lines, the port must be configured in input mode. All available GPIO pins are
     51                  connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.
     52          
     53            The external interrupt/event controller consists of up to 23 edge detectors
     54                  (16 lines are connected to GPIO) for generating event/interrupt requests (each
     55                  input line can be independently configured to select the type (interrupt or event)
     56                  and the corresponding trigger event (rising or falling or both). Each line can
     57                  also be masked independently.
     58          
     59                               ##### How to use this driver #####
     60            ==============================================================================
     61            [..]
     62              (#) Enable the GPIO AHB clock using the following function: __HAL_RCC_GPIOx_CLK_ENABLE().
     63          
     64              (#) Configure the GPIO pin(s) using HAL_GPIO_Init().
     65                  (++) Configure the IO mode using "Mode" member from GPIO_InitTypeDef structure
     66                  (++) Activate Pull-up, Pull-down resistor using "Pull" member from GPIO_InitTypeDef
     67                       structure.
     68                  (++) In case of Output or alternate function mode selection: the speed is
     69                       configured through "Speed" member from GPIO_InitTypeDef structure.
     70                  (++) In alternate mode is selection, the alternate function connected to the IO
     71                       is configured through "Alternate" member from GPIO_InitTypeDef structure.
     72                  (++) Analog mode is required when a pin is to be used as ADC channel
     73                       or DAC output.
     74                  (++) In case of external interrupt/event selection the "Mode" member from
     75                       GPIO_InitTypeDef structure select the type (interrupt or event) and
     76                       the corresponding trigger event (rising or falling or both).
     77          
     78              (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority
     79                  mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using
     80                  HAL_NVIC_EnableIRQ().
     81          
     82              (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().
     83          
     84              (#) To set/reset the level of a pin configured in output mode use
     85                  HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().
     86          
     87             (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().
     88          
     89          
     90              (#) During and just after reset, the alternate functions are not
     91                  active and the GPIO pins are configured in input floating mode (except JTAG
     92                  pins).
     93          
     94              (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose
     95                  (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has
     96                  priority over the GPIO function.
     97          
     98              (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as
     99                  general purpose PH0 and PH1, respectively, when the HSE oscillator is off.
    100                  The HSE has priority over the GPIO function.
    101          
    102            @endverbatim
    103            ******************************************************************************
    104            */
    105          
    106          /* Includes ------------------------------------------------------------------*/
    107          #include "stm32h7xx_hal.h"
    108          
    109          /** @addtogroup STM32H7xx_HAL_Driver
    110            * @{
    111            */
    112          
    113          /** @defgroup GPIO  GPIO
    114            * @brief GPIO HAL module driver
    115            * @{
    116            */
    117          
    118          #ifdef HAL_GPIO_MODULE_ENABLED
    119          
    120          /* Private typedef -----------------------------------------------------------*/
    121          /* Private defines ------------------------------------------------------------*/
    122          /** @addtogroup GPIO_Private_Constants GPIO Private Constants
    123            * @{
    124            */
    125          
    126          #if defined(DUAL_CORE)
    127          #define EXTI_CPU1             (0x01000000U)
    128          #define EXTI_CPU2             (0x02000000U)
    129          #endif /*DUAL_CORE*/
    130          #define GPIO_NUMBER           (16U)
    131          /**
    132            * @}
    133            */
    134          /* Private macro -------------------------------------------------------------*/
    135          /* Private variables ---------------------------------------------------------*/
    136          /* Private function prototypes -----------------------------------------------*/
    137          /* Private functions ---------------------------------------------------------*/
    138          /* Exported functions --------------------------------------------------------*/
    139          /** @defgroup GPIO_Exported_Functions GPIO Exported Functions
    140            * @{
    141            */
    142          
    143          /** @defgroup GPIO_Exported_Functions_Group1 Initialization and de-initialization functions
    144           *  @brief    Initialization and Configuration functions
    145           *
    146          @verbatim
    147           ===============================================================================
    148                        ##### Initialization and de-initialization functions #####
    149           ===============================================================================
    150            [..]
    151              This section provides functions allowing to initialize and de-initialize the GPIOs
    152              to be ready for use.
    153          
    154          @endverbatim
    155            * @{
    156            */
    157          
    158          /**
    159            * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.
    160            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral.
    161            * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
    162            *         the configuration information for the specified GPIO peripheral.
    163            * @retval None
    164            */

   \                                 In section .text, align 2, keep-with-next
    165          void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
    166          {
   \                     HAL_GPIO_Init: (+1)
   \        0x0   0xB4F8             PUSH     {R3-R7}
   \        0x2   0x0002             MOVS     R2,R0
    167            uint32_t position = 0x00U;
   \        0x4   0x2500             MOVS     R5,#+0
    168            uint32_t iocurrent;
    169            uint32_t temp;
    170            EXTI_Core_TypeDef *EXTI_CurrentCPU;
    171          
    172          #if defined(DUAL_CORE) && defined(CORE_CM4)
    173            EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
    174          #else
    175            EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
   \        0x6   0x.... 0x....      LDR.W    R4,??DataTable2
    176          #endif
    177          
    178            /* Check the parameters */
    179            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    180            assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    181            assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
   \        0xA   0xE036             B.N      ??HAL_GPIO_Init_0
    182          
    183            /* Configure the port pins */
    184            while (((GPIO_Init->Pin) >> position) != 0x00U)
    185            {
    186              /* Get current io position */
    187              iocurrent = (GPIO_Init->Pin) & (1UL << position);
    188          
    189              if (iocurrent != 0x00U)
    190              {
    191                /*--------------------- GPIO Mode Configuration ------------------------*/
    192                /* In case of Output or Alternate function mode selection */
    193                if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
    194                {
    195                  /* Check the Speed parameter */
    196                  assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    197          
    198                  /* Configure the IO Speed */
    199                  temp = GPIOx->OSPEEDR;
    200                  temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
    201                  temp |= (GPIO_Init->Speed << (position * 2U));
    202                  GPIOx->OSPEEDR = temp;
    203          
    204                  /* Configure the IO Output Type */
    205                  temp = GPIOx->OTYPER;
    206                  temp &= ~(GPIO_OTYPER_OT0 << position) ;
    207                  temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
    208                  GPIOx->OTYPER = temp;
    209                }
    210          
    211                if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
    212                {
    213                 /* Check the Pull parameter */
    214                 assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
    215          
    216                /* Activate the Pull-up or Pull down resistor for the current IO */
    217                temp = GPIOx->PUPDR;
    218                temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    219                temp |= ((GPIO_Init->Pull) << (position * 2U));
    220                GPIOx->PUPDR = temp;
    221                }
    222          
    223                /* In case of Alternate function mode selection */
    224                if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
    225                {
    226                  /* Check the Alternate function parameters */
    227                  assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    228                  assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    229          
    230                  /* Configure Alternate function mapped with the current IO */
    231                  temp = GPIOx->AFR[position >> 3U];
    232                  temp &= ~(0xFU << ((position & 0x07U) * 4U));
    233                  temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
    234                  GPIOx->AFR[position >> 3U] = temp;
    235                }
    236          
    237                /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
    238                temp = GPIOx->MODER;
    239                temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
    240                temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
    241                GPIOx->MODER = temp;
    242          
    243                /*--------------------- EXTI Mode Configuration ------------------------*/
    244                /* Configure the External Interrupt or event for the current IO */
    245                if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
    246                {
    247                  /* Enable SYSCFG Clock */
    248                  __HAL_RCC_SYSCFG_CLK_ENABLE();
    249          
    250                  temp = SYSCFG->EXTICR[position >> 2U];
    251                  temp &= ~(0x0FUL << (4U * (position & 0x03U)));
    252                  temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
   \                     ??HAL_GPIO_Init_1: (+1)
   \        0xC   0xF05F 0x0C0A      MOVS     R12,#+10
   \       0x10   0xE005             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_3: (+1)
   \       0x12   0x.... 0x....      LDR.W    R3,??DataTable2_1
   \       0x16   0x429A             CMP      R2,R3
   \       0x18   0xD1F8             BNE.N    ??HAL_GPIO_Init_1
   \       0x1A   0xF05F 0x0C09      MOVS     R12,#+9
   \                     ??HAL_GPIO_Init_2: (+1)
   \       0x1E   0xF015 0x0303      ANDS     R3,R5,#0x3
   \       0x22   0xB2DB             UXTB     R3,R3
   \       0x24   0x009B             LSLS     R3,R3,#+2
   \       0x26   0xFA1C 0xFC03      LSLS     R12,R12,R3
   \       0x2A   0xEA5C 0x0707      ORRS     R7,R12,R7
    253                  SYSCFG->EXTICR[position >> 2U] = temp;
   \       0x2E   0x002B             MOVS     R3,R5
   \       0x30   0x089B             LSRS     R3,R3,#+2
   \       0x32   0xF846 0x7023      STR      R7,[R6, R3, LSL #+2]
    254          
    255                  /* Clear Rising Falling edge configuration */
    256                  temp = EXTI->RTSR1;
   \       0x36   0xF05F 0x46B0      MOVS     R6,#+1476395008
   \       0x3A   0x6833             LDR      R3,[R6, #+0]
    257                  temp &= ~(iocurrent);
   \       0x3C   0x4383             BICS     R3,R3,R0
    258                  if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
   \       0x3E   0x684F             LDR      R7,[R1, #+4]
   \       0x40   0x02FF             LSLS     R7,R7,#+11
   \       0x42   0xD500             BPL.N    ??HAL_GPIO_Init_4
    259                  {
    260                    temp |= iocurrent;
   \       0x44   0x4303             ORRS     R3,R0,R3
    261                  }
    262                  EXTI->RTSR1 = temp;
   \                     ??HAL_GPIO_Init_4: (+1)
   \       0x46   0x6033             STR      R3,[R6, #+0]
    263          
    264                  temp = EXTI->FTSR1;
   \       0x48   0x.... 0x....      LDR.W    R6,??DataTable2_2
   \       0x4C   0x6833             LDR      R3,[R6, #+0]
    265                  temp &= ~(iocurrent);
   \       0x4E   0x4383             BICS     R3,R3,R0
    266                  if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
   \       0x50   0x684F             LDR      R7,[R1, #+4]
   \       0x52   0x02BF             LSLS     R7,R7,#+10
   \       0x54   0xD500             BPL.N    ??HAL_GPIO_Init_5
    267                  {
    268                    temp |= iocurrent;
   \       0x56   0x4303             ORRS     R3,R0,R3
    269                  }
    270                  EXTI->FTSR1 = temp;
   \                     ??HAL_GPIO_Init_5: (+1)
   \       0x58   0x6033             STR      R3,[R6, #+0]
    271          
    272                  temp = EXTI_CurrentCPU->EMR1;
   \       0x5A   0x6863             LDR      R3,[R4, #+4]
    273                  temp &= ~(iocurrent);
   \       0x5C   0x4383             BICS     R3,R3,R0
    274                  if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
   \       0x5E   0x684E             LDR      R6,[R1, #+4]
   \       0x60   0x03B6             LSLS     R6,R6,#+14
   \       0x62   0xD500             BPL.N    ??HAL_GPIO_Init_6
    275                  {
    276                    temp |= iocurrent;
   \       0x64   0x4303             ORRS     R3,R0,R3
    277                  }
    278                  EXTI_CurrentCPU->EMR1 = temp;
   \                     ??HAL_GPIO_Init_6: (+1)
   \       0x66   0x6063             STR      R3,[R4, #+4]
    279          
    280                  /* Clear EXTI line configuration */
    281                  temp = EXTI_CurrentCPU->IMR1;
   \       0x68   0x6823             LDR      R3,[R4, #+0]
    282                  temp &= ~(iocurrent);
   \       0x6A   0x4383             BICS     R3,R3,R0
    283                  if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
   \       0x6C   0x684E             LDR      R6,[R1, #+4]
   \       0x6E   0x03F6             LSLS     R6,R6,#+15
   \       0x70   0xD501             BPL.N    ??HAL_GPIO_Init_7
    284                  {
    285                    temp |= iocurrent;
   \       0x72   0x4318             ORRS     R0,R0,R3
   \       0x74   0x0003             MOVS     R3,R0
    286                  }
    287                  EXTI_CurrentCPU->IMR1 = temp;
   \                     ??HAL_GPIO_Init_7: (+1)
   \       0x76   0x6023             STR      R3,[R4, #+0]
    288                }
    289              }
    290          
    291              position++;
   \                     ??HAL_GPIO_Init_8: (+1)
   \       0x78   0x1C6D             ADDS     R5,R5,#+1
   \                     ??HAL_GPIO_Init_0: (+1)
   \       0x7A   0x6808             LDR      R0,[R1, #+0]
   \       0x7C   0x40E8             LSRS     R0,R0,R5
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xF000 0x80C2      BEQ.W    ??HAL_GPIO_Init_9
   \       0x84   0x2601             MOVS     R6,#+1
   \       0x86   0x6808             LDR      R0,[R1, #+0]
   \       0x88   0xFA16 0xF305      LSLS     R3,R6,R5
   \       0x8C   0x4018             ANDS     R0,R3,R0
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD0F2             BEQ.N    ??HAL_GPIO_Init_8
   \       0x92   0x790B             LDRB     R3,[R1, #+4]
   \       0x94   0xF013 0x0303      ANDS     R3,R3,#0x3
   \       0x98   0x2B01             CMP      R3,#+1
   \       0x9A   0xD004             BEQ.N    ??HAL_GPIO_Init_10
   \       0x9C   0x790B             LDRB     R3,[R1, #+4]
   \       0x9E   0xF013 0x0303      ANDS     R3,R3,#0x3
   \       0xA2   0x2B02             CMP      R3,#+2
   \       0xA4   0xD11C             BNE.N    ??HAL_GPIO_Init_11
   \                     ??HAL_GPIO_Init_10: (+1)
   \       0xA6   0x6897             LDR      R7,[R2, #+8]
   \       0xA8   0xF05F 0x0C03      MOVS     R12,#+3
   \       0xAC   0x002B             MOVS     R3,R5
   \       0xAE   0xB2DB             UXTB     R3,R3
   \       0xB0   0x005B             LSLS     R3,R3,#+1
   \       0xB2   0xFA1C 0xFC03      LSLS     R12,R12,R3
   \       0xB6   0xEA37 0x070C      BICS     R7,R7,R12
   \       0xBA   0xF8D1 0xC00C      LDR      R12,[R1, #+12]
   \       0xBE   0x002B             MOVS     R3,R5
   \       0xC0   0xB2DB             UXTB     R3,R3
   \       0xC2   0x005B             LSLS     R3,R3,#+1
   \       0xC4   0xFA1C 0xFC03      LSLS     R12,R12,R3
   \       0xC8   0xEA5C 0x0707      ORRS     R7,R12,R7
   \       0xCC   0x6097             STR      R7,[R2, #+8]
   \       0xCE   0x6853             LDR      R3,[R2, #+4]
   \       0xD0   0x40AE             LSLS     R6,R6,R5
   \       0xD2   0x43B3             BICS     R3,R3,R6
   \       0xD4   0x684E             LDR      R6,[R1, #+4]
   \       0xD6   0xF3C6 0x1600      UBFX     R6,R6,#+4,#+1
   \       0xDA   0x40AE             LSLS     R6,R6,R5
   \       0xDC   0x4333             ORRS     R3,R6,R3
   \       0xDE   0x6053             STR      R3,[R2, #+4]
   \                     ??HAL_GPIO_Init_11: (+1)
   \       0xE0   0x790B             LDRB     R3,[R1, #+4]
   \       0xE2   0xF013 0x0303      ANDS     R3,R3,#0x3
   \       0xE6   0x2B03             CMP      R3,#+3
   \       0xE8   0xD00D             BEQ.N    ??HAL_GPIO_Init_12
   \       0xEA   0x68D6             LDR      R6,[R2, #+12]
   \       0xEC   0x2703             MOVS     R7,#+3
   \       0xEE   0x002B             MOVS     R3,R5
   \       0xF0   0xB2DB             UXTB     R3,R3
   \       0xF2   0x005B             LSLS     R3,R3,#+1
   \       0xF4   0x409F             LSLS     R7,R7,R3
   \       0xF6   0x43BE             BICS     R6,R6,R7
   \       0xF8   0x688F             LDR      R7,[R1, #+8]
   \       0xFA   0x002B             MOVS     R3,R5
   \       0xFC   0xB2DB             UXTB     R3,R3
   \       0xFE   0x005B             LSLS     R3,R3,#+1
   \      0x100   0x409F             LSLS     R7,R7,R3
   \      0x102   0x433E             ORRS     R6,R7,R6
   \      0x104   0x60D6             STR      R6,[R2, #+12]
   \                     ??HAL_GPIO_Init_12: (+1)
   \      0x106   0x790B             LDRB     R3,[R1, #+4]
   \      0x108   0xF013 0x0303      ANDS     R3,R3,#0x3
   \      0x10C   0x2B02             CMP      R3,#+2
   \      0x10E   0xD117             BNE.N    ??HAL_GPIO_Init_13
   \      0x110   0x002B             MOVS     R3,R5
   \      0x112   0x08DB             LSRS     R3,R3,#+3
   \      0x114   0xEB02 0x0383      ADD      R3,R2,R3, LSL #+2
   \      0x118   0x6A1E             LDR      R6,[R3, #+32]
   \      0x11A   0x270F             MOVS     R7,#+15
   \      0x11C   0xF015 0x0307      ANDS     R3,R5,#0x7
   \      0x120   0xB2DB             UXTB     R3,R3
   \      0x122   0x009B             LSLS     R3,R3,#+2
   \      0x124   0x409F             LSLS     R7,R7,R3
   \      0x126   0x43BE             BICS     R6,R6,R7
   \      0x128   0x690F             LDR      R7,[R1, #+16]
   \      0x12A   0xF015 0x0307      ANDS     R3,R5,#0x7
   \      0x12E   0xB2DB             UXTB     R3,R3
   \      0x130   0x009B             LSLS     R3,R3,#+2
   \      0x132   0x409F             LSLS     R7,R7,R3
   \      0x134   0x433E             ORRS     R6,R7,R6
   \      0x136   0x002B             MOVS     R3,R5
   \      0x138   0x08DB             LSRS     R3,R3,#+3
   \      0x13A   0xEB02 0x0383      ADD      R3,R2,R3, LSL #+2
   \      0x13E   0x621E             STR      R6,[R3, #+32]
   \                     ??HAL_GPIO_Init_13: (+1)
   \      0x140   0x6816             LDR      R6,[R2, #+0]
   \      0x142   0x2703             MOVS     R7,#+3
   \      0x144   0x002B             MOVS     R3,R5
   \      0x146   0xB2DB             UXTB     R3,R3
   \      0x148   0x005B             LSLS     R3,R3,#+1
   \      0x14A   0x409F             LSLS     R7,R7,R3
   \      0x14C   0x43BE             BICS     R6,R6,R7
   \      0x14E   0x790F             LDRB     R7,[R1, #+4]
   \      0x150   0xF017 0x0703      ANDS     R7,R7,#0x3
   \      0x154   0x002B             MOVS     R3,R5
   \      0x156   0xB2DB             UXTB     R3,R3
   \      0x158   0x005B             LSLS     R3,R3,#+1
   \      0x15A   0x409F             LSLS     R7,R7,R3
   \      0x15C   0x433E             ORRS     R6,R7,R6
   \      0x15E   0x6016             STR      R6,[R2, #+0]
   \      0x160   0x684B             LDR      R3,[R1, #+4]
   \      0x162   0xF413 0x3F40      TST      R3,#0x30000
   \      0x166   0xD087             BEQ.N    ??HAL_GPIO_Init_8
   \      0x168   0x....             LDR.N    R3,??DataTable2_3
   \      0x16A   0x681E             LDR      R6,[R3, #+0]
   \      0x16C   0xF056 0x0602      ORRS     R6,R6,#0x2
   \      0x170   0x601E             STR      R6,[R3, #+0]
   \      0x172   0x681B             LDR      R3,[R3, #+0]
   \      0x174   0xF013 0x0302      ANDS     R3,R3,#0x2
   \      0x178   0x9300             STR      R3,[SP, #+0]
   \      0x17A   0x9B00             LDR      R3,[SP, #+0]
   \      0x17C   0x....             LDR.N    R6,??DataTable2_4
   \      0x17E   0x002B             MOVS     R3,R5
   \      0x180   0x089B             LSRS     R3,R3,#+2
   \      0x182   0xF856 0x7023      LDR      R7,[R6, R3, LSL #+2]
   \      0x186   0xF05F 0x0C0F      MOVS     R12,#+15
   \      0x18A   0xF015 0x0303      ANDS     R3,R5,#0x3
   \      0x18E   0xB2DB             UXTB     R3,R3
   \      0x190   0x009B             LSLS     R3,R3,#+2
   \      0x192   0xFA1C 0xFC03      LSLS     R12,R12,R3
   \      0x196   0xEA37 0x070C      BICS     R7,R7,R12
   \      0x19A   0x....             LDR.N    R3,??DataTable2_5
   \      0x19C   0x429A             CMP      R2,R3
   \      0x19E   0xD102             BNE.N    ??HAL_GPIO_Init_14
   \      0x1A0   0xF05F 0x0C00      MOVS     R12,#+0
   \      0x1A4   0xE73B             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_14: (+1)
   \      0x1A6   0x....             LDR.N    R3,??DataTable2_6
   \      0x1A8   0x429A             CMP      R2,R3
   \      0x1AA   0xD102             BNE.N    ??HAL_GPIO_Init_15
   \      0x1AC   0xF05F 0x0C01      MOVS     R12,#+1
   \      0x1B0   0xE735             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_15: (+1)
   \      0x1B2   0x....             LDR.N    R3,??DataTable2_7
   \      0x1B4   0x429A             CMP      R2,R3
   \      0x1B6   0xD102             BNE.N    ??HAL_GPIO_Init_16
   \      0x1B8   0xF05F 0x0C02      MOVS     R12,#+2
   \      0x1BC   0xE72F             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_16: (+1)
   \      0x1BE   0x....             LDR.N    R3,??DataTable2_8
   \      0x1C0   0x429A             CMP      R2,R3
   \      0x1C2   0xD102             BNE.N    ??HAL_GPIO_Init_17
   \      0x1C4   0xF05F 0x0C03      MOVS     R12,#+3
   \      0x1C8   0xE729             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_17: (+1)
   \      0x1CA   0x....             LDR.N    R3,??DataTable2_9
   \      0x1CC   0x429A             CMP      R2,R3
   \      0x1CE   0xD102             BNE.N    ??HAL_GPIO_Init_18
   \      0x1D0   0xF05F 0x0C04      MOVS     R12,#+4
   \      0x1D4   0xE723             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_18: (+1)
   \      0x1D6   0x....             LDR.N    R3,??DataTable2_10
   \      0x1D8   0x429A             CMP      R2,R3
   \      0x1DA   0xD102             BNE.N    ??HAL_GPIO_Init_19
   \      0x1DC   0xF05F 0x0C05      MOVS     R12,#+5
   \      0x1E0   0xE71D             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_19: (+1)
   \      0x1E2   0x....             LDR.N    R3,??DataTable2_11
   \      0x1E4   0x429A             CMP      R2,R3
   \      0x1E6   0xD102             BNE.N    ??HAL_GPIO_Init_20
   \      0x1E8   0xF05F 0x0C06      MOVS     R12,#+6
   \      0x1EC   0xE717             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_20: (+1)
   \      0x1EE   0x....             LDR.N    R3,??DataTable2_12
   \      0x1F0   0x429A             CMP      R2,R3
   \      0x1F2   0xD102             BNE.N    ??HAL_GPIO_Init_21
   \      0x1F4   0xF05F 0x0C07      MOVS     R12,#+7
   \      0x1F8   0xE711             B.N      ??HAL_GPIO_Init_2
   \                     ??HAL_GPIO_Init_21: (+1)
   \      0x1FA   0x....             LDR.N    R3,??DataTable2_13
   \      0x1FC   0x429A             CMP      R2,R3
   \      0x1FE   0xF47F 0xAF08      BNE.W    ??HAL_GPIO_Init_3
   \      0x202   0xF05F 0x0C08      MOVS     R12,#+8
   \      0x206   0xE70A             B.N      ??HAL_GPIO_Init_2
    292            }
    293          }
   \                     ??HAL_GPIO_Init_9: (+1)
   \      0x208   0xBCF1             POP      {R0,R4-R7}
   \      0x20A   0x4770             BX       LR
    294          
    295          /**
    296            * @brief  De-initializes the GPIOx peripheral registers to their default reset values.
    297            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral.
    298            * @param  GPIO_Pin: specifies the port bit to be written.
    299            *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
    300            * @retval None
    301            */

   \                                 In section .text, align 2, keep-with-next
    302          void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
    303          {
   \                     HAL_GPIO_DeInit: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0002             MOVS     R2,R0
    304            uint32_t position = 0x00U;
   \        0x6   0x2400             MOVS     R4,#+0
    305            uint32_t iocurrent;
    306            uint32_t tmp;
    307            EXTI_Core_TypeDef *EXTI_CurrentCPU;
    308          
    309          #if defined(DUAL_CORE) && defined(CORE_CM4)
    310            EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
    311          #else
    312            EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
   \        0x8   0x....             LDR.N    R5,??DataTable2
    313          #endif
    314          
    315            /* Check the parameters */
    316            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    317            assert_param(IS_GPIO_PIN(GPIO_Pin));
   \        0xA   0xE068             B.N      ??HAL_GPIO_DeInit_0
    318          
    319            /* Configure the port pins */
    320            while ((GPIO_Pin >> position) != 0x00U)
    321            {
    322              /* Get current io position */
    323              iocurrent = GPIO_Pin & (1UL << position) ;
    324          
    325              if (iocurrent != 0x00U)
    326              {
    327                /*------------------------- EXTI Mode Configuration --------------------*/
    328                /* Clear the External Interrupt or Event for the current IO */
    329                tmp = SYSCFG->EXTICR[position >> 2U];
    330                tmp &= (0x0FUL << (4U * (position & 0x03U)));
    331                if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
   \                     ??HAL_GPIO_DeInit_1: (+1)
   \        0xC   0xF05F 0x080A      MOVS     R8,#+10
   \       0x10   0xE004             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_3: (+1)
   \       0x12   0x....             LDR.N    R3,??DataTable2_1
   \       0x14   0x429A             CMP      R2,R3
   \       0x16   0xD1F9             BNE.N    ??HAL_GPIO_DeInit_1
   \       0x18   0xF05F 0x0809      MOVS     R8,#+9
   \                     ??HAL_GPIO_DeInit_2: (+1)
   \       0x1C   0xF014 0x0303      ANDS     R3,R4,#0x3
   \       0x20   0xB2DB             UXTB     R3,R3
   \       0x22   0x009B             LSLS     R3,R3,#+2
   \       0x24   0xFA18 0xF803      LSLS     R8,R8,R3
   \       0x28   0x45C6             CMP      LR,R8
   \       0x2A   0xD123             BNE.N    ??HAL_GPIO_DeInit_4
    332                {
    333                  /* Clear EXTI line configuration for Current CPU */
    334                  EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
   \       0x2C   0x682B             LDR      R3,[R5, #+0]
   \       0x2E   0x4383             BICS     R3,R3,R0
   \       0x30   0x602B             STR      R3,[R5, #+0]
    335                  EXTI_CurrentCPU->EMR1 &= ~(iocurrent);
   \       0x32   0x686B             LDR      R3,[R5, #+4]
   \       0x34   0x4383             BICS     R3,R3,R0
   \       0x36   0x606B             STR      R3,[R5, #+4]
    336          
    337                  /* Clear Rising Falling edge configuration */
    338                  EXTI->FTSR1 &= ~(iocurrent);
   \       0x38   0x....             LDR.N    R3,??DataTable2_2
   \       0x3A   0xF8D3 0xE000      LDR      LR,[R3, #+0]
   \       0x3E   0xEA3E 0x0E00      BICS     LR,LR,R0
   \       0x42   0xF8C3 0xE000      STR      LR,[R3, #+0]
    339                  EXTI->RTSR1 &= ~(iocurrent);
   \       0x46   0xF05F 0x43B0      MOVS     R3,#+1476395008
   \       0x4A   0xF8D3 0xE000      LDR      LR,[R3, #+0]
   \       0x4E   0xEA3E 0x0000      BICS     R0,LR,R0
   \       0x52   0x6018             STR      R0,[R3, #+0]
    340          
    341                  tmp = 0x0FUL << (4U * (position & 0x03U));
   \       0x54   0xF014 0x0003      ANDS     R0,R4,#0x3
   \       0x58   0xB2C0             UXTB     R0,R0
   \       0x5A   0x0080             LSLS     R0,R0,#+2
   \       0x5C   0xFA16 0xF000      LSLS     R0,R6,R0
    342                  SYSCFG->EXTICR[position >> 2U] &= ~tmp;
   \       0x60   0x0023             MOVS     R3,R4
   \       0x62   0x089B             LSRS     R3,R3,#+2
   \       0x64   0xF85C 0x3023      LDR      R3,[R12, R3, LSL #+2]
   \       0x68   0xEA33 0x0000      BICS     R0,R3,R0
   \       0x6C   0x0023             MOVS     R3,R4
   \       0x6E   0x089B             LSRS     R3,R3,#+2
   \       0x70   0xF84C 0x0023      STR      R0,[R12, R3, LSL #+2]
    343                }
    344          
    345                /*------------------------- GPIO Mode Configuration --------------------*/
    346                /* Configure IO in Analog Mode */
    347                GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
   \                     ??HAL_GPIO_DeInit_4: (+1)
   \       0x74   0x2303             MOVS     R3,#+3
   \       0x76   0x6810             LDR      R0,[R2, #+0]
   \       0x78   0x46A4             MOV      R12,R4
   \       0x7A   0xFA5F 0xFC8C      UXTB     R12,R12
   \       0x7E   0xEA5F 0x0C4C      LSLS     R12,R12,#+1
   \       0x82   0xFA13 0xFC0C      LSLS     R12,R3,R12
   \       0x86   0xEA5C 0x0000      ORRS     R0,R12,R0
   \       0x8A   0x6010             STR      R0,[R2, #+0]
    348          
    349                /* Configure the default Alternate Function in current IO */
    350                GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
   \       0x8C   0x0020             MOVS     R0,R4
   \       0x8E   0x08C0             LSRS     R0,R0,#+3
   \       0x90   0xEB02 0x0C80      ADD      R12,R2,R0, LSL #+2
   \       0x94   0x0020             MOVS     R0,R4
   \       0x96   0x08C0             LSRS     R0,R0,#+3
   \       0x98   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \       0x9C   0xF8D0 0xE020      LDR      LR,[R0, #+32]
   \       0xA0   0xF014 0x0007      ANDS     R0,R4,#0x7
   \       0xA4   0xB2C0             UXTB     R0,R0
   \       0xA6   0x0080             LSLS     R0,R0,#+2
   \       0xA8   0x4086             LSLS     R6,R6,R0
   \       0xAA   0xEA3E 0x0606      BICS     R6,LR,R6
   \       0xAE   0xF8CC 0x6020      STR      R6,[R12, #+32]
    351          
    352                /* Deactivate the Pull-up and Pull-down resistor for the current IO */
    353                GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
   \       0xB2   0x68D0             LDR      R0,[R2, #+12]
   \       0xB4   0x0026             MOVS     R6,R4
   \       0xB6   0xB2F6             UXTB     R6,R6
   \       0xB8   0x0076             LSLS     R6,R6,#+1
   \       0xBA   0xFA13 0xF606      LSLS     R6,R3,R6
   \       0xBE   0x43B0             BICS     R0,R0,R6
   \       0xC0   0x60D0             STR      R0,[R2, #+12]
    354          
    355                /* Configure the default value IO Output Type */
    356                GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
   \       0xC2   0x6850             LDR      R0,[R2, #+4]
   \       0xC4   0x40A7             LSLS     R7,R7,R4
   \       0xC6   0xEA30 0x0707      BICS     R7,R0,R7
   \       0xCA   0x6057             STR      R7,[R2, #+4]
    357          
    358                /* Configure the default value for IO Speed */
    359                GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
   \       0xCC   0x6896             LDR      R6,[R2, #+8]
   \       0xCE   0x0020             MOVS     R0,R4
   \       0xD0   0xB2C0             UXTB     R0,R0
   \       0xD2   0x0040             LSLS     R0,R0,#+1
   \       0xD4   0x4083             LSLS     R3,R3,R0
   \       0xD6   0xEA36 0x0303      BICS     R3,R6,R3
   \       0xDA   0x6093             STR      R3,[R2, #+8]
    360              }
    361          
    362              position++;
   \                     ??HAL_GPIO_DeInit_5: (+1)
   \       0xDC   0x1C64             ADDS     R4,R4,#+1
   \                     ??HAL_GPIO_DeInit_0: (+1)
   \       0xDE   0x0008             MOVS     R0,R1
   \       0xE0   0x40E0             LSRS     R0,R0,R4
   \       0xE2   0x2800             CMP      R0,#+0
   \       0xE4   0xD04B             BEQ.N    ??HAL_GPIO_DeInit_6
   \       0xE6   0x2701             MOVS     R7,#+1
   \       0xE8   0xFA17 0xF004      LSLS     R0,R7,R4
   \       0xEC   0x4008             ANDS     R0,R0,R1
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD0F4             BEQ.N    ??HAL_GPIO_DeInit_5
   \       0xF2   0x.... 0x....      LDR.W    R12,??DataTable2_4
   \       0xF6   0x0023             MOVS     R3,R4
   \       0xF8   0x089B             LSRS     R3,R3,#+2
   \       0xFA   0xF85C 0xE023      LDR      LR,[R12, R3, LSL #+2]
   \       0xFE   0x260F             MOVS     R6,#+15
   \      0x100   0xF014 0x0303      ANDS     R3,R4,#0x3
   \      0x104   0xB2DB             UXTB     R3,R3
   \      0x106   0x009B             LSLS     R3,R3,#+2
   \      0x108   0xFA16 0xF303      LSLS     R3,R6,R3
   \      0x10C   0xEA13 0x0E0E      ANDS     LR,R3,LR
   \      0x110   0x....             LDR.N    R3,??DataTable2_5
   \      0x112   0x429A             CMP      R2,R3
   \      0x114   0xD102             BNE.N    ??HAL_GPIO_DeInit_7
   \      0x116   0xF05F 0x0800      MOVS     R8,#+0
   \      0x11A   0xE77F             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_7: (+1)
   \      0x11C   0x....             LDR.N    R3,??DataTable2_6
   \      0x11E   0x429A             CMP      R2,R3
   \      0x120   0xD102             BNE.N    ??HAL_GPIO_DeInit_8
   \      0x122   0xF05F 0x0801      MOVS     R8,#+1
   \      0x126   0xE779             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_8: (+1)
   \      0x128   0x....             LDR.N    R3,??DataTable2_7
   \      0x12A   0x429A             CMP      R2,R3
   \      0x12C   0xD102             BNE.N    ??HAL_GPIO_DeInit_9
   \      0x12E   0xF05F 0x0802      MOVS     R8,#+2
   \      0x132   0xE773             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_9: (+1)
   \      0x134   0x....             LDR.N    R3,??DataTable2_8
   \      0x136   0x429A             CMP      R2,R3
   \      0x138   0xD102             BNE.N    ??HAL_GPIO_DeInit_10
   \      0x13A   0xF05F 0x0803      MOVS     R8,#+3
   \      0x13E   0xE76D             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_10: (+1)
   \      0x140   0x....             LDR.N    R3,??DataTable2_9
   \      0x142   0x429A             CMP      R2,R3
   \      0x144   0xD102             BNE.N    ??HAL_GPIO_DeInit_11
   \      0x146   0xF05F 0x0804      MOVS     R8,#+4
   \      0x14A   0xE767             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_11: (+1)
   \      0x14C   0x....             LDR.N    R3,??DataTable2_10
   \      0x14E   0x429A             CMP      R2,R3
   \      0x150   0xD102             BNE.N    ??HAL_GPIO_DeInit_12
   \      0x152   0xF05F 0x0805      MOVS     R8,#+5
   \      0x156   0xE761             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_12: (+1)
   \      0x158   0x....             LDR.N    R3,??DataTable2_11
   \      0x15A   0x429A             CMP      R2,R3
   \      0x15C   0xD102             BNE.N    ??HAL_GPIO_DeInit_13
   \      0x15E   0xF05F 0x0806      MOVS     R8,#+6
   \      0x162   0xE75B             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_13: (+1)
   \      0x164   0x....             LDR.N    R3,??DataTable2_12
   \      0x166   0x429A             CMP      R2,R3
   \      0x168   0xD102             BNE.N    ??HAL_GPIO_DeInit_14
   \      0x16A   0xF05F 0x0807      MOVS     R8,#+7
   \      0x16E   0xE755             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_14: (+1)
   \      0x170   0x....             LDR.N    R3,??DataTable2_13
   \      0x172   0x429A             CMP      R2,R3
   \      0x174   0xF47F 0xAF4D      BNE.W    ??HAL_GPIO_DeInit_3
   \      0x178   0xF05F 0x0808      MOVS     R8,#+8
   \      0x17C   0xE74E             B.N      ??HAL_GPIO_DeInit_2
    363            }
    364          }
   \                     ??HAL_GPIO_DeInit_6: (+1)
   \      0x17E   0xE8BD 0x81F0      POP      {R4-R8,PC}
    365          
    366          /**
    367            * @}
    368            */
    369          
    370          /** @defgroup GPIO_Exported_Functions_Group2 IO operation functions
    371           *  @brief GPIO Read, Write, Toggle, Lock and EXTI management functions.
    372           *
    373          @verbatim
    374           ===============================================================================
    375                                 ##### IO operation functions #####
    376           ===============================================================================
    377          
    378          @endverbatim
    379            * @{
    380            */
    381          
    382          /**
    383            * @brief  Reads the specified input port pin.
    384            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral.
    385            * @param  GPIO_Pin: specifies the port bit to read.
    386            *         This parameter can be GPIO_PIN_x where x can be (0..15).
    387            * @retval The input port pin value.
    388            */

   \                                 In section .text, align 2, keep-with-next
    389          GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
    390          {
    391            GPIO_PinState bitstatus;
    392          
    393            /* Check the parameters */
    394            assert_param(IS_GPIO_PIN(GPIO_Pin));
    395          
    396            if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
   \                     HAL_GPIO_ReadPin: (+1)
   \        0x0   0x6900             LDR      R0,[R0, #+16]
   \        0x2   0xB289             UXTH     R1,R1
   \        0x4   0x4208             TST      R0,R1
   \        0x6   0xD001             BEQ.N    ??HAL_GPIO_ReadPin_0
    397            {
    398              bitstatus = GPIO_PIN_SET;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE000             B.N      ??HAL_GPIO_ReadPin_1
    399            }
    400            else
    401            {
    402              bitstatus = GPIO_PIN_RESET;
   \                     ??HAL_GPIO_ReadPin_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
    403            }
    404            return bitstatus;
   \                     ??HAL_GPIO_ReadPin_1: (+1)
   \        0xE   0xB2C0             UXTB     R0,R0
   \       0x10   0x4770             BX       LR
    405          }
    406          
    407          /**
    408            * @brief  Sets or clears the selected data port bit.
    409            *
    410            * @note   This function uses GPIOx_BSRR register to allow atomic read/modify
    411            *         accesses. In this way, there is no risk of an IRQ occurring between
    412            *         the read and the modify access.
    413            *
    414            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral.
    415            * @param  GPIO_Pin: specifies the port bit to be written.
    416            *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
    417            * @param  PinState: specifies the value to be written to the selected bit.
    418            *          This parameter can be one of the GPIO_PinState enum values:
    419            *            @arg GPIO_PIN_RESET: to clear the port pin
    420            *            @arg GPIO_PIN_SET: to set the port pin
    421            * @retval None
    422            */

   \                                 In section .text, align 2, keep-with-next
    423          void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
    424          {
    425            /* Check the parameters */
    426            assert_param(IS_GPIO_PIN(GPIO_Pin));
    427            assert_param(IS_GPIO_PIN_ACTION(PinState));
    428          
    429            if (PinState != GPIO_PIN_RESET)
   \                     HAL_GPIO_WritePin: (+1)
   \        0x0   0xB2D2             UXTB     R2,R2
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD002             BEQ.N    ??HAL_GPIO_WritePin_0
    430            {
    431              GPIOx->BSRR = GPIO_Pin;
   \        0x6   0xB289             UXTH     R1,R1
   \        0x8   0x6181             STR      R1,[R0, #+24]
   \        0xA   0xE002             B.N      ??HAL_GPIO_WritePin_1
    432            }
    433            else
    434            {
    435              GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
   \                     ??HAL_GPIO_WritePin_0: (+1)
   \        0xC   0xB289             UXTH     R1,R1
   \        0xE   0x0409             LSLS     R1,R1,#+16
   \       0x10   0x6181             STR      R1,[R0, #+24]
    436            }
    437          }
   \                     ??HAL_GPIO_WritePin_1: (+1)
   \       0x12   0x4770             BX       LR
    438          
    439          /**
    440            * @brief  Toggles the specified GPIO pins.
    441            * @param  GPIOx: Where x can be (A..K) to select the GPIO peripheral.
    442            * @param  GPIO_Pin: Specifies the pins to be toggled.
    443            * @retval None
    444            */

   \                                 In section .text, align 2, keep-with-next
    445          void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
    446          {
    447            uint32_t odr;
    448          
    449            /* Check the parameters */
    450            assert_param(IS_GPIO_PIN(GPIO_Pin));
    451          
    452            /* get current Output Data Register value */
    453            odr = GPIOx->ODR;
   \                     HAL_GPIO_TogglePin: (+1)
   \        0x0   0x6942             LDR      R2,[R0, #+20]
    454          
    455            /* Set selected pins that were at low level, and reset ones that were high */
    456            GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
   \        0x2   0x000B             MOVS     R3,R1
   \        0x4   0xB29B             UXTH     R3,R3
   \        0x6   0x4013             ANDS     R3,R3,R2
   \        0x8   0xB289             UXTH     R1,R1
   \        0xA   0x4391             BICS     R1,R1,R2
   \        0xC   0xEA51 0x4103      ORRS     R1,R1,R3, LSL #+16
   \       0x10   0x6181             STR      R1,[R0, #+24]
    457          }
   \       0x12   0x4770             BX       LR
    458          
    459          /**
    460            * @brief  Locks GPIO Pins configuration registers.
    461            * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
    462            *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
    463            * @note   The configuration of the locked GPIO pins can no longer be modified
    464            *         until the next reset.
    465            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32H7 family
    466            * @param  GPIO_Pin: specifies the port bit to be locked.
    467            *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
    468            * @retval None
    469            */

   \                                 In section .text, align 2, keep-with-next
    470          HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
    471          {
   \                     HAL_GPIO_LockPin: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
    472            __IO uint32_t tmp = GPIO_LCKR_LCKK;
   \        0x2   0xF45F 0x3280      MOVS     R2,#+65536
   \        0x6   0x9200             STR      R2,[SP, #+0]
    473          
    474            /* Check the parameters */
    475            assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
    476            assert_param(IS_GPIO_PIN(GPIO_Pin));
    477          
    478            /* Apply lock key write sequence */
    479            tmp |= GPIO_Pin;
   \        0x8   0x9B00             LDR      R3,[SP, #+0]
   \        0xA   0x000A             MOVS     R2,R1
   \        0xC   0xB292             UXTH     R2,R2
   \        0xE   0x4313             ORRS     R3,R2,R3
   \       0x10   0x9300             STR      R3,[SP, #+0]
    480            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    481            GPIOx->LCKR = tmp;
   \       0x12   0x9A00             LDR      R2,[SP, #+0]
   \       0x14   0x61C2             STR      R2,[R0, #+28]
    482            /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
    483            GPIOx->LCKR = GPIO_Pin;
   \       0x16   0xB289             UXTH     R1,R1
   \       0x18   0x61C1             STR      R1,[R0, #+28]
    484            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    485            GPIOx->LCKR = tmp;
   \       0x1A   0x9900             LDR      R1,[SP, #+0]
   \       0x1C   0x61C1             STR      R1,[R0, #+28]
    486            /* Read LCKK register. This read is mandatory to complete key lock sequence*/
    487            tmp = GPIOx->LCKR;
   \       0x1E   0x69C1             LDR      R1,[R0, #+28]
   \       0x20   0x9100             STR      R1,[SP, #+0]
    488          
    489            /* read again in order to confirm lock is active */
    490            if ((GPIOx->LCKR & GPIO_LCKR_LCKK) != 0x00U)
   \       0x22   0x69C0             LDR      R0,[R0, #+28]
   \       0x24   0x03C0             LSLS     R0,R0,#+15
   \       0x26   0xD501             BPL.N    ??HAL_GPIO_LockPin_0
    491            {
    492              return HAL_OK;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xE000             B.N      ??HAL_GPIO_LockPin_1
    493            }
    494            else
    495            {
    496              return HAL_ERROR;
   \                     ??HAL_GPIO_LockPin_0: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \                     ??HAL_GPIO_LockPin_1: (+1)
   \       0x2E   0xB001             ADD      SP,SP,#+4
   \       0x30   0x4770             BX       LR
    497            }
    498          }
    499          
    500          /**
    501            * @brief  Handle EXTI interrupt request.
    502            * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
    503            * @retval None
    504            */

   \                                 In section .text, align 2, keep-with-next
    505          void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
    506          {
   \                     HAL_GPIO_EXTI_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    507          #if defined(DUAL_CORE) && defined(CORE_CM4)
    508            if (__HAL_GPIO_EXTID2_GET_IT(GPIO_Pin) != 0x00U)
    509            {
    510              __HAL_GPIO_EXTID2_CLEAR_IT(GPIO_Pin);
    511              HAL_GPIO_EXTI_Callback(GPIO_Pin);
    512            }
    513          #else
    514            /* EXTI line interrupt detected */
    515            if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00U)
   \        0x2   0x....             LDR.N    R1,??DataTable2_14
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0x0003             MOVS     R3,R0
   \        0x8   0xB29B             UXTH     R3,R3
   \        0xA   0x421A             TST      R2,R3
   \        0xC   0xD005             BEQ.N    ??HAL_GPIO_EXTI_IRQHandler_0
    516            {
    517              __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
   \        0xE   0x0002             MOVS     R2,R0
   \       0x10   0xB292             UXTH     R2,R2
   \       0x12   0x600A             STR      R2,[R1, #+0]
    518              HAL_GPIO_EXTI_Callback(GPIO_Pin);
   \       0x14   0xB280             UXTH     R0,R0
   \       0x16   0x.... 0x....      BL       HAL_GPIO_EXTI_Callback
    519            }
    520          #endif
    521          }
   \                     ??HAL_GPIO_EXTI_IRQHandler_0: (+1)
   \       0x1A   0xBD01             POP      {R0,PC}
    522          
    523          /**
    524            * @brief  EXTI line detection callback.
    525            * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
    526            * @retval None
    527            */

   \                                 In section .text, align 2
    528          __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
    529          {
    530            /* Prevent unused argument(s) compilation warning */
    531            UNUSED(GPIO_Pin);
    532          
    533            /* NOTE: This function Should not be modified, when the callback is needed,
    534                     the HAL_GPIO_EXTI_Callback could be implemented in the user file
    535             */
    536          }
   \                     HAL_GPIO_EXTI_Callback: (+1)
   \        0x0   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x5800'0080        DC32     0x58000080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x5802'2400        DC32     0x58022400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x5800'0004        DC32     0x58000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x5802'4554        DC32     0x58024554

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x5800'0408        DC32     0x58000408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \        0x0   0x5802'0000        DC32     0x58020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \        0x0   0x5802'0400        DC32     0x58020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \        0x0   0x5802'0800        DC32     0x58020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \        0x0   0x5802'0C00        DC32     0x58020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \        0x0   0x5802'1000        DC32     0x58021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \        0x0   0x5802'1400        DC32     0x58021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \        0x0   0x5802'1800        DC32     0x58021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_12:
   \        0x0   0x5802'1C00        DC32     0x58021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_13:
   \        0x0   0x5802'2000        DC32     0x58022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_14:
   \        0x0   0x5800'0088        DC32     0x58000088
    537          
    538          /**
    539            * @}
    540            */
    541          
    542          
    543          /**
    544            * @}
    545            */
    546          
    547          #endif /* HAL_GPIO_MODULE_ENABLED */
    548          /**
    549            * @}
    550            */
    551          
    552          /**
    553            * @}
    554            */
    555          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   HAL_GPIO_DeInit
       0   HAL_GPIO_EXTI_Callback
       8   HAL_GPIO_EXTI_IRQHandler
         8   -> HAL_GPIO_EXTI_Callback
      20   HAL_GPIO_Init
       4   HAL_GPIO_LockPin
       0   HAL_GPIO_ReadPin
       0   HAL_GPIO_TogglePin
       0   HAL_GPIO_WritePin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_14
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
     386  HAL_GPIO_DeInit
       2  HAL_GPIO_EXTI_Callback
      28  HAL_GPIO_EXTI_IRQHandler
     524  HAL_GPIO_Init
      50  HAL_GPIO_LockPin
      18  HAL_GPIO_ReadPin
      20  HAL_GPIO_TogglePin
      20  HAL_GPIO_WritePin

 
 1'108 bytes in section .text
 
 1'106 bytes of CODE memory (+ 2 bytes shared)

Errors: none
Warnings: none
