###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         09/Feb/2022  10:51:23
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_tim_ex.c
#        [UTF-8]
#    Command line      =
#        -f
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_tim_ex.o.rsp
#        (D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_tim_ex.c
#        -D USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver
#        -lA
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver
#        -o
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Core/Inc\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/App\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_tim_ex.o.d
#    Locale            =  C
#    List file         =
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_tim_ex.lst
#    Object file       =
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_tim_ex.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_tim_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32h7xx_hal_tim_ex.c
      4            * @author  MCD Application Team
      5            * @brief   TIM HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Timer Extended peripheral:
      8            *           + Time Hall Sensor Interface Initialization
      9            *           + Time Hall Sensor Interface Start
     10            *           + Time Complementary signal break and dead time configuration
     11            *           + Time Master and Slave synchronization configuration
     12            *           + Time Output Compare/PWM Channel Configuration (for channels 5 and 6)
     13            *           + Timer remapping capabilities configuration
     14            ******************************************************************************
     15            * @attention
     16            *
     17            * Copyright (c) 2017 STMicroelectronics.
     18            * All rights reserved.
     19            *
     20            * This software is licensed under terms that can be found in the LICENSE file
     21            * in the root directory of this software component.
     22            * If no LICENSE file comes with this software, it is provided AS-IS.
     23            *
     24            ******************************************************************************
     25            @verbatim
     26            ==============================================================================
     27                                ##### TIMER Extended features #####
     28            ==============================================================================
     29            [..]
     30              The Timer Extended features include:
     31              (#) Complementary outputs with programmable dead-time for :
     32                  (++) Output Compare
     33                  (++) PWM generation (Edge and Center-aligned Mode)
     34                  (++) One-pulse mode output
     35              (#) Synchronization circuit to control the timer with external signals and to
     36                  interconnect several timers together.
     37              (#) Break input to put the timer output signals in reset state or in a known state.
     38              (#) Supports incremental (quadrature) encoder and hall-sensor circuitry for
     39                  positioning purposes
     40          
     41                      ##### How to use this driver #####
     42            ==============================================================================
     43              [..]
     44               (#) Initialize the TIM low level resources by implementing the following functions
     45                   depending on the selected feature:
     46                     (++) Hall Sensor output : HAL_TIMEx_HallSensor_MspInit()
     47          
     48               (#) Initialize the TIM low level resources :
     49                  (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
     50                  (##) TIM pins configuration
     51                      (+++) Enable the clock for the TIM GPIOs using the following function:
     52                        __HAL_RCC_GPIOx_CLK_ENABLE();
     53                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
     54          
     55               (#) The external Clock can be configured, if needed (the default clock is the
     56                   internal clock from the APBx), using the following function:
     57                   HAL_TIM_ConfigClockSource, the clock configuration should be done before
     58                   any start function.
     59          
     60               (#) Configure the TIM in the desired functioning mode using one of the
     61                   initialization function of this driver:
     62                    (++) HAL_TIMEx_HallSensor_Init() and HAL_TIMEx_ConfigCommutEvent(): to use the
     63                         Timer Hall Sensor Interface and the commutation event with the corresponding
     64                         Interrupt and DMA request if needed (Note that One Timer is used to interface
     65                         with the Hall sensor Interface and another Timer should be used to use
     66                         the commutation event).
     67          
     68               (#) Activate the TIM peripheral using one of the start functions:
     69                     (++) Complementary Output Compare : HAL_TIMEx_OCN_Start(), HAL_TIMEx_OCN_Start_DMA(),
     70                          HAL_TIMEx_OCN_Start_IT()
     71                     (++) Complementary PWM generation : HAL_TIMEx_PWMN_Start(), HAL_TIMEx_PWMN_Start_DMA(),
     72                          HAL_TIMEx_PWMN_Start_IT()
     73                     (++) Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(), HAL_TIMEx_OnePulseN_Start_IT()
     74                     (++) Hall Sensor output : HAL_TIMEx_HallSensor_Start(), HAL_TIMEx_HallSensor_Start_DMA(),
     75                          HAL_TIMEx_HallSensor_Start_IT().
     76          
     77            @endverbatim
     78            ******************************************************************************
     79            */
     80          
     81          /* Includes ------------------------------------------------------------------*/
     82          #include "stm32h7xx_hal.h"
     83          
     84          /** @addtogroup STM32H7xx_HAL_Driver
     85            * @{
     86            */
     87          
     88          /** @defgroup TIMEx TIMEx
     89            * @brief TIM Extended HAL module driver
     90            * @{
     91            */
     92          
     93          #ifdef HAL_TIM_MODULE_ENABLED
     94          
     95          /* Private typedef -----------------------------------------------------------*/
     96          /* Private define ------------------------------------------------------------*/
     97          #if defined(TIM_BDTR_BKBID)
     98          /* Private constants ---------------------------------------------------------*/
     99          /** @defgroup TIMEx_Private_Constants TIM Extended Private Constants
    100            * @{
    101            */
    102          /* Timeout for break input rearm */
    103          #define TIM_BREAKINPUT_REARM_TIMEOUT    5UL /* 5 milliseconds */
    104          /**
    105            * @}
    106            */
    107          /* End of private constants --------------------------------------------------*/
    108          
    109          #endif /* TIM_BDTR_BKBID */
    110          /* Private macros ------------------------------------------------------------*/
    111          /* Private variables ---------------------------------------------------------*/
    112          /* Private function prototypes -----------------------------------------------*/
    113          static void TIM_DMADelayPulseNCplt(DMA_HandleTypeDef *hdma);
    114          static void TIM_DMAErrorCCxN(DMA_HandleTypeDef *hdma);
    115          static void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState);
    116          
    117          /* Exported functions --------------------------------------------------------*/
    118          /** @defgroup TIMEx_Exported_Functions TIM Extended Exported Functions
    119            * @{
    120            */
    121          
    122          /** @defgroup TIMEx_Exported_Functions_Group1 Extended Timer Hall Sensor functions
    123            * @brief    Timer Hall Sensor functions
    124            *
    125          @verbatim
    126            ==============================================================================
    127                                ##### Timer Hall Sensor functions #####
    128            ==============================================================================
    129            [..]
    130              This section provides functions allowing to:
    131              (+) Initialize and configure TIM HAL Sensor.
    132              (+) De-initialize TIM HAL Sensor.
    133              (+) Start the Hall Sensor Interface.
    134              (+) Stop the Hall Sensor Interface.
    135              (+) Start the Hall Sensor Interface and enable interrupts.
    136              (+) Stop the Hall Sensor Interface and disable interrupts.
    137              (+) Start the Hall Sensor Interface and enable DMA transfers.
    138              (+) Stop the Hall Sensor Interface and disable DMA transfers.
    139          
    140          @endverbatim
    141            * @{
    142            */
    143          /**
    144            * @brief  Initializes the TIM Hall Sensor Interface and initialize the associated handle.
    145            * @note   When the timer instance is initialized in Hall Sensor Interface mode,
    146            *         timer channels 1 and channel 2 are reserved and cannot be used for
    147            *         other purpose.
    148            * @param  htim TIM Hall Sensor Interface handle
    149            * @param  sConfig TIM Hall Sensor configuration structure
    150            * @retval HAL status
    151            */

   \                                 In section .text, align 2, keep-with-next
    152          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef *sConfig)
    153          {
   \                     HAL_TIMEx_HallSensor_Init: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    154            TIM_OC_InitTypeDef OC_Config;
    155          
    156            /* Check the TIM handle allocation */
    157            if (htim == NULL)
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD101             BNE.N    ??HAL_TIMEx_HallSensor_Init_0
    158            {
    159              return HAL_ERROR;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE077             B.N      ??HAL_TIMEx_HallSensor_Init_1
    160            }
    161          
    162            /* Check the parameters */
    163            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    164            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    165            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    166            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    167            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
    168            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
    169            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
    170          
    171            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIMEx_HallSensor_Init_0: (+1)
   \       0x10   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD105             BNE.N    ??HAL_TIMEx_HallSensor_Init_2
    172            {
    173              /* Allocate lock resource and initialize it */
    174              htim->Lock = HAL_UNLOCKED;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF884 0x003C      STRB     R0,[R4, #+60]
    175          
    176          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    177              /* Reset interrupt callbacks to legacy week callbacks */
    178              TIM_ResetCallback(htim);
    179          
    180              if (htim->HallSensor_MspInitCallback == NULL)
    181              {
    182                htim->HallSensor_MspInitCallback = HAL_TIMEx_HallSensor_MspInit;
    183              }
    184              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    185              htim->HallSensor_MspInitCallback(htim);
    186          #else
    187              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    188              HAL_TIMEx_HallSensor_MspInit(htim);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       HAL_TIMEx_HallSensor_MspInit
    189          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    190            }
    191          
    192            /* Set the TIM state */
    193            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_HallSensor_Init_2: (+1)
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0xF884 0x003D      STRB     R0,[R4, #+61]
    194          
    195            /* Configure the Time base in the Encoder Mode */
    196            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x2A   0x1D21             ADDS     R1,R4,#+4
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x.... 0x....      BL       TIM_Base_SetConfig
    197          
    198            /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
    199            TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
   \       0x32   0x68AB             LDR      R3,[R5, #+8]
   \       0x34   0x2203             MOVS     R2,#+3
   \       0x36   0x6829             LDR      R1,[R5, #+0]
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x.... 0x....      BL       TIM_TI1_SetConfig
    200          
    201            /* Reset the IC1PSC Bits */
    202            htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6980             LDR      R0,[R0, #+24]
   \       0x42   0xF030 0x000C      BICS     R0,R0,#0xC
   \       0x46   0x6821             LDR      R1,[R4, #+0]
   \       0x48   0x6188             STR      R0,[R1, #+24]
    203            /* Set the IC1PSC value */
    204            htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x6981             LDR      R1,[R0, #+24]
   \       0x4E   0x6868             LDR      R0,[R5, #+4]
   \       0x50   0x4301             ORRS     R1,R0,R1
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x6181             STR      R1,[R0, #+24]
    205          
    206            /* Enable the Hall sensor interface (XOR function of the three inputs) */
    207            htim->Instance->CR2 |= TIM_CR2_TI1S;
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x6840             LDR      R0,[R0, #+4]
   \       0x5A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \       0x5E   0x6821             LDR      R1,[R4, #+0]
   \       0x60   0x6048             STR      R0,[R1, #+4]
    208          
    209            /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
    210            htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x6881             LDR      R1,[R0, #+8]
   \       0x66   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x6A   0x4001             ANDS     R1,R0,R1
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x6081             STR      R1,[R0, #+8]
    211            htim->Instance->SMCR |= TIM_TS_TI1F_ED;
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x6880             LDR      R0,[R0, #+8]
   \       0x74   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x78   0x6821             LDR      R1,[R4, #+0]
   \       0x7A   0x6088             STR      R0,[R1, #+8]
    212          
    213            /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */
    214            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x6881             LDR      R1,[R0, #+8]
   \       0x80   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \       0x84   0x4001             ANDS     R1,R0,R1
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x6081             STR      R1,[R0, #+8]
    215            htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
   \       0x8A   0x6820             LDR      R0,[R4, #+0]
   \       0x8C   0x6880             LDR      R0,[R0, #+8]
   \       0x8E   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x92   0x6821             LDR      R1,[R4, #+0]
   \       0x94   0x6088             STR      R0,[R1, #+8]
    216          
    217            /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
    218            OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0x9004             STR      R0,[SP, #+16]
    219            OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0x9005             STR      R0,[SP, #+20]
    220            OC_Config.OCMode = TIM_OCMODE_PWM2;
   \       0x9E   0x2070             MOVS     R0,#+112
   \       0xA0   0x9000             STR      R0,[SP, #+0]
    221            OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0x9006             STR      R0,[SP, #+24]
    222            OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0x9003             STR      R0,[SP, #+12]
    223            OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0x9002             STR      R0,[SP, #+8]
    224            OC_Config.Pulse = sConfig->Commutation_Delay;
   \       0xAE   0x68E8             LDR      R0,[R5, #+12]
   \       0xB0   0x9001             STR      R0,[SP, #+4]
    225          
    226            TIM_OC2_SetConfig(htim->Instance, &OC_Config);
   \       0xB2   0x4669             MOV      R1,SP
   \       0xB4   0x6820             LDR      R0,[R4, #+0]
   \       0xB6   0x.... 0x....      BL       TIM_OC2_SetConfig
    227          
    228            /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
    229              register to 101 */
    230            htim->Instance->CR2 &= ~TIM_CR2_MMS;
   \       0xBA   0x6820             LDR      R0,[R4, #+0]
   \       0xBC   0x6840             LDR      R0,[R0, #+4]
   \       0xBE   0xF030 0x0070      BICS     R0,R0,#0x70
   \       0xC2   0x6821             LDR      R1,[R4, #+0]
   \       0xC4   0x6048             STR      R0,[R1, #+4]
    231            htim->Instance->CR2 |= TIM_TRGO_OC2REF;
   \       0xC6   0x6820             LDR      R0,[R4, #+0]
   \       0xC8   0x6840             LDR      R0,[R0, #+4]
   \       0xCA   0xF050 0x0050      ORRS     R0,R0,#0x50
   \       0xCE   0x6821             LDR      R1,[R4, #+0]
   \       0xD0   0x6048             STR      R0,[R1, #+4]
    232          
    233            /* Initialize the DMA burst operation state */
    234            htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
   \       0xD2   0x2001             MOVS     R0,#+1
   \       0xD4   0xF884 0x0048      STRB     R0,[R4, #+72]
    235          
    236            /* Initialize the TIM channels state */
    237            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   \       0xD8   0x2001             MOVS     R0,#+1
   \       0xDA   0xF884 0x003E      STRB     R0,[R4, #+62]
   \       0xDE   0xB2C0             UXTB     R0,R0
    238            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   \       0xE0   0x2001             MOVS     R0,#+1
   \       0xE2   0xF884 0x003F      STRB     R0,[R4, #+63]
   \       0xE6   0xB2C0             UXTB     R0,R0
    239            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   \       0xE8   0x2001             MOVS     R0,#+1
   \       0xEA   0xF884 0x0044      STRB     R0,[R4, #+68]
   \       0xEE   0xB2C0             UXTB     R0,R0
    240            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   \       0xF0   0x2001             MOVS     R0,#+1
   \       0xF2   0xF884 0x0045      STRB     R0,[R4, #+69]
   \       0xF6   0xB2C0             UXTB     R0,R0
    241          
    242            /* Initialize the TIM state*/
    243            htim->State = HAL_TIM_STATE_READY;
   \       0xF8   0x2001             MOVS     R0,#+1
   \       0xFA   0xF884 0x003D      STRB     R0,[R4, #+61]
    244          
    245            return HAL_OK;
   \       0xFE   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_HallSensor_Init_1: (+1)
   \      0x100   0xB007             ADD      SP,SP,#+28
   \      0x102   0xBD30             POP      {R4,R5,PC}
    246          }
    247          
    248          /**
    249            * @brief  DeInitializes the TIM Hall Sensor interface
    250            * @param  htim TIM Hall Sensor Interface handle
    251            * @retval HAL status
    252            */

   \                                 In section .text, align 2, keep-with-next
    253          HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
    254          {
   \                     HAL_TIMEx_HallSensor_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    255            /* Check the parameters */
    256            assert_param(IS_TIM_INSTANCE(htim->Instance));
    257          
    258            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0xF884 0x003D      STRB     R0,[R4, #+61]
    259          
    260            /* Disable the TIM Peripheral Clock */
    261            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0xF241 0x1111      MOVW     R1,#+4369
   \       0x12   0x4208             TST      R0,R1
   \       0x14   0xD10B             BNE.N    ??HAL_TIMEx_HallSensor_DeInit_0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0xF240 0x4144      MOVW     R1,#+1092
   \       0x1E   0x4208             TST      R0,R1
   \       0x20   0xD105             BNE.N    ??HAL_TIMEx_HallSensor_DeInit_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x0840             LSRS     R0,R0,#+1
   \       0x28   0x0040             LSLS     R0,R0,#+1
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
    262          
    263          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    264            if (htim->HallSensor_MspDeInitCallback == NULL)
    265            {
    266              htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;
    267            }
    268            /* DeInit the low level hardware */
    269            htim->HallSensor_MspDeInitCallback(htim);
    270          #else
    271            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    272            HAL_TIMEx_HallSensor_MspDeInit(htim);
   \                     ??HAL_TIMEx_HallSensor_DeInit_0: (+1)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       HAL_TIMEx_HallSensor_MspDeInit
    273          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    274          
    275            /* Change the DMA burst operation state */
    276            htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF884 0x0048      STRB     R0,[R4, #+72]
    277          
    278            /* Change the TIM channels state */
    279            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xF884 0x003E      STRB     R0,[R4, #+62]
   \       0x40   0xB2C0             UXTB     R0,R0
    280            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xF884 0x003F      STRB     R0,[R4, #+63]
   \       0x48   0xB2C0             UXTB     R0,R0
    281            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_RESET);
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xF884 0x0044      STRB     R0,[R4, #+68]
   \       0x50   0xB2C0             UXTB     R0,R0
    282            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_RESET);
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xF884 0x0045      STRB     R0,[R4, #+69]
   \       0x58   0xB2C0             UXTB     R0,R0
    283          
    284            /* Change TIM state */
    285            htim->State = HAL_TIM_STATE_RESET;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xF884 0x003D      STRB     R0,[R4, #+61]
    286          
    287            /* Release Lock */
    288            __HAL_UNLOCK(htim);
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0xF884 0x003C      STRB     R0,[R4, #+60]
    289          
    290            return HAL_OK;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xBD10             POP      {R4,PC}
    291          }
    292          
    293          /**
    294            * @brief  Initializes the TIM Hall Sensor MSP.
    295            * @param  htim TIM Hall Sensor Interface handle
    296            * @retval None
    297            */

   \                                 In section .text, align 2
    298          __weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
    299          {
    300            /* Prevent unused argument(s) compilation warning */
    301            UNUSED(htim);
    302          
    303            /* NOTE : This function should not be modified, when the callback is needed,
    304                      the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
    305             */
    306          }
   \                     HAL_TIMEx_HallSensor_MspInit: (+1)
   \        0x0   0x4770             BX       LR
    307          
    308          /**
    309            * @brief  DeInitializes TIM Hall Sensor MSP.
    310            * @param  htim TIM Hall Sensor Interface handle
    311            * @retval None
    312            */

   \                                 In section .text, align 2
    313          __weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
    314          {
    315            /* Prevent unused argument(s) compilation warning */
    316            UNUSED(htim);
    317          
    318            /* NOTE : This function should not be modified, when the callback is needed,
    319                      the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
    320             */
    321          }
   \                     HAL_TIMEx_HallSensor_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
    322          
    323          /**
    324            * @brief  Starts the TIM Hall Sensor Interface.
    325            * @param  htim TIM Hall Sensor Interface handle
    326            * @retval HAL status
    327            */

   \                                 In section .text, align 2, keep-with-next
    328          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
    329          {
   \                     HAL_TIMEx_HallSensor_Start: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    330            uint32_t tmpsmcr;
    331            HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
   \        0x4   0xF894 0x303E      LDRB     R3,[R4, #+62]
    332            HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
   \        0x8   0xF894 0x003F      LDRB     R0,[R4, #+63]
    333            HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
   \        0xC   0xF894 0x1044      LDRB     R1,[R4, #+68]
    334            HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
   \       0x10   0xF894 0x2045      LDRB     R2,[R4, #+69]
    335          
    336            /* Check the parameters */
    337            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    338          
    339            /* Check the TIM channels state */
    340            if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
    341                || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
    342                || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
    343                || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
   \       0x14   0xB2DB             UXTB     R3,R3
   \       0x16   0x2B01             CMP      R3,#+1
   \       0x18   0xD108             BNE.N    ??HAL_TIMEx_HallSensor_Start_0
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD105             BNE.N    ??HAL_TIMEx_HallSensor_Start_0
   \       0x20   0xB2C9             UXTB     R1,R1
   \       0x22   0x2901             CMP      R1,#+1
   \       0x24   0xD102             BNE.N    ??HAL_TIMEx_HallSensor_Start_0
   \       0x26   0xB2D2             UXTB     R2,R2
   \       0x28   0x2A01             CMP      R2,#+1
   \       0x2A   0xD001             BEQ.N    ??HAL_TIMEx_HallSensor_Start_1
    344            {
    345              return HAL_ERROR;
   \                     ??HAL_TIMEx_HallSensor_Start_0: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xE053             B.N      ??HAL_TIMEx_HallSensor_Start_2
    346            }
    347          
    348            /* Set the TIM channels state */
    349            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   \                     ??HAL_TIMEx_HallSensor_Start_1: (+1)
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0xF884 0x003E      STRB     R0,[R4, #+62]
   \       0x36   0xB2C0             UXTB     R0,R0
    350            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   \       0x38   0x2002             MOVS     R0,#+2
   \       0x3A   0xF884 0x003F      STRB     R0,[R4, #+63]
   \       0x3E   0xB2C0             UXTB     R0,R0
    351            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   \       0x40   0x2002             MOVS     R0,#+2
   \       0x42   0xF884 0x0044      STRB     R0,[R4, #+68]
   \       0x46   0xB2C0             UXTB     R0,R0
    352            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   \       0x48   0x2002             MOVS     R0,#+2
   \       0x4A   0xF884 0x0045      STRB     R0,[R4, #+69]
   \       0x4E   0xB2C0             UXTB     R0,R0
    353          
    354            /* Enable the Input Capture channel 1
    355            (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,
    356            TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    357            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \       0x50   0x2201             MOVS     R2,#+1
   \       0x52   0x2100             MOVS     R1,#+0
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x.... 0x....      BL       TIM_CCxChannelCmd
    358          
    359            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    360            if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x.... 0x....      LDR.W    R1,??DataTable6_2
   \       0x60   0x4288             CMP      R0,R1
   \       0x62   0xD021             BEQ.N    ??HAL_TIMEx_HallSensor_Start_3
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0x6A   0xD01D             BEQ.N    ??HAL_TIMEx_HallSensor_Start_3
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x.... 0x....      LDR.W    R1,??DataTable6_3
   \       0x72   0x4288             CMP      R0,R1
   \       0x74   0xD018             BEQ.N    ??HAL_TIMEx_HallSensor_Start_3
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \       0x7C   0x4288             CMP      R0,R1
   \       0x7E   0xD013             BEQ.N    ??HAL_TIMEx_HallSensor_Start_3
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \       0x86   0x4288             CMP      R0,R1
   \       0x88   0xD00E             BEQ.N    ??HAL_TIMEx_HallSensor_Start_3
   \       0x8A   0x6820             LDR      R0,[R4, #+0]
   \       0x8C   0x.... 0x....      LDR.W    R1,??DataTable6_6
   \       0x90   0x4288             CMP      R0,R1
   \       0x92   0xD009             BEQ.N    ??HAL_TIMEx_HallSensor_Start_3
   \       0x94   0x6820             LDR      R0,[R4, #+0]
   \       0x96   0x.... 0x....      LDR.W    R1,??DataTable6_7
   \       0x9A   0x4288             CMP      R0,R1
   \       0x9C   0xD004             BEQ.N    ??HAL_TIMEx_HallSensor_Start_3
   \       0x9E   0x6820             LDR      R0,[R4, #+0]
   \       0xA0   0x.... 0x....      LDR.W    R1,??DataTable6_8
   \       0xA4   0x4288             CMP      R0,R1
   \       0xA6   0xD110             BNE.N    ??HAL_TIMEx_HallSensor_Start_4
    361            {
    362              tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIMEx_HallSensor_Start_3: (+1)
   \       0xA8   0x6820             LDR      R0,[R4, #+0]
   \       0xAA   0x6881             LDR      R1,[R0, #+8]
   \       0xAC   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0xB0   0x4001             ANDS     R1,R0,R1
    363              if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0xB2   0x2906             CMP      R1,#+6
   \       0xB4   0xD00F             BEQ.N    ??HAL_TIMEx_HallSensor_Start_5
   \       0xB6   0xF5B1 0x3F80      CMP      R1,#+65536
   \       0xBA   0xD00C             BEQ.N    ??HAL_TIMEx_HallSensor_Start_5
    364              {
    365                __HAL_TIM_ENABLE(htim);
   \       0xBC   0x6820             LDR      R0,[R4, #+0]
   \       0xBE   0x6800             LDR      R0,[R0, #+0]
   \       0xC0   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xC4   0x6821             LDR      R1,[R4, #+0]
   \       0xC6   0x6008             STR      R0,[R1, #+0]
   \       0xC8   0xE005             B.N      ??HAL_TIMEx_HallSensor_Start_5
    366              }
    367            }
    368            else
    369            {
    370              __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIMEx_HallSensor_Start_4: (+1)
   \       0xCA   0x6820             LDR      R0,[R4, #+0]
   \       0xCC   0x6800             LDR      R0,[R0, #+0]
   \       0xCE   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xD2   0x6821             LDR      R1,[R4, #+0]
   \       0xD4   0x6008             STR      R0,[R1, #+0]
    371            }
    372          
    373            /* Return function status */
    374            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Start_5: (+1)
   \       0xD6   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_HallSensor_Start_2: (+1)
   \       0xD8   0xBD10             POP      {R4,PC}
    375          }
    376          
    377          /**
    378            * @brief  Stops the TIM Hall sensor Interface.
    379            * @param  htim TIM Hall Sensor Interface handle
    380            * @retval HAL status
    381            */

   \                                 In section .text, align 2, keep-with-next
    382          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
    383          {
   \                     HAL_TIMEx_HallSensor_Stop: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    384            /* Check the parameters */
    385            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    386          
    387            /* Disable the Input Capture channels 1, 2 and 3
    388            (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,
    389            TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    390            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x.... 0x....      BL       TIM_CCxChannelCmd
    391          
    392            /* Disable the Peripheral */
    393            __HAL_TIM_DISABLE(htim);
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x6A00             LDR      R0,[R0, #+32]
   \       0x12   0xF241 0x1111      MOVW     R1,#+4369
   \       0x16   0x4208             TST      R0,R1
   \       0x18   0xD10B             BNE.N    ??HAL_TIMEx_HallSensor_Stop_0
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x6A00             LDR      R0,[R0, #+32]
   \       0x1E   0xF240 0x4144      MOVW     R1,#+1092
   \       0x22   0x4208             TST      R0,R1
   \       0x24   0xD105             BNE.N    ??HAL_TIMEx_HallSensor_Stop_0
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0x0840             LSRS     R0,R0,#+1
   \       0x2C   0x0040             LSLS     R0,R0,#+1
   \       0x2E   0x6821             LDR      R1,[R4, #+0]
   \       0x30   0x6008             STR      R0,[R1, #+0]
    394          
    395            /* Set the TIM channels state */
    396            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   \                     ??HAL_TIMEx_HallSensor_Stop_0: (+1)
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xF884 0x003E      STRB     R0,[R4, #+62]
   \       0x38   0xB2C0             UXTB     R0,R0
    397            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0xF884 0x003F      STRB     R0,[R4, #+63]
   \       0x40   0xB2C0             UXTB     R0,R0
    398            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0xF884 0x0044      STRB     R0,[R4, #+68]
   \       0x48   0xB2C0             UXTB     R0,R0
    399            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0xF884 0x0045      STRB     R0,[R4, #+69]
   \       0x50   0xB2C0             UXTB     R0,R0
    400          
    401            /* Return function status */
    402            return HAL_OK;
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xBD10             POP      {R4,PC}
    403          }
    404          
    405          /**
    406            * @brief  Starts the TIM Hall Sensor Interface in interrupt mode.
    407            * @param  htim TIM Hall Sensor Interface handle
    408            * @retval HAL status
    409            */

   \                                 In section .text, align 2, keep-with-next
    410          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
    411          {
   \                     HAL_TIMEx_HallSensor_Start_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    412            uint32_t tmpsmcr;
    413            HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
   \        0x4   0xF894 0x303E      LDRB     R3,[R4, #+62]
    414            HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
   \        0x8   0xF894 0x003F      LDRB     R0,[R4, #+63]
    415            HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
   \        0xC   0xF894 0x1044      LDRB     R1,[R4, #+68]
    416            HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
   \       0x10   0xF894 0x2045      LDRB     R2,[R4, #+69]
    417          
    418            /* Check the parameters */
    419            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    420          
    421            /* Check the TIM channels state */
    422            if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
    423                || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
    424                || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
    425                || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
   \       0x14   0xB2DB             UXTB     R3,R3
   \       0x16   0x2B01             CMP      R3,#+1
   \       0x18   0xD108             BNE.N    ??HAL_TIMEx_HallSensor_Start_IT_0
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD105             BNE.N    ??HAL_TIMEx_HallSensor_Start_IT_0
   \       0x20   0xB2C9             UXTB     R1,R1
   \       0x22   0x2901             CMP      R1,#+1
   \       0x24   0xD102             BNE.N    ??HAL_TIMEx_HallSensor_Start_IT_0
   \       0x26   0xB2D2             UXTB     R2,R2
   \       0x28   0x2A01             CMP      R2,#+1
   \       0x2A   0xD001             BEQ.N    ??HAL_TIMEx_HallSensor_Start_IT_1
    426            {
    427              return HAL_ERROR;
   \                     ??HAL_TIMEx_HallSensor_Start_IT_0: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xE059             B.N      ??HAL_TIMEx_HallSensor_Start_IT_2
    428            }
    429          
    430            /* Set the TIM channels state */
    431            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   \                     ??HAL_TIMEx_HallSensor_Start_IT_1: (+1)
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0xF884 0x003E      STRB     R0,[R4, #+62]
   \       0x36   0xB2C0             UXTB     R0,R0
    432            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   \       0x38   0x2002             MOVS     R0,#+2
   \       0x3A   0xF884 0x003F      STRB     R0,[R4, #+63]
   \       0x3E   0xB2C0             UXTB     R0,R0
    433            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   \       0x40   0x2002             MOVS     R0,#+2
   \       0x42   0xF884 0x0044      STRB     R0,[R4, #+68]
   \       0x46   0xB2C0             UXTB     R0,R0
    434            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   \       0x48   0x2002             MOVS     R0,#+2
   \       0x4A   0xF884 0x0045      STRB     R0,[R4, #+69]
   \       0x4E   0xB2C0             UXTB     R0,R0
    435          
    436            /* Enable the capture compare Interrupts 1 event */
    437            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x68C0             LDR      R0,[R0, #+12]
   \       0x54   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x58   0x6821             LDR      R1,[R4, #+0]
   \       0x5A   0x60C8             STR      R0,[R1, #+12]
    438          
    439            /* Enable the Input Capture channel 1
    440            (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,
    441            TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    442            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \       0x5C   0x2201             MOVS     R2,#+1
   \       0x5E   0x2100             MOVS     R1,#+0
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x.... 0x....      BL       TIM_CCxChannelCmd
    443          
    444            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    445            if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x.... 0x....      LDR.W    R1,??DataTable6_2
   \       0x6C   0x4288             CMP      R0,R1
   \       0x6E   0xD021             BEQ.N    ??HAL_TIMEx_HallSensor_Start_IT_3
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0x76   0xD01D             BEQ.N    ??HAL_TIMEx_HallSensor_Start_IT_3
   \       0x78   0x6820             LDR      R0,[R4, #+0]
   \       0x7A   0x.... 0x....      LDR.W    R1,??DataTable6_3
   \       0x7E   0x4288             CMP      R0,R1
   \       0x80   0xD018             BEQ.N    ??HAL_TIMEx_HallSensor_Start_IT_3
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \       0x88   0x4288             CMP      R0,R1
   \       0x8A   0xD013             BEQ.N    ??HAL_TIMEx_HallSensor_Start_IT_3
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \       0x92   0x4288             CMP      R0,R1
   \       0x94   0xD00E             BEQ.N    ??HAL_TIMEx_HallSensor_Start_IT_3
   \       0x96   0x6820             LDR      R0,[R4, #+0]
   \       0x98   0x.... 0x....      LDR.W    R1,??DataTable6_6
   \       0x9C   0x4288             CMP      R0,R1
   \       0x9E   0xD009             BEQ.N    ??HAL_TIMEx_HallSensor_Start_IT_3
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x.... 0x....      LDR.W    R1,??DataTable6_7
   \       0xA6   0x4288             CMP      R0,R1
   \       0xA8   0xD004             BEQ.N    ??HAL_TIMEx_HallSensor_Start_IT_3
   \       0xAA   0x6820             LDR      R0,[R4, #+0]
   \       0xAC   0x.... 0x....      LDR.W    R1,??DataTable6_8
   \       0xB0   0x4288             CMP      R0,R1
   \       0xB2   0xD110             BNE.N    ??HAL_TIMEx_HallSensor_Start_IT_4
    446            {
    447              tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIMEx_HallSensor_Start_IT_3: (+1)
   \       0xB4   0x6820             LDR      R0,[R4, #+0]
   \       0xB6   0x6881             LDR      R1,[R0, #+8]
   \       0xB8   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0xBC   0x4001             ANDS     R1,R0,R1
    448              if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0xBE   0x2906             CMP      R1,#+6
   \       0xC0   0xD00F             BEQ.N    ??HAL_TIMEx_HallSensor_Start_IT_5
   \       0xC2   0xF5B1 0x3F80      CMP      R1,#+65536
   \       0xC6   0xD00C             BEQ.N    ??HAL_TIMEx_HallSensor_Start_IT_5
    449              {
    450                __HAL_TIM_ENABLE(htim);
   \       0xC8   0x6820             LDR      R0,[R4, #+0]
   \       0xCA   0x6800             LDR      R0,[R0, #+0]
   \       0xCC   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xD0   0x6821             LDR      R1,[R4, #+0]
   \       0xD2   0x6008             STR      R0,[R1, #+0]
   \       0xD4   0xE005             B.N      ??HAL_TIMEx_HallSensor_Start_IT_5
    451              }
    452            }
    453            else
    454            {
    455              __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIMEx_HallSensor_Start_IT_4: (+1)
   \       0xD6   0x6820             LDR      R0,[R4, #+0]
   \       0xD8   0x6800             LDR      R0,[R0, #+0]
   \       0xDA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xDE   0x6821             LDR      R1,[R4, #+0]
   \       0xE0   0x6008             STR      R0,[R1, #+0]
    456            }
    457          
    458            /* Return function status */
    459            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Start_IT_5: (+1)
   \       0xE2   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_HallSensor_Start_IT_2: (+1)
   \       0xE4   0xBD10             POP      {R4,PC}
    460          }
    461          
    462          /**
    463            * @brief  Stops the TIM Hall Sensor Interface in interrupt mode.
    464            * @param  htim TIM Hall Sensor Interface handle
    465            * @retval HAL status
    466            */

   \                                 In section .text, align 2, keep-with-next
    467          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
    468          {
   \                     HAL_TIMEx_HallSensor_Stop_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    469            /* Check the parameters */
    470            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    471          
    472            /* Disable the Input Capture channel 1
    473            (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,
    474            TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    475            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x.... 0x....      BL       TIM_CCxChannelCmd
    476          
    477            /* Disable the capture compare Interrupts event */
    478            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x68C0             LDR      R0,[R0, #+12]
   \       0x12   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x16   0x6821             LDR      R1,[R4, #+0]
   \       0x18   0x60C8             STR      R0,[R1, #+12]
    479          
    480            /* Disable the Peripheral */
    481            __HAL_TIM_DISABLE(htim);
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x6A00             LDR      R0,[R0, #+32]
   \       0x1E   0xF241 0x1111      MOVW     R1,#+4369
   \       0x22   0x4208             TST      R0,R1
   \       0x24   0xD10B             BNE.N    ??HAL_TIMEx_HallSensor_Stop_IT_0
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6A00             LDR      R0,[R0, #+32]
   \       0x2A   0xF240 0x4144      MOVW     R1,#+1092
   \       0x2E   0x4208             TST      R0,R1
   \       0x30   0xD105             BNE.N    ??HAL_TIMEx_HallSensor_Stop_IT_0
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0x0840             LSRS     R0,R0,#+1
   \       0x38   0x0040             LSLS     R0,R0,#+1
   \       0x3A   0x6821             LDR      R1,[R4, #+0]
   \       0x3C   0x6008             STR      R0,[R1, #+0]
    482          
    483            /* Set the TIM channels state */
    484            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   \                     ??HAL_TIMEx_HallSensor_Stop_IT_0: (+1)
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0xF884 0x003E      STRB     R0,[R4, #+62]
   \       0x44   0xB2C0             UXTB     R0,R0
    485            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0xF884 0x003F      STRB     R0,[R4, #+63]
   \       0x4C   0xB2C0             UXTB     R0,R0
    486            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   \       0x4E   0x2001             MOVS     R0,#+1
   \       0x50   0xF884 0x0044      STRB     R0,[R4, #+68]
   \       0x54   0xB2C0             UXTB     R0,R0
    487            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   \       0x56   0x2001             MOVS     R0,#+1
   \       0x58   0xF884 0x0045      STRB     R0,[R4, #+69]
   \       0x5C   0xB2C0             UXTB     R0,R0
    488          
    489            /* Return function status */
    490            return HAL_OK;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xBD10             POP      {R4,PC}
    491          }
    492          
    493          /**
    494            * @brief  Starts the TIM Hall Sensor Interface in DMA mode.
    495            * @param  htim TIM Hall Sensor Interface handle
    496            * @param  pData The destination Buffer address.
    497            * @param  Length The length of data to be transferred from TIM peripheral to memory.
    498            * @retval HAL status
    499            */

   \                                 In section .text, align 2, keep-with-next
    500          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    501          {
   \                     HAL_TIMEx_HallSensor_Start_DMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0016             MOVS     R6,R2
    502            uint32_t tmpsmcr;
    503            HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
   \        0x8   0xF895 0x003E      LDRB     R0,[R5, #+62]
    504            HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
   \        0xC   0xF895 0x1044      LDRB     R1,[R5, #+68]
    505          
    506            /* Check the parameters */
    507            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    508          
    509            /* Set the TIM channel state */
    510            if ((channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY)
    511                || (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_BUSY))
   \       0x10   0x0002             MOVS     R2,R0
   \       0x12   0xB2D2             UXTB     R2,R2
   \       0x14   0x2A02             CMP      R2,#+2
   \       0x16   0xD003             BEQ.N    ??HAL_TIMEx_HallSensor_Start_DMA_0
   \       0x18   0x000A             MOVS     R2,R1
   \       0x1A   0xB2D2             UXTB     R2,R2
   \       0x1C   0x2A02             CMP      R2,#+2
   \       0x1E   0xD101             BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_1
    512            {
    513              return HAL_BUSY;
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_0: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xE07A             B.N      ??HAL_TIMEx_HallSensor_Start_DMA_2
    514            }
    515            else if ((channel_1_state == HAL_TIM_CHANNEL_STATE_READY)
    516                     && (complementary_channel_1_state == HAL_TIM_CHANNEL_STATE_READY))
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_1: (+1)
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x2801             CMP      R0,#+1
   \       0x28   0xD16C             BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_3
   \       0x2A   0xB2C9             UXTB     R1,R1
   \       0x2C   0x2901             CMP      R1,#+1
   \       0x2E   0xD169             BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_3
    517            {
    518              if ((pData == NULL) && (Length > 0U))
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD105             BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_4
   \       0x34   0x0030             MOVS     R0,R6
   \       0x36   0xB280             UXTH     R0,R0
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD001             BEQ.N    ??HAL_TIMEx_HallSensor_Start_DMA_4
    519              {
    520                return HAL_ERROR;
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xE06C             B.N      ??HAL_TIMEx_HallSensor_Start_DMA_2
    521              }
    522              else
    523              {
    524                TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_4: (+1)
   \       0x40   0x2002             MOVS     R0,#+2
   \       0x42   0xF885 0x003E      STRB     R0,[R5, #+62]
   \       0x46   0xB2C0             UXTB     R0,R0
    525                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   \       0x48   0x2002             MOVS     R0,#+2
   \       0x4A   0xF885 0x0044      STRB     R0,[R5, #+68]
   \       0x4E   0xB2C0             UXTB     R0,R0
    526              }
    527            }
    528            else
    529            {
    530              return HAL_ERROR;
    531            }
    532          
    533            /* Enable the Input Capture channel 1
    534            (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,
    535            TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    536            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \       0x50   0x2201             MOVS     R2,#+1
   \       0x52   0x2100             MOVS     R1,#+0
   \       0x54   0x6828             LDR      R0,[R5, #+0]
   \       0x56   0x.... 0x....      BL       TIM_CCxChannelCmd
    537          
    538            /* Set the DMA Input Capture 1 Callbacks */
    539            htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \       0x5A   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \       0x5E   0x6A69             LDR      R1,[R5, #+36]
   \       0x60   0x63C8             STR      R0,[R1, #+60]
    540            htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x66   0x6A69             LDR      R1,[R5, #+36]
   \       0x68   0x6408             STR      R0,[R1, #+64]
    541            /* Set the DMA error callback */
    542            htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x6A   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \       0x6E   0x6A69             LDR      R1,[R5, #+36]
   \       0x70   0x64C8             STR      R0,[R1, #+76]
    543          
    544            /* Enable the DMA stream for Capture 1*/
    545            if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
   \       0x72   0xB2B6             UXTH     R6,R6
   \       0x74   0x0033             MOVS     R3,R6
   \       0x76   0x0022             MOVS     R2,R4
   \       0x78   0x6828             LDR      R0,[R5, #+0]
   \       0x7A   0xF110 0x0134      ADDS     R1,R0,#+52
   \       0x7E   0x6A68             LDR      R0,[R5, #+36]
   \       0x80   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD13F             BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_5
    546            {
    547              /* Return error status */
    548              return HAL_ERROR;
    549            }
    550            /* Enable the capture compare 1 Interrupt */
    551            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \       0x88   0x6828             LDR      R0,[R5, #+0]
   \       0x8A   0x68C0             LDR      R0,[R0, #+12]
   \       0x8C   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0x90   0x6829             LDR      R1,[R5, #+0]
   \       0x92   0x60C8             STR      R0,[R1, #+12]
    552          
    553            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    554            if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   \       0x94   0x6828             LDR      R0,[R5, #+0]
   \       0x96   0x.... 0x....      LDR.W    R1,??DataTable6_2
   \       0x9A   0x4288             CMP      R0,R1
   \       0x9C   0xD021             BEQ.N    ??HAL_TIMEx_HallSensor_Start_DMA_6
   \       0x9E   0x6828             LDR      R0,[R5, #+0]
   \       0xA0   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0xA4   0xD01D             BEQ.N    ??HAL_TIMEx_HallSensor_Start_DMA_6
   \       0xA6   0x6828             LDR      R0,[R5, #+0]
   \       0xA8   0x.... 0x....      LDR.W    R1,??DataTable6_3
   \       0xAC   0x4288             CMP      R0,R1
   \       0xAE   0xD018             BEQ.N    ??HAL_TIMEx_HallSensor_Start_DMA_6
   \       0xB0   0x6828             LDR      R0,[R5, #+0]
   \       0xB2   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \       0xB6   0x4288             CMP      R0,R1
   \       0xB8   0xD013             BEQ.N    ??HAL_TIMEx_HallSensor_Start_DMA_6
   \       0xBA   0x6828             LDR      R0,[R5, #+0]
   \       0xBC   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \       0xC0   0x4288             CMP      R0,R1
   \       0xC2   0xD00E             BEQ.N    ??HAL_TIMEx_HallSensor_Start_DMA_6
   \       0xC4   0x6828             LDR      R0,[R5, #+0]
   \       0xC6   0x.... 0x....      LDR.W    R1,??DataTable6_6
   \       0xCA   0x4288             CMP      R0,R1
   \       0xCC   0xD009             BEQ.N    ??HAL_TIMEx_HallSensor_Start_DMA_6
   \       0xCE   0x6828             LDR      R0,[R5, #+0]
   \       0xD0   0x.... 0x....      LDR.W    R1,??DataTable6_7
   \       0xD4   0x4288             CMP      R0,R1
   \       0xD6   0xD004             BEQ.N    ??HAL_TIMEx_HallSensor_Start_DMA_6
   \       0xD8   0x6828             LDR      R0,[R5, #+0]
   \       0xDA   0x.... 0x....      LDR.W    R1,??DataTable6_8
   \       0xDE   0x4288             CMP      R0,R1
   \       0xE0   0xD114             BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_7
    555            {
    556              tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_6: (+1)
   \       0xE2   0x6828             LDR      R0,[R5, #+0]
   \       0xE4   0x6881             LDR      R1,[R0, #+8]
   \       0xE6   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0xEA   0x4001             ANDS     R1,R0,R1
    557              if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0xEC   0x2906             CMP      R1,#+6
   \       0xEE   0xD013             BEQ.N    ??HAL_TIMEx_HallSensor_Start_DMA_8
   \       0xF0   0xF5B1 0x3F80      CMP      R1,#+65536
   \       0xF4   0xD010             BEQ.N    ??HAL_TIMEx_HallSensor_Start_DMA_8
    558              {
    559                __HAL_TIM_ENABLE(htim);
   \       0xF6   0x6828             LDR      R0,[R5, #+0]
   \       0xF8   0x6800             LDR      R0,[R0, #+0]
   \       0xFA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xFE   0x6829             LDR      R1,[R5, #+0]
   \      0x100   0x6008             STR      R0,[R1, #+0]
   \      0x102   0xE009             B.N      ??HAL_TIMEx_HallSensor_Start_DMA_8
    560              }
    561            }
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_3: (+1)
   \      0x104   0x2001             MOVS     R0,#+1
   \      0x106   0xE008             B.N      ??HAL_TIMEx_HallSensor_Start_DMA_2
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_5: (+1)
   \      0x108   0x2001             MOVS     R0,#+1
   \      0x10A   0xE006             B.N      ??HAL_TIMEx_HallSensor_Start_DMA_2
    562            else
    563            {
    564              __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_7: (+1)
   \      0x10C   0x6828             LDR      R0,[R5, #+0]
   \      0x10E   0x6800             LDR      R0,[R0, #+0]
   \      0x110   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x114   0x6829             LDR      R1,[R5, #+0]
   \      0x116   0x6008             STR      R0,[R1, #+0]
    565            }
    566          
    567            /* Return function status */
    568            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_8: (+1)
   \      0x118   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_2: (+1)
   \      0x11A   0xBD70             POP      {R4-R6,PC}
    569          }
    570          
    571          /**
    572            * @brief  Stops the TIM Hall Sensor Interface in DMA mode.
    573            * @param  htim TIM Hall Sensor Interface handle
    574            * @retval HAL status
    575            */

   \                                 In section .text, align 2, keep-with-next
    576          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
    577          {
   \                     HAL_TIMEx_HallSensor_Stop_DMA: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    578            /* Check the parameters */
    579            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    580          
    581            /* Disable the Input Capture channel 1
    582            (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1,
    583            TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    584            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x.... 0x....      BL       TIM_CCxChannelCmd
    585          
    586          
    587            /* Disable the capture compare Interrupts 1 event */
    588            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x68C0             LDR      R0,[R0, #+12]
   \       0x12   0xF430 0x7000      BICS     R0,R0,#0x200
   \       0x16   0x6821             LDR      R1,[R4, #+0]
   \       0x18   0x60C8             STR      R0,[R1, #+12]
    589          
    590            (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x1A   0x6A60             LDR      R0,[R4, #+36]
   \       0x1C   0x.... 0x....      BL       HAL_DMA_Abort_IT
    591          
    592            /* Disable the Peripheral */
    593            __HAL_TIM_DISABLE(htim);
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x6A00             LDR      R0,[R0, #+32]
   \       0x24   0xF241 0x1111      MOVW     R1,#+4369
   \       0x28   0x4208             TST      R0,R1
   \       0x2A   0xD10B             BNE.N    ??HAL_TIMEx_HallSensor_Stop_DMA_0
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6A00             LDR      R0,[R0, #+32]
   \       0x30   0xF240 0x4144      MOVW     R1,#+1092
   \       0x34   0x4208             TST      R0,R1
   \       0x36   0xD105             BNE.N    ??HAL_TIMEx_HallSensor_Stop_DMA_0
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x6800             LDR      R0,[R0, #+0]
   \       0x3C   0x0840             LSRS     R0,R0,#+1
   \       0x3E   0x0040             LSLS     R0,R0,#+1
   \       0x40   0x6821             LDR      R1,[R4, #+0]
   \       0x42   0x6008             STR      R0,[R1, #+0]
    594          
    595            /* Set the TIM channel state */
    596            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   \                     ??HAL_TIMEx_HallSensor_Stop_DMA_0: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xF884 0x003E      STRB     R0,[R4, #+62]
   \       0x4A   0xB2C0             UXTB     R0,R0
    597            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   \       0x4C   0x2001             MOVS     R0,#+1
   \       0x4E   0xF884 0x0044      STRB     R0,[R4, #+68]
   \       0x52   0xB2C0             UXTB     R0,R0
    598          
    599            /* Return function status */
    600            return HAL_OK;
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xBD10             POP      {R4,PC}
    601          }
    602          
    603          /**
    604            * @}
    605            */
    606          
    607          /** @defgroup TIMEx_Exported_Functions_Group2 Extended Timer Complementary Output Compare functions
    608            *  @brief   Timer Complementary Output Compare functions
    609            *
    610          @verbatim
    611            ==============================================================================
    612                        ##### Timer Complementary Output Compare functions #####
    613            ==============================================================================
    614            [..]
    615              This section provides functions allowing to:
    616              (+) Start the Complementary Output Compare/PWM.
    617              (+) Stop the Complementary Output Compare/PWM.
    618              (+) Start the Complementary Output Compare/PWM and enable interrupts.
    619              (+) Stop the Complementary Output Compare/PWM and disable interrupts.
    620              (+) Start the Complementary Output Compare/PWM and enable DMA transfers.
    621              (+) Stop the Complementary Output Compare/PWM and disable DMA transfers.
    622          
    623          @endverbatim
    624            * @{
    625            */
    626          
    627          /**
    628            * @brief  Starts the TIM Output Compare signal generation on the complementary
    629            *         output.
    630            * @param  htim TIM Output Compare handle
    631            * @param  Channel TIM Channel to be enabled
    632            *          This parameter can be one of the following values:
    633            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    634            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    635            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    636            * @retval HAL status
    637            */

   \                                 In section .text, align 2, keep-with-next
    638          HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    639          {
   \                     HAL_TIMEx_OCN_Start: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    640            uint32_t tmpsmcr;
    641          
    642            /* Check the parameters */
    643            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    644          
    645            /* Check the TIM complementary channel state */
    646            if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD102             BNE.N    ??HAL_TIMEx_OCN_Start_0
   \        0x8   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \        0xC   0xE00B             B.N      ??HAL_TIMEx_OCN_Start_1
   \                     ??HAL_TIMEx_OCN_Start_0: (+1)
   \        0xE   0x2904             CMP      R1,#+4
   \       0x10   0xD102             BNE.N    ??HAL_TIMEx_OCN_Start_2
   \       0x12   0xF894 0x0045      LDRB     R0,[R4, #+69]
   \       0x16   0xE006             B.N      ??HAL_TIMEx_OCN_Start_1
   \                     ??HAL_TIMEx_OCN_Start_2: (+1)
   \       0x18   0x2908             CMP      R1,#+8
   \       0x1A   0xD102             BNE.N    ??HAL_TIMEx_OCN_Start_3
   \       0x1C   0xF894 0x0046      LDRB     R0,[R4, #+70]
   \       0x20   0xE001             B.N      ??HAL_TIMEx_OCN_Start_1
   \                     ??HAL_TIMEx_OCN_Start_3: (+1)
   \       0x22   0xF894 0x0047      LDRB     R0,[R4, #+71]
   \                     ??HAL_TIMEx_OCN_Start_1: (+1)
   \       0x26   0x2801             CMP      R0,#+1
   \       0x28   0xD001             BEQ.N    ??HAL_TIMEx_OCN_Start_4
    647            {
    648              return HAL_ERROR;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE061             B.N      ??HAL_TIMEx_OCN_Start_5
    649            }
    650          
    651            /* Set the TIM complementary channel state */
    652            TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
   \                     ??HAL_TIMEx_OCN_Start_4: (+1)
   \       0x2E   0x2900             CMP      R1,#+0
   \       0x30   0xD104             BNE.N    ??HAL_TIMEx_OCN_Start_6
   \       0x32   0x2002             MOVS     R0,#+2
   \       0x34   0xF884 0x0044      STRB     R0,[R4, #+68]
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0xE011             B.N      ??HAL_TIMEx_OCN_Start_7
   \                     ??HAL_TIMEx_OCN_Start_6: (+1)
   \       0x3C   0x2904             CMP      R1,#+4
   \       0x3E   0xD104             BNE.N    ??HAL_TIMEx_OCN_Start_8
   \       0x40   0x2002             MOVS     R0,#+2
   \       0x42   0xF884 0x0045      STRB     R0,[R4, #+69]
   \       0x46   0xB2C0             UXTB     R0,R0
   \       0x48   0xE00A             B.N      ??HAL_TIMEx_OCN_Start_7
   \                     ??HAL_TIMEx_OCN_Start_8: (+1)
   \       0x4A   0x2908             CMP      R1,#+8
   \       0x4C   0xD104             BNE.N    ??HAL_TIMEx_OCN_Start_9
   \       0x4E   0x2002             MOVS     R0,#+2
   \       0x50   0xF884 0x0046      STRB     R0,[R4, #+70]
   \       0x54   0xB2C0             UXTB     R0,R0
   \       0x56   0xE003             B.N      ??HAL_TIMEx_OCN_Start_7
   \                     ??HAL_TIMEx_OCN_Start_9: (+1)
   \       0x58   0x2002             MOVS     R0,#+2
   \       0x5A   0xF884 0x0047      STRB     R0,[R4, #+71]
   \       0x5E   0xB2C0             UXTB     R0,R0
    653          
    654            /* Enable the Capture compare channel N */
    655            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \                     ??HAL_TIMEx_OCN_Start_7: (+1)
   \       0x60   0x2204             MOVS     R2,#+4
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x.... 0x....      BL       TIM_CCxNChannelCmd
    656          
    657            /* Enable the Main Output */
    658            __HAL_TIM_MOE_ENABLE(htim);
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x6C40             LDR      R0,[R0, #+68]
   \       0x6C   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x70   0x6821             LDR      R1,[R4, #+0]
   \       0x72   0x6448             STR      R0,[R1, #+68]
    659          
    660            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    661            if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x.... 0x....      LDR.W    R1,??DataTable6_2
   \       0x7A   0x4288             CMP      R0,R1
   \       0x7C   0xD021             BEQ.N    ??HAL_TIMEx_OCN_Start_10
   \       0x7E   0x6820             LDR      R0,[R4, #+0]
   \       0x80   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0x84   0xD01D             BEQ.N    ??HAL_TIMEx_OCN_Start_10
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x.... 0x....      LDR.W    R1,??DataTable6_3
   \       0x8C   0x4288             CMP      R0,R1
   \       0x8E   0xD018             BEQ.N    ??HAL_TIMEx_OCN_Start_10
   \       0x90   0x6820             LDR      R0,[R4, #+0]
   \       0x92   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \       0x96   0x4288             CMP      R0,R1
   \       0x98   0xD013             BEQ.N    ??HAL_TIMEx_OCN_Start_10
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \       0xA0   0x4288             CMP      R0,R1
   \       0xA2   0xD00E             BEQ.N    ??HAL_TIMEx_OCN_Start_10
   \       0xA4   0x6820             LDR      R0,[R4, #+0]
   \       0xA6   0x.... 0x....      LDR.W    R1,??DataTable6_6
   \       0xAA   0x4288             CMP      R0,R1
   \       0xAC   0xD009             BEQ.N    ??HAL_TIMEx_OCN_Start_10
   \       0xAE   0x6820             LDR      R0,[R4, #+0]
   \       0xB0   0x.... 0x....      LDR.W    R1,??DataTable6_7
   \       0xB4   0x4288             CMP      R0,R1
   \       0xB6   0xD004             BEQ.N    ??HAL_TIMEx_OCN_Start_10
   \       0xB8   0x6820             LDR      R0,[R4, #+0]
   \       0xBA   0x.... 0x....      LDR.W    R1,??DataTable6_8
   \       0xBE   0x4288             CMP      R0,R1
   \       0xC0   0xD110             BNE.N    ??HAL_TIMEx_OCN_Start_11
    662            {
    663              tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIMEx_OCN_Start_10: (+1)
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0x6881             LDR      R1,[R0, #+8]
   \       0xC6   0x.... 0x....      LDR.W    R0,??DataTable7
   \       0xCA   0x4001             ANDS     R1,R0,R1
    664              if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0xCC   0x2906             CMP      R1,#+6
   \       0xCE   0xD00F             BEQ.N    ??HAL_TIMEx_OCN_Start_12
   \       0xD0   0xF5B1 0x3F80      CMP      R1,#+65536
   \       0xD4   0xD00C             BEQ.N    ??HAL_TIMEx_OCN_Start_12
    665              {
    666                __HAL_TIM_ENABLE(htim);
   \       0xD6   0x6820             LDR      R0,[R4, #+0]
   \       0xD8   0x6800             LDR      R0,[R0, #+0]
   \       0xDA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xDE   0x6821             LDR      R1,[R4, #+0]
   \       0xE0   0x6008             STR      R0,[R1, #+0]
   \       0xE2   0xE005             B.N      ??HAL_TIMEx_OCN_Start_12
    667              }
    668            }
    669            else
    670            {
    671              __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIMEx_OCN_Start_11: (+1)
   \       0xE4   0x6820             LDR      R0,[R4, #+0]
   \       0xE6   0x6800             LDR      R0,[R0, #+0]
   \       0xE8   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xEC   0x6821             LDR      R1,[R4, #+0]
   \       0xEE   0x6008             STR      R0,[R1, #+0]
    672            }
    673          
    674            /* Return function status */
    675            return HAL_OK;
   \                     ??HAL_TIMEx_OCN_Start_12: (+1)
   \       0xF0   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_OCN_Start_5: (+1)
   \       0xF2   0xBD10             POP      {R4,PC}
    676          }
    677          
    678          /**
    679            * @brief  Stops the TIM Output Compare signal generation on the complementary
    680            *         output.
    681            * @param  htim TIM handle
    682            * @param  Channel TIM Channel to be disabled
    683            *          This parameter can be one of the following values:
    684            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    685            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    686            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    687            * @retval HAL status
    688            */

   \                                 In section .text, align 2, keep-with-next
    689          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    690          {
   \                     HAL_TIMEx_OCN_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    691            /* Check the parameters */
    692            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    693          
    694            /* Disable the Capture compare channel N */
    695            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x0021             MOVS     R1,R4
   \        0xA   0x6828             LDR      R0,[R5, #+0]
   \        0xC   0x.... 0x....      BL       TIM_CCxNChannelCmd
    696          
    697            /* Disable the Main Output */
    698            __HAL_TIM_MOE_DISABLE(htim);
   \       0x10   0xF241 0x1011      MOVW     R0,#+4369
   \       0x14   0x6829             LDR      R1,[R5, #+0]
   \       0x16   0x6A09             LDR      R1,[R1, #+32]
   \       0x18   0x4201             TST      R1,R0
   \       0x1A   0xD10B             BNE.N    ??HAL_TIMEx_OCN_Stop_0
   \       0x1C   0x6829             LDR      R1,[R5, #+0]
   \       0x1E   0x6A09             LDR      R1,[R1, #+32]
   \       0x20   0xF240 0x4244      MOVW     R2,#+1092
   \       0x24   0x4211             TST      R1,R2
   \       0x26   0xD105             BNE.N    ??HAL_TIMEx_OCN_Stop_0
   \       0x28   0x6829             LDR      R1,[R5, #+0]
   \       0x2A   0x6C49             LDR      R1,[R1, #+68]
   \       0x2C   0xF431 0x4100      BICS     R1,R1,#0x8000
   \       0x30   0x682A             LDR      R2,[R5, #+0]
   \       0x32   0x6451             STR      R1,[R2, #+68]
    699          
    700            /* Disable the Peripheral */
    701            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_0: (+1)
   \       0x34   0x6829             LDR      R1,[R5, #+0]
   \       0x36   0x6A09             LDR      R1,[R1, #+32]
   \       0x38   0x4201             TST      R1,R0
   \       0x3A   0xD10B             BNE.N    ??HAL_TIMEx_OCN_Stop_1
   \       0x3C   0x6828             LDR      R0,[R5, #+0]
   \       0x3E   0x6A00             LDR      R0,[R0, #+32]
   \       0x40   0xF240 0x4144      MOVW     R1,#+1092
   \       0x44   0x4208             TST      R0,R1
   \       0x46   0xD105             BNE.N    ??HAL_TIMEx_OCN_Stop_1
   \       0x48   0x6828             LDR      R0,[R5, #+0]
   \       0x4A   0x6800             LDR      R0,[R0, #+0]
   \       0x4C   0x0840             LSRS     R0,R0,#+1
   \       0x4E   0x0040             LSLS     R0,R0,#+1
   \       0x50   0x6829             LDR      R1,[R5, #+0]
   \       0x52   0x6008             STR      R0,[R1, #+0]
    702          
    703            /* Set the TIM complementary channel state */
    704            TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   \                     ??HAL_TIMEx_OCN_Stop_1: (+1)
   \       0x54   0x2C00             CMP      R4,#+0
   \       0x56   0xD104             BNE.N    ??HAL_TIMEx_OCN_Stop_2
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0xF885 0x0044      STRB     R0,[R5, #+68]
   \       0x5E   0xB2C0             UXTB     R0,R0
   \       0x60   0xE011             B.N      ??HAL_TIMEx_OCN_Stop_3
   \                     ??HAL_TIMEx_OCN_Stop_2: (+1)
   \       0x62   0x2C04             CMP      R4,#+4
   \       0x64   0xD104             BNE.N    ??HAL_TIMEx_OCN_Stop_4
   \       0x66   0x2001             MOVS     R0,#+1
   \       0x68   0xF885 0x0045      STRB     R0,[R5, #+69]
   \       0x6C   0xB2C0             UXTB     R0,R0
   \       0x6E   0xE00A             B.N      ??HAL_TIMEx_OCN_Stop_3
   \                     ??HAL_TIMEx_OCN_Stop_4: (+1)
   \       0x70   0x2C08             CMP      R4,#+8
   \       0x72   0xD104             BNE.N    ??HAL_TIMEx_OCN_Stop_5
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0xF885 0x0046      STRB     R0,[R5, #+70]
   \       0x7A   0xB2C0             UXTB     R0,R0
   \       0x7C   0xE003             B.N      ??HAL_TIMEx_OCN_Stop_3
   \                     ??HAL_TIMEx_OCN_Stop_5: (+1)
   \       0x7E   0x2001             MOVS     R0,#+1
   \       0x80   0xF885 0x0047      STRB     R0,[R5, #+71]
   \       0x84   0xB2C0             UXTB     R0,R0
    705          
    706            /* Return function status */
    707            return HAL_OK;
   \                     ??HAL_TIMEx_OCN_Stop_3: (+1)
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0xBD32             POP      {R1,R4,R5,PC}
    708          }
    709          
    710          /**
    711            * @brief  Starts the TIM Output Compare signal generation in interrupt mode
    712            *         on the complementary output.
    713            * @param  htim TIM OC handle
    714            * @param  Channel TIM Channel to be enabled
    715            *          This parameter can be one of the following values:
    716            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    717            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    718            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    719            * @retval HAL status
    720            */

   \                                 In section .text, align 2, keep-with-next
    721          HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    722          {
   \                     HAL_TIMEx_OCN_Start_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    723            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
    724            uint32_t tmpsmcr;
    725          
    726            /* Check the parameters */
    727            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    728          
    729            /* Check the TIM complementary channel state */
    730            if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD102             BNE.N    ??HAL_TIMEx_OCN_Start_IT_0
   \        0xA   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \        0xE   0xE00B             B.N      ??HAL_TIMEx_OCN_Start_IT_1
   \                     ??HAL_TIMEx_OCN_Start_IT_0: (+1)
   \       0x10   0x2904             CMP      R1,#+4
   \       0x12   0xD102             BNE.N    ??HAL_TIMEx_OCN_Start_IT_2
   \       0x14   0xF894 0x0045      LDRB     R0,[R4, #+69]
   \       0x18   0xE006             B.N      ??HAL_TIMEx_OCN_Start_IT_1
   \                     ??HAL_TIMEx_OCN_Start_IT_2: (+1)
   \       0x1A   0x2908             CMP      R1,#+8
   \       0x1C   0xD102             BNE.N    ??HAL_TIMEx_OCN_Start_IT_3
   \       0x1E   0xF894 0x0046      LDRB     R0,[R4, #+70]
   \       0x22   0xE001             B.N      ??HAL_TIMEx_OCN_Start_IT_1
   \                     ??HAL_TIMEx_OCN_Start_IT_3: (+1)
   \       0x24   0xF894 0x0047      LDRB     R0,[R4, #+71]
   \                     ??HAL_TIMEx_OCN_Start_IT_1: (+1)
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD001             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_4
    731            {
    732              return HAL_ERROR;
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xE08A             B.N      ??HAL_TIMEx_OCN_Start_IT_5
    733            }
    734          
    735            /* Set the TIM complementary channel state */
    736            TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
   \                     ??HAL_TIMEx_OCN_Start_IT_4: (+1)
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD104             BNE.N    ??HAL_TIMEx_OCN_Start_IT_6
   \       0x34   0x2002             MOVS     R0,#+2
   \       0x36   0xF884 0x0044      STRB     R0,[R4, #+68]
   \       0x3A   0xB2C0             UXTB     R0,R0
   \       0x3C   0xE011             B.N      ??HAL_TIMEx_OCN_Start_IT_7
   \                     ??HAL_TIMEx_OCN_Start_IT_6: (+1)
   \       0x3E   0x2904             CMP      R1,#+4
   \       0x40   0xD104             BNE.N    ??HAL_TIMEx_OCN_Start_IT_8
   \       0x42   0x2002             MOVS     R0,#+2
   \       0x44   0xF884 0x0045      STRB     R0,[R4, #+69]
   \       0x48   0xB2C0             UXTB     R0,R0
   \       0x4A   0xE00A             B.N      ??HAL_TIMEx_OCN_Start_IT_7
   \                     ??HAL_TIMEx_OCN_Start_IT_8: (+1)
   \       0x4C   0x2908             CMP      R1,#+8
   \       0x4E   0xD104             BNE.N    ??HAL_TIMEx_OCN_Start_IT_9
   \       0x50   0x2002             MOVS     R0,#+2
   \       0x52   0xF884 0x0046      STRB     R0,[R4, #+70]
   \       0x56   0xB2C0             UXTB     R0,R0
   \       0x58   0xE003             B.N      ??HAL_TIMEx_OCN_Start_IT_7
   \                     ??HAL_TIMEx_OCN_Start_IT_9: (+1)
   \       0x5A   0x2002             MOVS     R0,#+2
   \       0x5C   0xF884 0x0047      STRB     R0,[R4, #+71]
   \       0x60   0xB2C0             UXTB     R0,R0
    737          
    738            switch (Channel)
   \                     ??HAL_TIMEx_OCN_Start_IT_7: (+1)
   \       0x62   0x0008             MOVS     R0,R1
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD004             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_10
   \       0x68   0x2804             CMP      R0,#+4
   \       0x6A   0xD009             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_11
   \       0x6C   0x2808             CMP      R0,#+8
   \       0x6E   0xD00E             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_12
   \       0x70   0xE014             B.N      ??HAL_TIMEx_OCN_Start_IT_13
    739            {
    740              case TIM_CHANNEL_1:
    741              {
    742                /* Enable the TIM Output Compare interrupt */
    743                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_OCN_Start_IT_10: (+1)
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x68C0             LDR      R0,[R0, #+12]
   \       0x76   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x7A   0x6822             LDR      R2,[R4, #+0]
   \       0x7C   0x60D0             STR      R0,[R2, #+12]
    744                break;
   \       0x7E   0xE00E             B.N      ??HAL_TIMEx_OCN_Start_IT_14
    745              }
    746          
    747              case TIM_CHANNEL_2:
    748              {
    749                /* Enable the TIM Output Compare interrupt */
    750                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_OCN_Start_IT_11: (+1)
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x68C0             LDR      R0,[R0, #+12]
   \       0x84   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x88   0x6822             LDR      R2,[R4, #+0]
   \       0x8A   0x60D0             STR      R0,[R2, #+12]
    751                break;
   \       0x8C   0xE007             B.N      ??HAL_TIMEx_OCN_Start_IT_14
    752              }
    753          
    754              case TIM_CHANNEL_3:
    755              {
    756                /* Enable the TIM Output Compare interrupt */
    757                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_OCN_Start_IT_12: (+1)
   \       0x8E   0x6820             LDR      R0,[R4, #+0]
   \       0x90   0x68C0             LDR      R0,[R0, #+12]
   \       0x92   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0x96   0x6822             LDR      R2,[R4, #+0]
   \       0x98   0x60D0             STR      R0,[R2, #+12]
    758                break;
   \       0x9A   0xE000             B.N      ??HAL_TIMEx_OCN_Start_IT_14
    759              }
    760          
    761          
    762              default:
    763                status = HAL_ERROR;
   \                     ??HAL_TIMEx_OCN_Start_IT_13: (+1)
   \       0x9C   0x2501             MOVS     R5,#+1
    764                break;
    765            }
    766          
    767            if (status == HAL_OK)
   \                     ??HAL_TIMEx_OCN_Start_IT_14: (+1)
   \       0x9E   0x0028             MOVS     R0,R5
   \       0xA0   0xB2C0             UXTB     R0,R0
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD14D             BNE.N    ??HAL_TIMEx_OCN_Start_IT_15
    768            {
    769              /* Enable the TIM Break interrupt */
    770              __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
   \       0xA6   0x6820             LDR      R0,[R4, #+0]
   \       0xA8   0x68C0             LDR      R0,[R0, #+12]
   \       0xAA   0xF050 0x0080      ORRS     R0,R0,#0x80
   \       0xAE   0x6822             LDR      R2,[R4, #+0]
   \       0xB0   0x60D0             STR      R0,[R2, #+12]
    771          
    772              /* Enable the Capture compare channel N */
    773              TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \       0xB2   0x2204             MOVS     R2,#+4
   \       0xB4   0x6820             LDR      R0,[R4, #+0]
   \       0xB6   0x.... 0x....      BL       TIM_CCxNChannelCmd
    774          
    775              /* Enable the Main Output */
    776              __HAL_TIM_MOE_ENABLE(htim);
   \       0xBA   0x6820             LDR      R0,[R4, #+0]
   \       0xBC   0x6C40             LDR      R0,[R0, #+68]
   \       0xBE   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0xC2   0x6821             LDR      R1,[R4, #+0]
   \       0xC4   0x6448             STR      R0,[R1, #+68]
    777          
    778              /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    779              if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   \       0xC6   0x6820             LDR      R0,[R4, #+0]
   \       0xC8   0x.... 0x....      LDR.W    R1,??DataTable6_2
   \       0xCC   0x4288             CMP      R0,R1
   \       0xCE   0xD021             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_16
   \       0xD0   0x6820             LDR      R0,[R4, #+0]
   \       0xD2   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0xD6   0xD01D             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_16
   \       0xD8   0x6820             LDR      R0,[R4, #+0]
   \       0xDA   0x.... 0x....      LDR.W    R1,??DataTable6_3
   \       0xDE   0x4288             CMP      R0,R1
   \       0xE0   0xD018             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_16
   \       0xE2   0x6820             LDR      R0,[R4, #+0]
   \       0xE4   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \       0xE8   0x4288             CMP      R0,R1
   \       0xEA   0xD013             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_16
   \       0xEC   0x6820             LDR      R0,[R4, #+0]
   \       0xEE   0x.... 0x....      LDR.W    R1,??DataTable6_5
   \       0xF2   0x4288             CMP      R0,R1
   \       0xF4   0xD00E             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_16
   \       0xF6   0x6820             LDR      R0,[R4, #+0]
   \       0xF8   0x.... 0x....      LDR.W    R1,??DataTable6_6
   \       0xFC   0x4288             CMP      R0,R1
   \       0xFE   0xD009             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_16
   \      0x100   0x6820             LDR      R0,[R4, #+0]
   \      0x102   0x.... 0x....      LDR.W    R1,??DataTable6_7
   \      0x106   0x4288             CMP      R0,R1
   \      0x108   0xD004             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_16
   \      0x10A   0x6820             LDR      R0,[R4, #+0]
   \      0x10C   0x.... 0x....      LDR.W    R1,??DataTable6_8
   \      0x110   0x4288             CMP      R0,R1
   \      0x112   0xD110             BNE.N    ??HAL_TIMEx_OCN_Start_IT_17
    780              {
    781                tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIMEx_OCN_Start_IT_16: (+1)
   \      0x114   0x6820             LDR      R0,[R4, #+0]
   \      0x116   0x6881             LDR      R1,[R0, #+8]
   \      0x118   0x.... 0x....      LDR.W    R0,??DataTable7
   \      0x11C   0x4001             ANDS     R1,R0,R1
    782                if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \      0x11E   0x2906             CMP      R1,#+6
   \      0x120   0xD00F             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_15
   \      0x122   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x126   0xD00C             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_15
    783                {
    784                  __HAL_TIM_ENABLE(htim);
   \      0x128   0x6820             LDR      R0,[R4, #+0]
   \      0x12A   0x6800             LDR      R0,[R0, #+0]
   \      0x12C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x130   0x6821             LDR      R1,[R4, #+0]
   \      0x132   0x6008             STR      R0,[R1, #+0]
   \      0x134   0xE005             B.N      ??HAL_TIMEx_OCN_Start_IT_15
    785                }
    786              }
    787              else
    788              {
    789                __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIMEx_OCN_Start_IT_17: (+1)
   \      0x136   0x6820             LDR      R0,[R4, #+0]
   \      0x138   0x6800             LDR      R0,[R0, #+0]
   \      0x13A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x13E   0x6821             LDR      R1,[R4, #+0]
   \      0x140   0x6008             STR      R0,[R1, #+0]
    790              }
    791            }
    792          
    793            /* Return function status */
    794            return status;
   \                     ??HAL_TIMEx_OCN_Start_IT_15: (+1)
   \      0x142   0x0028             MOVS     R0,R5
   \      0x144   0xB2C0             UXTB     R0,R0
   \                     ??HAL_TIMEx_OCN_Start_IT_5: (+1)
   \      0x146   0xBD32             POP      {R1,R4,R5,PC}
    795          }
    796          
    797          /**
    798            * @brief  Stops the TIM Output Compare signal generation in interrupt mode
    799            *         on the complementary output.
    800            * @param  htim TIM Output Compare handle
    801            * @param  Channel TIM Channel to be disabled
    802            *          This parameter can be one of the following values:
    803            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    804            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    805            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    806            * @retval HAL status
    807            */

   \                                 In section .text, align 2, keep-with-next
    808          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    809          {
   \                     HAL_TIMEx_OCN_Stop_IT: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
    810            HAL_StatusTypeDef status = HAL_OK;
   \        0x6   0x2500             MOVS     R5,#+0
    811            uint32_t tmpccer;
    812          
    813            /* Check the parameters */
    814            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    815          
    816            switch (Channel)
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD004             BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_0
   \        0xE   0x2804             CMP      R0,#+4
   \       0x10   0xD009             BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_1
   \       0x12   0x2808             CMP      R0,#+8
   \       0x14   0xD00E             BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_2
   \       0x16   0xE014             B.N      ??HAL_TIMEx_OCN_Stop_IT_3
    817            {
    818              case TIM_CHANNEL_1:
    819              {
    820                /* Disable the TIM Output Compare interrupt */
    821                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_OCN_Stop_IT_0: (+1)
   \       0x18   0x6830             LDR      R0,[R6, #+0]
   \       0x1A   0x68C0             LDR      R0,[R0, #+12]
   \       0x1C   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x20   0x6831             LDR      R1,[R6, #+0]
   \       0x22   0x60C8             STR      R0,[R1, #+12]
    822                break;
   \       0x24   0xE00E             B.N      ??HAL_TIMEx_OCN_Stop_IT_4
    823              }
    824          
    825              case TIM_CHANNEL_2:
    826              {
    827                /* Disable the TIM Output Compare interrupt */
    828                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_OCN_Stop_IT_1: (+1)
   \       0x26   0x6830             LDR      R0,[R6, #+0]
   \       0x28   0x68C0             LDR      R0,[R0, #+12]
   \       0x2A   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x2E   0x6831             LDR      R1,[R6, #+0]
   \       0x30   0x60C8             STR      R0,[R1, #+12]
    829                break;
   \       0x32   0xE007             B.N      ??HAL_TIMEx_OCN_Stop_IT_4
    830              }
    831          
    832              case TIM_CHANNEL_3:
    833              {
    834                /* Disable the TIM Output Compare interrupt */
    835                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_OCN_Stop_IT_2: (+1)
   \       0x34   0x6830             LDR      R0,[R6, #+0]
   \       0x36   0x68C0             LDR      R0,[R0, #+12]
   \       0x38   0xF030 0x0008      BICS     R0,R0,#0x8
   \       0x3C   0x6831             LDR      R1,[R6, #+0]
   \       0x3E   0x60C8             STR      R0,[R1, #+12]
    836                break;
   \       0x40   0xE000             B.N      ??HAL_TIMEx_OCN_Stop_IT_4
    837              }
    838          
    839              default:
    840                status = HAL_ERROR;
   \                     ??HAL_TIMEx_OCN_Stop_IT_3: (+1)
   \       0x42   0x2501             MOVS     R5,#+1
    841                break;
    842            }
    843          
    844            if (status == HAL_OK)
   \                     ??HAL_TIMEx_OCN_Stop_IT_4: (+1)
   \       0x44   0x0028             MOVS     R0,R5
   \       0x46   0xB2C0             UXTB     R0,R0
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD147             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_5
    845            {
    846              /* Disable the Capture compare channel N */
    847              TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \       0x4C   0x2200             MOVS     R2,#+0
   \       0x4E   0x0021             MOVS     R1,R4
   \       0x50   0x6830             LDR      R0,[R6, #+0]
   \       0x52   0x.... 0x....      BL       TIM_CCxNChannelCmd
    848          
    849              /* Disable the TIM Break interrupt (only if no more channel is active) */
    850              tmpccer = htim->Instance->CCER;
   \       0x56   0x6830             LDR      R0,[R6, #+0]
   \       0x58   0x6A01             LDR      R1,[R0, #+32]
    851              if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
   \       0x5A   0xF240 0x4044      MOVW     R0,#+1092
   \       0x5E   0x4201             TST      R1,R0
   \       0x60   0xD105             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_6
    852              {
    853                __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
   \       0x62   0x6831             LDR      R1,[R6, #+0]
   \       0x64   0x68C9             LDR      R1,[R1, #+12]
   \       0x66   0xF031 0x0180      BICS     R1,R1,#0x80
   \       0x6A   0x6832             LDR      R2,[R6, #+0]
   \       0x6C   0x60D1             STR      R1,[R2, #+12]
    854              }
    855          
    856              /* Disable the Main Output */
    857              __HAL_TIM_MOE_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_IT_6: (+1)
   \       0x6E   0xF241 0x1111      MOVW     R1,#+4369
   \       0x72   0x6832             LDR      R2,[R6, #+0]
   \       0x74   0x6A12             LDR      R2,[R2, #+32]
   \       0x76   0x420A             TST      R2,R1
   \       0x78   0xD109             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_7
   \       0x7A   0x6832             LDR      R2,[R6, #+0]
   \       0x7C   0x6A12             LDR      R2,[R2, #+32]
   \       0x7E   0x4202             TST      R2,R0
   \       0x80   0xD105             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_7
   \       0x82   0x6832             LDR      R2,[R6, #+0]
   \       0x84   0x6C52             LDR      R2,[R2, #+68]
   \       0x86   0xF432 0x4200      BICS     R2,R2,#0x8000
   \       0x8A   0x6833             LDR      R3,[R6, #+0]
   \       0x8C   0x645A             STR      R2,[R3, #+68]
    858          
    859              /* Disable the Peripheral */
    860              __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_IT_7: (+1)
   \       0x8E   0x6832             LDR      R2,[R6, #+0]
   \       0x90   0x6A12             LDR      R2,[R2, #+32]
   \       0x92   0x420A             TST      R2,R1
   \       0x94   0xD109             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_8
   \       0x96   0x6831             LDR      R1,[R6, #+0]
   \       0x98   0x6A09             LDR      R1,[R1, #+32]
   \       0x9A   0x4201             TST      R1,R0
   \       0x9C   0xD105             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_8
   \       0x9E   0x6830             LDR      R0,[R6, #+0]
   \       0xA0   0x6800             LDR      R0,[R0, #+0]
   \       0xA2   0x0840             LSRS     R0,R0,#+1
   \       0xA4   0x0040             LSLS     R0,R0,#+1
   \       0xA6   0x6831             LDR      R1,[R6, #+0]
   \       0xA8   0x6008             STR      R0,[R1, #+0]
    861          
    862              /* Set the TIM complementary channel state */
    863              TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   \                     ??HAL_TIMEx_OCN_Stop_IT_8: (+1)
   \       0xAA   0x2C00             CMP      R4,#+0
   \       0xAC   0xD104             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_9
   \       0xAE   0x2001             MOVS     R0,#+1
   \       0xB0   0xF886 0x0044      STRB     R0,[R6, #+68]
   \       0xB4   0xB2C0             UXTB     R0,R0
   \       0xB6   0xE011             B.N      ??HAL_TIMEx_OCN_Stop_IT_5
   \                     ??HAL_TIMEx_OCN_Stop_IT_9: (+1)
   \       0xB8   0x2C04             CMP      R4,#+4
   \       0xBA   0xD104             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_10
   \       0xBC   0x2001             MOVS     R0,#+1
   \       0xBE   0xF886 0x0045      STRB     R0,[R6, #+69]
   \       0xC2   0xB2C0             UXTB     R0,R0
   \       0xC4   0xE00A             B.N      ??HAL_TIMEx_OCN_Stop_IT_5
   \                     ??HAL_TIMEx_OCN_Stop_IT_10: (+1)
   \       0xC6   0x2C08             CMP      R4,#+8
   \       0xC8   0xD104             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_11
   \       0xCA   0x2001             MOVS     R0,#+1
   \       0xCC   0xF886 0x0046      STRB     R0,[R6, #+70]
   \       0xD0   0xB2C0             UXTB     R0,R0
   \       0xD2   0xE003             B.N      ??HAL_TIMEx_OCN_Stop_IT_5
   \                     ??HAL_TIMEx_OCN_Stop_IT_11: (+1)
   \       0xD4   0x2001             MOVS     R0,#+1
   \       0xD6   0xF886 0x0047      STRB     R0,[R6, #+71]
   \       0xDA   0xB2C0             UXTB     R0,R0
    864            }
    865          
    866            /* Return function status */
    867            return status;
   \                     ??HAL_TIMEx_OCN_Stop_IT_5: (+1)
   \       0xDC   0x0028             MOVS     R0,R5
   \       0xDE   0xB2C0             UXTB     R0,R0
   \       0xE0   0xBD70             POP      {R4-R6,PC}
    868          }
    869          
    870          /**
    871            * @brief  Starts the TIM Output Compare signal generation in DMA mode
    872            *         on the complementary output.
    873            * @param  htim TIM Output Compare handle
    874            * @param  Channel TIM Channel to be enabled
    875            *          This parameter can be one of the following values:
    876            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    877            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    878            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    879            * @param  pData The source Buffer address.
    880            * @param  Length The length of data to be transferred from memory to TIM peripheral
    881            * @retval HAL status
    882            */

   \                                 In section .text, align 2, keep-with-next
    883          HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    884          {
   \                     HAL_TIMEx_OCN_Start_DMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0011             MOVS     R1,R2
    885            HAL_StatusTypeDef status = HAL_OK;
   \        0x8   0x2600             MOVS     R6,#+0
    886            uint32_t tmpsmcr;
    887          
    888            /* Check the parameters */
    889            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    890          
    891            /* Set the TIM complementary channel state */
    892            if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD102             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_0
   \        0xE   0xF895 0x0044      LDRB     R0,[R5, #+68]
   \       0x12   0xE00B             B.N      ??HAL_TIMEx_OCN_Start_DMA_1
   \                     ??HAL_TIMEx_OCN_Start_DMA_0: (+1)
   \       0x14   0x2C04             CMP      R4,#+4
   \       0x16   0xD102             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_2
   \       0x18   0xF895 0x0045      LDRB     R0,[R5, #+69]
   \       0x1C   0xE006             B.N      ??HAL_TIMEx_OCN_Start_DMA_1
   \                     ??HAL_TIMEx_OCN_Start_DMA_2: (+1)
   \       0x1E   0x2C08             CMP      R4,#+8
   \       0x20   0xD102             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_3
   \       0x22   0xF895 0x0046      LDRB     R0,[R5, #+70]
   \       0x26   0xE001             B.N      ??HAL_TIMEx_OCN_Start_DMA_1
   \                     ??HAL_TIMEx_OCN_Start_DMA_3: (+1)
   \       0x28   0xF895 0x0047      LDRB     R0,[R5, #+71]
   \                     ??HAL_TIMEx_OCN_Start_DMA_1: (+1)
   \       0x2C   0x2802             CMP      R0,#+2
   \       0x2E   0xD101             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_4
    893            {
    894              return HAL_BUSY;
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0xE0E0             B.N      ??HAL_TIMEx_OCN_Start_DMA_5
    895            }
    896            else if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
   \                     ??HAL_TIMEx_OCN_Start_DMA_4: (+1)
   \       0x34   0x2C00             CMP      R4,#+0
   \       0x36   0xD102             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_6
   \       0x38   0xF895 0x0044      LDRB     R0,[R5, #+68]
   \       0x3C   0xE00B             B.N      ??HAL_TIMEx_OCN_Start_DMA_7
   \                     ??HAL_TIMEx_OCN_Start_DMA_6: (+1)
   \       0x3E   0x2C04             CMP      R4,#+4
   \       0x40   0xD102             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_8
   \       0x42   0xF895 0x0045      LDRB     R0,[R5, #+69]
   \       0x46   0xE006             B.N      ??HAL_TIMEx_OCN_Start_DMA_7
   \                     ??HAL_TIMEx_OCN_Start_DMA_8: (+1)
   \       0x48   0x2C08             CMP      R4,#+8
   \       0x4A   0xD102             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_9
   \       0x4C   0xF895 0x0046      LDRB     R0,[R5, #+70]
   \       0x50   0xE001             B.N      ??HAL_TIMEx_OCN_Start_DMA_7
   \                     ??HAL_TIMEx_OCN_Start_DMA_9: (+1)
   \       0x52   0xF895 0x0047      LDRB     R0,[R5, #+71]
   \                     ??HAL_TIMEx_OCN_Start_DMA_7: (+1)
   \       0x56   0x2801             CMP      R0,#+1
   \       0x58   0xD169             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_10
    897            {
    898              if ((pData == NULL) && (Length > 0U))
   \       0x5A   0x2900             CMP      R1,#+0
   \       0x5C   0xD105             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_11
   \       0x5E   0x0018             MOVS     R0,R3
   \       0x60   0xB280             UXTH     R0,R0
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD001             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_11
    899              {
    900                return HAL_ERROR;
   \       0x66   0x2001             MOVS     R0,#+1
   \       0x68   0xE0C5             B.N      ??HAL_TIMEx_OCN_Start_DMA_5
    901              }
    902              else
    903              {
    904                TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
   \                     ??HAL_TIMEx_OCN_Start_DMA_11: (+1)
   \       0x6A   0x2C00             CMP      R4,#+0
   \       0x6C   0xD104             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_12
   \       0x6E   0x2002             MOVS     R0,#+2
   \       0x70   0xF885 0x0044      STRB     R0,[R5, #+68]
   \       0x74   0xB2C0             UXTB     R0,R0
   \       0x76   0xE011             B.N      ??HAL_TIMEx_OCN_Start_DMA_13
   \                     ??HAL_TIMEx_OCN_Start_DMA_12: (+1)
   \       0x78   0x2C04             CMP      R4,#+4
   \       0x7A   0xD104             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_14
   \       0x7C   0x2002             MOVS     R0,#+2
   \       0x7E   0xF885 0x0045      STRB     R0,[R5, #+69]
   \       0x82   0xB2C0             UXTB     R0,R0
   \       0x84   0xE00A             B.N      ??HAL_TIMEx_OCN_Start_DMA_13
   \                     ??HAL_TIMEx_OCN_Start_DMA_14: (+1)
   \       0x86   0x2C08             CMP      R4,#+8
   \       0x88   0xD104             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_15
   \       0x8A   0x2002             MOVS     R0,#+2
   \       0x8C   0xF885 0x0046      STRB     R0,[R5, #+70]
   \       0x90   0xB2C0             UXTB     R0,R0
   \       0x92   0xE003             B.N      ??HAL_TIMEx_OCN_Start_DMA_13
   \                     ??HAL_TIMEx_OCN_Start_DMA_15: (+1)
   \       0x94   0x2002             MOVS     R0,#+2
   \       0x96   0xF885 0x0047      STRB     R0,[R5, #+71]
   \       0x9A   0xB2C0             UXTB     R0,R0
    905              }
    906            }
    907            else
    908            {
    909              return HAL_ERROR;
    910            }
    911          
    912            switch (Channel)
   \                     ??HAL_TIMEx_OCN_Start_DMA_13: (+1)
   \       0x9C   0x0020             MOVS     R0,R4
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD047             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_16
   \       0xA2   0x2804             CMP      R0,#+4
   \       0xA4   0xD063             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_17
   \       0xA6   0x2808             CMP      R0,#+8
   \       0xA8   0xF000 0x807F      BEQ.W    ??HAL_TIMEx_OCN_Start_DMA_18
    913            {
    914              case TIM_CHANNEL_1:
    915              {
    916                /* Set the DMA compare callbacks */
    917                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseNCplt;
    918                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
    919          
    920                /* Set the DMA error callback */
    921                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAErrorCCxN ;
    922          
    923                /* Enable the DMA stream */
    924                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,
    925                                     Length) != HAL_OK)
    926                {
    927                  /* Return error status */
    928                  return HAL_ERROR;
    929                }
    930                /* Enable the TIM Output Compare DMA request */
    931                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
    932                break;
    933              }
    934          
    935              case TIM_CHANNEL_2:
    936              {
    937                /* Set the DMA compare callbacks */
    938                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseNCplt;
    939                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
    940          
    941                /* Set the DMA error callback */
    942                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAErrorCCxN ;
    943          
    944                /* Enable the DMA stream */
    945                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,
    946                                     Length) != HAL_OK)
    947                {
    948                  /* Return error status */
    949                  return HAL_ERROR;
    950                }
    951                /* Enable the TIM Output Compare DMA request */
    952                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
    953                break;
    954              }
    955          
    956              case TIM_CHANNEL_3:
    957              {
    958                /* Set the DMA compare callbacks */
    959                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseNCplt;
    960                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
    961          
    962                /* Set the DMA error callback */
    963                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAErrorCCxN ;
    964          
    965                /* Enable the DMA stream */
    966                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,
    967                                     Length) != HAL_OK)
    968                {
    969                  /* Return error status */
    970                  return HAL_ERROR;
    971                }
    972                /* Enable the TIM Output Compare DMA request */
    973                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
    974                break;
    975              }
    976          
    977              default:
    978                status = HAL_ERROR;
   \                     ??HAL_TIMEx_OCN_Start_DMA_19: (+1)
   \       0xAC   0x2601             MOVS     R6,#+1
    979                break;
    980            }
    981          
    982            if (status == HAL_OK)
   \                     ??HAL_TIMEx_OCN_Start_DMA_20: (+1)
   \       0xAE   0x0030             MOVS     R0,R6
   \       0xB0   0xB2C0             UXTB     R0,R0
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xF040 0x809D      BNE.W    ??HAL_TIMEx_OCN_Start_DMA_21
    983            {
    984              /* Enable the Capture compare channel N */
    985              TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \       0xB8   0x2204             MOVS     R2,#+4
   \       0xBA   0x0021             MOVS     R1,R4
   \       0xBC   0x6828             LDR      R0,[R5, #+0]
   \       0xBE   0x.... 0x....      BL       TIM_CCxNChannelCmd
    986          
    987              /* Enable the Main Output */
    988              __HAL_TIM_MOE_ENABLE(htim);
   \       0xC2   0x6828             LDR      R0,[R5, #+0]
   \       0xC4   0x6C40             LDR      R0,[R0, #+68]
   \       0xC6   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0xCA   0x6829             LDR      R1,[R5, #+0]
   \       0xCC   0x6448             STR      R0,[R1, #+68]
    989          
    990              /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    991              if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   \       0xCE   0x6828             LDR      R0,[R5, #+0]
   \       0xD0   0x....             LDR.N    R1,??DataTable6_2
   \       0xD2   0x4288             CMP      R0,R1
   \       0xD4   0xD01B             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_22
   \       0xD6   0x6828             LDR      R0,[R5, #+0]
   \       0xD8   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0xDC   0xD017             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_22
   \       0xDE   0x6828             LDR      R0,[R5, #+0]
   \       0xE0   0x....             LDR.N    R1,??DataTable6_3
   \       0xE2   0x4288             CMP      R0,R1
   \       0xE4   0xD013             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_22
   \       0xE6   0x6828             LDR      R0,[R5, #+0]
   \       0xE8   0x....             LDR.N    R1,??DataTable6_4
   \       0xEA   0x4288             CMP      R0,R1
   \       0xEC   0xD00F             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_22
   \       0xEE   0x6828             LDR      R0,[R5, #+0]
   \       0xF0   0x....             LDR.N    R1,??DataTable6_5
   \       0xF2   0x4288             CMP      R0,R1
   \       0xF4   0xD00B             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_22
   \       0xF6   0x6828             LDR      R0,[R5, #+0]
   \       0xF8   0x....             LDR.N    R1,??DataTable6_6
   \       0xFA   0x4288             CMP      R0,R1
   \       0xFC   0xD007             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_22
   \       0xFE   0x6828             LDR      R0,[R5, #+0]
   \      0x100   0x....             LDR.N    R1,??DataTable6_7
   \      0x102   0x4288             CMP      R0,R1
   \      0x104   0xD003             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_22
   \      0x106   0x6828             LDR      R0,[R5, #+0]
   \      0x108   0x....             LDR.N    R1,??DataTable6_8
   \      0x10A   0x4288             CMP      R0,R1
   \      0x10C   0xD16B             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_23
    992              {
    993                tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIMEx_OCN_Start_DMA_22: (+1)
   \      0x10E   0x6828             LDR      R0,[R5, #+0]
   \      0x110   0x6881             LDR      R1,[R0, #+8]
   \      0x112   0x....             LDR.N    R0,??DataTable7
   \      0x114   0x4001             ANDS     R1,R0,R1
    994                if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \      0x116   0x2906             CMP      R1,#+6
   \      0x118   0xD06B             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_21
   \      0x11A   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x11E   0xD068             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_21
    995                {
    996                  __HAL_TIM_ENABLE(htim);
   \      0x120   0x6828             LDR      R0,[R5, #+0]
   \      0x122   0x6800             LDR      R0,[R0, #+0]
   \      0x124   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x128   0x6829             LDR      R1,[R5, #+0]
   \      0x12A   0x6008             STR      R0,[R1, #+0]
   \      0x12C   0xE061             B.N      ??HAL_TIMEx_OCN_Start_DMA_21
    997                }
    998              }
   \                     ??HAL_TIMEx_OCN_Start_DMA_10: (+1)
   \      0x12E   0x2001             MOVS     R0,#+1
   \      0x130   0xE061             B.N      ??HAL_TIMEx_OCN_Start_DMA_5
   \                     ??HAL_TIMEx_OCN_Start_DMA_16: (+1)
   \      0x132   0x.... 0x....      LDR.W    R0,??DataTable10
   \      0x136   0x6A6A             LDR      R2,[R5, #+36]
   \      0x138   0x63D0             STR      R0,[R2, #+60]
   \      0x13A   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \      0x13E   0x6A6A             LDR      R2,[R5, #+36]
   \      0x140   0x6410             STR      R0,[R2, #+64]
   \      0x142   0x.... 0x....      LDR.W    R0,??DataTable11
   \      0x146   0x6A6A             LDR      R2,[R5, #+36]
   \      0x148   0x64D0             STR      R0,[R2, #+76]
   \      0x14A   0xB29B             UXTH     R3,R3
   \      0x14C   0x6828             LDR      R0,[R5, #+0]
   \      0x14E   0xF110 0x0234      ADDS     R2,R0,#+52
   \      0x152   0x6A68             LDR      R0,[R5, #+36]
   \      0x154   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x158   0x2800             CMP      R0,#+0
   \      0x15A   0xD001             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_24
   \      0x15C   0x2001             MOVS     R0,#+1
   \      0x15E   0xE04A             B.N      ??HAL_TIMEx_OCN_Start_DMA_5
   \                     ??HAL_TIMEx_OCN_Start_DMA_24: (+1)
   \      0x160   0x6828             LDR      R0,[R5, #+0]
   \      0x162   0x68C0             LDR      R0,[R0, #+12]
   \      0x164   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x168   0x6829             LDR      R1,[R5, #+0]
   \      0x16A   0x60C8             STR      R0,[R1, #+12]
   \      0x16C   0xE79F             B.N      ??HAL_TIMEx_OCN_Start_DMA_20
   \                     ??HAL_TIMEx_OCN_Start_DMA_17: (+1)
   \      0x16E   0x.... 0x....      LDR.W    R0,??DataTable10
   \      0x172   0x6AAA             LDR      R2,[R5, #+40]
   \      0x174   0x63D0             STR      R0,[R2, #+60]
   \      0x176   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \      0x17A   0x6AAA             LDR      R2,[R5, #+40]
   \      0x17C   0x6410             STR      R0,[R2, #+64]
   \      0x17E   0x.... 0x....      LDR.W    R0,??DataTable11
   \      0x182   0x6AAA             LDR      R2,[R5, #+40]
   \      0x184   0x64D0             STR      R0,[R2, #+76]
   \      0x186   0xB29B             UXTH     R3,R3
   \      0x188   0x6828             LDR      R0,[R5, #+0]
   \      0x18A   0xF110 0x0238      ADDS     R2,R0,#+56
   \      0x18E   0x6AA8             LDR      R0,[R5, #+40]
   \      0x190   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x194   0x2800             CMP      R0,#+0
   \      0x196   0xD001             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_25
   \      0x198   0x2001             MOVS     R0,#+1
   \      0x19A   0xE02C             B.N      ??HAL_TIMEx_OCN_Start_DMA_5
   \                     ??HAL_TIMEx_OCN_Start_DMA_25: (+1)
   \      0x19C   0x6828             LDR      R0,[R5, #+0]
   \      0x19E   0x68C0             LDR      R0,[R0, #+12]
   \      0x1A0   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x1A4   0x6829             LDR      R1,[R5, #+0]
   \      0x1A6   0x60C8             STR      R0,[R1, #+12]
   \      0x1A8   0xE781             B.N      ??HAL_TIMEx_OCN_Start_DMA_20
   \                     ??HAL_TIMEx_OCN_Start_DMA_18: (+1)
   \      0x1AA   0x.... 0x....      LDR.W    R0,??DataTable10
   \      0x1AE   0x6AEA             LDR      R2,[R5, #+44]
   \      0x1B0   0x63D0             STR      R0,[R2, #+60]
   \      0x1B2   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \      0x1B6   0x6AEA             LDR      R2,[R5, #+44]
   \      0x1B8   0x6410             STR      R0,[R2, #+64]
   \      0x1BA   0x.... 0x....      LDR.W    R0,??DataTable11
   \      0x1BE   0x6AEA             LDR      R2,[R5, #+44]
   \      0x1C0   0x64D0             STR      R0,[R2, #+76]
   \      0x1C2   0xB29B             UXTH     R3,R3
   \      0x1C4   0x6828             LDR      R0,[R5, #+0]
   \      0x1C6   0xF110 0x023C      ADDS     R2,R0,#+60
   \      0x1CA   0x6AE8             LDR      R0,[R5, #+44]
   \      0x1CC   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x1D0   0x2800             CMP      R0,#+0
   \      0x1D2   0xD001             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_26
   \      0x1D4   0x2001             MOVS     R0,#+1
   \      0x1D6   0xE00E             B.N      ??HAL_TIMEx_OCN_Start_DMA_5
   \                     ??HAL_TIMEx_OCN_Start_DMA_26: (+1)
   \      0x1D8   0x6828             LDR      R0,[R5, #+0]
   \      0x1DA   0x68C0             LDR      R0,[R0, #+12]
   \      0x1DC   0xF450 0x6000      ORRS     R0,R0,#0x800
   \      0x1E0   0x6829             LDR      R1,[R5, #+0]
   \      0x1E2   0x60C8             STR      R0,[R1, #+12]
   \      0x1E4   0xE763             B.N      ??HAL_TIMEx_OCN_Start_DMA_20
    999              else
   1000              {
   1001                __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIMEx_OCN_Start_DMA_23: (+1)
   \      0x1E6   0x6828             LDR      R0,[R5, #+0]
   \      0x1E8   0x6800             LDR      R0,[R0, #+0]
   \      0x1EA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x1EE   0x6829             LDR      R1,[R5, #+0]
   \      0x1F0   0x6008             STR      R0,[R1, #+0]
   1002              }
   1003            }
   1004          
   1005            /* Return function status */
   1006            return status;
   \                     ??HAL_TIMEx_OCN_Start_DMA_21: (+1)
   \      0x1F2   0x0030             MOVS     R0,R6
   \      0x1F4   0xB2C0             UXTB     R0,R0
   \                     ??HAL_TIMEx_OCN_Start_DMA_5: (+1)
   \      0x1F6   0xBD70             POP      {R4-R6,PC}
   1007          }
   1008          
   1009          /**
   1010            * @brief  Stops the TIM Output Compare signal generation in DMA mode
   1011            *         on the complementary output.
   1012            * @param  htim TIM Output Compare handle
   1013            * @param  Channel TIM Channel to be disabled
   1014            *          This parameter can be one of the following values:
   1015            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1016            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1017            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1018            * @retval HAL status
   1019            */

   \                                 In section .text, align 2, keep-with-next
   1020          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1021          {
   \                     HAL_TIMEx_OCN_Stop_DMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   1022            HAL_StatusTypeDef status = HAL_OK;
   \        0x6   0x2500             MOVS     R5,#+0
   1023          
   1024            /* Check the parameters */
   1025            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1026          
   1027            switch (Channel)
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD004             BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_0
   \        0xE   0x2804             CMP      R0,#+4
   \       0x10   0xD00C             BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_1
   \       0x12   0x2808             CMP      R0,#+8
   \       0x14   0xD014             BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_2
   \       0x16   0xE01D             B.N      ??HAL_TIMEx_OCN_Stop_DMA_3
   1028            {
   1029              case TIM_CHANNEL_1:
   1030              {
   1031                /* Disable the TIM Output Compare DMA request */
   1032                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_0: (+1)
   \       0x18   0x6830             LDR      R0,[R6, #+0]
   \       0x1A   0x68C0             LDR      R0,[R0, #+12]
   \       0x1C   0xF430 0x7000      BICS     R0,R0,#0x200
   \       0x20   0x6831             LDR      R1,[R6, #+0]
   \       0x22   0x60C8             STR      R0,[R1, #+12]
   1033                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x24   0x6A70             LDR      R0,[R6, #+36]
   \       0x26   0x.... 0x....      BL       HAL_DMA_Abort_IT
   1034                break;
   \       0x2A   0xE014             B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
   1035              }
   1036          
   1037              case TIM_CHANNEL_2:
   1038              {
   1039                /* Disable the TIM Output Compare DMA request */
   1040                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_1: (+1)
   \       0x2C   0x6830             LDR      R0,[R6, #+0]
   \       0x2E   0x68C0             LDR      R0,[R0, #+12]
   \       0x30   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x34   0x6831             LDR      R1,[R6, #+0]
   \       0x36   0x60C8             STR      R0,[R1, #+12]
   1041                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \       0x38   0x6AB0             LDR      R0,[R6, #+40]
   \       0x3A   0x.... 0x....      BL       HAL_DMA_Abort_IT
   1042                break;
   \       0x3E   0xE00A             B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
   1043              }
   1044          
   1045              case TIM_CHANNEL_3:
   1046              {
   1047                /* Disable the TIM Output Compare DMA request */
   1048                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_2: (+1)
   \       0x40   0x6830             LDR      R0,[R6, #+0]
   \       0x42   0x68C0             LDR      R0,[R0, #+12]
   \       0x44   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x48   0x6831             LDR      R1,[R6, #+0]
   \       0x4A   0x60C8             STR      R0,[R1, #+12]
   1049                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \       0x4C   0x6AF0             LDR      R0,[R6, #+44]
   \       0x4E   0x.... 0x....      BL       HAL_DMA_Abort_IT
   1050                break;
   \       0x52   0xE000             B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
   1051              }
   1052          
   1053              default:
   1054                status = HAL_ERROR;
   \                     ??HAL_TIMEx_OCN_Stop_DMA_3: (+1)
   \       0x54   0x2501             MOVS     R5,#+1
   1055                break;
   1056            }
   1057          
   1058            if (status == HAL_OK)
   \                     ??HAL_TIMEx_OCN_Stop_DMA_4: (+1)
   \       0x56   0x0028             MOVS     R0,R5
   \       0x58   0xB2C0             UXTB     R0,R0
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD13F             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_5
   1059            {
   1060              /* Disable the Capture compare channel N */
   1061              TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \       0x5E   0x2200             MOVS     R2,#+0
   \       0x60   0x0021             MOVS     R1,R4
   \       0x62   0x6830             LDR      R0,[R6, #+0]
   \       0x64   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1062          
   1063              /* Disable the Main Output */
   1064              __HAL_TIM_MOE_DISABLE(htim);
   \       0x68   0xF241 0x1011      MOVW     R0,#+4369
   \       0x6C   0x6831             LDR      R1,[R6, #+0]
   \       0x6E   0x6A09             LDR      R1,[R1, #+32]
   \       0x70   0x4201             TST      R1,R0
   \       0x72   0xD10B             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_6
   \       0x74   0x6831             LDR      R1,[R6, #+0]
   \       0x76   0x6A09             LDR      R1,[R1, #+32]
   \       0x78   0xF240 0x4244      MOVW     R2,#+1092
   \       0x7C   0x4211             TST      R1,R2
   \       0x7E   0xD105             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_6
   \       0x80   0x6831             LDR      R1,[R6, #+0]
   \       0x82   0x6C49             LDR      R1,[R1, #+68]
   \       0x84   0xF431 0x4100      BICS     R1,R1,#0x8000
   \       0x88   0x6832             LDR      R2,[R6, #+0]
   \       0x8A   0x6451             STR      R1,[R2, #+68]
   1065          
   1066              /* Disable the Peripheral */
   1067              __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_6: (+1)
   \       0x8C   0x6831             LDR      R1,[R6, #+0]
   \       0x8E   0x6A09             LDR      R1,[R1, #+32]
   \       0x90   0x4201             TST      R1,R0
   \       0x92   0xD10B             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_7
   \       0x94   0x6830             LDR      R0,[R6, #+0]
   \       0x96   0x6A00             LDR      R0,[R0, #+32]
   \       0x98   0xF240 0x4144      MOVW     R1,#+1092
   \       0x9C   0x4208             TST      R0,R1
   \       0x9E   0xD105             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_7
   \       0xA0   0x6830             LDR      R0,[R6, #+0]
   \       0xA2   0x6800             LDR      R0,[R0, #+0]
   \       0xA4   0x0840             LSRS     R0,R0,#+1
   \       0xA6   0x0040             LSLS     R0,R0,#+1
   \       0xA8   0x6831             LDR      R1,[R6, #+0]
   \       0xAA   0x6008             STR      R0,[R1, #+0]
   1068          
   1069              /* Set the TIM complementary channel state */
   1070              TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_7: (+1)
   \       0xAC   0x2C00             CMP      R4,#+0
   \       0xAE   0xD104             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_8
   \       0xB0   0x2001             MOVS     R0,#+1
   \       0xB2   0xF886 0x0044      STRB     R0,[R6, #+68]
   \       0xB6   0xB2C0             UXTB     R0,R0
   \       0xB8   0xE011             B.N      ??HAL_TIMEx_OCN_Stop_DMA_5
   \                     ??HAL_TIMEx_OCN_Stop_DMA_8: (+1)
   \       0xBA   0x2C04             CMP      R4,#+4
   \       0xBC   0xD104             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_9
   \       0xBE   0x2001             MOVS     R0,#+1
   \       0xC0   0xF886 0x0045      STRB     R0,[R6, #+69]
   \       0xC4   0xB2C0             UXTB     R0,R0
   \       0xC6   0xE00A             B.N      ??HAL_TIMEx_OCN_Stop_DMA_5
   \                     ??HAL_TIMEx_OCN_Stop_DMA_9: (+1)
   \       0xC8   0x2C08             CMP      R4,#+8
   \       0xCA   0xD104             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_10
   \       0xCC   0x2001             MOVS     R0,#+1
   \       0xCE   0xF886 0x0046      STRB     R0,[R6, #+70]
   \       0xD2   0xB2C0             UXTB     R0,R0
   \       0xD4   0xE003             B.N      ??HAL_TIMEx_OCN_Stop_DMA_5
   \                     ??HAL_TIMEx_OCN_Stop_DMA_10: (+1)
   \       0xD6   0x2001             MOVS     R0,#+1
   \       0xD8   0xF886 0x0047      STRB     R0,[R6, #+71]
   \       0xDC   0xB2C0             UXTB     R0,R0
   1071            }
   1072          
   1073            /* Return function status */
   1074            return status;
   \                     ??HAL_TIMEx_OCN_Stop_DMA_5: (+1)
   \       0xDE   0x0028             MOVS     R0,R5
   \       0xE0   0xB2C0             UXTB     R0,R0
   \       0xE2   0xBD70             POP      {R4-R6,PC}
   1075          }
   1076          
   1077          /**
   1078            * @}
   1079            */
   1080          
   1081          /** @defgroup TIMEx_Exported_Functions_Group3 Extended Timer Complementary PWM functions
   1082            * @brief    Timer Complementary PWM functions
   1083            *
   1084          @verbatim
   1085            ==============================================================================
   1086                           ##### Timer Complementary PWM functions #####
   1087            ==============================================================================
   1088            [..]
   1089              This section provides functions allowing to:
   1090              (+) Start the Complementary PWM.
   1091              (+) Stop the Complementary PWM.
   1092              (+) Start the Complementary PWM and enable interrupts.
   1093              (+) Stop the Complementary PWM and disable interrupts.
   1094              (+) Start the Complementary PWM and enable DMA transfers.
   1095              (+) Stop the Complementary PWM and disable DMA transfers.
   1096              (+) Start the Complementary Input Capture measurement.
   1097              (+) Stop the Complementary Input Capture.
   1098              (+) Start the Complementary Input Capture and enable interrupts.
   1099              (+) Stop the Complementary Input Capture and disable interrupts.
   1100              (+) Start the Complementary Input Capture and enable DMA transfers.
   1101              (+) Stop the Complementary Input Capture and disable DMA transfers.
   1102              (+) Start the Complementary One Pulse generation.
   1103              (+) Stop the Complementary One Pulse.
   1104              (+) Start the Complementary One Pulse and enable interrupts.
   1105              (+) Stop the Complementary One Pulse and disable interrupts.
   1106          
   1107          @endverbatim
   1108            * @{
   1109            */
   1110          
   1111          /**
   1112            * @brief  Starts the PWM signal generation on the complementary output.
   1113            * @param  htim TIM handle
   1114            * @param  Channel TIM Channel to be enabled
   1115            *          This parameter can be one of the following values:
   1116            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1117            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1118            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1119            * @retval HAL status
   1120            */

   \                                 In section .text, align 2, keep-with-next
   1121          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1122          {
   \                     HAL_TIMEx_PWMN_Start: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1123            uint32_t tmpsmcr;
   1124          
   1125            /* Check the parameters */
   1126            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1127          
   1128            /* Check the TIM complementary channel state */
   1129            if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD102             BNE.N    ??HAL_TIMEx_PWMN_Start_0
   \        0x8   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \        0xC   0xE00B             B.N      ??HAL_TIMEx_PWMN_Start_1
   \                     ??HAL_TIMEx_PWMN_Start_0: (+1)
   \        0xE   0x2904             CMP      R1,#+4
   \       0x10   0xD102             BNE.N    ??HAL_TIMEx_PWMN_Start_2
   \       0x12   0xF894 0x0045      LDRB     R0,[R4, #+69]
   \       0x16   0xE006             B.N      ??HAL_TIMEx_PWMN_Start_1
   \                     ??HAL_TIMEx_PWMN_Start_2: (+1)
   \       0x18   0x2908             CMP      R1,#+8
   \       0x1A   0xD102             BNE.N    ??HAL_TIMEx_PWMN_Start_3
   \       0x1C   0xF894 0x0046      LDRB     R0,[R4, #+70]
   \       0x20   0xE001             B.N      ??HAL_TIMEx_PWMN_Start_1
   \                     ??HAL_TIMEx_PWMN_Start_3: (+1)
   \       0x22   0xF894 0x0047      LDRB     R0,[R4, #+71]
   \                     ??HAL_TIMEx_PWMN_Start_1: (+1)
   \       0x26   0x2801             CMP      R0,#+1
   \       0x28   0xD001             BEQ.N    ??HAL_TIMEx_PWMN_Start_4
   1130            {
   1131              return HAL_ERROR;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE061             B.N      ??HAL_TIMEx_PWMN_Start_5
   1132            }
   1133          
   1134            /* Set the TIM complementary channel state */
   1135            TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
   \                     ??HAL_TIMEx_PWMN_Start_4: (+1)
   \       0x2E   0x2900             CMP      R1,#+0
   \       0x30   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Start_6
   \       0x32   0x2002             MOVS     R0,#+2
   \       0x34   0xF884 0x0044      STRB     R0,[R4, #+68]
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0xE011             B.N      ??HAL_TIMEx_PWMN_Start_7
   \                     ??HAL_TIMEx_PWMN_Start_6: (+1)
   \       0x3C   0x2904             CMP      R1,#+4
   \       0x3E   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Start_8
   \       0x40   0x2002             MOVS     R0,#+2
   \       0x42   0xF884 0x0045      STRB     R0,[R4, #+69]
   \       0x46   0xB2C0             UXTB     R0,R0
   \       0x48   0xE00A             B.N      ??HAL_TIMEx_PWMN_Start_7
   \                     ??HAL_TIMEx_PWMN_Start_8: (+1)
   \       0x4A   0x2908             CMP      R1,#+8
   \       0x4C   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Start_9
   \       0x4E   0x2002             MOVS     R0,#+2
   \       0x50   0xF884 0x0046      STRB     R0,[R4, #+70]
   \       0x54   0xB2C0             UXTB     R0,R0
   \       0x56   0xE003             B.N      ??HAL_TIMEx_PWMN_Start_7
   \                     ??HAL_TIMEx_PWMN_Start_9: (+1)
   \       0x58   0x2002             MOVS     R0,#+2
   \       0x5A   0xF884 0x0047      STRB     R0,[R4, #+71]
   \       0x5E   0xB2C0             UXTB     R0,R0
   1136          
   1137            /* Enable the complementary PWM output  */
   1138            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \                     ??HAL_TIMEx_PWMN_Start_7: (+1)
   \       0x60   0x2204             MOVS     R2,#+4
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1139          
   1140            /* Enable the Main Output */
   1141            __HAL_TIM_MOE_ENABLE(htim);
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x6C40             LDR      R0,[R0, #+68]
   \       0x6C   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x70   0x6821             LDR      R1,[R4, #+0]
   \       0x72   0x6448             STR      R0,[R1, #+68]
   1142          
   1143            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1144            if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x.... 0x....      LDR.W    R1,??DataTable13
   \       0x7A   0x4288             CMP      R0,R1
   \       0x7C   0xD021             BEQ.N    ??HAL_TIMEx_PWMN_Start_10
   \       0x7E   0x6820             LDR      R0,[R4, #+0]
   \       0x80   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0x84   0xD01D             BEQ.N    ??HAL_TIMEx_PWMN_Start_10
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \       0x8C   0x4288             CMP      R0,R1
   \       0x8E   0xD018             BEQ.N    ??HAL_TIMEx_PWMN_Start_10
   \       0x90   0x6820             LDR      R0,[R4, #+0]
   \       0x92   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \       0x96   0x4288             CMP      R0,R1
   \       0x98   0xD013             BEQ.N    ??HAL_TIMEx_PWMN_Start_10
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \       0xA0   0x4288             CMP      R0,R1
   \       0xA2   0xD00E             BEQ.N    ??HAL_TIMEx_PWMN_Start_10
   \       0xA4   0x6820             LDR      R0,[R4, #+0]
   \       0xA6   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \       0xAA   0x4288             CMP      R0,R1
   \       0xAC   0xD009             BEQ.N    ??HAL_TIMEx_PWMN_Start_10
   \       0xAE   0x6820             LDR      R0,[R4, #+0]
   \       0xB0   0x.... 0x....      LDR.W    R1,??DataTable14
   \       0xB4   0x4288             CMP      R0,R1
   \       0xB6   0xD004             BEQ.N    ??HAL_TIMEx_PWMN_Start_10
   \       0xB8   0x6820             LDR      R0,[R4, #+0]
   \       0xBA   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \       0xBE   0x4288             CMP      R0,R1
   \       0xC0   0xD110             BNE.N    ??HAL_TIMEx_PWMN_Start_11
   1145            {
   1146              tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIMEx_PWMN_Start_10: (+1)
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0x6881             LDR      R1,[R0, #+8]
   \       0xC6   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \       0xCA   0x4001             ANDS     R1,R0,R1
   1147              if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0xCC   0x2906             CMP      R1,#+6
   \       0xCE   0xD00F             BEQ.N    ??HAL_TIMEx_PWMN_Start_12
   \       0xD0   0xF5B1 0x3F80      CMP      R1,#+65536
   \       0xD4   0xD00C             BEQ.N    ??HAL_TIMEx_PWMN_Start_12
   1148              {
   1149                __HAL_TIM_ENABLE(htim);
   \       0xD6   0x6820             LDR      R0,[R4, #+0]
   \       0xD8   0x6800             LDR      R0,[R0, #+0]
   \       0xDA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xDE   0x6821             LDR      R1,[R4, #+0]
   \       0xE0   0x6008             STR      R0,[R1, #+0]
   \       0xE2   0xE005             B.N      ??HAL_TIMEx_PWMN_Start_12
   1150              }
   1151            }
   1152            else
   1153            {
   1154              __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Start_11: (+1)
   \       0xE4   0x6820             LDR      R0,[R4, #+0]
   \       0xE6   0x6800             LDR      R0,[R0, #+0]
   \       0xE8   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xEC   0x6821             LDR      R1,[R4, #+0]
   \       0xEE   0x6008             STR      R0,[R1, #+0]
   1155            }
   1156          
   1157            /* Return function status */
   1158            return HAL_OK;
   \                     ??HAL_TIMEx_PWMN_Start_12: (+1)
   \       0xF0   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_PWMN_Start_5: (+1)
   \       0xF2   0xBD10             POP      {R4,PC}
   1159          }
   1160          
   1161          /**
   1162            * @brief  Stops the PWM signal generation on the complementary output.
   1163            * @param  htim TIM handle
   1164            * @param  Channel TIM Channel to be disabled
   1165            *          This parameter can be one of the following values:
   1166            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1167            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1168            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1169            * @retval HAL status
   1170            */

   \                                 In section .text, align 2, keep-with-next
   1171          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1172          {
   \                     HAL_TIMEx_PWMN_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1173            /* Check the parameters */
   1174            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1175          
   1176            /* Disable the complementary PWM output  */
   1177            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x0021             MOVS     R1,R4
   \        0xA   0x6828             LDR      R0,[R5, #+0]
   \        0xC   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1178          
   1179            /* Disable the Main Output */
   1180            __HAL_TIM_MOE_DISABLE(htim);
   \       0x10   0xF241 0x1011      MOVW     R0,#+4369
   \       0x14   0x6829             LDR      R1,[R5, #+0]
   \       0x16   0x6A09             LDR      R1,[R1, #+32]
   \       0x18   0x4201             TST      R1,R0
   \       0x1A   0xD10B             BNE.N    ??HAL_TIMEx_PWMN_Stop_0
   \       0x1C   0x6829             LDR      R1,[R5, #+0]
   \       0x1E   0x6A09             LDR      R1,[R1, #+32]
   \       0x20   0xF240 0x4244      MOVW     R2,#+1092
   \       0x24   0x4211             TST      R1,R2
   \       0x26   0xD105             BNE.N    ??HAL_TIMEx_PWMN_Stop_0
   \       0x28   0x6829             LDR      R1,[R5, #+0]
   \       0x2A   0x6C49             LDR      R1,[R1, #+68]
   \       0x2C   0xF431 0x4100      BICS     R1,R1,#0x8000
   \       0x30   0x682A             LDR      R2,[R5, #+0]
   \       0x32   0x6451             STR      R1,[R2, #+68]
   1181          
   1182            /* Disable the Peripheral */
   1183            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_0: (+1)
   \       0x34   0x6829             LDR      R1,[R5, #+0]
   \       0x36   0x6A09             LDR      R1,[R1, #+32]
   \       0x38   0x4201             TST      R1,R0
   \       0x3A   0xD10B             BNE.N    ??HAL_TIMEx_PWMN_Stop_1
   \       0x3C   0x6828             LDR      R0,[R5, #+0]
   \       0x3E   0x6A00             LDR      R0,[R0, #+32]
   \       0x40   0xF240 0x4144      MOVW     R1,#+1092
   \       0x44   0x4208             TST      R0,R1
   \       0x46   0xD105             BNE.N    ??HAL_TIMEx_PWMN_Stop_1
   \       0x48   0x6828             LDR      R0,[R5, #+0]
   \       0x4A   0x6800             LDR      R0,[R0, #+0]
   \       0x4C   0x0840             LSRS     R0,R0,#+1
   \       0x4E   0x0040             LSLS     R0,R0,#+1
   \       0x50   0x6829             LDR      R1,[R5, #+0]
   \       0x52   0x6008             STR      R0,[R1, #+0]
   1184          
   1185            /* Set the TIM complementary channel state */
   1186            TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   \                     ??HAL_TIMEx_PWMN_Stop_1: (+1)
   \       0x54   0x2C00             CMP      R4,#+0
   \       0x56   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Stop_2
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0xF885 0x0044      STRB     R0,[R5, #+68]
   \       0x5E   0xB2C0             UXTB     R0,R0
   \       0x60   0xE011             B.N      ??HAL_TIMEx_PWMN_Stop_3
   \                     ??HAL_TIMEx_PWMN_Stop_2: (+1)
   \       0x62   0x2C04             CMP      R4,#+4
   \       0x64   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Stop_4
   \       0x66   0x2001             MOVS     R0,#+1
   \       0x68   0xF885 0x0045      STRB     R0,[R5, #+69]
   \       0x6C   0xB2C0             UXTB     R0,R0
   \       0x6E   0xE00A             B.N      ??HAL_TIMEx_PWMN_Stop_3
   \                     ??HAL_TIMEx_PWMN_Stop_4: (+1)
   \       0x70   0x2C08             CMP      R4,#+8
   \       0x72   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Stop_5
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0xF885 0x0046      STRB     R0,[R5, #+70]
   \       0x7A   0xB2C0             UXTB     R0,R0
   \       0x7C   0xE003             B.N      ??HAL_TIMEx_PWMN_Stop_3
   \                     ??HAL_TIMEx_PWMN_Stop_5: (+1)
   \       0x7E   0x2001             MOVS     R0,#+1
   \       0x80   0xF885 0x0047      STRB     R0,[R5, #+71]
   \       0x84   0xB2C0             UXTB     R0,R0
   1187          
   1188            /* Return function status */
   1189            return HAL_OK;
   \                     ??HAL_TIMEx_PWMN_Stop_3: (+1)
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0xBD32             POP      {R1,R4,R5,PC}
   1190          }
   1191          
   1192          /**
   1193            * @brief  Starts the PWM signal generation in interrupt mode on the
   1194            *         complementary output.
   1195            * @param  htim TIM handle
   1196            * @param  Channel TIM Channel to be disabled
   1197            *          This parameter can be one of the following values:
   1198            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1199            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1200            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1201            * @retval HAL status
   1202            */

   \                                 In section .text, align 2, keep-with-next
   1203          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1204          {
   \                     HAL_TIMEx_PWMN_Start_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1205            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
   1206            uint32_t tmpsmcr;
   1207          
   1208            /* Check the parameters */
   1209            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1210          
   1211            /* Check the TIM complementary channel state */
   1212            if (TIM_CHANNEL_N_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD102             BNE.N    ??HAL_TIMEx_PWMN_Start_IT_0
   \        0xA   0xF894 0x0044      LDRB     R0,[R4, #+68]
   \        0xE   0xE00B             B.N      ??HAL_TIMEx_PWMN_Start_IT_1
   \                     ??HAL_TIMEx_PWMN_Start_IT_0: (+1)
   \       0x10   0x2904             CMP      R1,#+4
   \       0x12   0xD102             BNE.N    ??HAL_TIMEx_PWMN_Start_IT_2
   \       0x14   0xF894 0x0045      LDRB     R0,[R4, #+69]
   \       0x18   0xE006             B.N      ??HAL_TIMEx_PWMN_Start_IT_1
   \                     ??HAL_TIMEx_PWMN_Start_IT_2: (+1)
   \       0x1A   0x2908             CMP      R1,#+8
   \       0x1C   0xD102             BNE.N    ??HAL_TIMEx_PWMN_Start_IT_3
   \       0x1E   0xF894 0x0046      LDRB     R0,[R4, #+70]
   \       0x22   0xE001             B.N      ??HAL_TIMEx_PWMN_Start_IT_1
   \                     ??HAL_TIMEx_PWMN_Start_IT_3: (+1)
   \       0x24   0xF894 0x0047      LDRB     R0,[R4, #+71]
   \                     ??HAL_TIMEx_PWMN_Start_IT_1: (+1)
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD001             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_4
   1213            {
   1214              return HAL_ERROR;
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xE08A             B.N      ??HAL_TIMEx_PWMN_Start_IT_5
   1215            }
   1216          
   1217            /* Set the TIM complementary channel state */
   1218            TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
   \                     ??HAL_TIMEx_PWMN_Start_IT_4: (+1)
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Start_IT_6
   \       0x34   0x2002             MOVS     R0,#+2
   \       0x36   0xF884 0x0044      STRB     R0,[R4, #+68]
   \       0x3A   0xB2C0             UXTB     R0,R0
   \       0x3C   0xE011             B.N      ??HAL_TIMEx_PWMN_Start_IT_7
   \                     ??HAL_TIMEx_PWMN_Start_IT_6: (+1)
   \       0x3E   0x2904             CMP      R1,#+4
   \       0x40   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Start_IT_8
   \       0x42   0x2002             MOVS     R0,#+2
   \       0x44   0xF884 0x0045      STRB     R0,[R4, #+69]
   \       0x48   0xB2C0             UXTB     R0,R0
   \       0x4A   0xE00A             B.N      ??HAL_TIMEx_PWMN_Start_IT_7
   \                     ??HAL_TIMEx_PWMN_Start_IT_8: (+1)
   \       0x4C   0x2908             CMP      R1,#+8
   \       0x4E   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Start_IT_9
   \       0x50   0x2002             MOVS     R0,#+2
   \       0x52   0xF884 0x0046      STRB     R0,[R4, #+70]
   \       0x56   0xB2C0             UXTB     R0,R0
   \       0x58   0xE003             B.N      ??HAL_TIMEx_PWMN_Start_IT_7
   \                     ??HAL_TIMEx_PWMN_Start_IT_9: (+1)
   \       0x5A   0x2002             MOVS     R0,#+2
   \       0x5C   0xF884 0x0047      STRB     R0,[R4, #+71]
   \       0x60   0xB2C0             UXTB     R0,R0
   1219          
   1220            switch (Channel)
   \                     ??HAL_TIMEx_PWMN_Start_IT_7: (+1)
   \       0x62   0x0008             MOVS     R0,R1
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD004             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_10
   \       0x68   0x2804             CMP      R0,#+4
   \       0x6A   0xD009             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_11
   \       0x6C   0x2808             CMP      R0,#+8
   \       0x6E   0xD00E             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_12
   \       0x70   0xE014             B.N      ??HAL_TIMEx_PWMN_Start_IT_13
   1221            {
   1222              case TIM_CHANNEL_1:
   1223              {
   1224                /* Enable the TIM Capture/Compare 1 interrupt */
   1225                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_PWMN_Start_IT_10: (+1)
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x68C0             LDR      R0,[R0, #+12]
   \       0x76   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x7A   0x6822             LDR      R2,[R4, #+0]
   \       0x7C   0x60D0             STR      R0,[R2, #+12]
   1226                break;
   \       0x7E   0xE00E             B.N      ??HAL_TIMEx_PWMN_Start_IT_14
   1227              }
   1228          
   1229              case TIM_CHANNEL_2:
   1230              {
   1231                /* Enable the TIM Capture/Compare 2 interrupt */
   1232                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_PWMN_Start_IT_11: (+1)
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x68C0             LDR      R0,[R0, #+12]
   \       0x84   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x88   0x6822             LDR      R2,[R4, #+0]
   \       0x8A   0x60D0             STR      R0,[R2, #+12]
   1233                break;
   \       0x8C   0xE007             B.N      ??HAL_TIMEx_PWMN_Start_IT_14
   1234              }
   1235          
   1236              case TIM_CHANNEL_3:
   1237              {
   1238                /* Enable the TIM Capture/Compare 3 interrupt */
   1239                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_PWMN_Start_IT_12: (+1)
   \       0x8E   0x6820             LDR      R0,[R4, #+0]
   \       0x90   0x68C0             LDR      R0,[R0, #+12]
   \       0x92   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0x96   0x6822             LDR      R2,[R4, #+0]
   \       0x98   0x60D0             STR      R0,[R2, #+12]
   1240                break;
   \       0x9A   0xE000             B.N      ??HAL_TIMEx_PWMN_Start_IT_14
   1241              }
   1242          
   1243              default:
   1244                status = HAL_ERROR;
   \                     ??HAL_TIMEx_PWMN_Start_IT_13: (+1)
   \       0x9C   0x2501             MOVS     R5,#+1
   1245                break;
   1246            }
   1247          
   1248            if (status == HAL_OK)
   \                     ??HAL_TIMEx_PWMN_Start_IT_14: (+1)
   \       0x9E   0x0028             MOVS     R0,R5
   \       0xA0   0xB2C0             UXTB     R0,R0
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD14D             BNE.N    ??HAL_TIMEx_PWMN_Start_IT_15
   1249            {
   1250              /* Enable the TIM Break interrupt */
   1251              __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
   \       0xA6   0x6820             LDR      R0,[R4, #+0]
   \       0xA8   0x68C0             LDR      R0,[R0, #+12]
   \       0xAA   0xF050 0x0080      ORRS     R0,R0,#0x80
   \       0xAE   0x6822             LDR      R2,[R4, #+0]
   \       0xB0   0x60D0             STR      R0,[R2, #+12]
   1252          
   1253              /* Enable the complementary PWM output  */
   1254              TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \       0xB2   0x2204             MOVS     R2,#+4
   \       0xB4   0x6820             LDR      R0,[R4, #+0]
   \       0xB6   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1255          
   1256              /* Enable the Main Output */
   1257              __HAL_TIM_MOE_ENABLE(htim);
   \       0xBA   0x6820             LDR      R0,[R4, #+0]
   \       0xBC   0x6C40             LDR      R0,[R0, #+68]
   \       0xBE   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0xC2   0x6821             LDR      R1,[R4, #+0]
   \       0xC4   0x6448             STR      R0,[R1, #+68]
   1258          
   1259              /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1260              if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   \       0xC6   0x6820             LDR      R0,[R4, #+0]
   \       0xC8   0x.... 0x....      LDR.W    R1,??DataTable13
   \       0xCC   0x4288             CMP      R0,R1
   \       0xCE   0xD021             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_16
   \       0xD0   0x6820             LDR      R0,[R4, #+0]
   \       0xD2   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0xD6   0xD01D             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_16
   \       0xD8   0x6820             LDR      R0,[R4, #+0]
   \       0xDA   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \       0xDE   0x4288             CMP      R0,R1
   \       0xE0   0xD018             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_16
   \       0xE2   0x6820             LDR      R0,[R4, #+0]
   \       0xE4   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \       0xE8   0x4288             CMP      R0,R1
   \       0xEA   0xD013             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_16
   \       0xEC   0x6820             LDR      R0,[R4, #+0]
   \       0xEE   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \       0xF2   0x4288             CMP      R0,R1
   \       0xF4   0xD00E             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_16
   \       0xF6   0x6820             LDR      R0,[R4, #+0]
   \       0xF8   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \       0xFC   0x4288             CMP      R0,R1
   \       0xFE   0xD009             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_16
   \      0x100   0x6820             LDR      R0,[R4, #+0]
   \      0x102   0x.... 0x....      LDR.W    R1,??DataTable14
   \      0x106   0x4288             CMP      R0,R1
   \      0x108   0xD004             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_16
   \      0x10A   0x6820             LDR      R0,[R4, #+0]
   \      0x10C   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \      0x110   0x4288             CMP      R0,R1
   \      0x112   0xD110             BNE.N    ??HAL_TIMEx_PWMN_Start_IT_17
   1261              {
   1262                tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIMEx_PWMN_Start_IT_16: (+1)
   \      0x114   0x6820             LDR      R0,[R4, #+0]
   \      0x116   0x6881             LDR      R1,[R0, #+8]
   \      0x118   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \      0x11C   0x4001             ANDS     R1,R0,R1
   1263                if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \      0x11E   0x2906             CMP      R1,#+6
   \      0x120   0xD00F             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_15
   \      0x122   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x126   0xD00C             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_15
   1264                {
   1265                  __HAL_TIM_ENABLE(htim);
   \      0x128   0x6820             LDR      R0,[R4, #+0]
   \      0x12A   0x6800             LDR      R0,[R0, #+0]
   \      0x12C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x130   0x6821             LDR      R1,[R4, #+0]
   \      0x132   0x6008             STR      R0,[R1, #+0]
   \      0x134   0xE005             B.N      ??HAL_TIMEx_PWMN_Start_IT_15
   1266                }
   1267              }
   1268              else
   1269              {
   1270                __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Start_IT_17: (+1)
   \      0x136   0x6820             LDR      R0,[R4, #+0]
   \      0x138   0x6800             LDR      R0,[R0, #+0]
   \      0x13A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x13E   0x6821             LDR      R1,[R4, #+0]
   \      0x140   0x6008             STR      R0,[R1, #+0]
   1271              }
   1272            }
   1273          
   1274            /* Return function status */
   1275            return status;
   \                     ??HAL_TIMEx_PWMN_Start_IT_15: (+1)
   \      0x142   0x0028             MOVS     R0,R5
   \      0x144   0xB2C0             UXTB     R0,R0
   \                     ??HAL_TIMEx_PWMN_Start_IT_5: (+1)
   \      0x146   0xBD32             POP      {R1,R4,R5,PC}
   1276          }
   1277          
   1278          /**
   1279            * @brief  Stops the PWM signal generation in interrupt mode on the
   1280            *         complementary output.
   1281            * @param  htim TIM handle
   1282            * @param  Channel TIM Channel to be disabled
   1283            *          This parameter can be one of the following values:
   1284            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1285            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1286            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1287            * @retval HAL status
   1288            */

   \                                 In section .text, align 2, keep-with-next
   1289          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1290          {
   \                     HAL_TIMEx_PWMN_Stop_IT: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   1291            HAL_StatusTypeDef status = HAL_OK;
   \        0x6   0x2500             MOVS     R5,#+0
   1292            uint32_t tmpccer;
   1293          
   1294            /* Check the parameters */
   1295            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1296          
   1297            switch (Channel)
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD004             BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_0
   \        0xE   0x2804             CMP      R0,#+4
   \       0x10   0xD009             BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_1
   \       0x12   0x2808             CMP      R0,#+8
   \       0x14   0xD00E             BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_2
   \       0x16   0xE014             B.N      ??HAL_TIMEx_PWMN_Stop_IT_3
   1298            {
   1299              case TIM_CHANNEL_1:
   1300              {
   1301                /* Disable the TIM Capture/Compare 1 interrupt */
   1302                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_0: (+1)
   \       0x18   0x6830             LDR      R0,[R6, #+0]
   \       0x1A   0x68C0             LDR      R0,[R0, #+12]
   \       0x1C   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x20   0x6831             LDR      R1,[R6, #+0]
   \       0x22   0x60C8             STR      R0,[R1, #+12]
   1303                break;
   \       0x24   0xE00E             B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
   1304              }
   1305          
   1306              case TIM_CHANNEL_2:
   1307              {
   1308                /* Disable the TIM Capture/Compare 2 interrupt */
   1309                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_1: (+1)
   \       0x26   0x6830             LDR      R0,[R6, #+0]
   \       0x28   0x68C0             LDR      R0,[R0, #+12]
   \       0x2A   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x2E   0x6831             LDR      R1,[R6, #+0]
   \       0x30   0x60C8             STR      R0,[R1, #+12]
   1310                break;
   \       0x32   0xE007             B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
   1311              }
   1312          
   1313              case TIM_CHANNEL_3:
   1314              {
   1315                /* Disable the TIM Capture/Compare 3 interrupt */
   1316                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_2: (+1)
   \       0x34   0x6830             LDR      R0,[R6, #+0]
   \       0x36   0x68C0             LDR      R0,[R0, #+12]
   \       0x38   0xF030 0x0008      BICS     R0,R0,#0x8
   \       0x3C   0x6831             LDR      R1,[R6, #+0]
   \       0x3E   0x60C8             STR      R0,[R1, #+12]
   1317                break;
   \       0x40   0xE000             B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
   1318              }
   1319          
   1320              default:
   1321                status = HAL_ERROR;
   \                     ??HAL_TIMEx_PWMN_Stop_IT_3: (+1)
   \       0x42   0x2501             MOVS     R5,#+1
   1322                break;
   1323            }
   1324          
   1325            if (status == HAL_OK)
   \                     ??HAL_TIMEx_PWMN_Stop_IT_4: (+1)
   \       0x44   0x0028             MOVS     R0,R5
   \       0x46   0xB2C0             UXTB     R0,R0
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD147             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_5
   1326            {
   1327              /* Disable the complementary PWM output  */
   1328              TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \       0x4C   0x2200             MOVS     R2,#+0
   \       0x4E   0x0021             MOVS     R1,R4
   \       0x50   0x6830             LDR      R0,[R6, #+0]
   \       0x52   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1329          
   1330              /* Disable the TIM Break interrupt (only if no more channel is active) */
   1331              tmpccer = htim->Instance->CCER;
   \       0x56   0x6830             LDR      R0,[R6, #+0]
   \       0x58   0x6A01             LDR      R1,[R0, #+32]
   1332              if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
   \       0x5A   0xF240 0x4044      MOVW     R0,#+1092
   \       0x5E   0x4201             TST      R1,R0
   \       0x60   0xD105             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_6
   1333              {
   1334                __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
   \       0x62   0x6831             LDR      R1,[R6, #+0]
   \       0x64   0x68C9             LDR      R1,[R1, #+12]
   \       0x66   0xF031 0x0180      BICS     R1,R1,#0x80
   \       0x6A   0x6832             LDR      R2,[R6, #+0]
   \       0x6C   0x60D1             STR      R1,[R2, #+12]
   1335              }
   1336          
   1337              /* Disable the Main Output */
   1338              __HAL_TIM_MOE_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_6: (+1)
   \       0x6E   0xF241 0x1111      MOVW     R1,#+4369
   \       0x72   0x6832             LDR      R2,[R6, #+0]
   \       0x74   0x6A12             LDR      R2,[R2, #+32]
   \       0x76   0x420A             TST      R2,R1
   \       0x78   0xD109             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_7
   \       0x7A   0x6832             LDR      R2,[R6, #+0]
   \       0x7C   0x6A12             LDR      R2,[R2, #+32]
   \       0x7E   0x4202             TST      R2,R0
   \       0x80   0xD105             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_7
   \       0x82   0x6832             LDR      R2,[R6, #+0]
   \       0x84   0x6C52             LDR      R2,[R2, #+68]
   \       0x86   0xF432 0x4200      BICS     R2,R2,#0x8000
   \       0x8A   0x6833             LDR      R3,[R6, #+0]
   \       0x8C   0x645A             STR      R2,[R3, #+68]
   1339          
   1340              /* Disable the Peripheral */
   1341              __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_7: (+1)
   \       0x8E   0x6832             LDR      R2,[R6, #+0]
   \       0x90   0x6A12             LDR      R2,[R2, #+32]
   \       0x92   0x420A             TST      R2,R1
   \       0x94   0xD109             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_8
   \       0x96   0x6831             LDR      R1,[R6, #+0]
   \       0x98   0x6A09             LDR      R1,[R1, #+32]
   \       0x9A   0x4201             TST      R1,R0
   \       0x9C   0xD105             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_8
   \       0x9E   0x6830             LDR      R0,[R6, #+0]
   \       0xA0   0x6800             LDR      R0,[R0, #+0]
   \       0xA2   0x0840             LSRS     R0,R0,#+1
   \       0xA4   0x0040             LSLS     R0,R0,#+1
   \       0xA6   0x6831             LDR      R1,[R6, #+0]
   \       0xA8   0x6008             STR      R0,[R1, #+0]
   1342          
   1343              /* Set the TIM complementary channel state */
   1344              TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_8: (+1)
   \       0xAA   0x2C00             CMP      R4,#+0
   \       0xAC   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_9
   \       0xAE   0x2001             MOVS     R0,#+1
   \       0xB0   0xF886 0x0044      STRB     R0,[R6, #+68]
   \       0xB4   0xB2C0             UXTB     R0,R0
   \       0xB6   0xE011             B.N      ??HAL_TIMEx_PWMN_Stop_IT_5
   \                     ??HAL_TIMEx_PWMN_Stop_IT_9: (+1)
   \       0xB8   0x2C04             CMP      R4,#+4
   \       0xBA   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_10
   \       0xBC   0x2001             MOVS     R0,#+1
   \       0xBE   0xF886 0x0045      STRB     R0,[R6, #+69]
   \       0xC2   0xB2C0             UXTB     R0,R0
   \       0xC4   0xE00A             B.N      ??HAL_TIMEx_PWMN_Stop_IT_5
   \                     ??HAL_TIMEx_PWMN_Stop_IT_10: (+1)
   \       0xC6   0x2C08             CMP      R4,#+8
   \       0xC8   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_11
   \       0xCA   0x2001             MOVS     R0,#+1
   \       0xCC   0xF886 0x0046      STRB     R0,[R6, #+70]
   \       0xD0   0xB2C0             UXTB     R0,R0
   \       0xD2   0xE003             B.N      ??HAL_TIMEx_PWMN_Stop_IT_5
   \                     ??HAL_TIMEx_PWMN_Stop_IT_11: (+1)
   \       0xD4   0x2001             MOVS     R0,#+1
   \       0xD6   0xF886 0x0047      STRB     R0,[R6, #+71]
   \       0xDA   0xB2C0             UXTB     R0,R0
   1345            }
   1346          
   1347            /* Return function status */
   1348            return status;
   \                     ??HAL_TIMEx_PWMN_Stop_IT_5: (+1)
   \       0xDC   0x0028             MOVS     R0,R5
   \       0xDE   0xB2C0             UXTB     R0,R0
   \       0xE0   0xBD70             POP      {R4-R6,PC}
   1349          }
   1350          
   1351          /**
   1352            * @brief  Starts the TIM PWM signal generation in DMA mode on the
   1353            *         complementary output
   1354            * @param  htim TIM handle
   1355            * @param  Channel TIM Channel to be enabled
   1356            *          This parameter can be one of the following values:
   1357            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1358            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1359            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1360            * @param  pData The source Buffer address.
   1361            * @param  Length The length of data to be transferred from memory to TIM peripheral
   1362            * @retval HAL status
   1363            */

   \                                 In section .text, align 2, keep-with-next
   1364          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1365          {
   \                     HAL_TIMEx_PWMN_Start_DMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0011             MOVS     R1,R2
   1366            HAL_StatusTypeDef status = HAL_OK;
   \        0x8   0x2600             MOVS     R6,#+0
   1367            uint32_t tmpsmcr;
   1368          
   1369            /* Check the parameters */
   1370            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1371          
   1372            /* Set the TIM complementary channel state */
   1373            if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_BUSY)
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD102             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_0
   \        0xE   0xF895 0x0044      LDRB     R0,[R5, #+68]
   \       0x12   0xE00B             B.N      ??HAL_TIMEx_PWMN_Start_DMA_1
   \                     ??HAL_TIMEx_PWMN_Start_DMA_0: (+1)
   \       0x14   0x2C04             CMP      R4,#+4
   \       0x16   0xD102             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_2
   \       0x18   0xF895 0x0045      LDRB     R0,[R5, #+69]
   \       0x1C   0xE006             B.N      ??HAL_TIMEx_PWMN_Start_DMA_1
   \                     ??HAL_TIMEx_PWMN_Start_DMA_2: (+1)
   \       0x1E   0x2C08             CMP      R4,#+8
   \       0x20   0xD102             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_3
   \       0x22   0xF895 0x0046      LDRB     R0,[R5, #+70]
   \       0x26   0xE001             B.N      ??HAL_TIMEx_PWMN_Start_DMA_1
   \                     ??HAL_TIMEx_PWMN_Start_DMA_3: (+1)
   \       0x28   0xF895 0x0047      LDRB     R0,[R5, #+71]
   \                     ??HAL_TIMEx_PWMN_Start_DMA_1: (+1)
   \       0x2C   0x2802             CMP      R0,#+2
   \       0x2E   0xD101             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_4
   1374            {
   1375              return HAL_BUSY;
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0xE0E8             B.N      ??HAL_TIMEx_PWMN_Start_DMA_5
   1376            }
   1377            else if (TIM_CHANNEL_N_STATE_GET(htim, Channel) == HAL_TIM_CHANNEL_STATE_READY)
   \                     ??HAL_TIMEx_PWMN_Start_DMA_4: (+1)
   \       0x34   0x2C00             CMP      R4,#+0
   \       0x36   0xD102             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_6
   \       0x38   0xF895 0x0044      LDRB     R0,[R5, #+68]
   \       0x3C   0xE00B             B.N      ??HAL_TIMEx_PWMN_Start_DMA_7
   \                     ??HAL_TIMEx_PWMN_Start_DMA_6: (+1)
   \       0x3E   0x2C04             CMP      R4,#+4
   \       0x40   0xD102             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_8
   \       0x42   0xF895 0x0045      LDRB     R0,[R5, #+69]
   \       0x46   0xE006             B.N      ??HAL_TIMEx_PWMN_Start_DMA_7
   \                     ??HAL_TIMEx_PWMN_Start_DMA_8: (+1)
   \       0x48   0x2C08             CMP      R4,#+8
   \       0x4A   0xD102             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_9
   \       0x4C   0xF895 0x0046      LDRB     R0,[R5, #+70]
   \       0x50   0xE001             B.N      ??HAL_TIMEx_PWMN_Start_DMA_7
   \                     ??HAL_TIMEx_PWMN_Start_DMA_9: (+1)
   \       0x52   0xF895 0x0047      LDRB     R0,[R5, #+71]
   \                     ??HAL_TIMEx_PWMN_Start_DMA_7: (+1)
   \       0x56   0x2801             CMP      R0,#+1
   \       0x58   0xD171             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_10
   1378            {
   1379              if ((pData == NULL) && (Length > 0U))
   \       0x5A   0x2900             CMP      R1,#+0
   \       0x5C   0xD105             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_11
   \       0x5E   0x0018             MOVS     R0,R3
   \       0x60   0xB280             UXTH     R0,R0
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD001             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_11
   1380              {
   1381                return HAL_ERROR;
   \       0x66   0x2001             MOVS     R0,#+1
   \       0x68   0xE0CD             B.N      ??HAL_TIMEx_PWMN_Start_DMA_5
   1382              }
   1383              else
   1384              {
   1385                TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
   \                     ??HAL_TIMEx_PWMN_Start_DMA_11: (+1)
   \       0x6A   0x2C00             CMP      R4,#+0
   \       0x6C   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_12
   \       0x6E   0x2002             MOVS     R0,#+2
   \       0x70   0xF885 0x0044      STRB     R0,[R5, #+68]
   \       0x74   0xB2C0             UXTB     R0,R0
   \       0x76   0xE011             B.N      ??HAL_TIMEx_PWMN_Start_DMA_13
   \                     ??HAL_TIMEx_PWMN_Start_DMA_12: (+1)
   \       0x78   0x2C04             CMP      R4,#+4
   \       0x7A   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_14
   \       0x7C   0x2002             MOVS     R0,#+2
   \       0x7E   0xF885 0x0045      STRB     R0,[R5, #+69]
   \       0x82   0xB2C0             UXTB     R0,R0
   \       0x84   0xE00A             B.N      ??HAL_TIMEx_PWMN_Start_DMA_13
   \                     ??HAL_TIMEx_PWMN_Start_DMA_14: (+1)
   \       0x86   0x2C08             CMP      R4,#+8
   \       0x88   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_15
   \       0x8A   0x2002             MOVS     R0,#+2
   \       0x8C   0xF885 0x0046      STRB     R0,[R5, #+70]
   \       0x90   0xB2C0             UXTB     R0,R0
   \       0x92   0xE003             B.N      ??HAL_TIMEx_PWMN_Start_DMA_13
   \                     ??HAL_TIMEx_PWMN_Start_DMA_15: (+1)
   \       0x94   0x2002             MOVS     R0,#+2
   \       0x96   0xF885 0x0047      STRB     R0,[R5, #+71]
   \       0x9A   0xB2C0             UXTB     R0,R0
   1386              }
   1387            }
   1388            else
   1389            {
   1390              return HAL_ERROR;
   1391            }
   1392          
   1393            switch (Channel)
   \                     ??HAL_TIMEx_PWMN_Start_DMA_13: (+1)
   \       0x9C   0x0020             MOVS     R0,R4
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD04F             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_16
   \       0xA2   0x2804             CMP      R0,#+4
   \       0xA4   0xD06B             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_17
   \       0xA6   0x2808             CMP      R0,#+8
   \       0xA8   0xF000 0x8087      BEQ.W    ??HAL_TIMEx_PWMN_Start_DMA_18
   1394            {
   1395              case TIM_CHANNEL_1:
   1396              {
   1397                /* Set the DMA compare callbacks */
   1398                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseNCplt;
   1399                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1400          
   1401                /* Set the DMA error callback */
   1402                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAErrorCCxN ;
   1403          
   1404                /* Enable the DMA stream */
   1405                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1,
   1406                                     Length) != HAL_OK)
   1407                {
   1408                  /* Return error status */
   1409                  return HAL_ERROR;
   1410                }
   1411                /* Enable the TIM Capture/Compare 1 DMA request */
   1412                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   1413                break;
   1414              }
   1415          
   1416              case TIM_CHANNEL_2:
   1417              {
   1418                /* Set the DMA compare callbacks */
   1419                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseNCplt;
   1420                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1421          
   1422                /* Set the DMA error callback */
   1423                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAErrorCCxN ;
   1424          
   1425                /* Enable the DMA stream */
   1426                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2,
   1427                                     Length) != HAL_OK)
   1428                {
   1429                  /* Return error status */
   1430                  return HAL_ERROR;
   1431                }
   1432                /* Enable the TIM Capture/Compare 2 DMA request */
   1433                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   1434                break;
   1435              }
   1436          
   1437              case TIM_CHANNEL_3:
   1438              {
   1439                /* Set the DMA compare callbacks */
   1440                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseNCplt;
   1441                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   1442          
   1443                /* Set the DMA error callback */
   1444                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAErrorCCxN ;
   1445          
   1446                /* Enable the DMA stream */
   1447                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,
   1448                                     Length) != HAL_OK)
   1449                {
   1450                  /* Return error status */
   1451                  return HAL_ERROR;
   1452                }
   1453                /* Enable the TIM Capture/Compare 3 DMA request */
   1454                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   1455                break;
   1456              }
   1457          
   1458              default:
   1459                status = HAL_ERROR;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_19: (+1)
   \       0xAC   0x2601             MOVS     R6,#+1
   1460                break;
   1461            }
   1462          
   1463            if (status == HAL_OK)
   \                     ??HAL_TIMEx_PWMN_Start_DMA_20: (+1)
   \       0xAE   0x0030             MOVS     R0,R6
   \       0xB0   0xB2C0             UXTB     R0,R0
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xF040 0x80A5      BNE.W    ??HAL_TIMEx_PWMN_Start_DMA_21
   1464            {
   1465              /* Enable the complementary PWM output  */
   1466              TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \       0xB8   0x2204             MOVS     R2,#+4
   \       0xBA   0x0021             MOVS     R1,R4
   \       0xBC   0x6828             LDR      R0,[R5, #+0]
   \       0xBE   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1467          
   1468              /* Enable the Main Output */
   1469              __HAL_TIM_MOE_ENABLE(htim);
   \       0xC2   0x6828             LDR      R0,[R5, #+0]
   \       0xC4   0x6C40             LDR      R0,[R0, #+68]
   \       0xC6   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0xCA   0x6829             LDR      R1,[R5, #+0]
   \       0xCC   0x6448             STR      R0,[R1, #+68]
   1470          
   1471              /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1472              if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   \       0xCE   0x6828             LDR      R0,[R5, #+0]
   \       0xD0   0x.... 0x....      LDR.W    R1,??DataTable13
   \       0xD4   0x4288             CMP      R0,R1
   \       0xD6   0xD021             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_22
   \       0xD8   0x6828             LDR      R0,[R5, #+0]
   \       0xDA   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0xDE   0xD01D             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_22
   \       0xE0   0x6828             LDR      R0,[R5, #+0]
   \       0xE2   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \       0xE6   0x4288             CMP      R0,R1
   \       0xE8   0xD018             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_22
   \       0xEA   0x6828             LDR      R0,[R5, #+0]
   \       0xEC   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \       0xF0   0x4288             CMP      R0,R1
   \       0xF2   0xD013             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_22
   \       0xF4   0x6828             LDR      R0,[R5, #+0]
   \       0xF6   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \       0xFA   0x4288             CMP      R0,R1
   \       0xFC   0xD00E             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_22
   \       0xFE   0x6828             LDR      R0,[R5, #+0]
   \      0x100   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \      0x104   0x4288             CMP      R0,R1
   \      0x106   0xD009             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_22
   \      0x108   0x6828             LDR      R0,[R5, #+0]
   \      0x10A   0x.... 0x....      LDR.W    R1,??DataTable14
   \      0x10E   0x4288             CMP      R0,R1
   \      0x110   0xD004             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_22
   \      0x112   0x6828             LDR      R0,[R5, #+0]
   \      0x114   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \      0x118   0x4288             CMP      R0,R1
   \      0x11A   0xD16C             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_23
   1473              {
   1474                tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_22: (+1)
   \      0x11C   0x6828             LDR      R0,[R5, #+0]
   \      0x11E   0x6881             LDR      R1,[R0, #+8]
   \      0x120   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \      0x124   0x4001             ANDS     R1,R0,R1
   1475                if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \      0x126   0x2906             CMP      R1,#+6
   \      0x128   0xD06B             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_21
   \      0x12A   0xF5B1 0x3F80      CMP      R1,#+65536
   \      0x12E   0xD068             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_21
   1476                {
   1477                  __HAL_TIM_ENABLE(htim);
   \      0x130   0x6828             LDR      R0,[R5, #+0]
   \      0x132   0x6800             LDR      R0,[R0, #+0]
   \      0x134   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x138   0x6829             LDR      R1,[R5, #+0]
   \      0x13A   0x6008             STR      R0,[R1, #+0]
   \      0x13C   0xE061             B.N      ??HAL_TIMEx_PWMN_Start_DMA_21
   1478                }
   1479              }
   \                     ??HAL_TIMEx_PWMN_Start_DMA_10: (+1)
   \      0x13E   0x2001             MOVS     R0,#+1
   \      0x140   0xE061             B.N      ??HAL_TIMEx_PWMN_Start_DMA_5
   \                     ??HAL_TIMEx_PWMN_Start_DMA_16: (+1)
   \      0x142   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseNCplt
   \      0x146   0x6A6A             LDR      R2,[R5, #+36]
   \      0x148   0x63D0             STR      R0,[R2, #+60]
   \      0x14A   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \      0x14E   0x6A6A             LDR      R2,[R5, #+36]
   \      0x150   0x6410             STR      R0,[R2, #+64]
   \      0x152   0x.... 0x....      ADR.W    R0,TIM_DMAErrorCCxN
   \      0x156   0x6A6A             LDR      R2,[R5, #+36]
   \      0x158   0x64D0             STR      R0,[R2, #+76]
   \      0x15A   0xB29B             UXTH     R3,R3
   \      0x15C   0x6828             LDR      R0,[R5, #+0]
   \      0x15E   0xF110 0x0234      ADDS     R2,R0,#+52
   \      0x162   0x6A68             LDR      R0,[R5, #+36]
   \      0x164   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x168   0x2800             CMP      R0,#+0
   \      0x16A   0xD001             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_24
   \      0x16C   0x2001             MOVS     R0,#+1
   \      0x16E   0xE04A             B.N      ??HAL_TIMEx_PWMN_Start_DMA_5
   \                     ??HAL_TIMEx_PWMN_Start_DMA_24: (+1)
   \      0x170   0x6828             LDR      R0,[R5, #+0]
   \      0x172   0x68C0             LDR      R0,[R0, #+12]
   \      0x174   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x178   0x6829             LDR      R1,[R5, #+0]
   \      0x17A   0x60C8             STR      R0,[R1, #+12]
   \      0x17C   0xE797             B.N      ??HAL_TIMEx_PWMN_Start_DMA_20
   \                     ??HAL_TIMEx_PWMN_Start_DMA_17: (+1)
   \      0x17E   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseNCplt
   \      0x182   0x6AAA             LDR      R2,[R5, #+40]
   \      0x184   0x63D0             STR      R0,[R2, #+60]
   \      0x186   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \      0x18A   0x6AAA             LDR      R2,[R5, #+40]
   \      0x18C   0x6410             STR      R0,[R2, #+64]
   \      0x18E   0x.... 0x....      ADR.W    R0,TIM_DMAErrorCCxN
   \      0x192   0x6AAA             LDR      R2,[R5, #+40]
   \      0x194   0x64D0             STR      R0,[R2, #+76]
   \      0x196   0xB29B             UXTH     R3,R3
   \      0x198   0x6828             LDR      R0,[R5, #+0]
   \      0x19A   0xF110 0x0238      ADDS     R2,R0,#+56
   \      0x19E   0x6AA8             LDR      R0,[R5, #+40]
   \      0x1A0   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x1A4   0x2800             CMP      R0,#+0
   \      0x1A6   0xD001             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_25
   \      0x1A8   0x2001             MOVS     R0,#+1
   \      0x1AA   0xE02C             B.N      ??HAL_TIMEx_PWMN_Start_DMA_5
   \                     ??HAL_TIMEx_PWMN_Start_DMA_25: (+1)
   \      0x1AC   0x6828             LDR      R0,[R5, #+0]
   \      0x1AE   0x68C0             LDR      R0,[R0, #+12]
   \      0x1B0   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x1B4   0x6829             LDR      R1,[R5, #+0]
   \      0x1B6   0x60C8             STR      R0,[R1, #+12]
   \      0x1B8   0xE779             B.N      ??HAL_TIMEx_PWMN_Start_DMA_20
   \                     ??HAL_TIMEx_PWMN_Start_DMA_18: (+1)
   \      0x1BA   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseNCplt
   \      0x1BE   0x6AEA             LDR      R2,[R5, #+44]
   \      0x1C0   0x63D0             STR      R0,[R2, #+60]
   \      0x1C2   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \      0x1C6   0x6AEA             LDR      R2,[R5, #+44]
   \      0x1C8   0x6410             STR      R0,[R2, #+64]
   \      0x1CA   0x.... 0x....      ADR.W    R0,TIM_DMAErrorCCxN
   \      0x1CE   0x6AEA             LDR      R2,[R5, #+44]
   \      0x1D0   0x64D0             STR      R0,[R2, #+76]
   \      0x1D2   0xB29B             UXTH     R3,R3
   \      0x1D4   0x6828             LDR      R0,[R5, #+0]
   \      0x1D6   0xF110 0x023C      ADDS     R2,R0,#+60
   \      0x1DA   0x6AE8             LDR      R0,[R5, #+44]
   \      0x1DC   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x1E0   0x2800             CMP      R0,#+0
   \      0x1E2   0xD001             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_26
   \      0x1E4   0x2001             MOVS     R0,#+1
   \      0x1E6   0xE00E             B.N      ??HAL_TIMEx_PWMN_Start_DMA_5
   \                     ??HAL_TIMEx_PWMN_Start_DMA_26: (+1)
   \      0x1E8   0x6828             LDR      R0,[R5, #+0]
   \      0x1EA   0x68C0             LDR      R0,[R0, #+12]
   \      0x1EC   0xF450 0x6000      ORRS     R0,R0,#0x800
   \      0x1F0   0x6829             LDR      R1,[R5, #+0]
   \      0x1F2   0x60C8             STR      R0,[R1, #+12]
   \      0x1F4   0xE75B             B.N      ??HAL_TIMEx_PWMN_Start_DMA_20
   1480              else
   1481              {
   1482                __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Start_DMA_23: (+1)
   \      0x1F6   0x6828             LDR      R0,[R5, #+0]
   \      0x1F8   0x6800             LDR      R0,[R0, #+0]
   \      0x1FA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x1FE   0x6829             LDR      R1,[R5, #+0]
   \      0x200   0x6008             STR      R0,[R1, #+0]
   1483              }
   1484            }
   1485          
   1486            /* Return function status */
   1487            return status;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_21: (+1)
   \      0x202   0x0030             MOVS     R0,R6
   \      0x204   0xB2C0             UXTB     R0,R0
   \                     ??HAL_TIMEx_PWMN_Start_DMA_5: (+1)
   \      0x206   0xBD70             POP      {R4-R6,PC}
   1488          }
   1489          
   1490          /**
   1491            * @brief  Stops the TIM PWM signal generation in DMA mode on the complementary
   1492            *         output
   1493            * @param  htim TIM handle
   1494            * @param  Channel TIM Channel to be disabled
   1495            *          This parameter can be one of the following values:
   1496            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1497            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1498            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1499            * @retval HAL status
   1500            */

   \                                 In section .text, align 2, keep-with-next
   1501          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1502          {
   \                     HAL_TIMEx_PWMN_Stop_DMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   \        0x4   0x000C             MOVS     R4,R1
   1503            HAL_StatusTypeDef status = HAL_OK;
   \        0x6   0x2500             MOVS     R5,#+0
   1504          
   1505            /* Check the parameters */
   1506            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1507          
   1508            switch (Channel)
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD004             BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_0
   \        0xE   0x2804             CMP      R0,#+4
   \       0x10   0xD00C             BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_1
   \       0x12   0x2808             CMP      R0,#+8
   \       0x14   0xD014             BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_2
   \       0x16   0xE01D             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_3
   1509            {
   1510              case TIM_CHANNEL_1:
   1511              {
   1512                /* Disable the TIM Capture/Compare 1 DMA request */
   1513                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_0: (+1)
   \       0x18   0x6830             LDR      R0,[R6, #+0]
   \       0x1A   0x68C0             LDR      R0,[R0, #+12]
   \       0x1C   0xF430 0x7000      BICS     R0,R0,#0x200
   \       0x20   0x6831             LDR      R1,[R6, #+0]
   \       0x22   0x60C8             STR      R0,[R1, #+12]
   1514                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x24   0x6A70             LDR      R0,[R6, #+36]
   \       0x26   0x.... 0x....      BL       HAL_DMA_Abort_IT
   1515                break;
   \       0x2A   0xE014             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
   1516              }
   1517          
   1518              case TIM_CHANNEL_2:
   1519              {
   1520                /* Disable the TIM Capture/Compare 2 DMA request */
   1521                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_1: (+1)
   \       0x2C   0x6830             LDR      R0,[R6, #+0]
   \       0x2E   0x68C0             LDR      R0,[R0, #+12]
   \       0x30   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x34   0x6831             LDR      R1,[R6, #+0]
   \       0x36   0x60C8             STR      R0,[R1, #+12]
   1522                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \       0x38   0x6AB0             LDR      R0,[R6, #+40]
   \       0x3A   0x.... 0x....      BL       HAL_DMA_Abort_IT
   1523                break;
   \       0x3E   0xE00A             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
   1524              }
   1525          
   1526              case TIM_CHANNEL_3:
   1527              {
   1528                /* Disable the TIM Capture/Compare 3 DMA request */
   1529                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_2: (+1)
   \       0x40   0x6830             LDR      R0,[R6, #+0]
   \       0x42   0x68C0             LDR      R0,[R0, #+12]
   \       0x44   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x48   0x6831             LDR      R1,[R6, #+0]
   \       0x4A   0x60C8             STR      R0,[R1, #+12]
   1530                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \       0x4C   0x6AF0             LDR      R0,[R6, #+44]
   \       0x4E   0x.... 0x....      BL       HAL_DMA_Abort_IT
   1531                break;
   \       0x52   0xE000             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
   1532              }
   1533          
   1534              default:
   1535                status = HAL_ERROR;
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_3: (+1)
   \       0x54   0x2501             MOVS     R5,#+1
   1536                break;
   1537            }
   1538          
   1539            if (status == HAL_OK)
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_4: (+1)
   \       0x56   0x0028             MOVS     R0,R5
   \       0x58   0xB2C0             UXTB     R0,R0
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD13F             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_5
   1540            {
   1541              /* Disable the complementary PWM output */
   1542              TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \       0x5E   0x2200             MOVS     R2,#+0
   \       0x60   0x0021             MOVS     R1,R4
   \       0x62   0x6830             LDR      R0,[R6, #+0]
   \       0x64   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1543          
   1544              /* Disable the Main Output */
   1545              __HAL_TIM_MOE_DISABLE(htim);
   \       0x68   0xF241 0x1011      MOVW     R0,#+4369
   \       0x6C   0x6831             LDR      R1,[R6, #+0]
   \       0x6E   0x6A09             LDR      R1,[R1, #+32]
   \       0x70   0x4201             TST      R1,R0
   \       0x72   0xD10B             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_6
   \       0x74   0x6831             LDR      R1,[R6, #+0]
   \       0x76   0x6A09             LDR      R1,[R1, #+32]
   \       0x78   0xF240 0x4244      MOVW     R2,#+1092
   \       0x7C   0x4211             TST      R1,R2
   \       0x7E   0xD105             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_6
   \       0x80   0x6831             LDR      R1,[R6, #+0]
   \       0x82   0x6C49             LDR      R1,[R1, #+68]
   \       0x84   0xF431 0x4100      BICS     R1,R1,#0x8000
   \       0x88   0x6832             LDR      R2,[R6, #+0]
   \       0x8A   0x6451             STR      R1,[R2, #+68]
   1546          
   1547              /* Disable the Peripheral */
   1548              __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_6: (+1)
   \       0x8C   0x6831             LDR      R1,[R6, #+0]
   \       0x8E   0x6A09             LDR      R1,[R1, #+32]
   \       0x90   0x4201             TST      R1,R0
   \       0x92   0xD10B             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_7
   \       0x94   0x6830             LDR      R0,[R6, #+0]
   \       0x96   0x6A00             LDR      R0,[R0, #+32]
   \       0x98   0xF240 0x4144      MOVW     R1,#+1092
   \       0x9C   0x4208             TST      R0,R1
   \       0x9E   0xD105             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_7
   \       0xA0   0x6830             LDR      R0,[R6, #+0]
   \       0xA2   0x6800             LDR      R0,[R0, #+0]
   \       0xA4   0x0840             LSRS     R0,R0,#+1
   \       0xA6   0x0040             LSLS     R0,R0,#+1
   \       0xA8   0x6831             LDR      R1,[R6, #+0]
   \       0xAA   0x6008             STR      R0,[R1, #+0]
   1549          
   1550              /* Set the TIM complementary channel state */
   1551              TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_READY);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_7: (+1)
   \       0xAC   0x2C00             CMP      R4,#+0
   \       0xAE   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_8
   \       0xB0   0x2001             MOVS     R0,#+1
   \       0xB2   0xF886 0x0044      STRB     R0,[R6, #+68]
   \       0xB6   0xB2C0             UXTB     R0,R0
   \       0xB8   0xE011             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_5
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_8: (+1)
   \       0xBA   0x2C04             CMP      R4,#+4
   \       0xBC   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_9
   \       0xBE   0x2001             MOVS     R0,#+1
   \       0xC0   0xF886 0x0045      STRB     R0,[R6, #+69]
   \       0xC4   0xB2C0             UXTB     R0,R0
   \       0xC6   0xE00A             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_5
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_9: (+1)
   \       0xC8   0x2C08             CMP      R4,#+8
   \       0xCA   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_10
   \       0xCC   0x2001             MOVS     R0,#+1
   \       0xCE   0xF886 0x0046      STRB     R0,[R6, #+70]
   \       0xD2   0xB2C0             UXTB     R0,R0
   \       0xD4   0xE003             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_5
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_10: (+1)
   \       0xD6   0x2001             MOVS     R0,#+1
   \       0xD8   0xF886 0x0047      STRB     R0,[R6, #+71]
   \       0xDC   0xB2C0             UXTB     R0,R0
   1552            }
   1553          
   1554            /* Return function status */
   1555            return status;
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_5: (+1)
   \       0xDE   0x0028             MOVS     R0,R5
   \       0xE0   0xB2C0             UXTB     R0,R0
   \       0xE2   0xBD70             POP      {R4-R6,PC}
   1556          }
   1557          
   1558          /**
   1559            * @}
   1560            */
   1561          
   1562          /** @defgroup TIMEx_Exported_Functions_Group4 Extended Timer Complementary One Pulse functions
   1563            * @brief    Timer Complementary One Pulse functions
   1564            *
   1565          @verbatim
   1566            ==============================================================================
   1567                          ##### Timer Complementary One Pulse functions #####
   1568            ==============================================================================
   1569            [..]
   1570              This section provides functions allowing to:
   1571              (+) Start the Complementary One Pulse generation.
   1572              (+) Stop the Complementary One Pulse.
   1573              (+) Start the Complementary One Pulse and enable interrupts.
   1574              (+) Stop the Complementary One Pulse and disable interrupts.
   1575          
   1576          @endverbatim
   1577            * @{
   1578            */
   1579          
   1580          /**
   1581            * @brief  Starts the TIM One Pulse signal generation on the complementary
   1582            *         output.
   1583            * @note OutputChannel must match the pulse output channel chosen when calling
   1584            *       @ref HAL_TIM_OnePulse_ConfigChannel().
   1585            * @param  htim TIM One Pulse handle
   1586            * @param  OutputChannel pulse output channel to enable
   1587            *          This parameter can be one of the following values:
   1588            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1589            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1590            * @retval HAL status
   1591            */

   \                                 In section .text, align 2, keep-with-next
   1592          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1593          {
   \                     HAL_TIMEx_OnePulseN_Start: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   1594            uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD101             BNE.N    ??HAL_TIMEx_OnePulseN_Start_0
   \        0x8   0x2404             MOVS     R4,#+4
   \        0xA   0xE000             B.N      ??HAL_TIMEx_OnePulseN_Start_1
   \                     ??HAL_TIMEx_OnePulseN_Start_0: (+1)
   \        0xC   0x2400             MOVS     R4,#+0
   1595            HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
   \                     ??HAL_TIMEx_OnePulseN_Start_1: (+1)
   \        0xE   0xF895 0x603E      LDRB     R6,[R5, #+62]
   1596            HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
   \       0x12   0xF895 0x003F      LDRB     R0,[R5, #+63]
   1597            HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
   \       0x16   0xF895 0x2044      LDRB     R2,[R5, #+68]
   1598            HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
   \       0x1A   0xF895 0x3045      LDRB     R3,[R5, #+69]
   1599          
   1600            /* Check the parameters */
   1601            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1602          
   1603            /* Check the TIM channels state */
   1604            if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
   1605                || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
   1606                || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
   1607                || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
   \       0x1E   0xB2F6             UXTB     R6,R6
   \       0x20   0x2E01             CMP      R6,#+1
   \       0x22   0xD108             BNE.N    ??HAL_TIMEx_OnePulseN_Start_2
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x2801             CMP      R0,#+1
   \       0x28   0xD105             BNE.N    ??HAL_TIMEx_OnePulseN_Start_2
   \       0x2A   0xB2D2             UXTB     R2,R2
   \       0x2C   0x2A01             CMP      R2,#+1
   \       0x2E   0xD102             BNE.N    ??HAL_TIMEx_OnePulseN_Start_2
   \       0x30   0xB2DB             UXTB     R3,R3
   \       0x32   0x2B01             CMP      R3,#+1
   \       0x34   0xD001             BEQ.N    ??HAL_TIMEx_OnePulseN_Start_3
   1608            {
   1609              return HAL_ERROR;
   \                     ??HAL_TIMEx_OnePulseN_Start_2: (+1)
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0xE01F             B.N      ??HAL_TIMEx_OnePulseN_Start_4
   1610            }
   1611          
   1612            /* Set the TIM channels state */
   1613            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   \                     ??HAL_TIMEx_OnePulseN_Start_3: (+1)
   \       0x3A   0x2002             MOVS     R0,#+2
   \       0x3C   0xF885 0x003E      STRB     R0,[R5, #+62]
   \       0x40   0xB2C0             UXTB     R0,R0
   1614            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   \       0x42   0x2002             MOVS     R0,#+2
   \       0x44   0xF885 0x003F      STRB     R0,[R5, #+63]
   \       0x48   0xB2C0             UXTB     R0,R0
   1615            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   \       0x4A   0x2002             MOVS     R0,#+2
   \       0x4C   0xF885 0x0044      STRB     R0,[R5, #+68]
   \       0x50   0xB2C0             UXTB     R0,R0
   1616            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   \       0x52   0x2002             MOVS     R0,#+2
   \       0x54   0xF885 0x0045      STRB     R0,[R5, #+69]
   \       0x58   0xB2C0             UXTB     R0,R0
   1617          
   1618            /* Enable the complementary One Pulse output channel and the Input Capture channel */
   1619            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
   \       0x5A   0x2204             MOVS     R2,#+4
   \       0x5C   0x6828             LDR      R0,[R5, #+0]
   \       0x5E   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1620            TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_ENABLE);
   \       0x62   0x2201             MOVS     R2,#+1
   \       0x64   0x0021             MOVS     R1,R4
   \       0x66   0x6828             LDR      R0,[R5, #+0]
   \       0x68   0x.... 0x....      BL       TIM_CCxChannelCmd
   1621          
   1622            /* Enable the Main Output */
   1623            __HAL_TIM_MOE_ENABLE(htim);
   \       0x6C   0x6828             LDR      R0,[R5, #+0]
   \       0x6E   0x6C40             LDR      R0,[R0, #+68]
   \       0x70   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x74   0x6829             LDR      R1,[R5, #+0]
   \       0x76   0x6448             STR      R0,[R1, #+68]
   1624          
   1625            /* Return function status */
   1626            return HAL_OK;
   \       0x78   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_OnePulseN_Start_4: (+1)
   \       0x7A   0xBD70             POP      {R4-R6,PC}
   1627          }
   1628          
   1629          /**
   1630            * @brief  Stops the TIM One Pulse signal generation on the complementary
   1631            *         output.
   1632            * @note OutputChannel must match the pulse output channel chosen when calling
   1633            *       @ref HAL_TIM_OnePulse_ConfigChannel().
   1634            * @param  htim TIM One Pulse handle
   1635            * @param  OutputChannel pulse output channel to disable
   1636            *          This parameter can be one of the following values:
   1637            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1638            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1639            * @retval HAL status
   1640            */

   \                                 In section .text, align 2, keep-with-next
   1641          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1642          {
   \                     HAL_TIMEx_OnePulseN_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1643            uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD101             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_0
   \        0x8   0x2504             MOVS     R5,#+4
   \        0xA   0xE000             B.N      ??HAL_TIMEx_OnePulseN_Stop_1
   \                     ??HAL_TIMEx_OnePulseN_Stop_0: (+1)
   \        0xC   0x2500             MOVS     R5,#+0
   1644          
   1645            /* Check the parameters */
   1646            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1647          
   1648            /* Disable the complementary One Pulse output channel and the Input Capture channel */
   1649            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_OnePulseN_Stop_1: (+1)
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1650            TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_DISABLE);
   \       0x16   0x2200             MOVS     R2,#+0
   \       0x18   0x0029             MOVS     R1,R5
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x.... 0x....      BL       TIM_CCxChannelCmd
   1651          
   1652            /* Disable the Main Output */
   1653            __HAL_TIM_MOE_DISABLE(htim);
   \       0x20   0xF241 0x1011      MOVW     R0,#+4369
   \       0x24   0x6821             LDR      R1,[R4, #+0]
   \       0x26   0x6A09             LDR      R1,[R1, #+32]
   \       0x28   0x4201             TST      R1,R0
   \       0x2A   0xD10B             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_2
   \       0x2C   0x6821             LDR      R1,[R4, #+0]
   \       0x2E   0x6A09             LDR      R1,[R1, #+32]
   \       0x30   0xF240 0x4244      MOVW     R2,#+1092
   \       0x34   0x4211             TST      R1,R2
   \       0x36   0xD105             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_2
   \       0x38   0x6821             LDR      R1,[R4, #+0]
   \       0x3A   0x6C49             LDR      R1,[R1, #+68]
   \       0x3C   0xF431 0x4100      BICS     R1,R1,#0x8000
   \       0x40   0x6822             LDR      R2,[R4, #+0]
   \       0x42   0x6451             STR      R1,[R2, #+68]
   1654          
   1655            /* Disable the Peripheral */
   1656            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OnePulseN_Stop_2: (+1)
   \       0x44   0x6821             LDR      R1,[R4, #+0]
   \       0x46   0x6A09             LDR      R1,[R1, #+32]
   \       0x48   0x4201             TST      R1,R0
   \       0x4A   0xD10B             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_3
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x6A00             LDR      R0,[R0, #+32]
   \       0x50   0xF240 0x4144      MOVW     R1,#+1092
   \       0x54   0x4208             TST      R0,R1
   \       0x56   0xD105             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_3
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x6800             LDR      R0,[R0, #+0]
   \       0x5C   0x0840             LSRS     R0,R0,#+1
   \       0x5E   0x0040             LSLS     R0,R0,#+1
   \       0x60   0x6821             LDR      R1,[R4, #+0]
   \       0x62   0x6008             STR      R0,[R1, #+0]
   1657          
   1658            /* Set the TIM  channels state */
   1659            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   \                     ??HAL_TIMEx_OnePulseN_Stop_3: (+1)
   \       0x64   0x2001             MOVS     R0,#+1
   \       0x66   0xF884 0x003E      STRB     R0,[R4, #+62]
   \       0x6A   0xB2C0             UXTB     R0,R0
   1660            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0xF884 0x003F      STRB     R0,[R4, #+63]
   \       0x72   0xB2C0             UXTB     R0,R0
   1661            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0xF884 0x0044      STRB     R0,[R4, #+68]
   \       0x7A   0xB2C0             UXTB     R0,R0
   1662            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   \       0x7C   0x2001             MOVS     R0,#+1
   \       0x7E   0xF884 0x0045      STRB     R0,[R4, #+69]
   \       0x82   0xB2C0             UXTB     R0,R0
   1663          
   1664            /* Return function status */
   1665            return HAL_OK;
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0xBD32             POP      {R1,R4,R5,PC}
   1666          }
   1667          
   1668          /**
   1669            * @brief  Starts the TIM One Pulse signal generation in interrupt mode on the
   1670            *         complementary channel.
   1671            * @note OutputChannel must match the pulse output channel chosen when calling
   1672            *       @ref HAL_TIM_OnePulse_ConfigChannel().
   1673            * @param  htim TIM One Pulse handle
   1674            * @param  OutputChannel pulse output channel to enable
   1675            *          This parameter can be one of the following values:
   1676            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1677            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1678            * @retval HAL status
   1679            */

   \                                 In section .text, align 2, keep-with-next
   1680          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1681          {
   \                     HAL_TIMEx_OnePulseN_Start_IT: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   1682            uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD101             BNE.N    ??HAL_TIMEx_OnePulseN_Start_IT_0
   \        0x8   0x2404             MOVS     R4,#+4
   \        0xA   0xE000             B.N      ??HAL_TIMEx_OnePulseN_Start_IT_1
   \                     ??HAL_TIMEx_OnePulseN_Start_IT_0: (+1)
   \        0xC   0x2400             MOVS     R4,#+0
   1683            HAL_TIM_ChannelStateTypeDef channel_1_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_1);
   \                     ??HAL_TIMEx_OnePulseN_Start_IT_1: (+1)
   \        0xE   0xF895 0x603E      LDRB     R6,[R5, #+62]
   1684            HAL_TIM_ChannelStateTypeDef channel_2_state = TIM_CHANNEL_STATE_GET(htim, TIM_CHANNEL_2);
   \       0x12   0xF895 0x003F      LDRB     R0,[R5, #+63]
   1685            HAL_TIM_ChannelStateTypeDef complementary_channel_1_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_1);
   \       0x16   0xF895 0x2044      LDRB     R2,[R5, #+68]
   1686            HAL_TIM_ChannelStateTypeDef complementary_channel_2_state = TIM_CHANNEL_N_STATE_GET(htim, TIM_CHANNEL_2);
   \       0x1A   0xF895 0x3045      LDRB     R3,[R5, #+69]
   1687          
   1688            /* Check the parameters */
   1689            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1690          
   1691            /* Check the TIM channels state */
   1692            if ((channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
   1693                || (channel_2_state != HAL_TIM_CHANNEL_STATE_READY)
   1694                || (complementary_channel_1_state != HAL_TIM_CHANNEL_STATE_READY)
   1695                || (complementary_channel_2_state != HAL_TIM_CHANNEL_STATE_READY))
   \       0x1E   0xB2F6             UXTB     R6,R6
   \       0x20   0x2E01             CMP      R6,#+1
   \       0x22   0xD108             BNE.N    ??HAL_TIMEx_OnePulseN_Start_IT_2
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x2801             CMP      R0,#+1
   \       0x28   0xD105             BNE.N    ??HAL_TIMEx_OnePulseN_Start_IT_2
   \       0x2A   0xB2D2             UXTB     R2,R2
   \       0x2C   0x2A01             CMP      R2,#+1
   \       0x2E   0xD102             BNE.N    ??HAL_TIMEx_OnePulseN_Start_IT_2
   \       0x30   0xB2DB             UXTB     R3,R3
   \       0x32   0x2B01             CMP      R3,#+1
   \       0x34   0xD001             BEQ.N    ??HAL_TIMEx_OnePulseN_Start_IT_3
   1696            {
   1697              return HAL_ERROR;
   \                     ??HAL_TIMEx_OnePulseN_Start_IT_2: (+1)
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0xE02B             B.N      ??HAL_TIMEx_OnePulseN_Start_IT_4
   1698            }
   1699          
   1700            /* Set the TIM channels state */
   1701            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   \                     ??HAL_TIMEx_OnePulseN_Start_IT_3: (+1)
   \       0x3A   0x2002             MOVS     R0,#+2
   \       0x3C   0xF885 0x003E      STRB     R0,[R5, #+62]
   \       0x40   0xB2C0             UXTB     R0,R0
   1702            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   \       0x42   0x2002             MOVS     R0,#+2
   \       0x44   0xF885 0x003F      STRB     R0,[R5, #+63]
   \       0x48   0xB2C0             UXTB     R0,R0
   1703            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_BUSY);
   \       0x4A   0x2002             MOVS     R0,#+2
   \       0x4C   0xF885 0x0044      STRB     R0,[R5, #+68]
   \       0x50   0xB2C0             UXTB     R0,R0
   1704            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_BUSY);
   \       0x52   0x2002             MOVS     R0,#+2
   \       0x54   0xF885 0x0045      STRB     R0,[R5, #+69]
   \       0x58   0xB2C0             UXTB     R0,R0
   1705          
   1706            /* Enable the TIM Capture/Compare 1 interrupt */
   1707            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \       0x5A   0x6828             LDR      R0,[R5, #+0]
   \       0x5C   0x68C0             LDR      R0,[R0, #+12]
   \       0x5E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x62   0x682A             LDR      R2,[R5, #+0]
   \       0x64   0x60D0             STR      R0,[R2, #+12]
   1708          
   1709            /* Enable the TIM Capture/Compare 2 interrupt */
   1710            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \       0x66   0x6828             LDR      R0,[R5, #+0]
   \       0x68   0x68C0             LDR      R0,[R0, #+12]
   \       0x6A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x6E   0x682A             LDR      R2,[R5, #+0]
   \       0x70   0x60D0             STR      R0,[R2, #+12]
   1711          
   1712            /* Enable the complementary One Pulse output channel and the Input Capture channel */
   1713            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
   \       0x72   0x2204             MOVS     R2,#+4
   \       0x74   0x6828             LDR      R0,[R5, #+0]
   \       0x76   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1714            TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_ENABLE);
   \       0x7A   0x2201             MOVS     R2,#+1
   \       0x7C   0x0021             MOVS     R1,R4
   \       0x7E   0x6828             LDR      R0,[R5, #+0]
   \       0x80   0x.... 0x....      BL       TIM_CCxChannelCmd
   1715          
   1716            /* Enable the Main Output */
   1717            __HAL_TIM_MOE_ENABLE(htim);
   \       0x84   0x6828             LDR      R0,[R5, #+0]
   \       0x86   0x6C40             LDR      R0,[R0, #+68]
   \       0x88   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x8C   0x6829             LDR      R1,[R5, #+0]
   \       0x8E   0x6448             STR      R0,[R1, #+68]
   1718          
   1719            /* Return function status */
   1720            return HAL_OK;
   \       0x90   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_OnePulseN_Start_IT_4: (+1)
   \       0x92   0xBD70             POP      {R4-R6,PC}
   1721          }
   1722          
   1723          /**
   1724            * @brief  Stops the TIM One Pulse signal generation in interrupt mode on the
   1725            *         complementary channel.
   1726            * @note OutputChannel must match the pulse output channel chosen when calling
   1727            *       @ref HAL_TIM_OnePulse_ConfigChannel().
   1728            * @param  htim TIM One Pulse handle
   1729            * @param  OutputChannel pulse output channel to disable
   1730            *          This parameter can be one of the following values:
   1731            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1732            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1733            * @retval HAL status
   1734            */

   \                                 In section .text, align 2, keep-with-next
   1735          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1736          {
   \                     HAL_TIMEx_OnePulseN_Stop_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1737            uint32_t input_channel = (OutputChannel == TIM_CHANNEL_1) ? TIM_CHANNEL_2 : TIM_CHANNEL_1;
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD101             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_0
   \        0x8   0x2504             MOVS     R5,#+4
   \        0xA   0xE000             B.N      ??HAL_TIMEx_OnePulseN_Stop_IT_1
   \                     ??HAL_TIMEx_OnePulseN_Stop_IT_0: (+1)
   \        0xC   0x2500             MOVS     R5,#+0
   1738          
   1739            /* Check the parameters */
   1740            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1741          
   1742            /* Disable the TIM Capture/Compare 1 interrupt */
   1743            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_OnePulseN_Stop_IT_1: (+1)
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x68C0             LDR      R0,[R0, #+12]
   \       0x12   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x16   0x6822             LDR      R2,[R4, #+0]
   \       0x18   0x60D0             STR      R0,[R2, #+12]
   1744          
   1745            /* Disable the TIM Capture/Compare 2 interrupt */
   1746            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x22   0x6822             LDR      R2,[R4, #+0]
   \       0x24   0x60D0             STR      R0,[R2, #+12]
   1747          
   1748            /* Disable the complementary One Pulse output channel and the Input Capture channel */
   1749            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1750            TIM_CCxChannelCmd(htim->Instance, input_channel, TIM_CCx_DISABLE);
   \       0x2E   0x2200             MOVS     R2,#+0
   \       0x30   0x0029             MOVS     R1,R5
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x.... 0x....      BL       TIM_CCxChannelCmd
   1751          
   1752            /* Disable the Main Output */
   1753            __HAL_TIM_MOE_DISABLE(htim);
   \       0x38   0xF241 0x1011      MOVW     R0,#+4369
   \       0x3C   0x6821             LDR      R1,[R4, #+0]
   \       0x3E   0x6A09             LDR      R1,[R1, #+32]
   \       0x40   0x4201             TST      R1,R0
   \       0x42   0xD10B             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_2
   \       0x44   0x6821             LDR      R1,[R4, #+0]
   \       0x46   0x6A09             LDR      R1,[R1, #+32]
   \       0x48   0xF240 0x4244      MOVW     R2,#+1092
   \       0x4C   0x4211             TST      R1,R2
   \       0x4E   0xD105             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_2
   \       0x50   0x6821             LDR      R1,[R4, #+0]
   \       0x52   0x6C49             LDR      R1,[R1, #+68]
   \       0x54   0xF431 0x4100      BICS     R1,R1,#0x8000
   \       0x58   0x6822             LDR      R2,[R4, #+0]
   \       0x5A   0x6451             STR      R1,[R2, #+68]
   1754          
   1755            /* Disable the Peripheral */
   1756            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OnePulseN_Stop_IT_2: (+1)
   \       0x5C   0x6821             LDR      R1,[R4, #+0]
   \       0x5E   0x6A09             LDR      R1,[R1, #+32]
   \       0x60   0x4201             TST      R1,R0
   \       0x62   0xD10B             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_3
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x6A00             LDR      R0,[R0, #+32]
   \       0x68   0xF240 0x4144      MOVW     R1,#+1092
   \       0x6C   0x4208             TST      R0,R1
   \       0x6E   0xD105             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_3
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x6800             LDR      R0,[R0, #+0]
   \       0x74   0x0840             LSRS     R0,R0,#+1
   \       0x76   0x0040             LSLS     R0,R0,#+1
   \       0x78   0x6821             LDR      R1,[R4, #+0]
   \       0x7A   0x6008             STR      R0,[R1, #+0]
   1757          
   1758            /* Set the TIM  channels state */
   1759            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   \                     ??HAL_TIMEx_OnePulseN_Stop_IT_3: (+1)
   \       0x7C   0x2001             MOVS     R0,#+1
   \       0x7E   0xF884 0x003E      STRB     R0,[R4, #+62]
   \       0x82   0xB2C0             UXTB     R0,R0
   1760            TIM_CHANNEL_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   \       0x84   0x2001             MOVS     R0,#+1
   \       0x86   0xF884 0x003F      STRB     R0,[R4, #+63]
   \       0x8A   0xB2C0             UXTB     R0,R0
   1761            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   \       0x8C   0x2001             MOVS     R0,#+1
   \       0x8E   0xF884 0x0044      STRB     R0,[R4, #+68]
   \       0x92   0xB2C0             UXTB     R0,R0
   1762            TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   \       0x94   0x2001             MOVS     R0,#+1
   \       0x96   0xF884 0x0045      STRB     R0,[R4, #+69]
   \       0x9A   0xB2C0             UXTB     R0,R0
   1763          
   1764            /* Return function status */
   1765            return HAL_OK;
   \       0x9C   0x2000             MOVS     R0,#+0
   \       0x9E   0xBD32             POP      {R1,R4,R5,PC}
   1766          }
   1767          
   1768          /**
   1769            * @}
   1770            */
   1771          
   1772          /** @defgroup TIMEx_Exported_Functions_Group5 Extended Peripheral Control functions
   1773            * @brief    Peripheral Control functions
   1774            *
   1775          @verbatim
   1776            ==============================================================================
   1777                              ##### Peripheral Control functions #####
   1778            ==============================================================================
   1779            [..]
   1780              This section provides functions allowing to:
   1781                (+) Configure the commutation event in case of use of the Hall sensor interface.
   1782                (+) Configure Output channels for OC and PWM mode.
   1783          
   1784                (+) Configure Complementary channels, break features and dead time.
   1785                (+) Configure Master synchronization.
   1786                (+) Configure timer remapping capabilities.
   1787                (+) Select timer input source.
   1788                (+) Enable or disable channel grouping.
   1789          
   1790          @endverbatim
   1791            * @{
   1792            */
   1793          
   1794          /**
   1795            * @brief  Configure the TIM commutation event sequence.
   1796            * @note  This function is mandatory to use the commutation event in order to
   1797            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1798            *        the typical use of this feature is with the use of another Timer(interface Timer)
   1799            *        configured in Hall sensor interface, this interface Timer will generate the
   1800            *        commutation at its TRGO output (connected to Timer used in this function) each time
   1801            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1802            * @param  htim TIM handle
   1803            * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
   1804            *          This parameter can be one of the following values:
   1805            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1806            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1807            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1808            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1809            *            @arg TIM_TS_ITR12: Internal trigger 12 selected (*)
   1810            *            @arg TIM_TS_ITR13: Internal trigger 13 selected (*)
   1811            *            @arg TIM_TS_NONE: No trigger is needed
   1812            * @param  CommutationSource the Commutation Event source
   1813            *          This parameter can be one of the following values:
   1814            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1815            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1816            * @retval HAL status
   1817            */

   \                                 In section .text, align 2, keep-with-next
   1818          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
   1819                                                        uint32_t  CommutationSource)
   1820          {
   \                     HAL_TIMEx_ConfigCommutEvent: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1821            /* Check the parameters */
   1822            assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
   1823            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1824          
   1825            __HAL_LOCK(htim);
   \        0x2   0xF890 0x303C      LDRB     R3,[R0, #+60]
   \        0x6   0x2B01             CMP      R3,#+1
   \        0x8   0xD101             BNE.N    ??HAL_TIMEx_ConfigCommutEvent_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE03E             B.N      ??HAL_TIMEx_ConfigCommutEvent_1
   \                     ??HAL_TIMEx_ConfigCommutEvent_0: (+1)
   \        0xE   0x2301             MOVS     R3,#+1
   \       0x10   0xF880 0x303C      STRB     R3,[R0, #+60]
   1826          
   1827            if ((InputTrigger == TIM_TS_ITR0)  || (InputTrigger == TIM_TS_ITR1) ||
   1828                (InputTrigger == TIM_TS_ITR2)  || (InputTrigger == TIM_TS_ITR3) ||
   1829                (InputTrigger == TIM_TS_ITR12)  || (InputTrigger == TIM_TS_ITR13))
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD00C             BEQ.N    ??HAL_TIMEx_ConfigCommutEvent_2
   \       0x18   0x2910             CMP      R1,#+16
   \       0x1A   0xD00A             BEQ.N    ??HAL_TIMEx_ConfigCommutEvent_2
   \       0x1C   0x2920             CMP      R1,#+32
   \       0x1E   0xD008             BEQ.N    ??HAL_TIMEx_ConfigCommutEvent_2
   \       0x20   0x2930             CMP      R1,#+48
   \       0x22   0xD006             BEQ.N    ??HAL_TIMEx_ConfigCommutEvent_2
   \       0x24   0xF5B1 0x1F00      CMP      R1,#+2097152
   \       0x28   0xD003             BEQ.N    ??HAL_TIMEx_ConfigCommutEvent_2
   \       0x2A   0x.... 0x....      LDR.W    R3,??DataTable15
   \       0x2E   0x4299             CMP      R1,R3
   \       0x30   0xD10B             BNE.N    ??HAL_TIMEx_ConfigCommutEvent_3
   1830            {
   1831              /* Select the Input trigger */
   1832              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutEvent_2: (+1)
   \       0x32   0x6803             LDR      R3,[R0, #+0]
   \       0x34   0x689C             LDR      R4,[R3, #+8]
   \       0x36   0x.... 0x....      LDR.W    R3,??DataTable15_1
   \       0x3A   0x401C             ANDS     R4,R3,R4
   \       0x3C   0x6803             LDR      R3,[R0, #+0]
   \       0x3E   0x609C             STR      R4,[R3, #+8]
   1833              htim->Instance->SMCR |= InputTrigger;
   \       0x40   0x6803             LDR      R3,[R0, #+0]
   \       0x42   0x689B             LDR      R3,[R3, #+8]
   \       0x44   0x4319             ORRS     R1,R1,R3
   \       0x46   0x6803             LDR      R3,[R0, #+0]
   \       0x48   0x6099             STR      R1,[R3, #+8]
   1834            }
   1835          
   1836            /* Select the Capture Compare preload feature */
   1837            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutEvent_3: (+1)
   \       0x4A   0x6801             LDR      R1,[R0, #+0]
   \       0x4C   0x6849             LDR      R1,[R1, #+4]
   \       0x4E   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x52   0x6803             LDR      R3,[R0, #+0]
   \       0x54   0x6059             STR      R1,[R3, #+4]
   1838            /* Select the Commutation event source */
   1839            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \       0x56   0x6801             LDR      R1,[R0, #+0]
   \       0x58   0x6849             LDR      R1,[R1, #+4]
   \       0x5A   0xF031 0x0104      BICS     R1,R1,#0x4
   \       0x5E   0x6803             LDR      R3,[R0, #+0]
   \       0x60   0x6059             STR      R1,[R3, #+4]
   1840            htim->Instance->CR2 |= CommutationSource;
   \       0x62   0x6801             LDR      R1,[R0, #+0]
   \       0x64   0x6849             LDR      R1,[R1, #+4]
   \       0x66   0x430A             ORRS     R2,R2,R1
   \       0x68   0x6801             LDR      R1,[R0, #+0]
   \       0x6A   0x604A             STR      R2,[R1, #+4]
   1841          
   1842            /* Disable Commutation Interrupt */
   1843            __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);
   \       0x6C   0x6801             LDR      R1,[R0, #+0]
   \       0x6E   0x68C9             LDR      R1,[R1, #+12]
   \       0x70   0xF031 0x0120      BICS     R1,R1,#0x20
   \       0x74   0x6802             LDR      R2,[R0, #+0]
   \       0x76   0x60D1             STR      R1,[R2, #+12]
   1844          
   1845            /* Disable Commutation DMA request */
   1846            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);
   \       0x78   0x6801             LDR      R1,[R0, #+0]
   \       0x7A   0x68C9             LDR      R1,[R1, #+12]
   \       0x7C   0xF431 0x5100      BICS     R1,R1,#0x2000
   \       0x80   0x6802             LDR      R2,[R0, #+0]
   \       0x82   0x60D1             STR      R1,[R2, #+12]
   1847          
   1848            __HAL_UNLOCK(htim);
   \       0x84   0x2100             MOVS     R1,#+0
   \       0x86   0xF880 0x103C      STRB     R1,[R0, #+60]
   1849          
   1850            return HAL_OK;
   \       0x8A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_ConfigCommutEvent_1: (+1)
   \       0x8C   0xBC10             POP      {R4}
   \       0x8E   0x4770             BX       LR
   1851          }
   1852          
   1853          /**
   1854            * @brief  Configure the TIM commutation event sequence with interrupt.
   1855            * @note  This function is mandatory to use the commutation event in order to
   1856            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1857            *        the typical use of this feature is with the use of another Timer(interface Timer)
   1858            *        configured in Hall sensor interface, this interface Timer will generate the
   1859            *        commutation at its TRGO output (connected to Timer used in this function) each time
   1860            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1861            * @param  htim TIM handle
   1862            * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
   1863            *          This parameter can be one of the following values:
   1864            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1865            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1866            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1867            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1868            *            @arg TIM_TS_ITR2: Internal trigger 12 selected (*)
   1869            *            @arg TIM_TS_ITR3: Internal trigger 13 selected (*)
   1870            *            @arg TIM_TS_NONE: No trigger is needed
   1871            * @param  CommutationSource the Commutation Event source
   1872            *          This parameter can be one of the following values:
   1873            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1874            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1875            * @retval HAL status
   1876            */

   \                                 In section .text, align 2, keep-with-next
   1877          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
   1878                                                           uint32_t  CommutationSource)
   1879          {
   \                     HAL_TIMEx_ConfigCommutEvent_IT: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1880            /* Check the parameters */
   1881            assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
   1882            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1883          
   1884            __HAL_LOCK(htim);
   \        0x2   0xF890 0x303C      LDRB     R3,[R0, #+60]
   \        0x6   0x2B01             CMP      R3,#+1
   \        0x8   0xD101             BNE.N    ??HAL_TIMEx_ConfigCommutEvent_IT_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE03E             B.N      ??HAL_TIMEx_ConfigCommutEvent_IT_1
   \                     ??HAL_TIMEx_ConfigCommutEvent_IT_0: (+1)
   \        0xE   0x2301             MOVS     R3,#+1
   \       0x10   0xF880 0x303C      STRB     R3,[R0, #+60]
   1885          
   1886            if ((InputTrigger == TIM_TS_ITR0)  || (InputTrigger == TIM_TS_ITR1) ||
   1887                (InputTrigger == TIM_TS_ITR2)  || (InputTrigger == TIM_TS_ITR3) ||
   1888                (InputTrigger == TIM_TS_ITR12)  || (InputTrigger == TIM_TS_ITR13))
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD00C             BEQ.N    ??HAL_TIMEx_ConfigCommutEvent_IT_2
   \       0x18   0x2910             CMP      R1,#+16
   \       0x1A   0xD00A             BEQ.N    ??HAL_TIMEx_ConfigCommutEvent_IT_2
   \       0x1C   0x2920             CMP      R1,#+32
   \       0x1E   0xD008             BEQ.N    ??HAL_TIMEx_ConfigCommutEvent_IT_2
   \       0x20   0x2930             CMP      R1,#+48
   \       0x22   0xD006             BEQ.N    ??HAL_TIMEx_ConfigCommutEvent_IT_2
   \       0x24   0xF5B1 0x1F00      CMP      R1,#+2097152
   \       0x28   0xD003             BEQ.N    ??HAL_TIMEx_ConfigCommutEvent_IT_2
   \       0x2A   0x.... 0x....      LDR.W    R3,??DataTable15
   \       0x2E   0x4299             CMP      R1,R3
   \       0x30   0xD10B             BNE.N    ??HAL_TIMEx_ConfigCommutEvent_IT_3
   1889            {
   1890              /* Select the Input trigger */
   1891              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutEvent_IT_2: (+1)
   \       0x32   0x6803             LDR      R3,[R0, #+0]
   \       0x34   0x689C             LDR      R4,[R3, #+8]
   \       0x36   0x.... 0x....      LDR.W    R3,??DataTable15_1
   \       0x3A   0x401C             ANDS     R4,R3,R4
   \       0x3C   0x6803             LDR      R3,[R0, #+0]
   \       0x3E   0x609C             STR      R4,[R3, #+8]
   1892              htim->Instance->SMCR |= InputTrigger;
   \       0x40   0x6803             LDR      R3,[R0, #+0]
   \       0x42   0x689B             LDR      R3,[R3, #+8]
   \       0x44   0x4319             ORRS     R1,R1,R3
   \       0x46   0x6803             LDR      R3,[R0, #+0]
   \       0x48   0x6099             STR      R1,[R3, #+8]
   1893            }
   1894          
   1895            /* Select the Capture Compare preload feature */
   1896            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutEvent_IT_3: (+1)
   \       0x4A   0x6801             LDR      R1,[R0, #+0]
   \       0x4C   0x6849             LDR      R1,[R1, #+4]
   \       0x4E   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x52   0x6803             LDR      R3,[R0, #+0]
   \       0x54   0x6059             STR      R1,[R3, #+4]
   1897            /* Select the Commutation event source */
   1898            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \       0x56   0x6801             LDR      R1,[R0, #+0]
   \       0x58   0x6849             LDR      R1,[R1, #+4]
   \       0x5A   0xF031 0x0104      BICS     R1,R1,#0x4
   \       0x5E   0x6803             LDR      R3,[R0, #+0]
   \       0x60   0x6059             STR      R1,[R3, #+4]
   1899            htim->Instance->CR2 |= CommutationSource;
   \       0x62   0x6801             LDR      R1,[R0, #+0]
   \       0x64   0x6849             LDR      R1,[R1, #+4]
   \       0x66   0x430A             ORRS     R2,R2,R1
   \       0x68   0x6801             LDR      R1,[R0, #+0]
   \       0x6A   0x604A             STR      R2,[R1, #+4]
   1900          
   1901            /* Disable Commutation DMA request */
   1902            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);
   \       0x6C   0x6801             LDR      R1,[R0, #+0]
   \       0x6E   0x68C9             LDR      R1,[R1, #+12]
   \       0x70   0xF431 0x5100      BICS     R1,R1,#0x2000
   \       0x74   0x6802             LDR      R2,[R0, #+0]
   \       0x76   0x60D1             STR      R1,[R2, #+12]
   1903          
   1904            /* Enable the Commutation Interrupt */
   1905            __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
   \       0x78   0x6801             LDR      R1,[R0, #+0]
   \       0x7A   0x68C9             LDR      R1,[R1, #+12]
   \       0x7C   0xF051 0x0120      ORRS     R1,R1,#0x20
   \       0x80   0x6802             LDR      R2,[R0, #+0]
   \       0x82   0x60D1             STR      R1,[R2, #+12]
   1906          
   1907            __HAL_UNLOCK(htim);
   \       0x84   0x2100             MOVS     R1,#+0
   \       0x86   0xF880 0x103C      STRB     R1,[R0, #+60]
   1908          
   1909            return HAL_OK;
   \       0x8A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_ConfigCommutEvent_IT_1: (+1)
   \       0x8C   0xBC10             POP      {R4}
   \       0x8E   0x4770             BX       LR
   1910          }
   1911          
   1912          /**
   1913            * @brief  Configure the TIM commutation event sequence with DMA.
   1914            * @note  This function is mandatory to use the commutation event in order to
   1915            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1916            *        the typical use of this feature is with the use of another Timer(interface Timer)
   1917            *        configured in Hall sensor interface, this interface Timer will generate the
   1918            *        commutation at its TRGO output (connected to Timer used in this function) each time
   1919            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1920            * @note  The user should configure the DMA in his own software, in This function only the COMDE bit is set
   1921            * @param  htim TIM handle
   1922            * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
   1923            *          This parameter can be one of the following values:
   1924            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1925            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1926            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1927            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1928            *            @arg TIM_TS_ITR2: Internal trigger 12 selected (*)
   1929            *            @arg TIM_TS_ITR3: Internal trigger 13 selected (*)
   1930            *            @arg TIM_TS_NONE: No trigger is needed
   1931            *
   1932            *         (*)  Value not defined in all devices.
   1933            *
   1934            * @param  CommutationSource the Commutation Event source
   1935            *          This parameter can be one of the following values:
   1936            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1937            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1938            * @retval HAL status
   1939            */

   \                                 In section .text, align 2, keep-with-next
   1940          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
   1941                                                            uint32_t  CommutationSource)
   1942          {
   \                     HAL_TIMEx_ConfigCommutEvent_DMA: (+1)
   \        0x0   0xB410             PUSH     {R4}
   1943            /* Check the parameters */
   1944            assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
   1945            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1946          
   1947            __HAL_LOCK(htim);
   \        0x2   0xF890 0x303C      LDRB     R3,[R0, #+60]
   \        0x6   0x2B01             CMP      R3,#+1
   \        0x8   0xD101             BNE.N    ??HAL_TIMEx_ConfigCommutEvent_DMA_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE04A             B.N      ??HAL_TIMEx_ConfigCommutEvent_DMA_1
   \                     ??HAL_TIMEx_ConfigCommutEvent_DMA_0: (+1)
   \        0xE   0x2301             MOVS     R3,#+1
   \       0x10   0xF880 0x303C      STRB     R3,[R0, #+60]
   1948          
   1949            if ((InputTrigger == TIM_TS_ITR0)  || (InputTrigger == TIM_TS_ITR1) ||
   1950                (InputTrigger == TIM_TS_ITR2)  || (InputTrigger == TIM_TS_ITR3) ||
   1951                (InputTrigger == TIM_TS_ITR12)  || (InputTrigger == TIM_TS_ITR13))
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD00C             BEQ.N    ??HAL_TIMEx_ConfigCommutEvent_DMA_2
   \       0x18   0x2910             CMP      R1,#+16
   \       0x1A   0xD00A             BEQ.N    ??HAL_TIMEx_ConfigCommutEvent_DMA_2
   \       0x1C   0x2920             CMP      R1,#+32
   \       0x1E   0xD008             BEQ.N    ??HAL_TIMEx_ConfigCommutEvent_DMA_2
   \       0x20   0x2930             CMP      R1,#+48
   \       0x22   0xD006             BEQ.N    ??HAL_TIMEx_ConfigCommutEvent_DMA_2
   \       0x24   0xF5B1 0x1F00      CMP      R1,#+2097152
   \       0x28   0xD003             BEQ.N    ??HAL_TIMEx_ConfigCommutEvent_DMA_2
   \       0x2A   0x.... 0x....      LDR.W    R3,??DataTable15
   \       0x2E   0x4299             CMP      R1,R3
   \       0x30   0xD10B             BNE.N    ??HAL_TIMEx_ConfigCommutEvent_DMA_3
   1952            {
   1953              /* Select the Input trigger */
   1954              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutEvent_DMA_2: (+1)
   \       0x32   0x6803             LDR      R3,[R0, #+0]
   \       0x34   0x689C             LDR      R4,[R3, #+8]
   \       0x36   0x.... 0x....      LDR.W    R3,??DataTable15_1
   \       0x3A   0x401C             ANDS     R4,R3,R4
   \       0x3C   0x6803             LDR      R3,[R0, #+0]
   \       0x3E   0x609C             STR      R4,[R3, #+8]
   1955              htim->Instance->SMCR |= InputTrigger;
   \       0x40   0x6803             LDR      R3,[R0, #+0]
   \       0x42   0x689B             LDR      R3,[R3, #+8]
   \       0x44   0x4319             ORRS     R1,R1,R3
   \       0x46   0x6803             LDR      R3,[R0, #+0]
   \       0x48   0x6099             STR      R1,[R3, #+8]
   1956            }
   1957          
   1958            /* Select the Capture Compare preload feature */
   1959            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutEvent_DMA_3: (+1)
   \       0x4A   0x6801             LDR      R1,[R0, #+0]
   \       0x4C   0x6849             LDR      R1,[R1, #+4]
   \       0x4E   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x52   0x6803             LDR      R3,[R0, #+0]
   \       0x54   0x6059             STR      R1,[R3, #+4]
   1960            /* Select the Commutation event source */
   1961            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \       0x56   0x6801             LDR      R1,[R0, #+0]
   \       0x58   0x6849             LDR      R1,[R1, #+4]
   \       0x5A   0xF031 0x0104      BICS     R1,R1,#0x4
   \       0x5E   0x6803             LDR      R3,[R0, #+0]
   \       0x60   0x6059             STR      R1,[R3, #+4]
   1962            htim->Instance->CR2 |= CommutationSource;
   \       0x62   0x6801             LDR      R1,[R0, #+0]
   \       0x64   0x6849             LDR      R1,[R1, #+4]
   \       0x66   0x430A             ORRS     R2,R2,R1
   \       0x68   0x6801             LDR      R1,[R0, #+0]
   \       0x6A   0x604A             STR      R2,[R1, #+4]
   1963          
   1964            /* Enable the Commutation DMA Request */
   1965            /* Set the DMA Commutation Callback */
   1966            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
   \       0x6C   0x.... 0x....      ADR.W    R1,TIMEx_DMACommutationCplt
   \       0x70   0x6B42             LDR      R2,[R0, #+52]
   \       0x72   0x63D1             STR      R1,[R2, #+60]
   1967            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback = TIMEx_DMACommutationHalfCplt;
   \       0x74   0x.... 0x....      ADR.W    R1,TIMEx_DMACommutationHalfCplt
   \       0x78   0x6B42             LDR      R2,[R0, #+52]
   \       0x7A   0x6411             STR      R1,[R2, #+64]
   1968            /* Set the DMA error callback */
   1969            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;
   \       0x7C   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \       0x80   0x6B42             LDR      R2,[R0, #+52]
   \       0x82   0x64D1             STR      R1,[R2, #+76]
   1970          
   1971            /* Disable Commutation Interrupt */
   1972            __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);
   \       0x84   0x6801             LDR      R1,[R0, #+0]
   \       0x86   0x68C9             LDR      R1,[R1, #+12]
   \       0x88   0xF031 0x0120      BICS     R1,R1,#0x20
   \       0x8C   0x6802             LDR      R2,[R0, #+0]
   \       0x8E   0x60D1             STR      R1,[R2, #+12]
   1973          
   1974            /* Enable the Commutation DMA Request */
   1975            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
   \       0x90   0x6801             LDR      R1,[R0, #+0]
   \       0x92   0x68C9             LDR      R1,[R1, #+12]
   \       0x94   0xF451 0x5100      ORRS     R1,R1,#0x2000
   \       0x98   0x6802             LDR      R2,[R0, #+0]
   \       0x9A   0x60D1             STR      R1,[R2, #+12]
   1976          
   1977            __HAL_UNLOCK(htim);
   \       0x9C   0x2100             MOVS     R1,#+0
   \       0x9E   0xF880 0x103C      STRB     R1,[R0, #+60]
   1978          
   1979            return HAL_OK;
   \       0xA2   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_ConfigCommutEvent_DMA_1: (+1)
   \       0xA4   0xBC10             POP      {R4}
   \       0xA6   0x4770             BX       LR
   1980          }
   1981          
   1982          /**
   1983            * @brief  Configures the TIM in master mode.
   1984            * @param  htim TIM handle.
   1985            * @param  sMasterConfig pointer to a TIM_MasterConfigTypeDef structure that
   1986            *         contains the selected trigger output (TRGO) and the Master/Slave
   1987            *         mode.
   1988            * @retval HAL status
   1989            */

   \                                 In section .text, align 2, keep-with-next
   1990          HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
   1991                                                                  TIM_MasterConfigTypeDef *sMasterConfig)
   1992          {
   \                     HAL_TIMEx_MasterConfigSynchronization: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   1993            uint32_t tmpcr2;
   1994            uint32_t tmpsmcr;
   1995          
   1996            /* Check the parameters */
   1997            assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   1998            assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
   1999            assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
   2000          
   2001            /* Check input state */
   2002            __HAL_LOCK(htim);
   \        0x2   0xF890 0x203C      LDRB     R2,[R0, #+60]
   \        0x6   0x2A01             CMP      R2,#+1
   \        0x8   0xD101             BNE.N    ??HAL_TIMEx_MasterConfigSynchronization_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE047             B.N      ??HAL_TIMEx_MasterConfigSynchronization_1
   \                     ??HAL_TIMEx_MasterConfigSynchronization_0: (+1)
   \        0xE   0x2201             MOVS     R2,#+1
   \       0x10   0xF880 0x203C      STRB     R2,[R0, #+60]
   2003          
   2004            /* Change the handler state */
   2005            htim->State = HAL_TIM_STATE_BUSY;
   \       0x14   0x2202             MOVS     R2,#+2
   \       0x16   0xF880 0x203D      STRB     R2,[R0, #+61]
   2006          
   2007            /* Get the TIMx CR2 register value */
   2008            tmpcr2 = htim->Instance->CR2;
   \       0x1A   0x6802             LDR      R2,[R0, #+0]
   \       0x1C   0x6854             LDR      R4,[R2, #+4]
   2009          
   2010            /* Get the TIMx SMCR register value */
   2011            tmpsmcr = htim->Instance->SMCR;
   \       0x1E   0x6802             LDR      R2,[R0, #+0]
   \       0x20   0x6893             LDR      R3,[R2, #+8]
   2012          
   2013            /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
   2014            if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
   \       0x22   0x....             LDR.N    R5,??DataTable13
   \       0x24   0x6802             LDR      R2,[R0, #+0]
   \       0x26   0x42AA             CMP      R2,R5
   \       0x28   0xD003             BEQ.N    ??HAL_TIMEx_MasterConfigSynchronization_2
   \       0x2A   0x6802             LDR      R2,[R0, #+0]
   \       0x2C   0x....             LDR.N    R6,??DataTable13_4
   \       0x2E   0x42B2             CMP      R2,R6
   \       0x30   0xD103             BNE.N    ??HAL_TIMEx_MasterConfigSynchronization_3
   2015            {
   2016              /* Check the parameters */
   2017              assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
   2018          
   2019              /* Clear the MMS2 bits */
   2020              tmpcr2 &= ~TIM_CR2_MMS2;
   \                     ??HAL_TIMEx_MasterConfigSynchronization_2: (+1)
   \       0x32   0xF434 0x0470      BICS     R4,R4,#0xF00000
   2021              /* Select the TRGO2 source*/
   2022              tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
   \       0x36   0x684A             LDR      R2,[R1, #+4]
   \       0x38   0x4314             ORRS     R4,R2,R4
   2023            }
   2024          
   2025            /* Reset the MMS Bits */
   2026            tmpcr2 &= ~TIM_CR2_MMS;
   \                     ??HAL_TIMEx_MasterConfigSynchronization_3: (+1)
   \       0x3A   0xF034 0x0470      BICS     R4,R4,#0x70
   2027            /* Select the TRGO source */
   2028            tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
   \       0x3E   0x680A             LDR      R2,[R1, #+0]
   \       0x40   0x4314             ORRS     R4,R2,R4
   2029          
   2030            /* Update TIMx CR2 */
   2031            htim->Instance->CR2 = tmpcr2;
   \       0x42   0x6802             LDR      R2,[R0, #+0]
   \       0x44   0x6054             STR      R4,[R2, #+4]
   2032          
   2033            if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
   \       0x46   0x6802             LDR      R2,[R0, #+0]
   \       0x48   0x42AA             CMP      R2,R5
   \       0x4A   0xD01B             BEQ.N    ??HAL_TIMEx_MasterConfigSynchronization_4
   \       0x4C   0x6802             LDR      R2,[R0, #+0]
   \       0x4E   0xF1B2 0x4F80      CMP      R2,#+1073741824
   \       0x52   0xD017             BEQ.N    ??HAL_TIMEx_MasterConfigSynchronization_4
   \       0x54   0x6802             LDR      R2,[R0, #+0]
   \       0x56   0x....             LDR.N    R4,??DataTable13_1
   \       0x58   0x42A2             CMP      R2,R4
   \       0x5A   0xD013             BEQ.N    ??HAL_TIMEx_MasterConfigSynchronization_4
   \       0x5C   0x6802             LDR      R2,[R0, #+0]
   \       0x5E   0x....             LDR.N    R4,??DataTable13_2
   \       0x60   0x42A2             CMP      R2,R4
   \       0x62   0xD00F             BEQ.N    ??HAL_TIMEx_MasterConfigSynchronization_4
   \       0x64   0x6802             LDR      R2,[R0, #+0]
   \       0x66   0x....             LDR.N    R4,??DataTable13_3
   \       0x68   0x42A2             CMP      R2,R4
   \       0x6A   0xD00B             BEQ.N    ??HAL_TIMEx_MasterConfigSynchronization_4
   \       0x6C   0x6802             LDR      R2,[R0, #+0]
   \       0x6E   0x....             LDR.N    R4,??DataTable13_4
   \       0x70   0x42A2             CMP      R2,R4
   \       0x72   0xD007             BEQ.N    ??HAL_TIMEx_MasterConfigSynchronization_4
   \       0x74   0x6802             LDR      R2,[R0, #+0]
   \       0x76   0x....             LDR.N    R4,??DataTable14
   \       0x78   0x42A2             CMP      R2,R4
   \       0x7A   0xD003             BEQ.N    ??HAL_TIMEx_MasterConfigSynchronization_4
   \       0x7C   0x6802             LDR      R2,[R0, #+0]
   \       0x7E   0x....             LDR.N    R4,??DataTable14_1
   \       0x80   0x42A2             CMP      R2,R4
   \       0x82   0xD105             BNE.N    ??HAL_TIMEx_MasterConfigSynchronization_5
   2034            {
   2035              /* Reset the MSM Bit */
   2036              tmpsmcr &= ~TIM_SMCR_MSM;
   \                     ??HAL_TIMEx_MasterConfigSynchronization_4: (+1)
   \       0x84   0xF033 0x0380      BICS     R3,R3,#0x80
   2037              /* Set master mode */
   2038              tmpsmcr |= sMasterConfig->MasterSlaveMode;
   \       0x88   0x6889             LDR      R1,[R1, #+8]
   \       0x8A   0x430B             ORRS     R3,R1,R3
   2039          
   2040              /* Update TIMx SMCR */
   2041              htim->Instance->SMCR = tmpsmcr;
   \       0x8C   0x6801             LDR      R1,[R0, #+0]
   \       0x8E   0x608B             STR      R3,[R1, #+8]
   2042            }
   2043          
   2044            /* Change the htim state */
   2045            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIMEx_MasterConfigSynchronization_5: (+1)
   \       0x90   0x2101             MOVS     R1,#+1
   \       0x92   0xF880 0x103D      STRB     R1,[R0, #+61]
   2046          
   2047            __HAL_UNLOCK(htim);
   \       0x96   0x2100             MOVS     R1,#+0
   \       0x98   0xF880 0x103C      STRB     R1,[R0, #+60]
   2048          
   2049            return HAL_OK;
   \       0x9C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_MasterConfigSynchronization_1: (+1)
   \       0x9E   0xBC70             POP      {R4-R6}
   \       0xA0   0x4770             BX       LR
   2050          }
   2051          
   2052          /**
   2053            * @brief  Configures the Break feature, dead time, Lock level, OSSI/OSSR State
   2054            *         and the AOE(automatic output enable).
   2055            * @param  htim TIM handle
   2056            * @param  sBreakDeadTimeConfig pointer to a TIM_ConfigBreakDeadConfigTypeDef structure that
   2057            *         contains the BDTR Register configuration  information for the TIM peripheral.
   2058            * @note   Interrupts can be generated when an active level is detected on the
   2059            *         break input, the break 2 input or the system break input. Break
   2060            *         interrupt can be enabled by calling the @ref __HAL_TIM_ENABLE_IT macro.
   2061            * @retval HAL status
   2062            */

   \                                 In section .text, align 2, keep-with-next
   2063          HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
   2064                                                          TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
   2065          {
   \                     HAL_TIMEx_ConfigBreakDeadTime: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   2066            /* Keep this variable initialized to 0 as it is used to configure BDTR register */
   2067            uint32_t tmpbdtr = 0U;
   \        0x2   0x2300             MOVS     R3,#+0
   2068          
   2069            /* Check the parameters */
   2070            assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
   2071            assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
   2072            assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
   2073            assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
   2074            assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
   2075            assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
   2076            assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
   2077            assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
   2078            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
   2079          
   2080            /* Check input state */
   2081            __HAL_LOCK(htim);
   \        0x4   0xF890 0x203C      LDRB     R2,[R0, #+60]
   \        0x8   0x2A01             CMP      R2,#+1
   \        0xA   0xD101             BNE.N    ??HAL_TIMEx_ConfigBreakDeadTime_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE054             B.N      ??HAL_TIMEx_ConfigBreakDeadTime_1
   \                     ??HAL_TIMEx_ConfigBreakDeadTime_0: (+1)
   \       0x10   0x2201             MOVS     R2,#+1
   \       0x12   0xF880 0x203C      STRB     R2,[R0, #+60]
   2082          
   2083            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
   2084               the OSSI State, the dead time value and the Automatic Output Enable Bit */
   2085          
   2086            /* Set the BDTR bits */
   2087            MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
   \       0x16   0x0A1B             LSRS     R3,R3,#+8
   \       0x18   0x021B             LSLS     R3,R3,#+8
   \       0x1A   0x68CA             LDR      R2,[R1, #+12]
   \       0x1C   0x4313             ORRS     R3,R2,R3
   2088            MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
   \       0x1E   0xF433 0x7340      BICS     R3,R3,#0x300
   \       0x22   0x688A             LDR      R2,[R1, #+8]
   \       0x24   0x4313             ORRS     R3,R2,R3
   2089            MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
   \       0x26   0xF433 0x6380      BICS     R3,R3,#0x400
   \       0x2A   0x684A             LDR      R2,[R1, #+4]
   \       0x2C   0x4313             ORRS     R3,R2,R3
   2090            MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
   \       0x2E   0xF433 0x6300      BICS     R3,R3,#0x800
   \       0x32   0x680A             LDR      R2,[R1, #+0]
   \       0x34   0x4313             ORRS     R3,R2,R3
   2091            MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
   \       0x36   0xF433 0x5380      BICS     R3,R3,#0x1000
   \       0x3A   0x690A             LDR      R2,[R1, #+16]
   \       0x3C   0x4313             ORRS     R3,R2,R3
   2092            MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
   \       0x3E   0xF433 0x5300      BICS     R3,R3,#0x2000
   \       0x42   0x694A             LDR      R2,[R1, #+20]
   \       0x44   0x4313             ORRS     R3,R2,R3
   2093            MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
   \       0x46   0xF433 0x4380      BICS     R3,R3,#0x4000
   \       0x4A   0x6B0A             LDR      R2,[R1, #+48]
   \       0x4C   0x4313             ORRS     R3,R2,R3
   2094            MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
   \       0x4E   0xF433 0x2370      BICS     R3,R3,#0xF0000
   \       0x52   0x698A             LDR      R2,[R1, #+24]
   \       0x54   0xEA53 0x4302      ORRS     R3,R3,R2, LSL #+16
   2095          
   2096          #if defined(TIM_BDTR_BKBID)
   2097            if (IS_TIM_ADVANCED_INSTANCE(htim->Instance))
   \       0x58   0x....             LDR.N    R4,??DataTable15_3
   \       0x5A   0x6802             LDR      R2,[R0, #+0]
   \       0x5C   0x42A2             CMP      R2,R4
   \       0x5E   0xD003             BEQ.N    ??HAL_TIMEx_ConfigBreakDeadTime_2
   \       0x60   0x6802             LDR      R2,[R0, #+0]
   \       0x62   0x....             LDR.N    R5,??DataTable15_4
   \       0x64   0x42AA             CMP      R2,R5
   \       0x66   0xD103             BNE.N    ??HAL_TIMEx_ConfigBreakDeadTime_3
   2098            {
   2099              /* Check the parameters */
   2100              assert_param(IS_TIM_BREAK_AFMODE(sBreakDeadTimeConfig->BreakAFMode));
   2101          
   2102              /* Set BREAK AF mode */
   2103              MODIFY_REG(tmpbdtr, TIM_BDTR_BKBID, sBreakDeadTimeConfig->BreakAFMode);
   \                     ??HAL_TIMEx_ConfigBreakDeadTime_2: (+1)
   \       0x68   0xF033 0x5380      BICS     R3,R3,#0x10000000
   \       0x6C   0x69CA             LDR      R2,[R1, #+28]
   \       0x6E   0x4313             ORRS     R3,R2,R3
   2104            }
   2105          
   2106          #endif /* TIM_BDTR_BKBID */
   2107            if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
   \                     ??HAL_TIMEx_ConfigBreakDeadTime_3: (+1)
   \       0x70   0x6802             LDR      R2,[R0, #+0]
   \       0x72   0x42A2             CMP      R2,R4
   \       0x74   0xD003             BEQ.N    ??HAL_TIMEx_ConfigBreakDeadTime_4
   \       0x76   0x6802             LDR      R2,[R0, #+0]
   \       0x78   0x....             LDR.N    R5,??DataTable15_4
   \       0x7A   0x42AA             CMP      R2,R5
   \       0x7C   0xD117             BNE.N    ??HAL_TIMEx_ConfigBreakDeadTime_5
   2108            {
   2109              /* Check the parameters */
   2110              assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));
   2111              assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
   2112              assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));
   2113          
   2114              /* Set the BREAK2 input related BDTR bits */
   2115              MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
   \                     ??HAL_TIMEx_ConfigBreakDeadTime_4: (+1)
   \       0x7E   0xF433 0x0370      BICS     R3,R3,#0xF00000
   \       0x82   0x6A8A             LDR      R2,[R1, #+40]
   \       0x84   0xEA53 0x5302      ORRS     R3,R3,R2, LSL #+20
   2116              MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
   \       0x88   0xF033 0x7380      BICS     R3,R3,#0x1000000
   \       0x8C   0x6A0A             LDR      R2,[R1, #+32]
   \       0x8E   0x4313             ORRS     R3,R2,R3
   2117              MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
   \       0x90   0xF033 0x7300      BICS     R3,R3,#0x2000000
   \       0x94   0x6A4A             LDR      R2,[R1, #+36]
   \       0x96   0x4313             ORRS     R3,R2,R3
   2118          #if defined(TIM_BDTR_BKBID)
   2119          
   2120              if (IS_TIM_ADVANCED_INSTANCE(htim->Instance))
   \       0x98   0x6802             LDR      R2,[R0, #+0]
   \       0x9A   0x42A2             CMP      R2,R4
   \       0x9C   0xD003             BEQ.N    ??HAL_TIMEx_ConfigBreakDeadTime_6
   \       0x9E   0x6802             LDR      R2,[R0, #+0]
   \       0xA0   0x....             LDR.N    R4,??DataTable15_4
   \       0xA2   0x42A2             CMP      R2,R4
   \       0xA4   0xD103             BNE.N    ??HAL_TIMEx_ConfigBreakDeadTime_5
   2121              {
   2122                /* Check the parameters */
   2123                assert_param(IS_TIM_BREAK2_AFMODE(sBreakDeadTimeConfig->Break2AFMode));
   2124          
   2125                /* Set BREAK2 AF mode */
   2126                MODIFY_REG(tmpbdtr, TIM_BDTR_BK2BID, sBreakDeadTimeConfig->Break2AFMode);
   \                     ??HAL_TIMEx_ConfigBreakDeadTime_6: (+1)
   \       0xA6   0xF033 0x5300      BICS     R3,R3,#0x20000000
   \       0xAA   0x6AC9             LDR      R1,[R1, #+44]
   \       0xAC   0x430B             ORRS     R3,R1,R3
   2127              }
   2128          #endif /* TIM_BDTR_BKBID */
   2129            }
   2130          
   2131            /* Set TIMx_BDTR */
   2132            htim->Instance->BDTR = tmpbdtr;
   \                     ??HAL_TIMEx_ConfigBreakDeadTime_5: (+1)
   \       0xAE   0x6801             LDR      R1,[R0, #+0]
   \       0xB0   0x644B             STR      R3,[R1, #+68]
   2133          
   2134            __HAL_UNLOCK(htim);
   \       0xB2   0x2100             MOVS     R1,#+0
   \       0xB4   0xF880 0x103C      STRB     R1,[R0, #+60]
   2135          
   2136            return HAL_OK;
   \       0xB8   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_ConfigBreakDeadTime_1: (+1)
   \       0xBA   0xBC30             POP      {R4,R5}
   \       0xBC   0x4770             BX       LR
   2137          }
   2138          #if defined(TIM_BREAK_INPUT_SUPPORT)
   2139          
   2140          /**
   2141            * @brief  Configures the break input source.
   2142            * @param  htim TIM handle.
   2143            * @param  BreakInput Break input to configure
   2144            *          This parameter can be one of the following values:
   2145            *            @arg TIM_BREAKINPUT_BRK: Timer break input
   2146            *            @arg TIM_BREAKINPUT_BRK2: Timer break 2 input
   2147            * @param  sBreakInputConfig Break input source configuration
   2148            * @retval HAL status
   2149            */

   \                                 In section .text, align 2, keep-with-next
   2150          HAL_StatusTypeDef HAL_TIMEx_ConfigBreakInput(TIM_HandleTypeDef *htim,
   2151                                                       uint32_t BreakInput,
   2152                                                       TIMEx_BreakInputConfigTypeDef *sBreakInputConfig)
   2153          
   2154          {
   \                     HAL_TIMEx_ConfigBreakInput: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   2155            HAL_StatusTypeDef status = HAL_OK;
   \        0x2   0x2300             MOVS     R3,#+0
   2156            uint32_t tmporx;
   2157            uint32_t bkin_enable_mask;
   2158            uint32_t bkin_polarity_mask;
   2159            uint32_t bkin_enable_bitpos;
   2160            uint32_t bkin_polarity_bitpos;
   2161          
   2162            /* Check the parameters */
   2163            assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
   2164            assert_param(IS_TIM_BREAKINPUT(BreakInput));
   2165            assert_param(IS_TIM_BREAKINPUTSOURCE(sBreakInputConfig->Source));
   2166            assert_param(IS_TIM_BREAKINPUTSOURCE_STATE(sBreakInputConfig->Enable));
   2167            if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)
   \        0x4   0x6814             LDR      R4,[R2, #+0]
   \        0x6   0x2C08             CMP      R4,#+8
   2168            {
   2169              assert_param(IS_TIM_BREAKINPUTSOURCE_POLARITY(sBreakInputConfig->Polarity));
   2170            }
   2171          
   2172            /* Check input state */
   2173            __HAL_LOCK(htim);
   \                     ??HAL_TIMEx_ConfigBreakInput_0: (+1)
   \        0x8   0xF890 0x403C      LDRB     R4,[R0, #+60]
   \        0xC   0x2C01             CMP      R4,#+1
   \        0xE   0xD101             BNE.N    ??HAL_TIMEx_ConfigBreakInput_1
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE05D             B.N      ??HAL_TIMEx_ConfigBreakInput_2
   \                     ??HAL_TIMEx_ConfigBreakInput_1: (+1)
   \       0x14   0x2401             MOVS     R4,#+1
   \       0x16   0xF880 0x403C      STRB     R4,[R0, #+60]
   2174          
   2175            switch (sBreakInputConfig->Source)
   \       0x1A   0x6814             LDR      R4,[R2, #+0]
   \       0x1C   0x2C01             CMP      R4,#+1
   \       0x1E   0xD006             BEQ.N    ??HAL_TIMEx_ConfigBreakInput_3
   \       0x20   0x2C02             CMP      R4,#+2
   \       0x22   0xD00A             BEQ.N    ??HAL_TIMEx_ConfigBreakInput_4
   \       0x24   0x2C04             CMP      R4,#+4
   \       0x26   0xD00E             BEQ.N    ??HAL_TIMEx_ConfigBreakInput_5
   \       0x28   0x2C08             CMP      R4,#+8
   \       0x2A   0xD012             BEQ.N    ??HAL_TIMEx_ConfigBreakInput_6
   \       0x2C   0xE017             B.N      ??HAL_TIMEx_ConfigBreakInput_7
   2176            {
   2177              case TIM_BREAKINPUTSOURCE_BKIN:
   2178              {
   2179                bkin_enable_mask = TIM1_AF1_BKINE;
   \                     ??HAL_TIMEx_ConfigBreakInput_3: (+1)
   \       0x2E   0x2601             MOVS     R6,#+1
   2180                bkin_enable_bitpos = TIM1_AF1_BKINE_Pos;
   \       0x30   0x2700             MOVS     R7,#+0
   2181                bkin_polarity_mask = TIM1_AF1_BKINP;
   \       0x32   0xF44F 0x7400      MOV      R4,#+512
   2182                bkin_polarity_bitpos = TIM1_AF1_BKINP_Pos;
   \       0x36   0x2509             MOVS     R5,#+9
   2183                break;
   \       0x38   0xE015             B.N      ??HAL_TIMEx_ConfigBreakInput_8
   2184              }
   2185              case TIM_BREAKINPUTSOURCE_COMP1:
   2186              {
   2187                bkin_enable_mask = TIM1_AF1_BKCMP1E;
   \                     ??HAL_TIMEx_ConfigBreakInput_4: (+1)
   \       0x3A   0x2602             MOVS     R6,#+2
   2188                bkin_enable_bitpos = TIM1_AF1_BKCMP1E_Pos;
   \       0x3C   0x2701             MOVS     R7,#+1
   2189                bkin_polarity_mask = TIM1_AF1_BKCMP1P;
   \       0x3E   0xF44F 0x6480      MOV      R4,#+1024
   2190                bkin_polarity_bitpos = TIM1_AF1_BKCMP1P_Pos;
   \       0x42   0x250A             MOVS     R5,#+10
   2191                break;
   \       0x44   0xE00F             B.N      ??HAL_TIMEx_ConfigBreakInput_8
   2192              }
   2193              case TIM_BREAKINPUTSOURCE_COMP2:
   2194              {
   2195                bkin_enable_mask = TIM1_AF1_BKCMP2E;
   \                     ??HAL_TIMEx_ConfigBreakInput_5: (+1)
   \       0x46   0x2604             MOVS     R6,#+4
   2196                bkin_enable_bitpos = TIM1_AF1_BKCMP2E_Pos;
   \       0x48   0x2702             MOVS     R7,#+2
   2197                bkin_polarity_mask = TIM1_AF1_BKCMP2P;
   \       0x4A   0xF44F 0x6400      MOV      R4,#+2048
   2198                bkin_polarity_bitpos = TIM1_AF1_BKCMP2P_Pos;
   \       0x4E   0x250B             MOVS     R5,#+11
   2199                break;
   \       0x50   0xE009             B.N      ??HAL_TIMEx_ConfigBreakInput_8
   2200              }
   2201              case TIM_BREAKINPUTSOURCE_DFSDM1:
   2202              {
   2203                bkin_enable_mask = TIM1_AF1_BKDF1BK0E;
   \                     ??HAL_TIMEx_ConfigBreakInput_6: (+1)
   \       0x52   0xF44F 0x7680      MOV      R6,#+256
   2204                bkin_enable_bitpos = TIM1_AF1_BKDF1BK0E_Pos;
   \       0x56   0x2708             MOVS     R7,#+8
   2205                bkin_polarity_mask = 0U;
   \       0x58   0x2400             MOVS     R4,#+0
   2206                bkin_polarity_bitpos = 0U;
   \       0x5A   0x2500             MOVS     R5,#+0
   2207                break;
   \       0x5C   0xE003             B.N      ??HAL_TIMEx_ConfigBreakInput_8
   2208              }
   2209          
   2210              default:
   2211              {
   2212                bkin_enable_mask = 0U;
   \                     ??HAL_TIMEx_ConfigBreakInput_7: (+1)
   \       0x5E   0x2600             MOVS     R6,#+0
   2213                bkin_polarity_mask = 0U;
   \       0x60   0x2400             MOVS     R4,#+0
   2214                bkin_enable_bitpos = 0U;
   \       0x62   0x2700             MOVS     R7,#+0
   2215                bkin_polarity_bitpos = 0U;
   \       0x64   0x2500             MOVS     R5,#+0
   2216                break;
   2217              }
   2218            }
   2219          
   2220            switch (BreakInput)
   \                     ??HAL_TIMEx_ConfigBreakInput_8: (+1)
   \       0x66   0x2901             CMP      R1,#+1
   \       0x68   0xD002             BEQ.N    ??HAL_TIMEx_ConfigBreakInput_9
   \       0x6A   0x2902             CMP      R1,#+2
   \       0x6C   0xD015             BEQ.N    ??HAL_TIMEx_ConfigBreakInput_10
   \       0x6E   0xE029             B.N      ??HAL_TIMEx_ConfigBreakInput_11
   2221            {
   2222              case TIM_BREAKINPUT_BRK:
   2223              {
   2224                /* Get the TIMx_AF1 register value */
   2225                tmporx = htim->Instance->AF1;
   \                     ??HAL_TIMEx_ConfigBreakInput_9: (+1)
   \       0x70   0x6801             LDR      R1,[R0, #+0]
   \       0x72   0x6E09             LDR      R1,[R1, #+96]
   2226          
   2227                /* Enable the break input */
   2228                tmporx &= ~bkin_enable_mask;
   \       0x74   0x43B1             BICS     R1,R1,R6
   2229                tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
   \       0x76   0xF8D2 0xC004      LDR      R12,[R2, #+4]
   \       0x7A   0xFA1C 0xF707      LSLS     R7,R12,R7
   \       0x7E   0x403E             ANDS     R6,R6,R7
   \       0x80   0x4331             ORRS     R1,R6,R1
   2230          
   2231                /* Set the break input polarity */
   2232                if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)
   \       0x82   0x6816             LDR      R6,[R2, #+0]
   \       0x84   0x2E08             CMP      R6,#+8
   \       0x86   0xD005             BEQ.N    ??HAL_TIMEx_ConfigBreakInput_12
   2233                {
   2234                  tmporx &= ~bkin_polarity_mask;
   \       0x88   0x43A1             BICS     R1,R1,R4
   2235                  tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
   \       0x8A   0x6892             LDR      R2,[R2, #+8]
   \       0x8C   0xFA12 0xF505      LSLS     R5,R2,R5
   \       0x90   0x402C             ANDS     R4,R4,R5
   \       0x92   0x4321             ORRS     R1,R4,R1
   2236                }
   2237          
   2238                /* Set TIMx_AF1 */
   2239                htim->Instance->AF1 = tmporx;
   \                     ??HAL_TIMEx_ConfigBreakInput_12: (+1)
   \       0x94   0x6802             LDR      R2,[R0, #+0]
   \       0x96   0x6611             STR      R1,[R2, #+96]
   2240                break;
   \       0x98   0xE015             B.N      ??HAL_TIMEx_ConfigBreakInput_13
   2241              }
   2242              case TIM_BREAKINPUT_BRK2:
   2243              {
   2244                /* Get the TIMx_AF2 register value */
   2245                tmporx = htim->Instance->AF2;
   \                     ??HAL_TIMEx_ConfigBreakInput_10: (+1)
   \       0x9A   0x6801             LDR      R1,[R0, #+0]
   \       0x9C   0x6E49             LDR      R1,[R1, #+100]
   2246          
   2247                /* Enable the break input */
   2248                tmporx &= ~bkin_enable_mask;
   \       0x9E   0x43B1             BICS     R1,R1,R6
   2249                tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
   \       0xA0   0xF8D2 0xC004      LDR      R12,[R2, #+4]
   \       0xA4   0xFA1C 0xF707      LSLS     R7,R12,R7
   \       0xA8   0x403E             ANDS     R6,R6,R7
   \       0xAA   0x4331             ORRS     R1,R6,R1
   2250          
   2251                /* Set the break input polarity */
   2252                if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)
   \       0xAC   0x6816             LDR      R6,[R2, #+0]
   \       0xAE   0x2E08             CMP      R6,#+8
   \       0xB0   0xD005             BEQ.N    ??HAL_TIMEx_ConfigBreakInput_14
   2253                {
   2254                  tmporx &= ~bkin_polarity_mask;
   \       0xB2   0x43A1             BICS     R1,R1,R4
   2255                  tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
   \       0xB4   0x6892             LDR      R2,[R2, #+8]
   \       0xB6   0xFA12 0xF505      LSLS     R5,R2,R5
   \       0xBA   0x402C             ANDS     R4,R4,R5
   \       0xBC   0x4321             ORRS     R1,R4,R1
   2256                }
   2257          
   2258                /* Set TIMx_AF2 */
   2259                htim->Instance->AF2 = tmporx;
   \                     ??HAL_TIMEx_ConfigBreakInput_14: (+1)
   \       0xBE   0x6802             LDR      R2,[R0, #+0]
   \       0xC0   0x6651             STR      R1,[R2, #+100]
   2260                break;
   \       0xC2   0xE000             B.N      ??HAL_TIMEx_ConfigBreakInput_13
   2261              }
   2262              default:
   2263                status = HAL_ERROR;
   \                     ??HAL_TIMEx_ConfigBreakInput_11: (+1)
   \       0xC4   0x2301             MOVS     R3,#+1
   2264                break;
   2265            }
   2266          
   2267            __HAL_UNLOCK(htim);
   \                     ??HAL_TIMEx_ConfigBreakInput_13: (+1)
   \       0xC6   0x2100             MOVS     R1,#+0
   \       0xC8   0xF880 0x103C      STRB     R1,[R0, #+60]
   2268          
   2269            return status;
   \       0xCC   0x0018             MOVS     R0,R3
   \       0xCE   0xB2C0             UXTB     R0,R0
   \                     ??HAL_TIMEx_ConfigBreakInput_2: (+1)
   \       0xD0   0xBCF0             POP      {R4-R7}
   \       0xD2   0x4770             BX       LR
   2270          }
   2271          #endif /*TIM_BREAK_INPUT_SUPPORT */
   2272          
   2273          /**
   2274            * @brief  Configures the TIMx Remapping input capabilities.
   2275            * @param  htim TIM handle.
   2276            * @param  Remap specifies the TIM remapping source.
   2277            *         For TIM1, the parameter is one of the following values:
   2278            *            @arg TIM_TIM1_ETR_GPIO:               TIM1_ETR is connected to GPIO
   2279            *            @arg TIM_TIM1_ETR_COMP1:              TIM1_ETR is connected to COMP1 output
   2280            *            @arg TIM_TIM1_ETR_COMP2:              TIM1_ETR is connected to COMP2 output
   2281            *            @arg TIM_TIM1_ETR_ADC1_AWD1:          TIM1_ETR is connected to ADC1 AWD1
   2282            *            @arg TIM_TIM1_ETR_ADC1_AWD2:          TIM1_ETR is connected to ADC1 AWD2
   2283            *            @arg TIM_TIM1_ETR_ADC1_AWD3:          TIM1_ETR is connected to ADC1 AWD3
   2284            *            @arg TIM_TIM1_ETR_ADC3_AWD1:          TIM1_ETR is connected to ADC3 AWD1
   2285            *            @arg TIM_TIM1_ETR_ADC3_AWD2:          TIM1_ETR is connected to ADC3 AWD2
   2286            *            @arg TIM_TIM1_ETR_ADC3_AWD3:          TIM1_ETR is connected to ADC3 AWD3
   2287            *
   2288            *         For TIM2, the parameter is one of the following values:
   2289            *            @arg TIM_TIM2_ETR_GPIO:               TIM2_ETR is connected to GPIO
   2290            *            @arg TIM_TIM2_ETR_COMP1:              TIM2_ETR is connected to COMP1 output
   2291            *            @arg TIM_TIM2_ETR_COMP2:              TIM2_ETR is connected to COMP2 output
   2292            *            @arg TIM_TIM2_ETR_LSE:                TIM2_ETR is connected to LSE
   2293            *            @arg TIM_TIM2_ETR_SAI1_FSA:           TIM2_ETR is connected to SAI1 FS_A
   2294            *            @arg TIM_TIM2_ETR_SAI1_FSB:           TIM2_ETR is connected to SAI1 FS_B
   2295            *
   2296            *         For TIM3, the parameter is one of the following values:
   2297            *            @arg TIM_TIM3_ETR_GPIO:               TIM3_ETR is connected to GPIO
   2298            *            @arg TIM_TIM3_ETR_COMP1:              TIM3_ETR is connected to COMP1 output
   2299            *
   2300            *         For TIM5, the parameter is one of the following values:
   2301            *            @arg TIM_TIM5_ETR_GPIO:               TIM5_ETR is connected to GPIO
   2302            *            @arg TIM_TIM5_ETR_SAI2_FSA:           TIM5_ETR is connected to SAI2 FS_A (*)
   2303            *            @arg TIM_TIM5_ETR_SAI2_FSB:           TIM5_ETR is connected to SAI2 FS_B (*)
   2304            *            @arg TIM_TIM5_ETR_SAI4_FSA:           TIM5_ETR is connected to SAI2 FS_A (*)
   2305            *            @arg TIM_TIM5_ETR_SAI4_FSB:           TIM5_ETR is connected to SAI2 FS_B (*)
   2306            *
   2307            *         For TIM8, the parameter is one of the following values:
   2308            *            @arg TIM_TIM8_ETR_GPIO:               TIM8_ETR is connected to GPIO
   2309            *            @arg TIM_TIM8_ETR_COMP1:              TIM8_ETR is connected to COMP1 output
   2310            *            @arg TIM_TIM8_ETR_COMP2:              TIM8_ETR is connected to COMP2 output
   2311            *            @arg TIM_TIM8_ETR_ADC2_AWD1:          TIM8_ETR is connected to ADC2 AWD1
   2312            *            @arg TIM_TIM8_ETR_ADC2_AWD2:          TIM8_ETR is connected to ADC2 AWD2
   2313            *            @arg TIM_TIM8_ETR_ADC2_AWD3:          TIM8_ETR is connected to ADC2 AWD3
   2314            *            @arg TIM_TIM8_ETR_ADC3_AWD1:          TIM8_ETR is connected to ADC3 AWD1
   2315            *            @arg TIM_TIM8_ETR_ADC3_AWD2:          TIM8_ETR is connected to ADC3 AWD2
   2316            *            @arg TIM_TIM8_ETR_ADC3_AWD3:          TIM8_ETR is connected to ADC3 AWD3
   2317            *
   2318            *         For TIM23, the parameter is one of the following values: (*)
   2319            *            @arg TIM_TIM23_ETR_GPIO               TIM23_ETR is connected to GPIO
   2320            *            @arg TIM_TIM23_ETR_COMP1              TIM23_ETR is connected to COMP1 output
   2321            *            @arg TIM_TIM23_ETR_COMP2              TIM23_ETR is connected to COMP2 output
   2322            *
   2323            *         For TIM24, the parameter is one of the following values: (*)
   2324            *           @arg TIM_TIM24_ETR_GPIO                TIM24_ETR is connected to GPIO
   2325            *           @arg TIM_TIM24_ETR_SAI4_FSA            TIM24_ETR is connected to SAI4 FS_A
   2326            *           @arg TIM_TIM24_ETR_SAI4_FSB            TIM24_ETR is connected to SAI4 FS_B
   2327            *           @arg TIM_TIM24_ETR_SAI1_FSA            TIM24_ETR is connected to SAI1 FS_A
   2328            *           @arg TIM_TIM24_ETR_SAI1_FSB            TIM24_ETR is connected to SAI1 FS_B
   2329            *
   2330            *         (*)  Value not defined in all devices.
   2331            *
   2332            * @retval HAL status
   2333            */

   \                                 In section .text, align 2, keep-with-next
   2334          HAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef *htim, uint32_t Remap)
   2335          {
   2336            /* Check parameters */
   2337            assert_param(IS_TIM_REMAP_INSTANCE(htim->Instance));
   2338            assert_param(IS_TIM_REMAP(Remap));
   2339          
   2340            __HAL_LOCK(htim);
   \                     HAL_TIMEx_RemapConfig: (+1)
   \        0x0   0xF890 0x203C      LDRB     R2,[R0, #+60]
   \        0x4   0x2A01             CMP      R2,#+1
   \        0x6   0xD101             BNE.N    ??HAL_TIMEx_RemapConfig_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xE00D             B.N      ??HAL_TIMEx_RemapConfig_1
   \                     ??HAL_TIMEx_RemapConfig_0: (+1)
   \        0xC   0x2201             MOVS     R2,#+1
   \        0xE   0xF880 0x203C      STRB     R2,[R0, #+60]
   2341          
   2342            MODIFY_REG(htim->Instance->AF1, TIM1_AF1_ETRSEL_Msk, Remap);
   \       0x12   0x6802             LDR      R2,[R0, #+0]
   \       0x14   0x6E12             LDR      R2,[R2, #+96]
   \       0x16   0xF432 0x3270      BICS     R2,R2,#0x3C000
   \       0x1A   0x4311             ORRS     R1,R1,R2
   \       0x1C   0x6802             LDR      R2,[R0, #+0]
   \       0x1E   0x6611             STR      R1,[R2, #+96]
   2343          
   2344            __HAL_UNLOCK(htim);
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0xF880 0x103C      STRB     R1,[R0, #+60]
   2345          
   2346            return HAL_OK;
   \       0x26   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_RemapConfig_1: (+1)
   \       0x28   0x4770             BX       LR
   2347          }
   2348          
   2349          /**
   2350            * @brief  Select the timer input source
   2351            * @param  htim TIM handle.
   2352            * @param  Channel specifies the TIM Channel
   2353            *          This parameter can be one of the following values:
   2354            *            @arg TIM_CHANNEL_1: TI1 input channel
   2355            *            @arg TIM_CHANNEL_2: TI2 input channel
   2356            *            @arg TIM_CHANNEL_3: TIM Channel 3
   2357            *            @arg TIM_CHANNEL_4: TIM Channel 4
   2358            * @param  TISelection parameter of the TIM_TISelectionStruct structure is detailed as follows:
   2359            *         For TIM1, the parameter is one of the following values:
   2360            *            @arg TIM_TIM1_TI1_GPIO:                TIM1 TI1 is connected to GPIO
   2361            *            @arg TIM_TIM1_TI1_COMP1:               TIM1 TI1 is connected to COMP1 output
   2362            *
   2363            *         For TIM2, the parameter is one of the following values:
   2364            *            @arg TIM_TIM2_TI4_GPIO:                TIM2 TI4 is connected to GPIO
   2365            *            @arg TIM_TIM2_TI4_COMP1:               TIM2 TI4 is connected to COMP1 output
   2366            *            @arg TIM_TIM2_TI4_COMP2:               TIM2 TI4 is connected to COMP2 output
   2367            *            @arg TIM_TIM2_TI4_COMP1_COMP2:         TIM2 TI4 is connected to logical OR between COMP1 and COMP2 output
   2368            *
   2369            *         For TIM3, the parameter is one of the following values:
   2370            *            @arg TIM_TIM3_TI1_GPIO:                TIM3 TI1 is connected to GPIO
   2371            *            @arg TIM_TIM3_TI1_COMP1:               TIM3 TI1 is connected to COMP1 output
   2372            *            @arg TIM_TIM3_TI1_COMP2:               TIM3 TI1 is connected to COMP2 output
   2373            *            @arg TIM_TIM3_TI1_COMP1_COMP2:         TIM3 TI1 is connected to logical OR between COMP1 and COMP2 output
   2374            *
   2375            *         For TIM5, the parameter is one of the following values:
   2376            *            @arg TIM_TIM5_TI1_GPIO:                TIM5 TI1 is connected to GPIO
   2377            *            @arg TIM_TIM5_TI1_CAN_TMP:             TIM5 TI1 is connected to CAN TMP
   2378            *            @arg TIM_TIM5_TI1_CAN_RTP:             TIM5 TI1 is connected to CAN RTP
   2379            *
   2380            *         For TIM8, the parameter is one of the following values:
   2381            *            @arg TIM_TIM8_TI1_GPIO:               TIM8 TI1 is connected to GPIO
   2382            *            @arg TIM_TIM8_TI1_COMP2:              TIM8 TI1 is connected to COMP2 output
   2383            *
   2384            *         For TIM12, the parameter can have the following values: (*)
   2385            *            @arg TIM_TIM12_TI1_GPIO:              TIM12 TI1 is connected to GPIO
   2386            *            @arg TIM_TIM12_TI1_SPDIF_FS:          TIM12 TI1 is connected to SPDIF FS
   2387            *
   2388            *         For TIM15, the parameter is one of the following values:
   2389            *            @arg TIM_TIM15_TI1_GPIO:              TIM15 TI1 is connected to GPIO
   2390            *            @arg TIM_TIM15_TI1_TIM2:              TIM15 TI1 is connected to TIM2 CH1
   2391            *            @arg TIM_TIM15_TI1_TIM3:              TIM15 TI1 is connected to TIM3 CH1
   2392            *            @arg TIM_TIM15_TI1_TIM4:              TIM15 TI1 is connected to TIM4 CH1
   2393            *            @arg TIM_TIM15_TI1_LSE:               TIM15 TI1 is connected to LSE
   2394            *            @arg TIM_TIM15_TI1_CSI:               TIM15 TI1 is connected to CSI
   2395            *            @arg TIM_TIM15_TI1_MCO2:              TIM15 TI1 is connected to MCO2
   2396            *            @arg TIM_TIM15_TI2_GPIO:              TIM15 TI2 is connected to GPIO
   2397            *            @arg TIM_TIM15_TI2_TIM2:              TIM15 TI2 is connected to TIM2 CH2
   2398            *            @arg TIM_TIM15_TI2_TIM3:              TIM15 TI2 is connected to TIM3 CH2
   2399            *            @arg TIM_TIM15_TI2_TIM4:              TIM15 TI2 is connected to TIM4 CH2
   2400            *
   2401            *         For TIM16, the parameter can have the following values:
   2402            *            @arg TIM_TIM16_TI1_GPIO:              TIM16 TI1 is connected to GPIO
   2403            *            @arg TIM_TIM16_TI1_LSI:               TIM16 TI1 is connected to LSI
   2404            *            @arg TIM_TIM16_TI1_LSE:               TIM16 TI1 is connected to LSE
   2405            *            @arg TIM_TIM16_TI1_RTC:               TIM16 TI1 is connected to RTC wakeup interrupt
   2406            *
   2407            *         For TIM17, the parameter can have the following values:
   2408            *            @arg TIM_TIM17_TI1_GPIO:              TIM17 TI1 is connected to GPIO
   2409            *            @arg TIM_TIM17_TI1_SPDIF_FS:          TIM17 TI1 is connected to SPDIF FS (*)
   2410            *            @arg TIM_TIM17_TI1_HSE_1MHZ:          TIM17 TI1 is connected to HSE 1MHz
   2411            *            @arg TIM_TIM17_TI1_MCO1:              TIM17 TI1 is connected to MCO1
   2412            *
   2413            *         For TIM23, the parameter can have the following values: (*)
   2414            *            @arg TIM_TIM23_TI4_GPIO               TIM23_TI4 is connected to GPIO
   2415            *            @arg TIM_TIM23_TI4_COMP1              TIM23_TI4 is connected to COMP1 output
   2416            *            @arg TIM_TIM23_TI4_COMP2              TIM23_TI4 is connected to COMP2 output
   2417            *            @arg TIM_TIM23_TI4_COMP1_COMP2        TIM23_TI4 is connected to COMP2 output
   2418            *
   2419            *         For TIM24, the parameter can have the following values: (*)
   2420            *            @arg TIM_TIM24_TI1_GPIO               TIM24_TI1 is connected to GPIO
   2421            *            @arg TIM_TIM24_TI1_CAN_TMP            TIM24_TI1 is connected to CAN_TMP
   2422            *            @arg TIM_TIM24_TI1_CAN_RTP            TIM24_TI1 is connected to CAN_RTP
   2423            *            @arg TIM_TIM24_TI1_CAN_SOC            TIM24_TI1 is connected to CAN_SOC
   2424            *
   2425            *         (*)  Value not defined in all devices. \n
   2426            * @retval HAL status
   2427            */

   \                                 In section .text, align 2, keep-with-next
   2428          HAL_StatusTypeDef  HAL_TIMEx_TISelection(TIM_HandleTypeDef *htim, uint32_t TISelection, uint32_t Channel)
   2429          {
   \                     HAL_TIMEx_TISelection: (+1)
   \        0x0   0xB410             PUSH     {R4}
   2430            HAL_StatusTypeDef status = HAL_OK;
   \        0x2   0x2300             MOVS     R3,#+0
   2431          
   2432            /* Check parameters */
   2433            assert_param(IS_TIM_TISEL_INSTANCE(htim->Instance));
   2434            assert_param(IS_TIM_TISEL(TISelection));
   2435          
   2436            __HAL_LOCK(htim);
   \        0x4   0xF890 0x403C      LDRB     R4,[R0, #+60]
   \        0x8   0x2C01             CMP      R4,#+1
   \        0xA   0xD101             BNE.N    ??HAL_TIMEx_TISelection_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE031             B.N      ??HAL_TIMEx_TISelection_1
   \                     ??HAL_TIMEx_TISelection_0: (+1)
   \       0x10   0x2401             MOVS     R4,#+1
   \       0x12   0xF880 0x403C      STRB     R4,[R0, #+60]
   2437          
   2438            switch (Channel)
   \       0x16   0x2A00             CMP      R2,#+0
   \       0x18   0xD006             BEQ.N    ??HAL_TIMEx_TISelection_2
   \       0x1A   0x2A04             CMP      R2,#+4
   \       0x1C   0xD00C             BEQ.N    ??HAL_TIMEx_TISelection_3
   \       0x1E   0x2A08             CMP      R2,#+8
   \       0x20   0xD012             BEQ.N    ??HAL_TIMEx_TISelection_4
   \       0x22   0x2A0C             CMP      R2,#+12
   \       0x24   0xD018             BEQ.N    ??HAL_TIMEx_TISelection_5
   \       0x26   0xE01F             B.N      ??HAL_TIMEx_TISelection_6
   2439            {
   2440              case TIM_CHANNEL_1:
   2441                MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI1SEL, TISelection);
   \                     ??HAL_TIMEx_TISelection_2: (+1)
   \       0x28   0x6802             LDR      R2,[R0, #+0]
   \       0x2A   0x6E92             LDR      R2,[R2, #+104]
   \       0x2C   0x0912             LSRS     R2,R2,#+4
   \       0x2E   0x0112             LSLS     R2,R2,#+4
   \       0x30   0x4311             ORRS     R1,R1,R2
   \       0x32   0x6802             LDR      R2,[R0, #+0]
   \       0x34   0x6691             STR      R1,[R2, #+104]
   2442                break;
   \       0x36   0xE018             B.N      ??HAL_TIMEx_TISelection_7
   2443              case TIM_CHANNEL_2:
   2444                MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI2SEL, TISelection);
   \                     ??HAL_TIMEx_TISelection_3: (+1)
   \       0x38   0x6802             LDR      R2,[R0, #+0]
   \       0x3A   0x6E92             LDR      R2,[R2, #+104]
   \       0x3C   0xF432 0x6270      BICS     R2,R2,#0xF00
   \       0x40   0x4311             ORRS     R1,R1,R2
   \       0x42   0x6802             LDR      R2,[R0, #+0]
   \       0x44   0x6691             STR      R1,[R2, #+104]
   2445                break;
   \       0x46   0xE010             B.N      ??HAL_TIMEx_TISelection_7
   2446              case TIM_CHANNEL_3:
   2447                MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI3SEL, TISelection);
   \                     ??HAL_TIMEx_TISelection_4: (+1)
   \       0x48   0x6802             LDR      R2,[R0, #+0]
   \       0x4A   0x6E92             LDR      R2,[R2, #+104]
   \       0x4C   0xF432 0x2270      BICS     R2,R2,#0xF0000
   \       0x50   0x4311             ORRS     R1,R1,R2
   \       0x52   0x6802             LDR      R2,[R0, #+0]
   \       0x54   0x6691             STR      R1,[R2, #+104]
   2448                break;
   \       0x56   0xE008             B.N      ??HAL_TIMEx_TISelection_7
   2449              case TIM_CHANNEL_4:
   2450                MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI4SEL, TISelection);
   \                     ??HAL_TIMEx_TISelection_5: (+1)
   \       0x58   0x6802             LDR      R2,[R0, #+0]
   \       0x5A   0x6E92             LDR      R2,[R2, #+104]
   \       0x5C   0xF032 0x6270      BICS     R2,R2,#0xF000000
   \       0x60   0x4311             ORRS     R1,R1,R2
   \       0x62   0x6802             LDR      R2,[R0, #+0]
   \       0x64   0x6691             STR      R1,[R2, #+104]
   2451                break;
   \       0x66   0xE000             B.N      ??HAL_TIMEx_TISelection_7
   2452              default:
   2453                status = HAL_ERROR;
   \                     ??HAL_TIMEx_TISelection_6: (+1)
   \       0x68   0x2301             MOVS     R3,#+1
   2454                break;
   2455            }
   2456          
   2457            __HAL_UNLOCK(htim);
   \                     ??HAL_TIMEx_TISelection_7: (+1)
   \       0x6A   0x2100             MOVS     R1,#+0
   \       0x6C   0xF880 0x103C      STRB     R1,[R0, #+60]
   2458          
   2459            return status;
   \       0x70   0x0018             MOVS     R0,R3
   \       0x72   0xB2C0             UXTB     R0,R0
   \                     ??HAL_TIMEx_TISelection_1: (+1)
   \       0x74   0xBC10             POP      {R4}
   \       0x76   0x4770             BX       LR
   2460          }
   2461          
   2462          /**
   2463            * @brief  Group channel 5 and channel 1, 2 or 3
   2464            * @param  htim TIM handle.
   2465            * @param  Channels specifies the reference signal(s) the OC5REF is combined with.
   2466            *         This parameter can be any combination of the following values:
   2467            *         TIM_GROUPCH5_NONE: No effect of OC5REF on OC1REFC, OC2REFC and OC3REFC
   2468            *         TIM_GROUPCH5_OC1REFC: OC1REFC is the logical AND of OC1REFC and OC5REF
   2469            *         TIM_GROUPCH5_OC2REFC: OC2REFC is the logical AND of OC2REFC and OC5REF
   2470            *         TIM_GROUPCH5_OC3REFC: OC3REFC is the logical AND of OC3REFC and OC5REF
   2471            * @retval HAL status
   2472            */

   \                                 In section .text, align 2, keep-with-next
   2473          HAL_StatusTypeDef HAL_TIMEx_GroupChannel5(TIM_HandleTypeDef *htim, uint32_t Channels)
   2474          {
   2475            /* Check parameters */
   2476            assert_param(IS_TIM_COMBINED3PHASEPWM_INSTANCE(htim->Instance));
   2477            assert_param(IS_TIM_GROUPCH5(Channels));
   2478          
   2479            /* Process Locked */
   2480            __HAL_LOCK(htim);
   \                     HAL_TIMEx_GroupChannel5: (+1)
   \        0x0   0xF890 0x203C      LDRB     R2,[R0, #+60]
   \        0x4   0x2A01             CMP      R2,#+1
   \        0x6   0xD101             BNE.N    ??HAL_TIMEx_GroupChannel5_0
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0xE017             B.N      ??HAL_TIMEx_GroupChannel5_1
   \                     ??HAL_TIMEx_GroupChannel5_0: (+1)
   \        0xC   0x2201             MOVS     R2,#+1
   \        0xE   0xF880 0x203C      STRB     R2,[R0, #+60]
   2481          
   2482            htim->State = HAL_TIM_STATE_BUSY;
   \       0x12   0x2202             MOVS     R2,#+2
   \       0x14   0xF880 0x203D      STRB     R2,[R0, #+61]
   2483          
   2484            /* Clear GC5Cx bit fields */
   2485            htim->Instance->CCR5 &= ~(TIM_CCR5_GC5C3 | TIM_CCR5_GC5C2 | TIM_CCR5_GC5C1);
   \       0x18   0x6802             LDR      R2,[R0, #+0]
   \       0x1A   0x6D92             LDR      R2,[R2, #+88]
   \       0x1C   0xF022 0x4260      BIC      R2,R2,#0xE0000000
   \       0x20   0x6803             LDR      R3,[R0, #+0]
   \       0x22   0x659A             STR      R2,[R3, #+88]
   2486          
   2487            /* Set GC5Cx bit fields */
   2488            htim->Instance->CCR5 |= Channels;
   \       0x24   0x6802             LDR      R2,[R0, #+0]
   \       0x26   0x6D92             LDR      R2,[R2, #+88]
   \       0x28   0x4311             ORRS     R1,R1,R2
   \       0x2A   0x6802             LDR      R2,[R0, #+0]
   \       0x2C   0x6591             STR      R1,[R2, #+88]
   2489          
   2490            /* Change the htim state */
   2491            htim->State = HAL_TIM_STATE_READY;
   \       0x2E   0x2101             MOVS     R1,#+1
   \       0x30   0xF880 0x103D      STRB     R1,[R0, #+61]
   2492          
   2493            __HAL_UNLOCK(htim);
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0xF880 0x103C      STRB     R1,[R0, #+60]
   2494          
   2495            return HAL_OK;
   \       0x3A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_GroupChannel5_1: (+1)
   \       0x3C   0x4770             BX       LR
   2496          }
   2497          #if defined(TIM_BDTR_BKBID)
   2498          
   2499          /**
   2500            * @brief  Disarm the designated break input (when it operates in bidirectional mode).
   2501            * @param  htim TIM handle.
   2502            * @param  BreakInput Break input to disarm
   2503            *          This parameter can be one of the following values:
   2504            *            @arg TIM_BREAKINPUT_BRK: Timer break input
   2505            *            @arg TIM_BREAKINPUT_BRK2: Timer break 2 input
   2506            * @note  The break input can be disarmed only when it is configured in
   2507            *        bidirectional mode and when when MOE is reset.
   2508            * @note  Purpose is to be able to have the input voltage back to high-state,
   2509            *        whatever the time constant on the output .
   2510            * @retval HAL status
   2511            */

   \                                 In section .text, align 2, keep-with-next
   2512          HAL_StatusTypeDef HAL_TIMEx_DisarmBreakInput(TIM_HandleTypeDef *htim, uint32_t BreakInput)
   2513          {
   2514            HAL_StatusTypeDef status = HAL_OK;
   \                     HAL_TIMEx_DisarmBreakInput: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   2515            uint32_t tmpbdtr;
   2516          
   2517            /* Check the parameters */
   2518            assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
   2519            assert_param(IS_TIM_BREAKINPUT(BreakInput));
   2520          
   2521            switch (BreakInput)
   \        0x2   0x2901             CMP      R1,#+1
   \        0x4   0xD002             BEQ.N    ??HAL_TIMEx_DisarmBreakInput_0
   \        0x6   0x2902             CMP      R1,#+2
   \        0x8   0xD00E             BEQ.N    ??HAL_TIMEx_DisarmBreakInput_1
   \        0xA   0xE01B             B.N      ??HAL_TIMEx_DisarmBreakInput_2
   2522            {
   2523              case TIM_BREAKINPUT_BRK:
   2524              {
   2525                /* Check initial conditions */
   2526                tmpbdtr = READ_REG(htim->Instance->BDTR);
   \                     ??HAL_TIMEx_DisarmBreakInput_0: (+1)
   \        0xC   0x6801             LDR      R1,[R0, #+0]
   \        0xE   0x6C4B             LDR      R3,[R1, #+68]
   2527                if ((READ_BIT(tmpbdtr, TIM_BDTR_BKBID) == TIM_BDTR_BKBID) &&
   2528                    (READ_BIT(tmpbdtr, TIM_BDTR_MOE) == 0U))
   \       0x10   0x....             LDR.N    R1,??DataTable15_5
   \       0x12   0x400B             ANDS     R3,R1,R3
   \       0x14   0xF1B3 0x5F80      CMP      R3,#+268435456
   \       0x18   0xD105             BNE.N    ??HAL_TIMEx_DisarmBreakInput_3
   2529                {
   2530                  /* Break input BRK is disarmed */
   2531                  SET_BIT(htim->Instance->BDTR, TIM_BDTR_BKDSRM);
   \       0x1A   0x6801             LDR      R1,[R0, #+0]
   \       0x1C   0x6C49             LDR      R1,[R1, #+68]
   \       0x1E   0xF051 0x6180      ORRS     R1,R1,#0x4000000
   \       0x22   0x6800             LDR      R0,[R0, #+0]
   \       0x24   0x6441             STR      R1,[R0, #+68]
   2532                }
   2533                break;
   \                     ??HAL_TIMEx_DisarmBreakInput_3: (+1)
   \       0x26   0xE00E             B.N      ??HAL_TIMEx_DisarmBreakInput_4
   2534              }
   2535          
   2536              case TIM_BREAKINPUT_BRK2:
   2537              {
   2538                /* Check initial conditions */
   2539                tmpbdtr = READ_REG(htim->Instance->BDTR);
   \                     ??HAL_TIMEx_DisarmBreakInput_1: (+1)
   \       0x28   0x6801             LDR      R1,[R0, #+0]
   \       0x2A   0x6C4B             LDR      R3,[R1, #+68]
   2540                if ((READ_BIT(tmpbdtr, TIM_BDTR_BK2BID) == TIM_BDTR_BK2BID) &&
   2541                    (READ_BIT(tmpbdtr, TIM_BDTR_MOE) == 0U))
   \       0x2C   0x....             LDR.N    R1,??DataTable15_6
   \       0x2E   0x400B             ANDS     R3,R1,R3
   \       0x30   0xF1B3 0x5F00      CMP      R3,#+536870912
   \       0x34   0xD105             BNE.N    ??HAL_TIMEx_DisarmBreakInput_5
   2542                {
   2543                  /* Break input BRK is disarmed */
   2544                  SET_BIT(htim->Instance->BDTR, TIM_BDTR_BK2DSRM);
   \       0x36   0x6801             LDR      R1,[R0, #+0]
   \       0x38   0x6C49             LDR      R1,[R1, #+68]
   \       0x3A   0xF051 0x6100      ORRS     R1,R1,#0x8000000
   \       0x3E   0x6800             LDR      R0,[R0, #+0]
   \       0x40   0x6441             STR      R1,[R0, #+68]
   2545                }
   2546                break;
   \                     ??HAL_TIMEx_DisarmBreakInput_5: (+1)
   \       0x42   0xE000             B.N      ??HAL_TIMEx_DisarmBreakInput_4
   2547              }
   2548              default:
   2549                status = HAL_ERROR;
   \                     ??HAL_TIMEx_DisarmBreakInput_2: (+1)
   \       0x44   0x2201             MOVS     R2,#+1
   2550                break;
   2551            }
   2552          
   2553            return status;
   \                     ??HAL_TIMEx_DisarmBreakInput_4: (+1)
   \       0x46   0x0010             MOVS     R0,R2
   \       0x48   0xB2C0             UXTB     R0,R0
   \       0x4A   0x4770             BX       LR
   2554          }
   2555          
   2556          /**
   2557            * @brief  Arm the designated break input (when it operates in bidirectional mode).
   2558            * @param  htim TIM handle.
   2559            * @param  BreakInput Break input to arm
   2560            *          This parameter can be one of the following values:
   2561            *            @arg TIM_BREAKINPUT_BRK: Timer break input
   2562            *            @arg TIM_BREAKINPUT_BRK2: Timer break 2 input
   2563            * @note  Arming is possible at anytime, even if fault is present.
   2564            * @note  Break input is automatically armed as soon as MOE bit is set.
   2565            * @retval HAL status
   2566            */

   \                                 In section .text, align 2, keep-with-next
   2567          HAL_StatusTypeDef HAL_TIMEx_ReArmBreakInput(TIM_HandleTypeDef *htim, uint32_t BreakInput)
   2568          {
   \                     HAL_TIMEx_ReArmBreakInput: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2569            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
   2570            uint32_t tickstart;
   2571          
   2572            /* Check the parameters */
   2573            assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
   2574            assert_param(IS_TIM_BREAKINPUT(BreakInput));
   2575          
   2576            switch (BreakInput)
   \        0x6   0x2901             CMP      R1,#+1
   \        0x8   0xD002             BEQ.N    ??HAL_TIMEx_ReArmBreakInput_0
   \        0xA   0x2902             CMP      R1,#+2
   \        0xC   0xD017             BEQ.N    ??HAL_TIMEx_ReArmBreakInput_1
   \        0xE   0xE02D             B.N      ??HAL_TIMEx_ReArmBreakInput_2
   2577            {
   2578              case TIM_BREAKINPUT_BRK:
   2579              {
   2580                /* Check initial conditions */
   2581                if (READ_BIT(htim->Instance->BDTR, TIM_BDTR_BKBID) == TIM_BDTR_BKBID)
   \                     ??HAL_TIMEx_ReArmBreakInput_0: (+1)
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6C40             LDR      R0,[R0, #+68]
   \       0x14   0x00C0             LSLS     R0,R0,#+3
   \       0x16   0xD511             BPL.N    ??HAL_TIMEx_ReArmBreakInput_3
   2582                {
   2583                  /* Break input BRK is re-armed automatically by hardware. Poll to check whether fault condition disappeared */
   2584                  /* Init tickstart for timeout management */
   2585                  tickstart = HAL_GetTick();
   \       0x18   0x.... 0x....      BL       HAL_GetTick
   \       0x1C   0x0006             MOVS     R6,R0
   2586                  while (READ_BIT(htim->Instance->BDTR, TIM_BDTR_BKDSRM) != 0UL)
   \                     ??HAL_TIMEx_ReArmBreakInput_4: (+1)
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6C40             LDR      R0,[R0, #+68]
   \       0x22   0x0140             LSLS     R0,R0,#+5
   \       0x24   0xD50A             BPL.N    ??HAL_TIMEx_ReArmBreakInput_3
   2587                  {
   2588                    if ((HAL_GetTick() - tickstart) > TIM_BREAKINPUT_REARM_TIMEOUT)
   \       0x26   0x.... 0x....      BL       HAL_GetTick
   \       0x2A   0x1B80             SUBS     R0,R0,R6
   \       0x2C   0x2806             CMP      R0,#+6
   \       0x2E   0xD3F6             BCC.N    ??HAL_TIMEx_ReArmBreakInput_4
   2589                    {
   2590                      /* New check to avoid false timeout detection in case of preemption */
   2591                      if (READ_BIT(htim->Instance->BDTR, TIM_BDTR_BKDSRM) != 0UL)
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6C40             LDR      R0,[R0, #+68]
   \       0x34   0x0140             LSLS     R0,R0,#+5
   \       0x36   0xD5F2             BPL.N    ??HAL_TIMEx_ReArmBreakInput_4
   2592                      {
   2593                        return HAL_TIMEOUT;
   \       0x38   0x2003             MOVS     R0,#+3
   \       0x3A   0xE01A             B.N      ??HAL_TIMEx_ReArmBreakInput_5
   2594                      }
   2595                    }
   2596                  }
   2597                }
   2598                break;
   \                     ??HAL_TIMEx_ReArmBreakInput_3: (+1)
   \       0x3C   0xE017             B.N      ??HAL_TIMEx_ReArmBreakInput_6
   2599              }
   2600          
   2601              case TIM_BREAKINPUT_BRK2:
   2602              {
   2603                /* Check initial conditions */
   2604                if (READ_BIT(htim->Instance->BDTR, TIM_BDTR_BK2BID) == TIM_BDTR_BK2BID)
   \                     ??HAL_TIMEx_ReArmBreakInput_1: (+1)
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6C40             LDR      R0,[R0, #+68]
   \       0x42   0x0080             LSLS     R0,R0,#+2
   \       0x44   0xD511             BPL.N    ??HAL_TIMEx_ReArmBreakInput_7
   2605                {
   2606                  /* Break input BRK2 is re-armed automatically by hardware. Poll to check whether fault condition disappeared */
   2607                  /* Init tickstart for timeout management */
   2608                  tickstart = HAL_GetTick();
   \       0x46   0x.... 0x....      BL       HAL_GetTick
   \       0x4A   0x0006             MOVS     R6,R0
   2609                  while (READ_BIT(htim->Instance->BDTR, TIM_BDTR_BK2DSRM) != 0UL)
   \                     ??HAL_TIMEx_ReArmBreakInput_8: (+1)
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x6C40             LDR      R0,[R0, #+68]
   \       0x50   0x0100             LSLS     R0,R0,#+4
   \       0x52   0xD50A             BPL.N    ??HAL_TIMEx_ReArmBreakInput_7
   2610                  {
   2611                    if ((HAL_GetTick() - tickstart) > TIM_BREAKINPUT_REARM_TIMEOUT)
   \       0x54   0x.... 0x....      BL       HAL_GetTick
   \       0x58   0x1B80             SUBS     R0,R0,R6
   \       0x5A   0x2806             CMP      R0,#+6
   \       0x5C   0xD3F6             BCC.N    ??HAL_TIMEx_ReArmBreakInput_8
   2612                    {
   2613                      /* New check to avoid false timeout detection in case of preemption */
   2614                      if (READ_BIT(htim->Instance->BDTR, TIM_BDTR_BK2DSRM) != 0UL)
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6C40             LDR      R0,[R0, #+68]
   \       0x62   0x0100             LSLS     R0,R0,#+4
   \       0x64   0xD5F2             BPL.N    ??HAL_TIMEx_ReArmBreakInput_8
   2615                      {
   2616                        return HAL_TIMEOUT;
   \       0x66   0x2003             MOVS     R0,#+3
   \       0x68   0xE003             B.N      ??HAL_TIMEx_ReArmBreakInput_5
   2617                      }
   2618                    }
   2619                  }
   2620                }
   2621                break;
   \                     ??HAL_TIMEx_ReArmBreakInput_7: (+1)
   \       0x6A   0xE000             B.N      ??HAL_TIMEx_ReArmBreakInput_6
   2622              }
   2623              default:
   2624                status = HAL_ERROR;
   \                     ??HAL_TIMEx_ReArmBreakInput_2: (+1)
   \       0x6C   0x2501             MOVS     R5,#+1
   2625                break;
   2626            }
   2627          
   2628            return status;
   \                     ??HAL_TIMEx_ReArmBreakInput_6: (+1)
   \       0x6E   0x0028             MOVS     R0,R5
   \       0x70   0xB2C0             UXTB     R0,R0
   \                     ??HAL_TIMEx_ReArmBreakInput_5: (+1)
   \       0x72   0xBD70             POP      {R4-R6,PC}
   2629          }
   2630          #endif /* TIM_BDTR_BKBID */
   2631          
   2632          /**
   2633            * @}
   2634            */
   2635          
   2636          /** @defgroup TIMEx_Exported_Functions_Group6 Extended Callbacks functions
   2637            * @brief    Extended Callbacks functions
   2638            *
   2639          @verbatim
   2640            ==============================================================================
   2641                              ##### Extended Callbacks functions #####
   2642            ==============================================================================
   2643            [..]
   2644              This section provides Extended TIM callback functions:
   2645              (+) Timer Commutation callback
   2646              (+) Timer Break callback
   2647          
   2648          @endverbatim
   2649            * @{
   2650            */
   2651          
   2652          /**
   2653            * @brief  Hall commutation changed callback in non-blocking mode
   2654            * @param  htim TIM handle
   2655            * @retval None
   2656            */

   \                                 In section .text, align 2
   2657          __weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
   2658          {
   2659            /* Prevent unused argument(s) compilation warning */
   2660            UNUSED(htim);
   2661          
   2662            /* NOTE : This function should not be modified, when the callback is needed,
   2663                      the HAL_TIMEx_CommutCallback could be implemented in the user file
   2664             */
   2665          }
   \                     HAL_TIMEx_CommutCallback: (+1)
   \        0x0   0x4770             BX       LR
   2666          /**
   2667            * @brief  Hall commutation changed half complete callback in non-blocking mode
   2668            * @param  htim TIM handle
   2669            * @retval None
   2670            */

   \                                 In section .text, align 2
   2671          __weak void HAL_TIMEx_CommutHalfCpltCallback(TIM_HandleTypeDef *htim)
   2672          {
   2673            /* Prevent unused argument(s) compilation warning */
   2674            UNUSED(htim);
   2675          
   2676            /* NOTE : This function should not be modified, when the callback is needed,
   2677                      the HAL_TIMEx_CommutHalfCpltCallback could be implemented in the user file
   2678             */
   2679          }
   \                     HAL_TIMEx_CommutHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2680          
   2681          /**
   2682            * @brief  Hall Break detection callback in non-blocking mode
   2683            * @param  htim TIM handle
   2684            * @retval None
   2685            */

   \                                 In section .text, align 2
   2686          __weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
   2687          {
   2688            /* Prevent unused argument(s) compilation warning */
   2689            UNUSED(htim);
   2690          
   2691            /* NOTE : This function should not be modified, when the callback is needed,
   2692                      the HAL_TIMEx_BreakCallback could be implemented in the user file
   2693             */
   2694          }
   \                     HAL_TIMEx_BreakCallback: (+1)
   \        0x0   0x4770             BX       LR
   2695          
   2696          /**
   2697            * @brief  Hall Break2 detection callback in non blocking mode
   2698            * @param  htim: TIM handle
   2699            * @retval None
   2700            */

   \                                 In section .text, align 2
   2701          __weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
   2702          {
   2703            /* Prevent unused argument(s) compilation warning */
   2704            UNUSED(htim);
   2705          
   2706            /* NOTE : This function Should not be modified, when the callback is needed,
   2707                      the HAL_TIMEx_Break2Callback could be implemented in the user file
   2708             */
   2709          }
   \                     HAL_TIMEx_Break2Callback: (+1)
   \        0x0   0x4770             BX       LR
   2710          /**
   2711            * @}
   2712            */
   2713          
   2714          /** @defgroup TIMEx_Exported_Functions_Group7 Extended Peripheral State functions
   2715            * @brief    Extended Peripheral State functions
   2716            *
   2717          @verbatim
   2718            ==============================================================================
   2719                          ##### Extended Peripheral State functions #####
   2720            ==============================================================================
   2721            [..]
   2722              This subsection permits to get in run-time the status of the peripheral
   2723              and the data flow.
   2724          
   2725          @endverbatim
   2726            * @{
   2727            */
   2728          
   2729          /**
   2730            * @brief  Return the TIM Hall Sensor interface handle state.
   2731            * @param  htim TIM Hall Sensor handle
   2732            * @retval HAL state
   2733            */

   \                                 In section .text, align 2, keep-with-next
   2734          HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)
   2735          {
   2736            return htim->State;
   \                     HAL_TIMEx_HallSensor_GetState: (+1)
   \        0x0   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \        0x4   0x4770             BX       LR
   2737          }
   2738          
   2739          /**
   2740            * @brief  Return actual state of the TIM complementary channel.
   2741            * @param  htim TIM handle
   2742            * @param  ChannelN TIM Complementary channel
   2743            *          This parameter can be one of the following values:
   2744            *            @arg TIM_CHANNEL_1: TIM Channel 1
   2745            *            @arg TIM_CHANNEL_2: TIM Channel 2
   2746            *            @arg TIM_CHANNEL_3: TIM Channel 3
   2747            * @retval TIM Complementary channel state
   2748            */

   \                                 In section .text, align 2, keep-with-next
   2749          HAL_TIM_ChannelStateTypeDef HAL_TIMEx_GetChannelNState(TIM_HandleTypeDef *htim,  uint32_t ChannelN)
   2750          {
   2751            HAL_TIM_ChannelStateTypeDef channel_state;
   2752          
   2753            /* Check the parameters */
   2754            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, ChannelN));
   2755          
   2756            channel_state = TIM_CHANNEL_N_STATE_GET(htim, ChannelN);
   \                     HAL_TIMEx_GetChannelNState: (+1)
   \        0x0   0x2900             CMP      R1,#+0
   \        0x2   0xD102             BNE.N    ??HAL_TIMEx_GetChannelNState_0
   \        0x4   0xF890 0x0044      LDRB     R0,[R0, #+68]
   \        0x8   0xE00B             B.N      ??HAL_TIMEx_GetChannelNState_1
   \                     ??HAL_TIMEx_GetChannelNState_0: (+1)
   \        0xA   0x2904             CMP      R1,#+4
   \        0xC   0xD102             BNE.N    ??HAL_TIMEx_GetChannelNState_2
   \        0xE   0xF890 0x0045      LDRB     R0,[R0, #+69]
   \       0x12   0xE006             B.N      ??HAL_TIMEx_GetChannelNState_3
   \                     ??HAL_TIMEx_GetChannelNState_2: (+1)
   \       0x14   0x2908             CMP      R1,#+8
   \       0x16   0xD102             BNE.N    ??HAL_TIMEx_GetChannelNState_4
   \       0x18   0xF890 0x0046      LDRB     R0,[R0, #+70]
   \       0x1C   0xE001             B.N      ??HAL_TIMEx_GetChannelNState_3
   \                     ??HAL_TIMEx_GetChannelNState_4: (+1)
   \       0x1E   0xF890 0x0047      LDRB     R0,[R0, #+71]
   2757          
   2758            return channel_state;
   \                     ??HAL_TIMEx_GetChannelNState_3: (+1)
   \                     ??HAL_TIMEx_GetChannelNState_1: (+1)
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x4770             BX       LR
   2759          }
   2760          /**
   2761            * @}
   2762            */
   2763          
   2764          /**
   2765            * @}
   2766            */
   2767          
   2768          /* Private functions ---------------------------------------------------------*/
   2769          /** @defgroup TIMEx_Private_Functions TIM Extended Private Functions
   2770            * @{
   2771            */
   2772          
   2773          /**
   2774            * @brief  TIM DMA Commutation callback.
   2775            * @param  hdma pointer to DMA handle.
   2776            * @retval None
   2777            */

   \                                 In section .text, align 4, keep-with-next
   2778          void TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
   2779          {
   \                     TIMEx_DMACommutationCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2780            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x6B80             LDR      R0,[R0, #+56]
   2781          
   2782            /* Change the htim state */
   2783            htim->State = HAL_TIM_STATE_READY;
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0xF880 0x103D      STRB     R1,[R0, #+61]
   2784          
   2785          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2786            htim->CommutationCallback(htim);
   2787          #else
   2788            HAL_TIMEx_CommutCallback(htim);
   \        0xA   0x.... 0x....      BL       HAL_TIMEx_CommutCallback
   2789          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2790          }
   \        0xE   0xBD01             POP      {R0,PC}
   2791          
   2792          /**
   2793            * @brief  TIM DMA Commutation half complete callback.
   2794            * @param  hdma pointer to DMA handle.
   2795            * @retval None
   2796            */

   \                                 In section .text, align 4, keep-with-next
   2797          void TIMEx_DMACommutationHalfCplt(DMA_HandleTypeDef *hdma)
   2798          {
   \                     TIMEx_DMACommutationHalfCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2799            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x6B80             LDR      R0,[R0, #+56]
   2800          
   2801            /* Change the htim state */
   2802            htim->State = HAL_TIM_STATE_READY;
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0xF880 0x103D      STRB     R1,[R0, #+61]
   2803          
   2804          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2805            htim->CommutationHalfCpltCallback(htim);
   2806          #else
   2807            HAL_TIMEx_CommutHalfCpltCallback(htim);
   \        0xA   0x.... 0x....      BL       HAL_TIMEx_CommutHalfCpltCallback
   2808          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2809          }
   \        0xE   0xBD01             POP      {R0,PC}
   2810          
   2811          
   2812          /**
   2813            * @brief  TIM DMA Delay Pulse complete callback (complementary channel).
   2814            * @param  hdma pointer to DMA handle.
   2815            * @retval None
   2816            */

   \                                 In section .text, align 4, keep-with-next
   2817          static void TIM_DMADelayPulseNCplt(DMA_HandleTypeDef *hdma)
   2818          {
   \                     TIM_DMADelayPulseNCplt: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   2819            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x6B84             LDR      R4,[R0, #+56]
   2820          
   2821            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \        0x4   0x6A61             LDR      R1,[R4, #+36]
   \        0x6   0x4288             CMP      R0,R1
   \        0x8   0xD109             BNE.N    ??TIM_DMADelayPulseNCplt_0
   2822            {
   2823              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x7721             STRB     R1,[R4, #+28]
   2824          
   2825              if (hdma->Init.Mode == DMA_NORMAL)
   \        0xE   0x69C0             LDR      R0,[R0, #+28]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD12A             BNE.N    ??TIM_DMADelayPulseNCplt_1
   2826              {
   2827                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xF884 0x0044      STRB     R0,[R4, #+68]
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0xE025             B.N      ??TIM_DMADelayPulseNCplt_1
   2828              }
   2829            }
   2830            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMADelayPulseNCplt_0: (+1)
   \       0x1E   0x6AA1             LDR      R1,[R4, #+40]
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD109             BNE.N    ??TIM_DMADelayPulseNCplt_2
   2831            {
   2832              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x24   0x2102             MOVS     R1,#+2
   \       0x26   0x7721             STRB     R1,[R4, #+28]
   2833          
   2834              if (hdma->Init.Mode == DMA_NORMAL)
   \       0x28   0x69C0             LDR      R0,[R0, #+28]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD11D             BNE.N    ??TIM_DMADelayPulseNCplt_1
   2835              {
   2836                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xF884 0x0045      STRB     R0,[R4, #+69]
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0xE018             B.N      ??TIM_DMADelayPulseNCplt_1
   2837              }
   2838            }
   2839            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMADelayPulseNCplt_2: (+1)
   \       0x38   0x6AE1             LDR      R1,[R4, #+44]
   \       0x3A   0x4288             CMP      R0,R1
   \       0x3C   0xD109             BNE.N    ??TIM_DMADelayPulseNCplt_3
   2840            {
   2841              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x3E   0x2104             MOVS     R1,#+4
   \       0x40   0x7721             STRB     R1,[R4, #+28]
   2842          
   2843              if (hdma->Init.Mode == DMA_NORMAL)
   \       0x42   0x69C0             LDR      R0,[R0, #+28]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD110             BNE.N    ??TIM_DMADelayPulseNCplt_1
   2844              {
   2845                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0xF884 0x0046      STRB     R0,[R4, #+70]
   \       0x4E   0xB2C0             UXTB     R0,R0
   \       0x50   0xE00B             B.N      ??TIM_DMADelayPulseNCplt_1
   2846              }
   2847            }
   2848            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMADelayPulseNCplt_3: (+1)
   \       0x52   0x6B21             LDR      R1,[R4, #+48]
   \       0x54   0x4288             CMP      R0,R1
   \       0x56   0xD108             BNE.N    ??TIM_DMADelayPulseNCplt_1
   2849            {
   2850              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x58   0x2108             MOVS     R1,#+8
   \       0x5A   0x7721             STRB     R1,[R4, #+28]
   2851          
   2852              if (hdma->Init.Mode == DMA_NORMAL)
   \       0x5C   0x69C0             LDR      R0,[R0, #+28]
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD103             BNE.N    ??TIM_DMADelayPulseNCplt_1
   2853              {
   2854                TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_4, HAL_TIM_CHANNEL_STATE_READY);
   \       0x62   0x2001             MOVS     R0,#+1
   \       0x64   0xF884 0x0047      STRB     R0,[R4, #+71]
   \       0x68   0xB2C0             UXTB     R0,R0
   2855              }
   2856            }
   2857            else
   2858            {
   2859              /* nothing to do */
   2860            }
   2861          
   2862          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2863            htim->PWM_PulseFinishedCallback(htim);
   2864          #else
   2865            HAL_TIM_PWM_PulseFinishedCallback(htim);
   \                     ??TIM_DMADelayPulseNCplt_1: (+1)
   \       0x6A   0x0020             MOVS     R0,R4
   \       0x6C   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2866          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2867          
   2868            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x7720             STRB     R0,[R4, #+28]
   2869          }
   \       0x74   0xBD10             POP      {R4,PC}
   2870          
   2871          /**
   2872            * @brief  TIM DMA error callback (complementary channel)
   2873            * @param  hdma pointer to DMA handle.
   2874            * @retval None
   2875            */

   \                                 In section .text, align 4, keep-with-next
   2876          static void TIM_DMAErrorCCxN(DMA_HandleTypeDef *hdma)
   2877          {
   \                     TIM_DMAErrorCCxN: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   2878            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x2   0x6B84             LDR      R4,[R0, #+56]
   2879          
   2880            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \        0x4   0x6A61             LDR      R1,[R4, #+36]
   \        0x6   0x4288             CMP      R0,R1
   \        0x8   0xD106             BNE.N    ??TIM_DMAErrorCCxN_0
   2881            {
   2882              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x7720             STRB     R0,[R4, #+28]
   2883              TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_1, HAL_TIM_CHANNEL_STATE_READY);
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF884 0x0044      STRB     R0,[R4, #+68]
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0xE012             B.N      ??TIM_DMAErrorCCxN_1
   2884            }
   2885            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMAErrorCCxN_0: (+1)
   \       0x18   0x6AA1             LDR      R1,[R4, #+40]
   \       0x1A   0x4288             CMP      R0,R1
   \       0x1C   0xD106             BNE.N    ??TIM_DMAErrorCCxN_2
   2886            {
   2887              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x7720             STRB     R0,[R4, #+28]
   2888              TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_2, HAL_TIM_CHANNEL_STATE_READY);
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xF884 0x0045      STRB     R0,[R4, #+69]
   \       0x28   0xB2C0             UXTB     R0,R0
   \       0x2A   0xE008             B.N      ??TIM_DMAErrorCCxN_1
   2889            }
   2890            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMAErrorCCxN_2: (+1)
   \       0x2C   0x6AE1             LDR      R1,[R4, #+44]
   \       0x2E   0x4288             CMP      R0,R1
   \       0x30   0xD105             BNE.N    ??TIM_DMAErrorCCxN_1
   2891            {
   2892              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x32   0x2004             MOVS     R0,#+4
   \       0x34   0x7720             STRB     R0,[R4, #+28]
   2893              TIM_CHANNEL_N_STATE_SET(htim, TIM_CHANNEL_3, HAL_TIM_CHANNEL_STATE_READY);
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0xF884 0x0046      STRB     R0,[R4, #+70]
   \       0x3C   0xB2C0             UXTB     R0,R0
   2894            }
   2895            else
   2896            {
   2897              /* nothing to do */
   2898            }
   2899          
   2900          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2901            htim->ErrorCallback(htim);
   2902          #else
   2903            HAL_TIM_ErrorCallback(htim);
   \                     ??TIM_DMAErrorCCxN_1: (+1)
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x.... 0x....      BL       HAL_TIM_ErrorCallback
   2904          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2905          
   2906            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x7720             STRB     R0,[R4, #+28]
   2907          }
   \       0x48   0xBD10             POP      {R4,PC}
   2908          
   2909          /**
   2910            * @brief  Enables or disables the TIM Capture Compare Channel xN.
   2911            * @param  TIMx to select the TIM peripheral
   2912            * @param  Channel specifies the TIM Channel
   2913            *          This parameter can be one of the following values:
   2914            *            @arg TIM_CHANNEL_1: TIM Channel 1
   2915            *            @arg TIM_CHANNEL_2: TIM Channel 2
   2916            *            @arg TIM_CHANNEL_3: TIM Channel 3
   2917            * @param  ChannelNState specifies the TIM Channel CCxNE bit new state.
   2918            *          This parameter can be: TIM_CCxN_ENABLE or TIM_CCxN_Disable.
   2919            * @retval None
   2920            */

   \                                 In section .text, align 2, keep-with-next
   2921          static void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState)
   2922          {
   \                     TIM_CCxNChannelCmd: (+1)
   \        0x0   0xB410             PUSH     {R4}
   2923            uint32_t tmp;
   2924          
   2925            tmp = TIM_CCER_CC1NE << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
   \        0x2   0x2404             MOVS     R4,#+4
   \        0x4   0xF011 0x031F      ANDS     R3,R1,#0x1F
   \        0x8   0xFA14 0xF303      LSLS     R3,R4,R3
   2926          
   2927            /* Reset the CCxNE Bit */
   2928            TIMx->CCER &=  ~tmp;
   \        0xC   0x6A04             LDR      R4,[R0, #+32]
   \        0xE   0xEA34 0x0303      BICS     R3,R4,R3
   \       0x12   0x6203             STR      R3,[R0, #+32]
   2929          
   2930            /* Set or reset the CCxNE Bit */
   2931            TIMx->CCER |= (uint32_t)(ChannelNState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
   \       0x14   0x6A03             LDR      R3,[R0, #+32]
   \       0x16   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \       0x1A   0xFA12 0xF101      LSLS     R1,R2,R1
   \       0x1E   0x4319             ORRS     R1,R1,R3
   \       0x20   0x6201             STR      R1,[R0, #+32]
   2932          }
   \       0x22   0xBC10             POP      {R4}
   \       0x24   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0xFFCF'FF8F        DC32     0xffcfff8f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0xFFFE'FFF8        DC32     0xfffefff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x4001'0000        DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x4000'0400        DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \        0x0   0x4000'0800        DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \        0x0   0x4000'0C00        DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \        0x0   0x4001'0400        DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \        0x0   0x4000'1800        DC32     0x40001800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \        0x0   0x4001'4000        DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x0001'0007        DC32     0x10007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x....'....        DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     TIM_DMACaptureHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseNCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x0001'0007        DC32     0x10007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x....'....        DC32     TIM_DMAErrorCCxN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x4001'0000        DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0x4000'0400        DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x4000'0800        DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \        0x0   0x4000'0C00        DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \        0x0   0x4001'0400        DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x4000'1800        DC32     0x40001800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x4001'4000        DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x0020'0010        DC32     0x200010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0xFFCF'FF8F        DC32     0xffcfff8f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \        0x0   0x4001'0000        DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \        0x0   0x4001'0400        DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \        0x0   0x1000'8000        DC32     0x10008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \        0x0   0x2000'8000        DC32     0x20008000
   2933          /**
   2934            * @}
   2935            */
   2936          
   2937          #endif /* HAL_TIM_MODULE_ENABLED */
   2938          /**
   2939            * @}
   2940            */
   2941          
   2942          /**
   2943            * @}
   2944            */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_TIMEx_Break2Callback
       0   HAL_TIMEx_BreakCallback
       0   HAL_TIMEx_CommutCallback
       0   HAL_TIMEx_CommutHalfCpltCallback
       8   HAL_TIMEx_ConfigBreakDeadTime
      16   HAL_TIMEx_ConfigBreakInput
       4   HAL_TIMEx_ConfigCommutEvent
       4   HAL_TIMEx_ConfigCommutEvent_DMA
       4   HAL_TIMEx_ConfigCommutEvent_IT
       0   HAL_TIMEx_DisarmBreakInput
       0   HAL_TIMEx_GetChannelNState
       0   HAL_TIMEx_GroupChannel5
       8   HAL_TIMEx_HallSensor_DeInit
         8   -> HAL_TIMEx_HallSensor_MspDeInit
       0   HAL_TIMEx_HallSensor_GetState
      40   HAL_TIMEx_HallSensor_Init
        40   -> HAL_TIMEx_HallSensor_MspInit
        40   -> TIM_Base_SetConfig
        40   -> TIM_OC2_SetConfig
        40   -> TIM_TI1_SetConfig
       0   HAL_TIMEx_HallSensor_MspDeInit
       0   HAL_TIMEx_HallSensor_MspInit
       8   HAL_TIMEx_HallSensor_Start
         8   -> TIM_CCxChannelCmd
      16   HAL_TIMEx_HallSensor_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Stop_DMA
         8   -> HAL_DMA_Abort_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Stop_IT
         8   -> TIM_CCxChannelCmd
      12   HAL_TIMEx_MasterConfigSynchronization
       8   HAL_TIMEx_OCN_Start
         8   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OCN_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OCN_Start_IT
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OCN_Stop
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OCN_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OCN_Stop_IT
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OnePulseN_Start
        16   -> TIM_CCxChannelCmd
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OnePulseN_Start_IT
        16   -> TIM_CCxChannelCmd
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OnePulseN_Stop
        16   -> TIM_CCxChannelCmd
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OnePulseN_Stop_IT
        16   -> TIM_CCxChannelCmd
        16   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_PWMN_Start
         8   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_PWMN_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_PWMN_Start_IT
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_PWMN_Stop
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_PWMN_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_PWMN_Stop_IT
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_ReArmBreakInput
        16   -> HAL_GetTick
       0   HAL_TIMEx_RemapConfig
       4   HAL_TIMEx_TISelection
       8   TIMEx_DMACommutationCplt
         8   -> HAL_TIMEx_CommutCallback
       8   TIMEx_DMACommutationHalfCplt
         8   -> HAL_TIMEx_CommutHalfCpltCallback
       4   TIM_CCxNChannelCmd
       8   TIM_DMADelayPulseNCplt
         8   -> HAL_TIM_PWM_PulseFinishedCallback
       8   TIM_DMAErrorCCxN
         8   -> HAL_TIM_ErrorCallback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable11
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable8
       4  ??DataTable8_1
       2  HAL_TIMEx_Break2Callback
       2  HAL_TIMEx_BreakCallback
       2  HAL_TIMEx_CommutCallback
       2  HAL_TIMEx_CommutHalfCpltCallback
     190  HAL_TIMEx_ConfigBreakDeadTime
     212  HAL_TIMEx_ConfigBreakInput
     144  HAL_TIMEx_ConfigCommutEvent
     168  HAL_TIMEx_ConfigCommutEvent_DMA
     144  HAL_TIMEx_ConfigCommutEvent_IT
      76  HAL_TIMEx_DisarmBreakInput
      38  HAL_TIMEx_GetChannelNState
      62  HAL_TIMEx_GroupChannel5
     106  HAL_TIMEx_HallSensor_DeInit
       6  HAL_TIMEx_HallSensor_GetState
     260  HAL_TIMEx_HallSensor_Init
       2  HAL_TIMEx_HallSensor_MspDeInit
       2  HAL_TIMEx_HallSensor_MspInit
     218  HAL_TIMEx_HallSensor_Start
     284  HAL_TIMEx_HallSensor_Start_DMA
     230  HAL_TIMEx_HallSensor_Start_IT
      86  HAL_TIMEx_HallSensor_Stop
      88  HAL_TIMEx_HallSensor_Stop_DMA
      98  HAL_TIMEx_HallSensor_Stop_IT
     162  HAL_TIMEx_MasterConfigSynchronization
     244  HAL_TIMEx_OCN_Start
     504  HAL_TIMEx_OCN_Start_DMA
     328  HAL_TIMEx_OCN_Start_IT
     138  HAL_TIMEx_OCN_Stop
     228  HAL_TIMEx_OCN_Stop_DMA
     226  HAL_TIMEx_OCN_Stop_IT
     124  HAL_TIMEx_OnePulseN_Start
     148  HAL_TIMEx_OnePulseN_Start_IT
     136  HAL_TIMEx_OnePulseN_Stop
     160  HAL_TIMEx_OnePulseN_Stop_IT
     244  HAL_TIMEx_PWMN_Start
     520  HAL_TIMEx_PWMN_Start_DMA
     328  HAL_TIMEx_PWMN_Start_IT
     138  HAL_TIMEx_PWMN_Stop
     228  HAL_TIMEx_PWMN_Stop_DMA
     226  HAL_TIMEx_PWMN_Stop_IT
     116  HAL_TIMEx_ReArmBreakInput
      42  HAL_TIMEx_RemapConfig
     120  HAL_TIMEx_TISelection
      16  TIMEx_DMACommutationCplt
      16  TIMEx_DMACommutationHalfCplt
      38  TIM_CCxNChannelCmd
     118  TIM_DMADelayPulseNCplt
      74  TIM_DMAErrorCCxN

 
 7'168 bytes in section .text
 
 7'156 bytes of CODE memory (+ 12 bytes shared)

Errors: none
Warnings: none
