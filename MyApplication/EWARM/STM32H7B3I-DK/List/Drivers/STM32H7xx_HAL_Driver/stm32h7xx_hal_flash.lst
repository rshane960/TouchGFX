###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         09/Feb/2022  10:51:14
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_flash.c
#        [UTF-8]
#    Command line      =
#        -f
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_flash.o.rsp
#        (D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_flash.c
#        -D USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver
#        -lA
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver
#        -o
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Core/Inc\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/App\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_flash.o.d
#    Locale            =  C
#    List file         =
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_flash.lst
#    Object file       =
#        D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_flash.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\001_Project\B_TouchGFX_Stm32\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32h7xx_hal_flash.c
      4            * @author  MCD Application Team
      5            * @brief   FLASH HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the internal FLASH memory:
      8            *           + Program operations functions
      9            *           + Memory Control functions
     10            *           + Peripheral Errors functions
     11            *
     12           @verbatim
     13            ==============================================================================
     14                                  ##### FLASH peripheral features #####
     15            ==============================================================================
     16          
     17            [..] The Flash memory interface manages CPU AXI I-Code and D-Code accesses
     18                 to the Flash memory. It implements the erase and program Flash memory operations
     19                 and the read and write protection mechanisms.
     20          
     21            [..] The FLASH main features are:
     22                (+) Flash memory read operations
     23                (+) Flash memory program/erase operations
     24                (+) Read / write protections
     25                (+) Option bytes programming
     26                (+) Error code correction (ECC) : Data in flash are 266-bits word
     27                    (10 bits added per flash word)
     28          
     29                                  ##### How to use this driver #####
     30           ==============================================================================
     31              [..]
     32                This driver provides functions and macros to configure and program the FLASH
     33                memory of all STM32H7xx devices.
     34          
     35                (#) FLASH Memory IO Programming functions:
     36                     (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and
     37                          HAL_FLASH_Lock() functions
     38                     (++) Program functions: 256-bit word only
     39                     (++) There Two modes of programming :
     40                      (+++) Polling mode using HAL_FLASH_Program() function
     41                      (+++) Interrupt mode using HAL_FLASH_Program_IT() function
     42          
     43                (#) Interrupts and flags management functions :
     44                     (++) Handle FLASH interrupts by calling HAL_FLASH_IRQHandler()
     45                     (++) Callback functions are called when the flash operations are finished :
     46                          HAL_FLASH_EndOfOperationCallback() when everything is ok, otherwise
     47                          HAL_FLASH_OperationErrorCallback()
     48                     (++) Get error flag status by calling HAL_FLASH_GetError()
     49          
     50                (#) Option bytes management functions :
     51                     (++) Lock and Unlock the option bytes using HAL_FLASH_OB_Unlock() and
     52                          HAL_FLASH_OB_Lock() functions
     53                     (++) Launch the reload of the option bytes using HAL_FLASH_OB_Launch() function.
     54                          In this case, a reset is generated
     55              [..]
     56                In addition to these functions, this driver includes a set of macros allowing
     57                to handle the following operations:
     58                 (+) Set the latency
     59                 (+) Enable/Disable the FLASH interrupts
     60                 (+) Monitor the FLASH flags status
     61               [..]
     62              (@) For any Flash memory program operation (erase or program), the CPU clock frequency
     63                  (HCLK) must be at least 1MHz.
     64              (@) The contents of the Flash memory are not guaranteed if a device reset occurs during
     65                  a Flash memory operation.
     66              (@) The application can simultaneously request a read and a write operation through each AXI
     67                  interface.
     68                  As the Flash memory is divided into two independent banks, the embedded Flash
     69                  memory interface can drive different operations at the same time on each bank. For
     70                  example a read, write or erase operation can be executed on bank 1 while another read,
     71                  write or erase operation is executed on bank 2.
     72          
     73           @endverbatim
     74            ******************************************************************************
     75            * @attention
     76            *
     77            * Copyright (c) 2017 STMicroelectronics.
     78            * All rights reserved.
     79            *
     80            * This software is licensed under terms that can be found in the LICENSE file in
     81            * the root directory of this software component.
     82            * If no LICENSE file comes with this software, it is provided AS-IS.
     83            ******************************************************************************
     84            */
     85          
     86          /* Includes ------------------------------------------------------------------*/
     87          #include "stm32h7xx_hal.h"
     88          
     89          /** @addtogroup STM32H7xx_HAL_Driver
     90            * @{
     91            */
     92          
     93          /** @defgroup FLASH FLASH
     94            * @brief FLASH HAL module driver
     95            * @{
     96            */
     97          
     98          #ifdef HAL_FLASH_MODULE_ENABLED
     99          
    100          /* Private typedef -----------------------------------------------------------*/
    101          /* Private define ------------------------------------------------------------*/
    102          /** @addtogroup FLASH_Private_Constants
    103            * @{
    104            */
    105          #define FLASH_TIMEOUT_VALUE              50000U /* 50 s */
    106          /**
    107            * @}
    108            */
    109          /* Private macro -------------------------------------------------------------*/
    110          /* Private variables ---------------------------------------------------------*/

   \                                 In section .bss, align 4
    111          FLASH_ProcessTypeDef pFlash;
   \                     pFlash:
   \        0x0                      DS8 28
    112          /* Private function prototypes -----------------------------------------------*/
    113          /* Exported functions ---------------------------------------------------------*/
    114          
    115          /** @defgroup FLASH_Exported_Functions FLASH Exported functions
    116            * @{
    117            */
    118          
    119          /** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions
    120           *  @brief   Programming operation functions
    121           *
    122          @verbatim
    123           ===============================================================================
    124                            ##### Programming operation functions #####
    125           ===============================================================================
    126              [..]
    127              This subsection provides a set of functions allowing to manage the FLASH
    128              program operations.
    129          
    130          @endverbatim
    131            * @{
    132            */
    133          
    134          /**
    135            * @brief  Program a flash word at a specified address
    136            * @param  TypeProgram Indicate the way to program at a specified address.
    137            *         This parameter can be a value of @ref FLASH_Type_Program
    138            * @param  FlashAddress specifies the address to be programmed.
    139            *         This parameter shall be aligned to the Flash word:
    140            *          - 256 bits for STM32H74x/5X devices (8x 32bits words)
    141            *          - 128 bits for STM32H7Ax/BX devices (4x 32bits words)
    142            *          - 256 bits for STM32H72x/3X devices (8x 32bits words)
    143            * @param  DataAddress specifies the address of data to be programmed.
    144            *         This parameter shall be 32-bit aligned
    145            *
    146            * @retval HAL_StatusTypeDef HAL Status
    147            */

   \                                 In section .text, align 2, keep-with-next
    148          HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t FlashAddress, uint32_t DataAddress)
    149          {
   \                     HAL_FLASH_Program: (+1)
   \        0x0   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \        0x4   0x4683             MOV      R11,R0
   \        0x6   0x000C             MOVS     R4,R1
    150            HAL_StatusTypeDef status;
    151            __IO uint32_t *dest_addr = (__IO uint32_t *)FlashAddress;
   \        0x8   0x0025             MOVS     R5,R4
    152            __IO uint32_t *src_addr = (__IO uint32_t*)DataAddress;
   \        0xA   0x9E00             LDR      R6,[SP, #+0]
    153            uint32_t bank;
    154            uint8_t row_index = FLASH_NB_32BITWORD_IN_FLASHWORD;
   \        0xC   0x2704             MOVS     R7,#+4
    155          
    156            /* Check the parameters */
    157            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    158            assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));
    159          
    160            /* Process Locked */
    161            __HAL_LOCK(&pFlash);
   \        0xE   0x.... 0x....      LDR.W    R8,??DataTable11
   \       0x12   0xF898 0x0014      LDRB     R0,[R8, #+20]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD101             BNE.N    ??HAL_FLASH_Program_0
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0xE07A             B.N      ??HAL_FLASH_Program_1
   \                     ??HAL_FLASH_Program_0: (+1)
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xF888 0x0014      STRB     R0,[R8, #+20]
    162          
    163          #if defined (FLASH_OPTCR_PG_OTP)
    164            if((IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress)) || (IS_FLASH_PROGRAM_ADDRESS_OTP(FlashAddress)))
   \       0x24   0xF1B4 0x6000      SUBS     R0,R4,#+134217728
   \       0x28   0xF5B0 0x1F80      CMP      R0,#+1048576
   \       0x2C   0xD305             BCC.N    ??HAL_FLASH_Program_2
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \       0x32   0x1A20             SUBS     R0,R4,R0
   \       0x34   0xF5B0 0x6F80      CMP      R0,#+1024
   \       0x38   0xD21B             BCS.N    ??HAL_FLASH_Program_3
    165          #else
    166            if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
    167          #endif /* FLASH_OPTCR_PG_OTP */
    168            {
    169              bank = FLASH_BANK_1;
   \                     ??HAL_FLASH_Program_2: (+1)
   \       0x3A   0xF05F 0x0901      MOVS     R9,#+1
    170            }
    171          #if defined (DUAL_BANK)
    172            else if(IS_FLASH_PROGRAM_ADDRESS_BANK2(FlashAddress))
    173            {
    174              bank = FLASH_BANK_2;
    175            }
    176          #endif /* DUAL_BANK */
    177            else
    178            {
    179              return HAL_ERROR;
    180            }
    181          
    182            /* Reset error code */
    183            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \                     ??HAL_FLASH_Program_4: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xF8C8 0x0018      STR      R0,[R8, #+24]
    184          
    185            /* Wait for last operation to be completed */
    186            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
   \       0x44   0xF24C 0x3A50      MOVW     R10,#+50000
   \       0x48   0x4649             MOV      R1,R9
   \       0x4A   0x4650             MOV      R0,R10
   \       0x4C   0x.... 0x....      BL       FLASH_WaitForLastOperation
    187          
    188            if(status == HAL_OK)
   \       0x50   0x0001             MOVS     R1,R0
   \       0x52   0xB2C9             UXTB     R1,R1
   \       0x54   0x2900             CMP      R1,#+0
   \       0x56   0xD159             BNE.N    ??HAL_FLASH_Program_5
    189            {
    190          #if defined (DUAL_BANK)
    191              if(bank == FLASH_BANK_1)
   \       0x58   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x5C   0xD11A             BNE.N    ??HAL_FLASH_Program_6
    192              {
    193          #if defined (FLASH_OPTCR_PG_OTP)
    194                if (TypeProgram == FLASH_TYPEPROGRAM_OTPWORD)
   \       0x5E   0xF1BB 0x0F02      CMP      R11,#+2
   \       0x62   0xD110             BNE.N    ??HAL_FLASH_Program_7
    195                {
    196                  /* Set OTP_PG bit */
    197                  SET_BIT(FLASH->OPTCR, FLASH_OPTCR_PG_OTP);
   \       0x64   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \       0x68   0x6801             LDR      R1,[R0, #+0]
   \       0x6A   0xF051 0x0120      ORRS     R1,R1,#0x20
   \       0x6E   0x6001             STR      R1,[R0, #+0]
   \       0x70   0xE016             B.N      ??HAL_FLASH_Program_8
    198                }
   \                     ??HAL_FLASH_Program_3: (+1)
   \       0x72   0xF1B4 0x6001      SUBS     R0,R4,#+135266304
   \       0x76   0xF5B0 0x1F80      CMP      R0,#+1048576
   \       0x7A   0xD202             BCS.N    ??HAL_FLASH_Program_9
   \       0x7C   0xF05F 0x0902      MOVS     R9,#+2
   \       0x80   0xE7DD             B.N      ??HAL_FLASH_Program_4
   \                     ??HAL_FLASH_Program_9: (+1)
   \       0x82   0x2001             MOVS     R0,#+1
   \       0x84   0xE046             B.N      ??HAL_FLASH_Program_1
    199                else
    200          #endif /* FLASH_OPTCR_PG_OTP */
    201                {
    202                  /* Set PG bit */
    203                  SET_BIT(FLASH->CR1, FLASH_CR_PG);
   \                     ??HAL_FLASH_Program_7: (+1)
   \       0x86   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x8A   0x6801             LDR      R1,[R0, #+0]
   \       0x8C   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x90   0x6001             STR      R1,[R0, #+0]
   \       0x92   0xE005             B.N      ??HAL_FLASH_Program_8
    204                }
    205              }
    206              else
    207              {
    208                /* Set PG bit */
    209                SET_BIT(FLASH->CR2, FLASH_CR_PG);
   \                     ??HAL_FLASH_Program_6: (+1)
   \       0x94   0x.... 0x....      LDR.W    R0,??DataTable11_4
   \       0x98   0x6801             LDR      R1,[R0, #+0]
   \       0x9A   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x9E   0x6001             STR      R1,[R0, #+0]
    210              }
    211          #else /* Single Bank */
    212          #if defined (FLASH_OPTCR_PG_OTP)
    213                if (TypeProgram == FLASH_TYPEPROGRAM_OTPWORD)
    214                {
    215                  /* Set OTP_PG bit */
    216                  SET_BIT(FLASH->OPTCR, FLASH_OPTCR_PG_OTP);
    217                }
    218                else
    219          #endif /* FLASH_OPTCR_PG_OTP */
    220                {
    221                  /* Set PG bit */
    222                  SET_BIT(FLASH->CR1, FLASH_CR_PG);
    223                }
    224          #endif /* DUAL_BANK */
    225          
    226              __ISB();
   \                     ??HAL_FLASH_Program_8: (+1)
   \       0xA0   0xF3BF 0x8F6F      ISB      SY
    227              __DSB();
   \       0xA4   0xF3BF 0x8F4F      DSB      SY
    228          
    229          #if defined (FLASH_OPTCR_PG_OTP)
    230              if (TypeProgram == FLASH_TYPEPROGRAM_OTPWORD)
   \       0xA8   0xF1BB 0x0F02      CMP      R11,#+2
   \       0xAC   0xD103             BNE.N    ??HAL_FLASH_Program_10
    231              {
    232                /* Program an OTP word (16 bits) */
    233                *(__IO uint16_t *)FlashAddress = *(__IO uint16_t*)DataAddress;
   \       0xAE   0x9800             LDR      R0,[SP, #+0]
   \       0xB0   0x8800             LDRH     R0,[R0, #+0]
   \       0xB2   0x8020             STRH     R0,[R4, #+0]
   \       0xB4   0xE008             B.N      ??HAL_FLASH_Program_11
    234              }
    235              else
    236          #endif /* FLASH_OPTCR_PG_OTP */
    237              {
    238                /* Program the flash word */
    239                do
    240                {
    241                  *dest_addr = *src_addr;
   \                     ??HAL_FLASH_Program_10: (+1)
   \       0xB6   0x6830             LDR      R0,[R6, #+0]
   \       0xB8   0x6028             STR      R0,[R5, #+0]
    242                  dest_addr++;
   \       0xBA   0x1D2D             ADDS     R5,R5,#+4
    243                  src_addr++;
   \       0xBC   0x1D36             ADDS     R6,R6,#+4
    244                  row_index--;
   \       0xBE   0x1E7F             SUBS     R7,R7,#+1
    245               } while (row_index != 0U);
   \       0xC0   0x0038             MOVS     R0,R7
   \       0xC2   0xB2C0             UXTB     R0,R0
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD1F6             BNE.N    ??HAL_FLASH_Program_10
    246              }
    247          
    248              __ISB();
   \                     ??HAL_FLASH_Program_11: (+1)
   \       0xC8   0xF3BF 0x8F6F      ISB      SY
    249              __DSB();
   \       0xCC   0xF3BF 0x8F4F      DSB      SY
    250          
    251              /* Wait for last operation to be completed */
    252              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
   \       0xD0   0x4649             MOV      R1,R9
   \       0xD2   0x4650             MOV      R0,R10
   \       0xD4   0x.... 0x....      BL       FLASH_WaitForLastOperation
    253          
    254          #if defined (DUAL_BANK)
    255          #if defined (FLASH_OPTCR_PG_OTP)
    256              if (TypeProgram == FLASH_TYPEPROGRAM_OTPWORD)
   \       0xD8   0xF1BB 0x0F02      CMP      R11,#+2
   \       0xDC   0xD106             BNE.N    ??HAL_FLASH_Program_12
    257              {
    258                /* If the program operation is completed, disable the OTP_PG */
    259                CLEAR_BIT(FLASH->OPTCR, FLASH_OPTCR_PG_OTP);
   \       0xDE   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \       0xE2   0x680A             LDR      R2,[R1, #+0]
   \       0xE4   0xF032 0x0220      BICS     R2,R2,#0x20
   \       0xE8   0x600A             STR      R2,[R1, #+0]
   \       0xEA   0xE00F             B.N      ??HAL_FLASH_Program_5
    260              }
    261              else
    262          #endif /* FLASH_OPTCR_PG_OTP */
    263              {
    264                if(bank == FLASH_BANK_1)
   \                     ??HAL_FLASH_Program_12: (+1)
   \       0xEC   0xF1B9 0x0F01      CMP      R9,#+1
   \       0xF0   0xD106             BNE.N    ??HAL_FLASH_Program_13
    265                {
    266                  /* If the program operation is completed, disable the PG */
    267                  CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
   \       0xF2   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \       0xF6   0x680A             LDR      R2,[R1, #+0]
   \       0xF8   0xF032 0x0202      BICS     R2,R2,#0x2
   \       0xFC   0x600A             STR      R2,[R1, #+0]
   \       0xFE   0xE005             B.N      ??HAL_FLASH_Program_5
    268                }
    269                else
    270                {
    271                  /* If the program operation is completed, disable the PG */
    272                  CLEAR_BIT(FLASH->CR2, FLASH_CR_PG);
   \                     ??HAL_FLASH_Program_13: (+1)
   \      0x100   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \      0x104   0x680A             LDR      R2,[R1, #+0]
   \      0x106   0xF032 0x0202      BICS     R2,R2,#0x2
   \      0x10A   0x600A             STR      R2,[R1, #+0]
    273                }
    274              }
    275          #else /* Single Bank */
    276          #if defined (FLASH_OPTCR_PG_OTP)
    277              if (TypeProgram == FLASH_TYPEPROGRAM_OTPWORD)
    278              {
    279                /* If the program operation is completed, disable the OTP_PG */
    280                CLEAR_BIT(FLASH->OPTCR, FLASH_OPTCR_PG_OTP);
    281              }
    282              else
    283          #endif /* FLASH_OPTCR_PG_OTP */
    284              {
    285                /* If the program operation is completed, disable the PG */
    286                CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
    287              }
    288          #endif /* DUAL_BANK */
    289            }
    290          
    291            /* Process Unlocked */
    292            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASH_Program_5: (+1)
   \      0x10C   0x2100             MOVS     R1,#+0
   \      0x10E   0xF888 0x1014      STRB     R1,[R8, #+20]
    293          
    294            return status;
   \      0x112   0xB2C0             UXTB     R0,R0
   \                     ??HAL_FLASH_Program_1: (+1)
   \      0x114   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    295          }
    296          
    297          /**
    298            * @brief  Program a flash word at a specified address with interrupt enabled.
    299            * @param  TypeProgram Indicate the way to program at a specified address.
    300            *                      This parameter can be a value of @ref FLASH_Type_Program
    301            * @param  FlashAddress specifies the address to be programmed.
    302            *         This parameter shall be aligned to the Flash word:
    303            *          - 256 bits for STM32H74x/5X devices (8x 32bits words)
    304            *          - 128 bits for STM32H7Ax/BX devices (4x 32bits words)
    305            *          - 256 bits for STM32H72x/3X devices (8x 32bits words)
    306            * @param  DataAddress specifies the address of data to be programmed.
    307            *         This parameter shall be 32-bit aligned
    308            *
    309            * @retval HAL Status
    310            */

   \                                 In section .text, align 2, keep-with-next
    311          HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t FlashAddress, uint32_t DataAddress)
    312          {
   \                     HAL_FLASH_Program_IT: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    313            HAL_StatusTypeDef status;
    314            __IO uint32_t *dest_addr = (__IO uint32_t*)FlashAddress;
   \        0xA   0x002F             MOVS     R7,R5
    315            __IO uint32_t *src_addr = (__IO uint32_t*)DataAddress;
   \        0xC   0x46B0             MOV      R8,R6
    316            uint32_t bank;
    317            uint8_t row_index = FLASH_NB_32BITWORD_IN_FLASHWORD;
   \        0xE   0xF05F 0x0904      MOVS     R9,#+4
    318          
    319            /* Check the parameters */
    320            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    321            assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));
    322          
    323            /* Process Locked */
    324            __HAL_LOCK(&pFlash);
   \       0x12   0x.... 0x....      LDR.W    R10,??DataTable11
   \       0x16   0xF89A 0x0014      LDRB     R0,[R10, #+20]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD101             BNE.N    ??HAL_FLASH_Program_IT_0
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0xE06E             B.N      ??HAL_FLASH_Program_IT_1
   \                     ??HAL_FLASH_Program_IT_0: (+1)
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xF88A 0x0014      STRB     R0,[R10, #+20]
    325          
    326            /* Reset error code */
    327            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xF8CA 0x0018      STR      R0,[R10, #+24]
    328          
    329          #if defined (FLASH_OPTCR_PG_OTP)
    330            if((IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress)) || (IS_FLASH_PROGRAM_ADDRESS_OTP(FlashAddress)))
   \       0x2E   0xF1B5 0x6000      SUBS     R0,R5,#+134217728
   \       0x32   0xF5B0 0x1F80      CMP      R0,#+1048576
   \       0x36   0xD305             BCC.N    ??HAL_FLASH_Program_IT_2
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \       0x3C   0x1A28             SUBS     R0,R5,R0
   \       0x3E   0xF5B0 0x6F80      CMP      R0,#+1024
   \       0x42   0xD20E             BCS.N    ??HAL_FLASH_Program_IT_3
    331          #else
    332            if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
    333          #endif /* FLASH_OPTCR_PG_OTP */
    334            {
    335              bank = FLASH_BANK_1;
   \                     ??HAL_FLASH_Program_IT_2: (+1)
   \       0x44   0xF05F 0x0B01      MOVS     R11,#+1
    336            }
    337          #if defined (DUAL_BANK)
    338            else if(IS_FLASH_PROGRAM_ADDRESS_BANK2(FlashAddress))
    339            {
    340              bank = FLASH_BANK_2;
    341            }
    342          #endif /* DUAL_BANK */
    343            else
    344            {
    345              return HAL_ERROR;
    346            }
    347          
    348            /* Wait for last operation to be completed */
    349            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
   \                     ??HAL_FLASH_Program_IT_4: (+1)
   \       0x48   0x4659             MOV      R1,R11
   \       0x4A   0xF24C 0x3050      MOVW     R0,#+50000
   \       0x4E   0x.... 0x....      BL       FLASH_WaitForLastOperation
    350          
    351            if (status != HAL_OK)
   \       0x52   0x0001             MOVS     R1,R0
   \       0x54   0xB2C9             UXTB     R1,R1
   \       0x56   0x2900             CMP      R1,#+0
   \       0x58   0xD00D             BEQ.N    ??HAL_FLASH_Program_IT_5
    352            {
    353              /* Process Unlocked */
    354              __HAL_UNLOCK(&pFlash);
   \       0x5A   0x2100             MOVS     R1,#+0
   \       0x5C   0xF88A 0x1014      STRB     R1,[R10, #+20]
   \       0x60   0xE04D             B.N      ??HAL_FLASH_Program_IT_6
    355            }
   \                     ??HAL_FLASH_Program_IT_3: (+1)
   \       0x62   0xF1B5 0x6001      SUBS     R0,R5,#+135266304
   \       0x66   0xF5B0 0x1F80      CMP      R0,#+1048576
   \       0x6A   0xD202             BCS.N    ??HAL_FLASH_Program_IT_7
   \       0x6C   0xF05F 0x0B02      MOVS     R11,#+2
   \       0x70   0xE7EA             B.N      ??HAL_FLASH_Program_IT_4
   \                     ??HAL_FLASH_Program_IT_7: (+1)
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0xE044             B.N      ??HAL_FLASH_Program_IT_1
    356            else
    357            {
    358              pFlash.Address = FlashAddress;
   \                     ??HAL_FLASH_Program_IT_5: (+1)
   \       0x76   0xF8CA 0x5010      STR      R5,[R10, #+16]
    359          
    360          #if defined (DUAL_BANK)
    361              if(bank == FLASH_BANK_1)
   \       0x7A   0xF1BB 0x0F01      CMP      R11,#+1
   \       0x7E   0xD118             BNE.N    ??HAL_FLASH_Program_IT_8
    362              {
    363                /* Set internal variables used by the IRQ handler */
    364                pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_BANK1;
   \       0x80   0x2103             MOVS     R1,#+3
   \       0x82   0xF88A 0x1000      STRB     R1,[R10, #+0]
    365          
    366          #if defined (FLASH_OPTCR_PG_OTP)
    367                if (TypeProgram == FLASH_TYPEPROGRAM_OTPWORD)
   \       0x86   0x2C02             CMP      R4,#+2
   \       0x88   0xD106             BNE.N    ??HAL_FLASH_Program_IT_9
    368                {
    369                  /* Set OTP_PG bit */
    370                  SET_BIT(FLASH->OPTCR, FLASH_OPTCR_PG_OTP);
   \       0x8A   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \       0x8E   0x680A             LDR      R2,[R1, #+0]
   \       0x90   0xF052 0x0220      ORRS     R2,R2,#0x20
   \       0x94   0x600A             STR      R2,[R1, #+0]
   \       0x96   0xE005             B.N      ??HAL_FLASH_Program_IT_10
    371                }
    372                else
    373          #endif /* FLASH_OPTCR_PG_OTP */
    374                {
    375                  /* Set PG bit */
    376                  SET_BIT(FLASH->CR1, FLASH_CR_PG);
   \                     ??HAL_FLASH_Program_IT_9: (+1)
   \       0x98   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \       0x9C   0x680A             LDR      R2,[R1, #+0]
   \       0x9E   0xF052 0x0202      ORRS     R2,R2,#0x2
   \       0xA2   0x600A             STR      R2,[R1, #+0]
    377                }
    378          
    379                /* Enable End of Operation and Error interrupts for Bank 1 */
    380          #if defined (FLASH_CR_OPERRIE)
    381                __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
    382                                            FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1 | FLASH_IT_OPERR_BANK1);
    383          #else
    384                __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
    385                                            FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1);
   \                     ??HAL_FLASH_Program_IT_10: (+1)
   \       0xA4   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \       0xA8   0x680A             LDR      R2,[R1, #+0]
   \       0xAA   0xF452 0x123C      ORRS     R2,R2,#0x2F0000
   \       0xAE   0x600A             STR      R2,[R1, #+0]
   \       0xB0   0xE00C             B.N      ??HAL_FLASH_Program_IT_11
    386          #endif /* FLASH_CR_OPERRIE */
    387              }
    388              else
    389              {
    390                /* Set internal variables used by the IRQ handler */
    391                pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_BANK2;
   \                     ??HAL_FLASH_Program_IT_8: (+1)
   \       0xB2   0x2106             MOVS     R1,#+6
   \       0xB4   0xF88A 0x1000      STRB     R1,[R10, #+0]
    392          
    393                /* Set PG bit */
    394                SET_BIT(FLASH->CR2, FLASH_CR_PG);
   \       0xB8   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \       0xBC   0x680A             LDR      R2,[R1, #+0]
   \       0xBE   0xF052 0x0202      ORRS     R2,R2,#0x2
   \       0xC2   0x600A             STR      R2,[R1, #+0]
    395          
    396                /* Enable End of Operation and Error interrupts for Bank2 */
    397          #if defined (FLASH_CR_OPERRIE)
    398                __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
    399                                            FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2 | FLASH_IT_OPERR_BANK2);
    400          #else
    401                __HAL_FLASH_ENABLE_IT_BANK2(FLASH_IT_EOP_BANK2     | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
    402                                            FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);
   \       0xC4   0x680A             LDR      R2,[R1, #+0]
   \       0xC6   0xF452 0x123C      ORRS     R2,R2,#0x2F0000
   \       0xCA   0x600A             STR      R2,[R1, #+0]
    403          #endif /* FLASH_CR_OPERRIE */
    404              }
    405          #else /* Single Bank */
    406              /* Set internal variables used by the IRQ handler */
    407              pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_BANK1;
    408          
    409          #if defined (FLASH_OPTCR_PG_OTP)
    410              if (TypeProgram == FLASH_TYPEPROGRAM_OTPWORD)
    411              {
    412                /* Set OTP_PG bit */
    413                SET_BIT(FLASH->OPTCR, FLASH_OPTCR_PG_OTP);
    414              }
    415              else
    416          #endif /* FLASH_OPTCR_PG_OTP */
    417              {
    418                /* Set PG bit */
    419                SET_BIT(FLASH->CR1, FLASH_CR_PG);
    420              }
    421          
    422                /* Enable End of Operation and Error interrupts for Bank 1 */
    423          #if defined (FLASH_CR_OPERRIE)
    424                __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
    425                                            FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1 | FLASH_IT_OPERR_BANK1);
    426          #else
    427                __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
    428                                            FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1);
    429          #endif /* FLASH_CR_OPERRIE */
    430          #endif /* DUAL_BANK */
    431          
    432              __ISB();
   \                     ??HAL_FLASH_Program_IT_11: (+1)
   \       0xCC   0xF3BF 0x8F6F      ISB      SY
    433              __DSB();
   \       0xD0   0xF3BF 0x8F4F      DSB      SY
    434          
    435          #if defined (FLASH_OPTCR_PG_OTP)
    436              if (TypeProgram == FLASH_TYPEPROGRAM_OTPWORD)
   \       0xD4   0x2C02             CMP      R4,#+2
   \       0xD6   0xD102             BNE.N    ??HAL_FLASH_Program_IT_12
    437              {
    438                /* Program an OTP word (16 bits) */
    439                *(__IO uint16_t *)FlashAddress = *(__IO uint16_t*)DataAddress;
   \       0xD8   0x8831             LDRH     R1,[R6, #+0]
   \       0xDA   0x8029             STRH     R1,[R5, #+0]
   \       0xDC   0xE00B             B.N      ??HAL_FLASH_Program_IT_13
    440              }
    441              else
    442          #endif /* FLASH_OPTCR_PG_OTP */
    443              {
    444                /* Program the flash word */
    445                do
    446                {
    447                  *dest_addr = *src_addr;
   \                     ??HAL_FLASH_Program_IT_12: (+1)
   \       0xDE   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0xE2   0x6039             STR      R1,[R7, #+0]
    448                  dest_addr++;
   \       0xE4   0x1D3F             ADDS     R7,R7,#+4
    449                  src_addr++;
   \       0xE6   0xF118 0x0804      ADDS     R8,R8,#+4
    450                  row_index--;
   \       0xEA   0xF1B9 0x0901      SUBS     R9,R9,#+1
    451                } while (row_index != 0U);
   \       0xEE   0x4649             MOV      R1,R9
   \       0xF0   0xB2C9             UXTB     R1,R1
   \       0xF2   0x2900             CMP      R1,#+0
   \       0xF4   0xD1F3             BNE.N    ??HAL_FLASH_Program_IT_12
    452              }
    453          
    454              __ISB();
   \                     ??HAL_FLASH_Program_IT_13: (+1)
   \       0xF6   0xF3BF 0x8F6F      ISB      SY
    455              __DSB();
   \       0xFA   0xF3BF 0x8F4F      DSB      SY
    456            }
    457          
    458            return status;
   \                     ??HAL_FLASH_Program_IT_6: (+1)
   \       0xFE   0xB2C0             UXTB     R0,R0
   \                     ??HAL_FLASH_Program_IT_1: (+1)
   \      0x100   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    459          }
    460          
    461          /**
    462            * @brief This function handles FLASH interrupt request.
    463            * @retval None
    464            */

   \                                 In section .text, align 2, keep-with-next
    465          void HAL_FLASH_IRQHandler(void)
    466          {
   \                     HAL_FLASH_IRQHandler: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    467            uint32_t temp;
    468            uint32_t errorflag;
    469            FLASH_ProcedureTypeDef procedure;
    470          
    471            /* Check FLASH Bank1 End of Operation flag  */
    472            if(__HAL_FLASH_GET_FLAG_BANK1(FLASH_SR_EOP) != RESET)
   \        0x2   0x.... 0x....      LDR.W    R5,??DataTable11_5
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0x03C0             LSLS     R0,R0,#+15
   \        0xA   0xD54F             BPL.N    ??HAL_FLASH_IRQHandler_0
    473            {
    474              if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE_BANK1)
   \        0xC   0x.... 0x....      LDR.W    R4,??DataTable11
   \       0x10   0x7820             LDRB     R0,[R4, #+0]
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD124             BNE.N    ??HAL_FLASH_IRQHandler_1
    475              {
    476                /* Nb of sector to erased can be decreased */
    477                pFlash.NbSectorsToErase--;
   \       0x16   0x6860             LDR      R0,[R4, #+4]
   \       0x18   0x1E40             SUBS     R0,R0,#+1
   \       0x1A   0x6060             STR      R0,[R4, #+4]
    478          
    479                /* Check if there are still sectors to erase */
    480                if(pFlash.NbSectorsToErase != 0U)
   \       0x1C   0x6860             LDR      R0,[R4, #+4]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD010             BEQ.N    ??HAL_FLASH_IRQHandler_2
    481                {
    482                  /* Indicate user which sector has been erased */
    483                  HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
   \       0x22   0x68E0             LDR      R0,[R4, #+12]
   \       0x24   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    484          
    485                  /* Clear bank 1 End of Operation pending bit */
    486                  __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
   \       0x28   0xF45F 0x3080      MOVS     R0,#+65536
   \       0x2C   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \       0x30   0x6008             STR      R0,[R1, #+0]
    487          
    488                  /* Increment sector number */
    489                  pFlash.Sector++;
   \       0x32   0x68E0             LDR      R0,[R4, #+12]
   \       0x34   0x1C40             ADDS     R0,R0,#+1
   \       0x36   0x60E0             STR      R0,[R4, #+12]
    490                  temp = pFlash.Sector;
   \       0x38   0x68E0             LDR      R0,[R4, #+12]
    491                  FLASH_Erase_Sector(temp, FLASH_BANK_1, pFlash.VoltageForErase);
   \       0x3A   0x68A2             LDR      R2,[R4, #+8]
   \       0x3C   0x2101             MOVS     R1,#+1
   \       0x3E   0x.... 0x....      BL       FLASH_Erase_Sector
   \       0x42   0xE033             B.N      ??HAL_FLASH_IRQHandler_0
    492                }
    493                else
    494                {
    495                  /* No more sectors to Erase, user callback can be called */
    496                  /* Reset Sector and stop Erase sectors procedure */
    497                  pFlash.Sector = 0xFFFFFFFFU;
   \                     ??HAL_FLASH_IRQHandler_2: (+1)
   \       0x44   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x48   0x60E0             STR      R0,[R4, #+12]
    498                  pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x7020             STRB     R0,[R4, #+0]
    499          
    500                  /* FLASH EOP interrupt user callback */
    501                  HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
   \       0x4E   0x68E0             LDR      R0,[R4, #+12]
   \       0x50   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    502          
    503                  /* Clear FLASH End of Operation pending bit */
    504                  __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
   \       0x54   0xF45F 0x3080      MOVS     R0,#+65536
   \       0x58   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \       0x5C   0x6008             STR      R0,[R1, #+0]
   \       0x5E   0xE025             B.N      ??HAL_FLASH_IRQHandler_0
    505                }
    506              }
    507              else
    508              {
    509                procedure = pFlash.ProcedureOnGoing;
   \                     ??HAL_FLASH_IRQHandler_1: (+1)
   \       0x60   0x7826             LDRB     R6,[R4, #+0]
    510          
    511                if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
   \       0x62   0x0030             MOVS     R0,R6
   \       0x64   0xB2C0             UXTB     R0,R0
   \       0x66   0x2802             CMP      R0,#+2
   \       0x68   0xD003             BEQ.N    ??HAL_FLASH_IRQHandler_3
   \       0x6A   0x0030             MOVS     R0,R6
   \       0x6C   0xB2C0             UXTB     R0,R0
   \       0x6E   0x2807             CMP      R0,#+7
   \       0x70   0xD103             BNE.N    ??HAL_FLASH_IRQHandler_4
    512                {
    513                  /* MassErase ended. Return the selected bank */
    514                  /* FLASH EOP interrupt user callback */
    515                  HAL_FLASH_EndOfOperationCallback(FLASH_BANK_1);
   \                     ??HAL_FLASH_IRQHandler_3: (+1)
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
   \       0x78   0xE006             B.N      ??HAL_FLASH_IRQHandler_5
    516                }
    517                else if(procedure == FLASH_PROC_PROGRAM_BANK1)
   \                     ??HAL_FLASH_IRQHandler_4: (+1)
   \       0x7A   0x0030             MOVS     R0,R6
   \       0x7C   0xB2C0             UXTB     R0,R0
   \       0x7E   0x2803             CMP      R0,#+3
   \       0x80   0xD102             BNE.N    ??HAL_FLASH_IRQHandler_5
    518                {
    519                  /* Program ended. Return the selected address */
    520                  /* FLASH EOP interrupt user callback */
    521                  HAL_FLASH_EndOfOperationCallback(pFlash.Address);
   \       0x82   0x6920             LDR      R0,[R4, #+16]
   \       0x84   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    522                }
    523                else
    524                {
    525                  /* Nothing to do */
    526                }
    527          
    528                if((procedure != FLASH_PROC_SECTERASE_BANK2) && \
    529                   (procedure != FLASH_PROC_MASSERASE_BANK2) && \
    530                   (procedure != FLASH_PROC_PROGRAM_BANK2))
   \                     ??HAL_FLASH_IRQHandler_5: (+1)
   \       0x88   0x0030             MOVS     R0,R6
   \       0x8A   0xB2C0             UXTB     R0,R0
   \       0x8C   0x2804             CMP      R0,#+4
   \       0x8E   0xD00D             BEQ.N    ??HAL_FLASH_IRQHandler_0
   \       0x90   0x0030             MOVS     R0,R6
   \       0x92   0xB2C0             UXTB     R0,R0
   \       0x94   0x2805             CMP      R0,#+5
   \       0x96   0xD009             BEQ.N    ??HAL_FLASH_IRQHandler_0
   \       0x98   0xB2F6             UXTB     R6,R6
   \       0x9A   0x2E06             CMP      R6,#+6
   \       0x9C   0xD006             BEQ.N    ??HAL_FLASH_IRQHandler_0
    531                {
    532                  pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x7020             STRB     R0,[R4, #+0]
    533                  /* Clear FLASH End of Operation pending bit */
    534                  __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
   \       0xA2   0xF45F 0x3080      MOVS     R0,#+65536
   \       0xA6   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \       0xAA   0x6008             STR      R0,[R1, #+0]
    535                }
    536              }
    537            }
    538          
    539          #if defined (DUAL_BANK)
    540           /* Check FLASH Bank2 End of Operation flag  */
    541            if(__HAL_FLASH_GET_FLAG_BANK2(FLASH_SR_EOP) != RESET)
   \                     ??HAL_FLASH_IRQHandler_0: (+1)
   \       0xAC   0x.... 0x....      LDR.W    R4,??DataTable11_7
   \       0xB0   0x6820             LDR      R0,[R4, #+0]
   \       0xB2   0x03C0             LSLS     R0,R0,#+15
   \       0xB4   0xD54F             BPL.N    ??HAL_FLASH_IRQHandler_6
    542            {
    543              if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE_BANK2)
   \       0xB6   0x.... 0x....      LDR.W    R6,??DataTable11
   \       0xBA   0x7830             LDRB     R0,[R6, #+0]
   \       0xBC   0x2804             CMP      R0,#+4
   \       0xBE   0xD124             BNE.N    ??HAL_FLASH_IRQHandler_7
    544              {
    545                /*Nb of sector to erased can be decreased*/
    546                pFlash.NbSectorsToErase--;
   \       0xC0   0x6870             LDR      R0,[R6, #+4]
   \       0xC2   0x1E40             SUBS     R0,R0,#+1
   \       0xC4   0x6070             STR      R0,[R6, #+4]
    547          
    548                /* Check if there are still sectors to erase*/
    549                if(pFlash.NbSectorsToErase != 0U)
   \       0xC6   0x6870             LDR      R0,[R6, #+4]
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xD010             BEQ.N    ??HAL_FLASH_IRQHandler_8
    550                {
    551                  /*Indicate user which sector has been erased*/
    552                  HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
   \       0xCC   0x68F0             LDR      R0,[R6, #+12]
   \       0xCE   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    553          
    554                  /* Clear bank 2 End of Operation pending bit */
    555                  __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
   \       0xD2   0xF45F 0x3080      MOVS     R0,#+65536
   \       0xD6   0x.... 0x....      LDR.W    R1,??DataTable11_8
   \       0xDA   0x6008             STR      R0,[R1, #+0]
    556          
    557                  /*Increment sector number*/
    558                  pFlash.Sector++;
   \       0xDC   0x68F0             LDR      R0,[R6, #+12]
   \       0xDE   0x1C40             ADDS     R0,R0,#+1
   \       0xE0   0x60F0             STR      R0,[R6, #+12]
    559                  temp = pFlash.Sector;
   \       0xE2   0x68F0             LDR      R0,[R6, #+12]
    560                  FLASH_Erase_Sector(temp, FLASH_BANK_2, pFlash.VoltageForErase);
   \       0xE4   0x68B2             LDR      R2,[R6, #+8]
   \       0xE6   0x2102             MOVS     R1,#+2
   \       0xE8   0x.... 0x....      BL       FLASH_Erase_Sector
   \       0xEC   0xE033             B.N      ??HAL_FLASH_IRQHandler_6
    561                }
    562                else
    563                {
    564                  /* No more sectors to Erase, user callback can be called */
    565                  /* Reset Sector and stop Erase sectors procedure */
    566                  pFlash.Sector = 0xFFFFFFFFU;
   \                     ??HAL_FLASH_IRQHandler_8: (+1)
   \       0xEE   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0xF2   0x60F0             STR      R0,[R6, #+12]
    567                  pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \       0xF4   0x2000             MOVS     R0,#+0
   \       0xF6   0x7030             STRB     R0,[R6, #+0]
    568          
    569                  /* FLASH EOP interrupt user callback */
    570                  HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
   \       0xF8   0x68F0             LDR      R0,[R6, #+12]
   \       0xFA   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    571          
    572                  /* Clear FLASH End of Operation pending bit */
    573                  __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
   \       0xFE   0xF45F 0x3080      MOVS     R0,#+65536
   \      0x102   0x.... 0x....      LDR.W    R1,??DataTable11_8
   \      0x106   0x6008             STR      R0,[R1, #+0]
   \      0x108   0xE025             B.N      ??HAL_FLASH_IRQHandler_6
    574                }
    575              }
    576              else
    577              {
    578                procedure = pFlash.ProcedureOnGoing;
   \                     ??HAL_FLASH_IRQHandler_7: (+1)
   \      0x10A   0x7837             LDRB     R7,[R6, #+0]
    579          
    580                if((procedure == FLASH_PROC_MASSERASE_BANK2) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
   \      0x10C   0x0038             MOVS     R0,R7
   \      0x10E   0xB2C0             UXTB     R0,R0
   \      0x110   0x2805             CMP      R0,#+5
   \      0x112   0xD003             BEQ.N    ??HAL_FLASH_IRQHandler_9
   \      0x114   0x0038             MOVS     R0,R7
   \      0x116   0xB2C0             UXTB     R0,R0
   \      0x118   0x2807             CMP      R0,#+7
   \      0x11A   0xD103             BNE.N    ??HAL_FLASH_IRQHandler_10
    581                {
    582                  /*MassErase ended. Return the selected bank*/
    583                  /* FLASH EOP interrupt user callback */
    584                  HAL_FLASH_EndOfOperationCallback(FLASH_BANK_2);
   \                     ??HAL_FLASH_IRQHandler_9: (+1)
   \      0x11C   0x2002             MOVS     R0,#+2
   \      0x11E   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
   \      0x122   0xE006             B.N      ??HAL_FLASH_IRQHandler_11
    585                }
    586                else if(procedure == FLASH_PROC_PROGRAM_BANK2)
   \                     ??HAL_FLASH_IRQHandler_10: (+1)
   \      0x124   0x0038             MOVS     R0,R7
   \      0x126   0xB2C0             UXTB     R0,R0
   \      0x128   0x2806             CMP      R0,#+6
   \      0x12A   0xD102             BNE.N    ??HAL_FLASH_IRQHandler_11
    587                {
    588                  /* Program ended. Return the selected address */
    589                  /* FLASH EOP interrupt user callback */
    590                  HAL_FLASH_EndOfOperationCallback(pFlash.Address);
   \      0x12C   0x6930             LDR      R0,[R6, #+16]
   \      0x12E   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    591                }
    592                else
    593                {
    594                  /* Nothing to do */
    595                }
    596          
    597                if((procedure != FLASH_PROC_SECTERASE_BANK1) && \
    598                   (procedure != FLASH_PROC_MASSERASE_BANK1) && \
    599                   (procedure != FLASH_PROC_PROGRAM_BANK1))
   \                     ??HAL_FLASH_IRQHandler_11: (+1)
   \      0x132   0x0038             MOVS     R0,R7
   \      0x134   0xB2C0             UXTB     R0,R0
   \      0x136   0x2801             CMP      R0,#+1
   \      0x138   0xD00D             BEQ.N    ??HAL_FLASH_IRQHandler_6
   \      0x13A   0x0038             MOVS     R0,R7
   \      0x13C   0xB2C0             UXTB     R0,R0
   \      0x13E   0x2802             CMP      R0,#+2
   \      0x140   0xD009             BEQ.N    ??HAL_FLASH_IRQHandler_6
   \      0x142   0xB2FF             UXTB     R7,R7
   \      0x144   0x2F03             CMP      R7,#+3
   \      0x146   0xD006             BEQ.N    ??HAL_FLASH_IRQHandler_6
    600                {
    601                  pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \      0x148   0x2000             MOVS     R0,#+0
   \      0x14A   0x7030             STRB     R0,[R6, #+0]
    602                  /* Clear FLASH End of Operation pending bit */
    603                  __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
   \      0x14C   0xF45F 0x3080      MOVS     R0,#+65536
   \      0x150   0x.... 0x....      LDR.W    R1,??DataTable11_8
   \      0x154   0x6008             STR      R0,[R1, #+0]
    604                }
    605              }
    606            }
    607          #endif /* DUAL_BANK */
    608          
    609            /* Check FLASH Bank1 operation error flags */
    610          #if defined (FLASH_SR_OPERR)
    611            errorflag = FLASH->SR1 & (FLASH_FLAG_WRPERR_BANK1 | FLASH_FLAG_PGSERR_BANK1 | FLASH_FLAG_STRBERR_BANK1 | \
    612                                      FLASH_FLAG_INCERR_BANK1 | FLASH_FLAG_OPERR_BANK1);
    613          #else
    614            errorflag = FLASH->SR1 & (FLASH_FLAG_WRPERR_BANK1 | FLASH_FLAG_PGSERR_BANK1 | FLASH_FLAG_STRBERR_BANK1 | \
    615                                      FLASH_FLAG_INCERR_BANK1);
   \                     ??HAL_FLASH_IRQHandler_6: (+1)
   \      0x156   0x6828             LDR      R0,[R5, #+0]
   \      0x158   0xF410 0x1038      ANDS     R0,R0,#0x2E0000
    616          #endif /* FLASH_SR_OPERR */
    617          
    618            if(errorflag != 0U)
   \      0x15C   0x2800             CMP      R0,#+0
   \      0x15E   0xD01F             BEQ.N    ??HAL_FLASH_IRQHandler_12
    619            {
    620              /* Save the error code */
    621              pFlash.ErrorCode |= errorflag;
   \      0x160   0x.... 0x....      LDR.W    R1,??DataTable11
   \      0x164   0x698A             LDR      R2,[R1, #+24]
   \      0x166   0x4302             ORRS     R2,R0,R2
   \      0x168   0x618A             STR      R2,[R1, #+24]
    622          
    623              /* Clear error programming flags */
    624              __HAL_FLASH_CLEAR_FLAG_BANK1(errorflag);
   \      0x16A   0x.... 0x....      LDR.W    R2,??DataTable11_6
   \      0x16E   0x6010             STR      R0,[R2, #+0]
    625          
    626              procedure = pFlash.ProcedureOnGoing;
   \      0x170   0x7808             LDRB     R0,[R1, #+0]
    627          
    628              if(procedure == FLASH_PROC_SECTERASE_BANK1)
   \      0x172   0x0002             MOVS     R2,R0
   \      0x174   0xB2D2             UXTB     R2,R2
   \      0x176   0x2A01             CMP      R2,#+1
   \      0x178   0xD104             BNE.N    ??HAL_FLASH_IRQHandler_13
    629              {
    630                /* Return the faulty sector */
    631                temp = pFlash.Sector;
   \      0x17A   0x68C8             LDR      R0,[R1, #+12]
    632                pFlash.Sector = 0xFFFFFFFFU;
   \      0x17C   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x180   0x60CA             STR      R2,[R1, #+12]
   \      0x182   0xE009             B.N      ??HAL_FLASH_IRQHandler_14
    633              }
    634              else if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
   \                     ??HAL_FLASH_IRQHandler_13: (+1)
   \      0x184   0x0002             MOVS     R2,R0
   \      0x186   0xB2D2             UXTB     R2,R2
   \      0x188   0x2A02             CMP      R2,#+2
   \      0x18A   0xD002             BEQ.N    ??HAL_FLASH_IRQHandler_15
   \      0x18C   0xB2C0             UXTB     R0,R0
   \      0x18E   0x2807             CMP      R0,#+7
   \      0x190   0xD101             BNE.N    ??HAL_FLASH_IRQHandler_16
    635              {
    636                /* Return the faulty bank */
    637                temp = FLASH_BANK_1;
   \                     ??HAL_FLASH_IRQHandler_15: (+1)
   \      0x192   0x2001             MOVS     R0,#+1
   \      0x194   0xE000             B.N      ??HAL_FLASH_IRQHandler_14
    638              }
    639              else
    640              {
    641                /* Return the faulty address */
    642                temp = pFlash.Address;
   \                     ??HAL_FLASH_IRQHandler_16: (+1)
   \      0x196   0x6908             LDR      R0,[R1, #+16]
    643              }
    644          
    645              /* Stop the procedure ongoing*/
    646              pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \                     ??HAL_FLASH_IRQHandler_14: (+1)
   \      0x198   0x2200             MOVS     R2,#+0
   \      0x19A   0x700A             STRB     R2,[R1, #+0]
    647          
    648              /* FLASH error interrupt user callback */
    649              HAL_FLASH_OperationErrorCallback(temp);
   \      0x19C   0x.... 0x....      BL       HAL_FLASH_OperationErrorCallback
    650            }
    651          
    652          #if defined (DUAL_BANK)
    653            /* Check FLASH Bank2 operation error flags */
    654          #if defined (FLASH_SR_OPERR)
    655            errorflag = FLASH->SR2 & ((FLASH_FLAG_WRPERR_BANK2 | FLASH_FLAG_PGSERR_BANK2 | FLASH_FLAG_STRBERR_BANK2 | \
    656                                       FLASH_FLAG_INCERR_BANK2 | FLASH_FLAG_OPERR_BANK2) & 0x7FFFFFFFU);
    657          #else
    658            errorflag = FLASH->SR2 & ((FLASH_FLAG_WRPERR_BANK2 | FLASH_FLAG_PGSERR_BANK2 | FLASH_FLAG_STRBERR_BANK2 | \
    659                                       FLASH_FLAG_INCERR_BANK2) & 0x7FFFFFFFU);
   \                     ??HAL_FLASH_IRQHandler_12: (+1)
   \      0x1A0   0x6820             LDR      R0,[R4, #+0]
   \      0x1A2   0xF410 0x1038      ANDS     R0,R0,#0x2E0000
    660          #endif /* FLASH_SR_OPERR */
    661          
    662            if(errorflag != 0U)
   \      0x1A6   0x2800             CMP      R0,#+0
   \      0x1A8   0xD023             BEQ.N    ??HAL_FLASH_IRQHandler_17
    663            {
    664              /* Save the error code */
    665              pFlash.ErrorCode |= (errorflag | 0x80000000U);
   \      0x1AA   0x.... 0x....      LDR.W    R1,??DataTable11
   \      0x1AE   0x698A             LDR      R2,[R1, #+24]
   \      0x1B0   0x4302             ORRS     R2,R0,R2
   \      0x1B2   0xF052 0x4200      ORRS     R2,R2,#0x80000000
   \      0x1B6   0x618A             STR      R2,[R1, #+24]
    666          
    667              /* Clear error programming flags */
    668              __HAL_FLASH_CLEAR_FLAG_BANK2(errorflag);
   \      0x1B8   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \      0x1BC   0x.... 0x....      LDR.W    R2,??DataTable11_8
   \      0x1C0   0x6010             STR      R0,[R2, #+0]
    669          
    670              procedure = pFlash.ProcedureOnGoing;
   \      0x1C2   0x7808             LDRB     R0,[R1, #+0]
    671          
    672              if(procedure== FLASH_PROC_SECTERASE_BANK2)
   \      0x1C4   0x0002             MOVS     R2,R0
   \      0x1C6   0xB2D2             UXTB     R2,R2
   \      0x1C8   0x2A04             CMP      R2,#+4
   \      0x1CA   0xD104             BNE.N    ??HAL_FLASH_IRQHandler_18
    673              {
    674                /*return the faulty sector*/
    675                temp = pFlash.Sector;
   \      0x1CC   0x68C8             LDR      R0,[R1, #+12]
    676                pFlash.Sector = 0xFFFFFFFFU;
   \      0x1CE   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x1D2   0x60CA             STR      R2,[R1, #+12]
   \      0x1D4   0xE009             B.N      ??HAL_FLASH_IRQHandler_19
    677              }
    678              else if((procedure == FLASH_PROC_MASSERASE_BANK2) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
   \                     ??HAL_FLASH_IRQHandler_18: (+1)
   \      0x1D6   0x0002             MOVS     R2,R0
   \      0x1D8   0xB2D2             UXTB     R2,R2
   \      0x1DA   0x2A05             CMP      R2,#+5
   \      0x1DC   0xD002             BEQ.N    ??HAL_FLASH_IRQHandler_20
   \      0x1DE   0xB2C0             UXTB     R0,R0
   \      0x1E0   0x2807             CMP      R0,#+7
   \      0x1E2   0xD101             BNE.N    ??HAL_FLASH_IRQHandler_21
    679              {
    680                /*return the faulty bank*/
    681                temp = FLASH_BANK_2;
   \                     ??HAL_FLASH_IRQHandler_20: (+1)
   \      0x1E4   0x2002             MOVS     R0,#+2
   \      0x1E6   0xE000             B.N      ??HAL_FLASH_IRQHandler_19
    682              }
    683              else
    684              {
    685                /*return the faulty address*/
    686                temp = pFlash.Address;
   \                     ??HAL_FLASH_IRQHandler_21: (+1)
   \      0x1E8   0x6908             LDR      R0,[R1, #+16]
    687              }
    688          
    689              /*Stop the procedure ongoing*/
    690              pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \                     ??HAL_FLASH_IRQHandler_19: (+1)
   \      0x1EA   0x2200             MOVS     R2,#+0
   \      0x1EC   0x700A             STRB     R2,[R1, #+0]
    691          
    692              /* FLASH error interrupt user callback */
    693              HAL_FLASH_OperationErrorCallback(temp);
   \      0x1EE   0x.... 0x....      BL       HAL_FLASH_OperationErrorCallback
    694            }
    695          #endif /* DUAL_BANK */
    696          
    697            if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
   \                     ??HAL_FLASH_IRQHandler_17: (+1)
   \      0x1F2   0x.... 0x....      LDR.W    R1,??DataTable11
   \      0x1F6   0x7808             LDRB     R0,[R1, #+0]
   \      0x1F8   0x2800             CMP      R0,#+0
   \      0x1FA   0xD10D             BNE.N    ??HAL_FLASH_IRQHandler_22
    698            {
    699          #if defined (FLASH_CR_OPERRIE)
    700              /* Disable Bank1 Operation and Error source interrupt */
    701              __HAL_FLASH_DISABLE_IT_BANK1(FLASH_IT_EOP_BANK1    | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
    702                                           FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1 | FLASH_IT_OPERR_BANK1);
    703          
    704          #if defined (DUAL_BANK)
    705              /* Disable Bank2 Operation and Error source interrupt */
    706              __HAL_FLASH_DISABLE_IT_BANK2(FLASH_IT_EOP_BANK2    | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
    707                                           FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2 | FLASH_IT_OPERR_BANK2);
    708          #endif /* DUAL_BANK */
    709          #else
    710              /* Disable Bank1 Operation and Error source interrupt */
    711              __HAL_FLASH_DISABLE_IT_BANK1(FLASH_IT_EOP_BANK1    | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
    712                                           FLASH_IT_STRBERR_BANK1 | FLASH_IT_INCERR_BANK1);
   \      0x1FC   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \      0x200   0x6802             LDR      R2,[R0, #+0]
   \      0x202   0xF432 0x123C      BICS     R2,R2,#0x2F0000
   \      0x206   0x6002             STR      R2,[R0, #+0]
    713          
    714          #if defined (DUAL_BANK)
    715              /* Disable Bank2 Operation and Error source interrupt */
    716              __HAL_FLASH_DISABLE_IT_BANK2(FLASH_IT_EOP_BANK2    | FLASH_IT_WRPERR_BANK2 | FLASH_IT_PGSERR_BANK2 | \
    717                                           FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);
   \      0x208   0x.... 0x....      LDR.W    R0,??DataTable11_4
   \      0x20C   0x6802             LDR      R2,[R0, #+0]
   \      0x20E   0xF432 0x123C      BICS     R2,R2,#0x2F0000
   \      0x212   0x6002             STR      R2,[R0, #+0]
    718          #endif /* DUAL_BANK */
    719          #endif /* FLASH_CR_OPERRIE */
    720          
    721              /* Process Unlocked */
    722              __HAL_UNLOCK(&pFlash);
   \      0x214   0x2000             MOVS     R0,#+0
   \      0x216   0x7508             STRB     R0,[R1, #+20]
    723            }
    724          }
   \                     ??HAL_FLASH_IRQHandler_22: (+1)
   \      0x218   0xBDF1             POP      {R0,R4-R7,PC}
    725          
    726          /**
    727            * @brief  FLASH end of operation interrupt callback
    728            * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure
    729            *                  Mass Erase: Bank number which has been requested to erase
    730            *                  Sectors Erase: Sector which has been erased
    731            *                    (if 0xFFFFFFFF, it means that all the selected sectors have been erased)
    732            *                  Program: Address which was selected for data program
    733            * @retval None
    734            */

   \                                 In section .text, align 2
    735          __weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
    736          {
    737            /* Prevent unused argument(s) compilation warning */
    738            UNUSED(ReturnValue);
    739          
    740            /* NOTE : This function Should not be modified, when the callback is needed,
    741                      the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
    742             */
    743          }
   \                     HAL_FLASH_EndOfOperationCallback: (+1)
   \        0x0   0x4770             BX       LR
    744          
    745          /**
    746            * @brief  FLASH operation error interrupt callback
    747            * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure
    748            *                 Mass Erase: Bank number which has been requested to erase
    749            *                 Sectors Erase: Sector number which returned an error
    750            *                 Program: Address which was selected for data program
    751            * @retval None
    752            */

   \                                 In section .text, align 2
    753          __weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
    754          {
    755            /* Prevent unused argument(s) compilation warning */
    756            UNUSED(ReturnValue);
    757          
    758            /* NOTE : This function Should not be modified, when the callback is needed,
    759                      the HAL_FLASH_OperationErrorCallback could be implemented in the user file
    760             */
    761          }
   \                     HAL_FLASH_OperationErrorCallback: (+1)
   \        0x0   0x4770             BX       LR
    762          
    763          /**
    764            * @}
    765            */
    766          
    767          /** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions
    768           *  @brief   Management functions
    769           *
    770          @verbatim
    771           ===============================================================================
    772                                ##### Peripheral Control functions #####
    773           ===============================================================================
    774              [..]
    775              This subsection provides a set of functions allowing to control the FLASH
    776              memory operations.
    777          
    778          @endverbatim
    779            * @{
    780            */
    781          
    782          /**
    783            * @brief  Unlock the FLASH control registers access
    784            * @retval HAL Status
    785            */

   \                                 In section .text, align 2, keep-with-next
    786          HAL_StatusTypeDef HAL_FLASH_Unlock(void)
    787          {
    788            if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
   \                     HAL_FLASH_Unlock: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0x07C9             LSLS     R1,R1,#+31
   \        0x8   0xD50C             BPL.N    ??HAL_FLASH_Unlock_0
    789            {
    790              /* Authorize the FLASH Bank1 Registers access */
    791              WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable11_9
   \        0xE   0x.... 0x....      LDR.W    R2,??DataTable11_10
   \       0x12   0x600A             STR      R2,[R1, #+0]
    792              WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
   \       0x14   0x.... 0x....      LDR.W    R2,??DataTable11_11
   \       0x18   0x600A             STR      R2,[R1, #+0]
    793          
    794              /* Verify Flash Bank1 is unlocked */
    795              if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0x07C0             LSLS     R0,R0,#+31
   \       0x1E   0xD501             BPL.N    ??HAL_FLASH_Unlock_0
    796              {
    797                return HAL_ERROR;
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xE00E             B.N      ??HAL_FLASH_Unlock_1
    798              }
    799            }
    800          
    801          #if defined (DUAL_BANK)
    802            if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
   \                     ??HAL_FLASH_Unlock_0: (+1)
   \       0x24   0x....             LDR.N    R0,??DataTable11_4
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0x07C9             LSLS     R1,R1,#+31
   \       0x2A   0xD509             BPL.N    ??HAL_FLASH_Unlock_2
    803            {
    804              /* Authorize the FLASH Bank2 Registers access */
    805              WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
   \       0x2C   0x....             LDR.N    R1,??DataTable11_12
   \       0x2E   0x....             LDR.N    R2,??DataTable11_10
   \       0x30   0x600A             STR      R2,[R1, #+0]
    806              WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
   \       0x32   0x....             LDR.N    R2,??DataTable11_11
   \       0x34   0x600A             STR      R2,[R1, #+0]
    807          
    808              /* Verify Flash Bank2 is unlocked */
    809              if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
   \       0x36   0x6800             LDR      R0,[R0, #+0]
   \       0x38   0x07C0             LSLS     R0,R0,#+31
   \       0x3A   0xD501             BPL.N    ??HAL_FLASH_Unlock_2
    810              {
    811                return HAL_ERROR;
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xE000             B.N      ??HAL_FLASH_Unlock_1
    812              }
    813            }
    814          #endif /* DUAL_BANK */
    815          
    816            return HAL_OK;
   \                     ??HAL_FLASH_Unlock_2: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \                     ??HAL_FLASH_Unlock_1: (+1)
   \       0x42   0x4770             BX       LR
    817          }
    818          
    819          /**
    820            * @brief  Locks the FLASH control registers access
    821            * @retval HAL Status
    822            */

   \                                 In section .text, align 2, keep-with-next
    823          HAL_StatusTypeDef HAL_FLASH_Lock(void)
    824          {
    825            /* Set the LOCK Bit to lock the FLASH Bank1 Control Register access */
    826            SET_BIT(FLASH->CR1, FLASH_CR_LOCK);
   \                     HAL_FLASH_Lock: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_3
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF051 0x0101      ORRS     R1,R1,#0x1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    827          
    828            /* Verify Flash Bank1 is locked */
    829            if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) == 0U)
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0x07C0             LSLS     R0,R0,#+31
   \        0xE   0xD401             BMI.N    ??HAL_FLASH_Lock_0
    830            {
    831              return HAL_ERROR;
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xE00A             B.N      ??HAL_FLASH_Lock_1
    832            }
    833          
    834          #if defined (DUAL_BANK)
    835            /* Set the LOCK Bit to lock the FLASH Bank2 Control Register access */
    836            SET_BIT(FLASH->CR2, FLASH_CR_LOCK);
   \                     ??HAL_FLASH_Lock_0: (+1)
   \       0x14   0x....             LDR.N    R0,??DataTable11_4
   \       0x16   0x6801             LDR      R1,[R0, #+0]
   \       0x18   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x1C   0x6001             STR      R1,[R0, #+0]
    837          
    838            /* Verify Flash Bank2 is locked */
    839            if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) == 0U)
   \       0x1E   0x6800             LDR      R0,[R0, #+0]
   \       0x20   0x07C0             LSLS     R0,R0,#+31
   \       0x22   0xD401             BMI.N    ??HAL_FLASH_Lock_2
    840            {
    841              return HAL_ERROR;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xE000             B.N      ??HAL_FLASH_Lock_1
    842            }
    843          #endif /* DUAL_BANK */
    844          
    845            return HAL_OK;
   \                     ??HAL_FLASH_Lock_2: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \                     ??HAL_FLASH_Lock_1: (+1)
   \       0x2A   0x4770             BX       LR
    846          }
    847          
    848          /**
    849            * @brief  Unlock the FLASH Option Control Registers access.
    850            * @retval HAL Status
    851            */

   \                                 In section .text, align 2, keep-with-next
    852          HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
    853          {
    854            if(READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
   \                     HAL_FLASH_OB_Unlock: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_2
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x07C9             LSLS     R1,R1,#+31
   \        0x6   0xD509             BPL.N    ??HAL_FLASH_OB_Unlock_0
    855            {
    856              /* Authorizes the Option Byte registers programming */
    857              WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY1);
   \        0x8   0x....             LDR.N    R1,??DataTable11_13
   \        0xA   0x....             LDR.N    R2,??DataTable11_14
   \        0xC   0x600A             STR      R2,[R1, #+0]
    858              WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY2);
   \        0xE   0x....             LDR.N    R2,??DataTable11_15
   \       0x10   0x600A             STR      R2,[R1, #+0]
    859          
    860              /* Verify that the Option Bytes are unlocked */
    861              if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x07C0             LSLS     R0,R0,#+31
   \       0x16   0xD501             BPL.N    ??HAL_FLASH_OB_Unlock_0
    862              {
    863                return HAL_ERROR;
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE000             B.N      ??HAL_FLASH_OB_Unlock_1
    864              }
    865            }
    866          
    867            return HAL_OK;
   \                     ??HAL_FLASH_OB_Unlock_0: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??HAL_FLASH_OB_Unlock_1: (+1)
   \       0x1E   0x4770             BX       LR
    868          }
    869          
    870          /**
    871            * @brief  Lock the FLASH Option Control Registers access.
    872            * @retval HAL Status
    873            */

   \                                 In section .text, align 2, keep-with-next
    874          HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
    875          {
    876            /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
    877            SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK);
   \                     HAL_FLASH_OB_Lock: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11_2
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF051 0x0101      ORRS     R1,R1,#0x1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    878          
    879            /* Verify that the Option Bytes are locked */
    880            if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) == 0U)
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0x07C0             LSLS     R0,R0,#+31
   \        0xE   0xD401             BMI.N    ??HAL_FLASH_OB_Lock_0
    881            {
    882              return HAL_ERROR;
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xE000             B.N      ??HAL_FLASH_OB_Lock_1
    883            }
    884          
    885            return HAL_OK;
   \                     ??HAL_FLASH_OB_Lock_0: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \                     ??HAL_FLASH_OB_Lock_1: (+1)
   \       0x16   0x4770             BX       LR
    886          }
    887          
    888          /**
    889            * @brief  Launch the option bytes loading.
    890            * @retval HAL Status
    891            */

   \                                 In section .text, align 2, keep-with-next
    892          HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
    893          {
   \                     HAL_FLASH_OB_Launch: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    894            HAL_StatusTypeDef status;
    895          
    896            /* Wait for CRC computation to be completed */
    897            if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
   \        0x2   0xF24C 0x3450      MOVW     R4,#+50000
   \        0x6   0x2101             MOVS     R1,#+1
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       FLASH_CRC_WaitForLastOperation
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD001             BEQ.N    ??HAL_FLASH_OB_Launch_0
    898            {
    899              status = HAL_ERROR;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xE008             B.N      ??HAL_FLASH_OB_Launch_1
    900            }
    901          #if defined (DUAL_BANK)
    902            else if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
   \                     ??HAL_FLASH_OB_Launch_0: (+1)
   \       0x16   0x2102             MOVS     R1,#+2
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0x.... 0x....      BL       FLASH_CRC_WaitForLastOperation
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD001             BEQ.N    ??HAL_FLASH_OB_Launch_2
    903            {
    904              status = HAL_ERROR;
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xE000             B.N      ??HAL_FLASH_OB_Launch_1
    905            }
    906          #endif /* DUAL_BANK */
    907            else
    908            {
    909              status = HAL_OK;
   \                     ??HAL_FLASH_OB_Launch_2: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
    910            }
    911          
    912            if (status == HAL_OK)
   \                     ??HAL_FLASH_OB_Launch_1: (+1)
   \       0x28   0x0001             MOVS     R1,R0
   \       0x2A   0xB2C9             UXTB     R1,R1
   \       0x2C   0x2900             CMP      R1,#+0
   \       0x2E   0xD107             BNE.N    ??HAL_FLASH_OB_Launch_3
    913            {
    914              /* Set OPTSTRT Bit */
    915              SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTSTART);
   \       0x30   0x....             LDR.N    R0,??DataTable11_2
   \       0x32   0x6801             LDR      R1,[R0, #+0]
   \       0x34   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x38   0x6001             STR      R1,[R0, #+0]
    916          
    917              /* Wait for OB change operation to be completed */
    918              status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \       0x3A   0x0020             MOVS     R0,R4
   \       0x3C   0x.... 0x....      BL       FLASH_OB_WaitForLastOperation
    919            }
    920          
    921            return status;
   \                     ??HAL_FLASH_OB_Launch_3: (+1)
   \       0x40   0xB2C0             UXTB     R0,R0
   \       0x42   0xBD10             POP      {R4,PC}
    922          }
    923          
    924          /**
    925            * @}
    926            */
    927          
    928          /** @defgroup FLASH_Exported_Functions_Group3 Peripheral State and Errors functions
    929           *  @brief   Peripheral Errors functions
    930           *
    931          @verbatim
    932           ===============================================================================
    933                          ##### Peripheral Errors functions #####
    934           ===============================================================================
    935              [..]
    936              This subsection permits to get in run-time Errors of the FLASH peripheral.
    937          
    938          @endverbatim
    939            * @{
    940            */
    941          
    942          /**
    943            * @brief  Get the specific FLASH error flag.
    944            * @retval HAL_FLASH_ERRORCode The returned value can be:
    945            *            @arg HAL_FLASH_ERROR_NONE       : No error set
    946            *
    947            *            @arg HAL_FLASH_ERROR_WRP_BANK1  : Write Protection Error on Bank 1
    948            *            @arg HAL_FLASH_ERROR_PGS_BANK1  : Program Sequence Error on Bank 1
    949            *            @arg HAL_FLASH_ERROR_STRB_BANK1 : Strobe Error on Bank 1
    950            *            @arg HAL_FLASH_ERROR_INC_BANK1  : Inconsistency Error on Bank 1
    951            *            @arg HAL_FLASH_ERROR_OPE_BANK1  : Operation Error on Bank 1
    952            *            @arg HAL_FLASH_ERROR_RDP_BANK1  : Read Protection Error on Bank 1
    953            *            @arg HAL_FLASH_ERROR_RDS_BANK1  : Read Secured Error on Bank 1
    954            *            @arg HAL_FLASH_ERROR_SNECC_BANK1: ECC Single Correction Error on Bank 1
    955            *            @arg HAL_FLASH_ERROR_DBECC_BANK1: ECC Double Detection Error on Bank 1
    956            *            @arg HAL_FLASH_ERROR_CRCRD_BANK1: CRC Read Error on Bank 1
    957            *
    958            *            @arg HAL_FLASH_ERROR_WRP_BANK2  : Write Protection Error on Bank 2
    959            *            @arg HAL_FLASH_ERROR_PGS_BANK2  : Program Sequence Error on Bank 2
    960            *            @arg HAL_FLASH_ERROR_STRB_BANK2 : Strobe Error on Bank 2
    961            *            @arg HAL_FLASH_ERROR_INC_BANK2  : Inconsistency Error on Bank 2
    962            *            @arg HAL_FLASH_ERROR_OPE_BANK2  : Operation Error on Bank 2
    963            *            @arg HAL_FLASH_ERROR_RDP_BANK2  : Read Protection Error on Bank 2
    964            *            @arg HAL_FLASH_ERROR_RDS_BANK2  : Read Secured Error on Bank 2
    965            *            @arg HAL_FLASH_ERROR_SNECC_BANK2: SNECC Error on Bank 2
    966            *            @arg HAL_FLASH_ERROR_DBECC_BANK2: Double Detection ECC on Bank 2
    967            *            @arg HAL_FLASH_ERROR_CRCRD_BANK2: CRC Read Error on Bank 2
    968          */
    969          

   \                                 In section .text, align 2, keep-with-next
    970          uint32_t HAL_FLASH_GetError(void)
    971          {
    972             return pFlash.ErrorCode;
   \                     HAL_FLASH_GetError: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable11
   \        0x2   0x6980             LDR      R0,[R0, #+24]
   \        0x4   0x4770             BX       LR
    973          }
    974          
    975          /**
    976            * @}
    977            */
    978          
    979          /**
    980            * @}
    981            */
    982          
    983          /* Private functions ---------------------------------------------------------*/
    984          
    985          /** @addtogroup FLASH_Private_Functions
    986            * @{
    987            */
    988          
    989          /**
    990            * @brief  Wait for a FLASH operation to complete.
    991            * @param  Timeout maximum flash operation timeout
    992            * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
    993            * @retval HAL_StatusTypeDef HAL Status
    994            */

   \                                 In section .text, align 2, keep-with-next
    995          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
    996          {
   \                     FLASH_WaitForLastOperation: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    997            /* Wait for the FLASH operation to complete by polling on QW flag to be reset.
    998               Even if the FLASH operation fails, the QW flag will be reset and an error
    999               flag will be set */
   1000          
   1001            uint32_t bsyflag = FLASH_FLAG_QW_BANK1;
   \        0x6   0x2604             MOVS     R6,#+4
   1002            uint32_t errorflag = 0;
   \        0x8   0x2000             MOVS     R0,#+0
   1003            uint32_t tickstart = HAL_GetTick();
   \        0xA   0x.... 0x....      BL       HAL_GetTick
   \        0xE   0x0007             MOVS     R7,R0
   1004          
   1005            assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
   1006          
   1007          #if defined (DUAL_BANK)
   1008          
   1009            if (Bank == FLASH_BANK_2)
   \       0x10   0x2D02             CMP      R5,#+2
   \       0x12   0xD100             BNE.N    ??FLASH_WaitForLastOperation_0
   1010            {
   1011              /* Select bsyflag depending on Bank */
   1012              bsyflag = FLASH_FLAG_QW_BANK2;
   \       0x14   0x....             LDR.N    R6,??DataTable11_16
   1013            }
   1014          #endif /* DUAL_BANK */
   1015          
   1016            while(__HAL_FLASH_GET_FLAG(bsyflag))
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \       0x16   0x....             LDR.N    R1,??DataTable11_17
   \       0x18   0xEA11 0x0006      ANDS     R0,R1,R6
   \       0x1C   0x42B0             CMP      R0,R6
   \       0x1E   0xD108             BNE.N    ??FLASH_WaitForLastOperation_1
   \       0x20   0x....             LDR.N    R0,??DataTable11_5
   \       0x22   0x6800             LDR      R0,[R0, #+0]
   \       0x24   0x4030             ANDS     R0,R6,R0
   \       0x26   0x42B0             CMP      R0,R6
   \       0x28   0xD101             BNE.N    ??FLASH_WaitForLastOperation_2
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE00D             B.N      ??FLASH_WaitForLastOperation_3
   \                     ??FLASH_WaitForLastOperation_2: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xE00B             B.N      ??FLASH_WaitForLastOperation_3
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \       0x32   0x....             LDR.N    R0,??DataTable11_7
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0x4030             ANDS     R0,R6,R0
   \       0x38   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \       0x3C   0xF026 0x4200      BIC      R2,R6,#0x80000000
   \       0x40   0x4290             CMP      R0,R2
   \       0x42   0xD101             BNE.N    ??FLASH_WaitForLastOperation_4
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xE000             B.N      ??FLASH_WaitForLastOperation_3
   \                     ??FLASH_WaitForLastOperation_4: (+1)
   \       0x48   0x2000             MOVS     R0,#+0
   \                     ??FLASH_WaitForLastOperation_3: (+1)
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD00B             BEQ.N    ??FLASH_WaitForLastOperation_5
   1017            {
   1018              if(Timeout != HAL_MAX_DELAY)
   \       0x4E   0xF114 0x0F01      CMN      R4,#+1
   \       0x52   0xD0E0             BEQ.N    ??FLASH_WaitForLastOperation_0
   1019              {
   1020                if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   \       0x54   0x.... 0x....      BL       HAL_GetTick
   \       0x58   0x1BC0             SUBS     R0,R0,R7
   \       0x5A   0x4284             CMP      R4,R0
   \       0x5C   0xD301             BCC.N    ??FLASH_WaitForLastOperation_6
   \       0x5E   0x2C00             CMP      R4,#+0
   \       0x60   0xD1D9             BNE.N    ??FLASH_WaitForLastOperation_0
   1021                {
   1022                  return HAL_TIMEOUT;
   \                     ??FLASH_WaitForLastOperation_6: (+1)
   \       0x62   0x2003             MOVS     R0,#+3
   \       0x64   0xE032             B.N      ??FLASH_WaitForLastOperation_7
   1023                }
   1024              }
   1025            }
   1026          
   1027            /* Get Error Flags */
   1028            if (Bank == FLASH_BANK_1)
   \                     ??FLASH_WaitForLastOperation_5: (+1)
   \       0x66   0x2D01             CMP      R5,#+1
   \       0x68   0xD104             BNE.N    ??FLASH_WaitForLastOperation_8
   1029            {
   1030              errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
   \       0x6A   0x....             LDR.N    R0,??DataTable11_5
   \       0x6C   0x6802             LDR      R2,[R0, #+0]
   \       0x6E   0x....             LDR.N    R0,??DataTable11_18
   \       0x70   0x4002             ANDS     R2,R0,R2
   \       0x72   0xE005             B.N      ??FLASH_WaitForLastOperation_9
   1031            }
   1032          #if defined (DUAL_BANK)
   1033            else
   1034            {
   1035              errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
   \                     ??FLASH_WaitForLastOperation_8: (+1)
   \       0x74   0x....             LDR.N    R0,??DataTable11_7
   \       0x76   0x6802             LDR      R2,[R0, #+0]
   \       0x78   0x....             LDR.N    R0,??DataTable11_19
   \       0x7A   0x4002             ANDS     R2,R0,R2
   \       0x7C   0xF052 0x4200      ORRS     R2,R2,#0x80000000
   1036            }
   1037          #endif /* DUAL_BANK */
   1038          
   1039            /* In case of error reported in Flash SR1 or SR2 register */
   1040            if((errorflag & 0x7FFFFFFFU) != 0U)
   \                     ??FLASH_WaitForLastOperation_9: (+1)
   \       0x80   0x0050             LSLS     R0,R2,#+1
   \       0x82   0xD00F             BEQ.N    ??FLASH_WaitForLastOperation_10
   1041            {
   1042              /*Save the error code*/
   1043              pFlash.ErrorCode |= errorflag;
   \       0x84   0x....             LDR.N    R0,??DataTable11
   \       0x86   0x6983             LDR      R3,[R0, #+24]
   \       0x88   0x4313             ORRS     R3,R2,R3
   \       0x8A   0x6183             STR      R3,[R0, #+24]
   1044          
   1045              /* Clear error programming flags */
   1046              __HAL_FLASH_CLEAR_FLAG(errorflag);
   \       0x8C   0x4011             ANDS     R1,R1,R2
   \       0x8E   0x4291             CMP      R1,R2
   \       0x90   0xD102             BNE.N    ??FLASH_WaitForLastOperation_11
   \       0x92   0x....             LDR.N    R0,??DataTable11_6
   \       0x94   0x6002             STR      R2,[R0, #+0]
   \       0x96   0xE003             B.N      ??FLASH_WaitForLastOperation_12
   \                     ??FLASH_WaitForLastOperation_11: (+1)
   \       0x98   0xF022 0x4200      BIC      R2,R2,#0x80000000
   \       0x9C   0x....             LDR.N    R0,??DataTable11_8
   \       0x9E   0x6002             STR      R2,[R0, #+0]
   1047          
   1048              return HAL_ERROR;
   \                     ??FLASH_WaitForLastOperation_12: (+1)
   \       0xA0   0x2001             MOVS     R0,#+1
   \       0xA2   0xE013             B.N      ??FLASH_WaitForLastOperation_7
   1049            }
   1050          
   1051            /* Check FLASH End of Operation flag  */
   1052            if(Bank == FLASH_BANK_1)
   \                     ??FLASH_WaitForLastOperation_10: (+1)
   \       0xA4   0x2D01             CMP      R5,#+1
   \       0xA6   0xD108             BNE.N    ??FLASH_WaitForLastOperation_13
   1053            {
   1054              if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
   \       0xA8   0x....             LDR.N    R0,??DataTable11_5
   \       0xAA   0x6800             LDR      R0,[R0, #+0]
   \       0xAC   0x03C0             LSLS     R0,R0,#+15
   \       0xAE   0xD50C             BPL.N    ??FLASH_WaitForLastOperation_14
   1055              {
   1056                /* Clear FLASH End of Operation pending bit */
   1057                __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
   \       0xB0   0xF45F 0x3080      MOVS     R0,#+65536
   \       0xB4   0x....             LDR.N    R1,??DataTable11_6
   \       0xB6   0x6008             STR      R0,[R1, #+0]
   \       0xB8   0xE007             B.N      ??FLASH_WaitForLastOperation_14
   1058              }
   1059            }
   1060          #if defined (DUAL_BANK)
   1061            else
   1062            {
   1063              if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
   \                     ??FLASH_WaitForLastOperation_13: (+1)
   \       0xBA   0x....             LDR.N    R0,??DataTable11_7
   \       0xBC   0x6800             LDR      R0,[R0, #+0]
   \       0xBE   0x03C0             LSLS     R0,R0,#+15
   \       0xC0   0xD503             BPL.N    ??FLASH_WaitForLastOperation_14
   1064              {
   1065                /* Clear FLASH End of Operation pending bit */
   1066                __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
   \       0xC2   0xF45F 0x3080      MOVS     R0,#+65536
   \       0xC6   0x....             LDR.N    R1,??DataTable11_8
   \       0xC8   0x6008             STR      R0,[R1, #+0]
   1067              }
   1068            }
   1069          #endif /* DUAL_BANK */
   1070          
   1071            return HAL_OK;
   \                     ??FLASH_WaitForLastOperation_14: (+1)
   \       0xCA   0x2000             MOVS     R0,#+0
   \                     ??FLASH_WaitForLastOperation_7: (+1)
   \       0xCC   0xBDF2             POP      {R1,R4-R7,PC}
   1072          }
   1073          
   1074          /**
   1075            * @brief  Wait for a FLASH Option Bytes change operation to complete.
   1076            * @param  Timeout maximum flash operation timeout
   1077            * @retval HAL_StatusTypeDef HAL Status
   1078            */

   \                                 In section .text, align 2, keep-with-next
   1079          HAL_StatusTypeDef FLASH_OB_WaitForLastOperation(uint32_t Timeout)
   1080          {
   \                     FLASH_OB_WaitForLastOperation: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1081            /* Get timeout */
   1082            uint32_t tickstart = HAL_GetTick();
   \        0x4   0x.... 0x....      BL       HAL_GetTick
   \        0x8   0x0005             MOVS     R5,R0
   1083          
   1084            /* Wait for the FLASH Option Bytes change operation to complete by polling on OPT_BUSY flag to be reset */
   1085            while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
   \                     ??FLASH_OB_WaitForLastOperation_0: (+1)
   \        0xA   0x....             LDR.N    R0,??DataTable11_20
   \        0xC   0x6801             LDR      R1,[R0, #+0]
   \        0xE   0x07C9             LSLS     R1,R1,#+31
   \       0x10   0xD50B             BPL.N    ??FLASH_OB_WaitForLastOperation_1
   1086            {
   1087              if(Timeout != HAL_MAX_DELAY)
   \       0x12   0xF114 0x0F01      CMN      R4,#+1
   \       0x16   0xD0F8             BEQ.N    ??FLASH_OB_WaitForLastOperation_0
   1088              {
   1089                if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   \       0x18   0x.... 0x....      BL       HAL_GetTick
   \       0x1C   0x1B40             SUBS     R0,R0,R5
   \       0x1E   0x4284             CMP      R4,R0
   \       0x20   0xD301             BCC.N    ??FLASH_OB_WaitForLastOperation_2
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD1F1             BNE.N    ??FLASH_OB_WaitForLastOperation_0
   1090                {
   1091                  return HAL_TIMEOUT;
   \                     ??FLASH_OB_WaitForLastOperation_2: (+1)
   \       0x26   0x2003             MOVS     R0,#+3
   \       0x28   0xE00F             B.N      ??FLASH_OB_WaitForLastOperation_3
   1092                }
   1093              }
   1094            }
   1095          
   1096            /* Check option byte change error */
   1097            if(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPTCHANGEERR) != 0U)
   \                     ??FLASH_OB_WaitForLastOperation_1: (+1)
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0x0040             LSLS     R0,R0,#+1
   \       0x2E   0xD50B             BPL.N    ??FLASH_OB_WaitForLastOperation_4
   1098            {
   1099              /* Save the error code */
   1100              pFlash.ErrorCode |= HAL_FLASH_ERROR_OB_CHANGE;
   \       0x30   0x....             LDR.N    R0,??DataTable11
   \       0x32   0x6981             LDR      R1,[R0, #+24]
   \       0x34   0xF051 0x4180      ORRS     R1,R1,#0x40000000
   \       0x38   0x6181             STR      R1,[R0, #+24]
   1101          
   1102              /* Clear the OB error flag */
   1103              FLASH->OPTCCR |= FLASH_OPTCCR_CLR_OPTCHANGEERR;
   \       0x3A   0x....             LDR.N    R0,??DataTable11_21
   \       0x3C   0x6801             LDR      R1,[R0, #+0]
   \       0x3E   0xF051 0x4180      ORRS     R1,R1,#0x40000000
   \       0x42   0x6001             STR      R1,[R0, #+0]
   1104          
   1105              return HAL_ERROR;
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xE000             B.N      ??FLASH_OB_WaitForLastOperation_3
   1106            }
   1107          
   1108            /* If there is no error flag set */
   1109            return HAL_OK;
   \                     ??FLASH_OB_WaitForLastOperation_4: (+1)
   \       0x48   0x2000             MOVS     R0,#+0
   \                     ??FLASH_OB_WaitForLastOperation_3: (+1)
   \       0x4A   0xBD32             POP      {R1,R4,R5,PC}
   1110          }
   1111          
   1112          /**
   1113            * @brief  Wait for a FLASH CRC computation to complete.
   1114            * @param  Timeout maximum flash operation timeout
   1115            * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
   1116            * @retval HAL_StatusTypeDef HAL Status
   1117            */

   \                                 In section .text, align 2, keep-with-next
   1118          HAL_StatusTypeDef FLASH_CRC_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
   1119          {
   \                     FLASH_CRC_WaitForLastOperation: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1120            uint32_t bsyflag;
   1121            uint32_t tickstart = HAL_GetTick();
   \        0x6   0x.... 0x....      BL       HAL_GetTick
   \        0xA   0x0006             MOVS     R6,R0
   1122          
   1123            assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
   1124          
   1125            /* Select bsyflag depending on Bank */
   1126            if(Bank == FLASH_BANK_1)
   \        0xC   0x2D01             CMP      R5,#+1
   \        0xE   0xD101             BNE.N    ??FLASH_CRC_WaitForLastOperation_0
   1127            {
   1128              bsyflag = FLASH_FLAG_CRC_BUSY_BANK1;
   \       0x10   0x2708             MOVS     R7,#+8
   \       0x12   0xE000             B.N      ??FLASH_CRC_WaitForLastOperation_1
   1129            }
   1130            else
   1131            {
   1132              bsyflag = FLASH_FLAG_CRC_BUSY_BANK2;
   \                     ??FLASH_CRC_WaitForLastOperation_0: (+1)
   \       0x14   0x....             LDR.N    R7,??DataTable11_22
   1133            }
   1134          
   1135            /* Wait for the FLASH CRC computation to complete by polling on CRC_BUSY flag to be reset */
   1136            while(__HAL_FLASH_GET_FLAG(bsyflag))
   \                     ??FLASH_CRC_WaitForLastOperation_1: (+1)
   \       0x16   0x....             LDR.N    R0,??DataTable11_17
   \       0x18   0x4038             ANDS     R0,R0,R7
   \       0x1A   0x42B8             CMP      R0,R7
   \       0x1C   0xD108             BNE.N    ??FLASH_CRC_WaitForLastOperation_2
   \       0x1E   0x....             LDR.N    R0,??DataTable11_5
   \       0x20   0x6800             LDR      R0,[R0, #+0]
   \       0x22   0x4038             ANDS     R0,R7,R0
   \       0x24   0x42B8             CMP      R0,R7
   \       0x26   0xD101             BNE.N    ??FLASH_CRC_WaitForLastOperation_3
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE00D             B.N      ??FLASH_CRC_WaitForLastOperation_4
   \                     ??FLASH_CRC_WaitForLastOperation_3: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xE00B             B.N      ??FLASH_CRC_WaitForLastOperation_4
   \                     ??FLASH_CRC_WaitForLastOperation_2: (+1)
   \       0x30   0x....             LDR.N    R0,??DataTable11_7
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0x4038             ANDS     R0,R7,R0
   \       0x36   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \       0x3A   0xF027 0x4100      BIC      R1,R7,#0x80000000
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xD101             BNE.N    ??FLASH_CRC_WaitForLastOperation_5
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0xE000             B.N      ??FLASH_CRC_WaitForLastOperation_4
   \                     ??FLASH_CRC_WaitForLastOperation_5: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \                     ??FLASH_CRC_WaitForLastOperation_4: (+1)
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD00B             BEQ.N    ??FLASH_CRC_WaitForLastOperation_6
   1137            {
   1138              if(Timeout != HAL_MAX_DELAY)
   \       0x4C   0xF114 0x0F01      CMN      R4,#+1
   \       0x50   0xD0E1             BEQ.N    ??FLASH_CRC_WaitForLastOperation_1
   1139              {
   1140                if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   \       0x52   0x.... 0x....      BL       HAL_GetTick
   \       0x56   0x1B80             SUBS     R0,R0,R6
   \       0x58   0x4284             CMP      R4,R0
   \       0x5A   0xD301             BCC.N    ??FLASH_CRC_WaitForLastOperation_7
   \       0x5C   0x2C00             CMP      R4,#+0
   \       0x5E   0xD1DA             BNE.N    ??FLASH_CRC_WaitForLastOperation_1
   1141                {
   1142                  return HAL_TIMEOUT;
   \                     ??FLASH_CRC_WaitForLastOperation_7: (+1)
   \       0x60   0x2003             MOVS     R0,#+3
   \       0x62   0xE020             B.N      ??FLASH_CRC_WaitForLastOperation_8
   1143                }
   1144              }
   1145            }
   1146          
   1147            /* Check FLASH CRC read error flag  */
   1148            if(Bank == FLASH_BANK_1)
   \                     ??FLASH_CRC_WaitForLastOperation_6: (+1)
   \       0x64   0x2D01             CMP      R5,#+1
   \       0x66   0xD10E             BNE.N    ??FLASH_CRC_WaitForLastOperation_9
   1149            {
   1150              if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1))
   \       0x68   0x....             LDR.N    R0,??DataTable11_5
   \       0x6A   0x6800             LDR      R0,[R0, #+0]
   \       0x6C   0x00C0             LSLS     R0,R0,#+3
   \       0x6E   0xD519             BPL.N    ??FLASH_CRC_WaitForLastOperation_10
   1151              {
   1152                /* Save the error code */
   1153                pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK1;
   \       0x70   0x....             LDR.N    R0,??DataTable11
   \       0x72   0x6981             LDR      R1,[R0, #+24]
   \       0x74   0xF051 0x5180      ORRS     R1,R1,#0x10000000
   \       0x78   0x6181             STR      R1,[R0, #+24]
   1154          
   1155                /* Clear FLASH CRC read error pending bit */
   1156                __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1);
   \       0x7A   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0x7E   0x....             LDR.N    R1,??DataTable11_6
   \       0x80   0x6008             STR      R0,[R1, #+0]
   1157          
   1158                return HAL_ERROR;
   \       0x82   0x2001             MOVS     R0,#+1
   \       0x84   0xE00F             B.N      ??FLASH_CRC_WaitForLastOperation_8
   1159              }
   1160            }
   1161          #if defined (DUAL_BANK)
   1162            else
   1163            {
   1164              if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_CRCRDERR_BANK2))
   \                     ??FLASH_CRC_WaitForLastOperation_9: (+1)
   \       0x86   0x....             LDR.N    R0,??DataTable11_7
   \       0x88   0x6800             LDR      R0,[R0, #+0]
   \       0x8A   0x00C0             LSLS     R0,R0,#+3
   \       0x8C   0xD50A             BPL.N    ??FLASH_CRC_WaitForLastOperation_10
   1165              {
   1166                /* Save the error code */
   1167                pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK2;
   \       0x8E   0x....             LDR.N    R0,??DataTable11
   \       0x90   0x6981             LDR      R1,[R0, #+24]
   \       0x92   0xF051 0x4110      ORRS     R1,R1,#0x90000000
   \       0x96   0x6181             STR      R1,[R0, #+24]
   1168          
   1169                /* Clear FLASH CRC read error pending bit */
   1170                __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_CRCRDERR_BANK2);
   \       0x98   0xF05F 0x5080      MOVS     R0,#+268435456
   \       0x9C   0x....             LDR.N    R1,??DataTable11_8
   \       0x9E   0x6008             STR      R0,[R1, #+0]
   1171          
   1172                return HAL_ERROR;
   \       0xA0   0x2001             MOVS     R0,#+1
   \       0xA2   0xE000             B.N      ??FLASH_CRC_WaitForLastOperation_8
   1173              }
   1174            }
   1175          #endif /* DUAL_BANK */
   1176          
   1177            /* If there is no error flag set */
   1178            return HAL_OK;
   \                     ??FLASH_CRC_WaitForLastOperation_10: (+1)
   \       0xA4   0x2000             MOVS     R0,#+0
   \                     ??FLASH_CRC_WaitForLastOperation_8: (+1)
   \       0xA6   0xBDF2             POP      {R1,R4-R7,PC}
   1179          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x....'....        DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x08FF'F000        DC32     0x8fff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0x5200'2018        DC32     0x52002018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0x5200'200C        DC32     0x5200200c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0x5200'210C        DC32     0x5200210c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \        0x0   0x5200'2010        DC32     0x52002010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \        0x0   0x5200'2014        DC32     0x52002014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \        0x0   0x5200'2110        DC32     0x52002110

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \        0x0   0x5200'2114        DC32     0x52002114

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \        0x0   0x5200'2004        DC32     0x52002004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \        0x0   0x4567'0123        DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \        0x0   0xCDEF'89AB        DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \        0x0   0x5200'2104        DC32     0x52002104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \        0x0   0x5200'2008        DC32     0x52002008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \        0x0   0x0819'2A3B        DC32     0x8192a3b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \        0x0   0x4C5D'6E7F        DC32     0x4c5d6e7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \        0x0   0x8000'0004        DC32     0x80000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_17:
   \        0x0   0x1FAF'000F        DC32     0x1faf000f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_18:
   \        0x0   0x17AE'0000        DC32     0x17ae0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_19:
   \        0x0   0x97AE'0000        DC32     0x97ae0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_20:
   \        0x0   0x5200'201C        DC32     0x5200201c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_21:
   \        0x0   0x5200'2024        DC32     0x52002024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_22:
   \        0x0   0x8000'0008        DC32     0x80000008
   1180          
   1181          /**
   1182            * @}
   1183            */
   1184          
   1185          #endif /* HAL_FLASH_MODULE_ENABLED */
   1186          
   1187          /**
   1188            * @}
   1189            */
   1190          
   1191          /**
   1192            * @}
   1193            */
   1194          
   1195          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   FLASH_CRC_WaitForLastOperation
        24   -> HAL_GetTick
      16   FLASH_OB_WaitForLastOperation
        16   -> HAL_GetTick
      24   FLASH_WaitForLastOperation
        24   -> HAL_GetTick
       0   HAL_FLASH_EndOfOperationCallback
       0   HAL_FLASH_GetError
      24   HAL_FLASH_IRQHandler
        24   -> FLASH_Erase_Sector
        24   -> HAL_FLASH_EndOfOperationCallback
        24   -> HAL_FLASH_OperationErrorCallback
       0   HAL_FLASH_Lock
       8   HAL_FLASH_OB_Launch
         8   -> FLASH_CRC_WaitForLastOperation
         8   -> FLASH_OB_WaitForLastOperation
       0   HAL_FLASH_OB_Lock
       0   HAL_FLASH_OB_Unlock
       0   HAL_FLASH_OperationErrorCallback
      40   HAL_FLASH_Program
        40   -> FLASH_WaitForLastOperation
      40   HAL_FLASH_Program_IT
        40   -> FLASH_WaitForLastOperation
       0   HAL_FLASH_Unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_19
       4  ??DataTable11_2
       4  ??DataTable11_20
       4  ??DataTable11_21
       4  ??DataTable11_22
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
     168  FLASH_CRC_WaitForLastOperation
      76  FLASH_OB_WaitForLastOperation
     206  FLASH_WaitForLastOperation
       2  HAL_FLASH_EndOfOperationCallback
       6  HAL_FLASH_GetError
     538  HAL_FLASH_IRQHandler
      44  HAL_FLASH_Lock
      68  HAL_FLASH_OB_Launch
      24  HAL_FLASH_OB_Lock
      32  HAL_FLASH_OB_Unlock
       2  HAL_FLASH_OperationErrorCallback
     280  HAL_FLASH_Program
     260  HAL_FLASH_Program_IT
      68  HAL_FLASH_Unlock
      28  pFlash

 
    28 bytes in section .bss
 1'866 bytes in section .text
 
 1'862 bytes of CODE memory (+ 4 bytes shared)
    28 bytes of DATA memory

Errors: none
Warnings: none
