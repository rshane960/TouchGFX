###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         07/Feb/2022  20:39:50
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_rcc.c
#        [UTF-8]
#    Command line      =
#        -f
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_rcc.o.rsp
#        (D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_rcc.c
#        -D USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver
#        -lA
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver
#        -o
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Core/Inc\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/App\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_rcc.o.d
#    Locale            =  C
#    List file         =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_rcc.lst
#    Object file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_rcc.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32h7xx_hal_rcc.c
      4            * @author  MCD Application Team
      5            * @brief   RCC HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Reset and Clock Control (RCC) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + Peripheral Control functions
     10            *
     11            @verbatim
     12            ==============================================================================
     13                                ##### RCC specific features #####
     14            ==============================================================================
     15              [..]
     16                After reset the device is running from Internal High Speed oscillator
     17                (HSI 64MHz) with Flash 0 wait state,and all peripherals are off except
     18                internal SRAM, Flash, JTAG and PWR
     19                (+) There is no pre-scaler on High speed (AHB) and Low speed (APB) buses;
     20                    all peripherals mapped on these buses are running at HSI speed.
     21                (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
     22                (+) All GPIOs are in analogue mode , except the JTAG pins which
     23                    are assigned to be used for debug purpose.
     24          
     25              [..]
     26                Once the device started from reset, the user application has to:
     27                (+) Configure the clock source to be used to drive the System clock
     28                    (if the application needs higher frequency/performance)
     29                (+) Configure the System clock frequency and Flash settings
     30                (+) Configure the AHB and APB buses pre-scalers
     31                (+) Enable the clock for the peripheral(s) to be used
     32                (+) Configure the clock kernel source(s) for peripherals which clocks are not
     33                    derived from the System clock through :RCC_D1CCIPR,RCC_D2CCIP1R,RCC_D2CCIP2R
     34                    and RCC_D3CCIPR registers
     35          
     36                                ##### RCC Limitations #####
     37            ==============================================================================
     38              [..]
     39                A delay between an RCC peripheral clock enable and the effective peripheral
     40                enabling should be taken into account in order to manage the peripheral read/write
     41                from/to registers.
     42                (+) This delay depends on the peripheral mapping.
     43                (+) If peripheral is mapped on AHB: the delay is 2 AHB clock cycle
     44                    after the clock enable bit is set on the hardware register
     45                (+) If peripheral is mapped on APB: the delay is 2 APB clock cycle
     46                    after the clock enable bit is set on the hardware register
     47          
     48              [..]
     49                Implemented Workaround:
     50                (+) For AHB & APB peripherals, a dummy read to the peripheral register has been
     51                    inserted in each __HAL_RCC_PPP_CLK_ENABLE() macro.
     52          
     53            @endverbatim
     54           ******************************************************************************
     55            * @attention
     56            *
     57            * Copyright (c) 2017 STMicroelectronics.
     58            * All rights reserved.
     59            *
     60            * This software is licensed under terms that can be found in the LICENSE file in
     61            * the root directory of this software component.
     62            * If no LICENSE file comes with this software, it is provided AS-IS.
     63            ******************************************************************************
     64            */
     65          
     66          /* Includes ------------------------------------------------------------------*/
     67          #include "stm32h7xx_hal.h"
     68          
     69          /** @addtogroup STM32H7xx_HAL_Driver
     70            * @{
     71            */
     72          
     73          /** @defgroup RCC  RCC
     74            * @brief RCC HAL module driver
     75            * @{
     76            */
     77          
     78          #ifdef HAL_RCC_MODULE_ENABLED
     79          
     80          /* Private typedef -----------------------------------------------------------*/
     81          /* Private define ------------------------------------------------------------*/
     82          /* Private macro -------------------------------------------------------------*/
     83          /** @defgroup RCC_Private_Macros RCC Private Macros
     84            * @{
     85            */
     86          #define MCO1_CLK_ENABLE()     __HAL_RCC_GPIOA_CLK_ENABLE()
     87          #define MCO1_GPIO_PORT        GPIOA
     88          #define MCO1_PIN              GPIO_PIN_8
     89          
     90          #define MCO2_CLK_ENABLE()      __HAL_RCC_GPIOC_CLK_ENABLE()
     91          #define MCO2_GPIO_PORT         GPIOC
     92          #define MCO2_PIN               GPIO_PIN_9
     93          
     94          /**
     95            * @}
     96            */
     97          /* Private variables ---------------------------------------------------------*/
     98          /** @defgroup RCC_Private_Variables RCC Private Variables
     99            * @{
    100            */
    101          
    102          /**
    103            * @}
    104            */
    105          /* Private function prototypes -----------------------------------------------*/
    106          /* Exported functions --------------------------------------------------------*/
    107          
    108          /** @defgroup RCC_Exported_Functions RCC Exported Functions
    109            * @{
    110            */
    111          
    112          /** @defgroup RCC_Exported_Functions_Group1 Initialization and de-initialization functions
    113           *  @brief    Initialization and Configuration functions
    114           *
    115          @verbatim
    116           ===============================================================================
    117                     ##### Initialization and de-initialization functions #####
    118           ===============================================================================
    119              [..]
    120                This section provides functions allowing to configure the internal/external oscillators
    121                (HSE, HSI, LSE,CSI, LSI,HSI48, PLL, CSS and MCO) and the System buses clocks (SYSCLK, AHB3, AHB1
    122                 AHB2,AHB4,APB3, APB1L, APB1H, APB2, and APB4).
    123          
    124              [..] Internal/external clock and PLL configuration
    125                   (#) HSI (high-speed internal), 64 MHz factory-trimmed RC used directly or through
    126                       the PLL as System clock source.
    127                   (#) CSI is a low-power RC oscillator which can be used directly as system clock, peripheral
    128                       clock, or PLL input.But even with frequency calibration, is less accurate than an
    129                       external crystal oscillator or ceramic resonator.
    130                   (#) LSI (low-speed internal), 32 KHz low consumption RC used as IWDG and/or RTC
    131                       clock source.
    132          
    133                   (#) HSE (high-speed external), 4 to 48 MHz crystal oscillator used directly or
    134                       through the PLL as System clock source. Can be used also as RTC clock source.
    135          
    136                   (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.
    137          
    138                   (#) PLL , The RCC features three independent PLLs (clocked by HSI , HSE or CSI),
    139                       featuring three different output clocks and able  to work either in integer or Fractional mode.
    140                     (++) A main PLL, PLL1, which is generally used to provide clocks to the CPU
    141                          and to some peripherals.
    142                     (++) Two dedicated PLLs, PLL2 and PLL3, which are used to generate the kernel clock for peripherals.
    143          
    144          
    145                   (#) CSS (Clock security system), once enabled and if a HSE clock failure occurs
    146                      (HSE used directly or through PLL as System clock source), the System clock
    147                       is automatically switched to HSI and an interrupt is generated if enabled.
    148                       The interrupt is linked to the Cortex-M NMI (Non-Mask-able Interrupt)
    149                       exception vector.
    150          
    151                   (#) MCO1 (micro controller clock output), used to output HSI, LSE, HSE, PLL1(PLL1_Q)
    152                       or HSI48 clock (through a configurable pre-scaler) on PA8 pin.
    153          
    154                   (#) MCO2 (micro controller clock output), used to output HSE, PLL2(PLL2_P), SYSCLK,
    155                       LSI, CSI, or PLL1(PLL1_P) clock (through a configurable pre-scaler) on PC9 pin.
    156          
    157              [..] System, AHB and APB buses clocks configuration
    158                   (#) Several clock sources can be used to drive the System clock (SYSCLK): CSI,HSI,
    159                       HSE and PLL.
    160                       The AHB clock (HCLK) is derived from System core clock through configurable
    161                       pre-scaler and used to clock the CPU, memory and peripherals mapped
    162                       on AHB and APB bus of the 3 Domains (D1, D2, D3)* through configurable pre-scalers
    163                       and used to clock the peripherals mapped on these buses. You can use
    164                       "HAL_RCC_GetSysClockFreq()" function to retrieve system clock frequency.
    165          
    166                   -@- All the peripheral clocks are derived from the System clock (SYSCLK) except those
    167                       with dual clock domain where kernel source clock could be selected through
    168                       RCC_D1CCIPR,RCC_D2CCIP1R,RCC_D2CCIP2R and RCC_D3CCIPR registers.
    169          
    170               (*) : 2 Domains (CD and SRD) for stm32h7a3xx and stm32h7b3xx family lines.
    171          @endverbatim
    172            * @{
    173            */
    174          
    175          /**
    176            * @brief  Resets the RCC clock configuration to the default reset state.
    177            * @note   The default reset state of the clock configuration is given below:
    178            *            - HSI ON and used as system clock source
    179            *            - HSE, PLL1, PLL2 and PLL3 OFF
    180            *            - AHB, APB Bus pre-scaler set to 1.
    181            *            - CSS, MCO1 and MCO2 OFF
    182            *            - All interrupts disabled
    183            * @note   This function doesn't modify the configuration of the
    184            *            - Peripheral clocks
    185            *            - LSI, LSE and RTC clocks
    186            * @retval HAL status
    187            */

   \                                 In section .text, align 2, keep-with-next
    188          HAL_StatusTypeDef HAL_RCC_DeInit(void)
    189          {
   \                     HAL_RCC_DeInit: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    190            uint32_t tickstart;
    191          
    192                  /* Increasing the CPU frequency */
    193            if(FLASH_LATENCY_DEFAULT  > __HAL_FLASH_GET_LATENCY())
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable11
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0xF010 0x000F      ANDS     R0,R0,#0xF
   \        0xC   0x2803             CMP      R0,#+3
   \        0xE   0xD20B             BCS.N    ??HAL_RCC_DeInit_0
    194            {
    195              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    196              __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);
   \       0x10   0x2003             MOVS     R0,#+3
   \       0x12   0x6821             LDR      R1,[R4, #+0]
   \       0x14   0xF360 0x0103      BFI      R1,R0,#+0,#+4
   \       0x18   0x6021             STR      R1,[R4, #+0]
    197          
    198              /* Check that the new number of wait states is taken into account to access the Flash
    199              memory by reading the FLASH_ACR register */
    200              if(__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x20   0x2803             CMP      R0,#+3
   \       0x22   0xD001             BEQ.N    ??HAL_RCC_DeInit_0
    201              {
    202                return HAL_ERROR;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xE0D8             B.N      ??HAL_RCC_DeInit_1
    203              }
    204          
    205            }
    206          
    207          
    208            /* Get Start Tick */
    209            tickstart = HAL_GetTick();
   \                     ??HAL_RCC_DeInit_0: (+1)
   \       0x28   0x.... 0x....      BL       HAL_GetTick
   \       0x2C   0x0006             MOVS     R6,R0
    210          
    211            /* Set HSION bit */
    212            SET_BIT(RCC->CR, RCC_CR_HSION);
   \       0x2E   0x.... 0x....      LDR.W    R5,??DataTable11_1
   \       0x32   0x6828             LDR      R0,[R5, #+0]
   \       0x34   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x38   0x6028             STR      R0,[R5, #+0]
    213          
    214            /* Wait till HSI is ready */
    215            while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
   \                     ??HAL_RCC_DeInit_2: (+1)
   \       0x3A   0x6828             LDR      R0,[R5, #+0]
   \       0x3C   0x0740             LSLS     R0,R0,#+29
   \       0x3E   0xD406             BMI.N    ??HAL_RCC_DeInit_3
    216            {
    217              if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
   \       0x40   0x.... 0x....      BL       HAL_GetTick
   \       0x44   0x1B80             SUBS     R0,R0,R6
   \       0x46   0x2803             CMP      R0,#+3
   \       0x48   0xD3F7             BCC.N    ??HAL_RCC_DeInit_2
    218              {
    219                return HAL_TIMEOUT;
   \       0x4A   0x2003             MOVS     R0,#+3
   \       0x4C   0xE0C5             B.N      ??HAL_RCC_DeInit_1
    220              }
    221            }
    222          
    223            /* Set HSITRIM[6:0] bits to the reset value */
    224            SET_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM_6);
   \                     ??HAL_RCC_DeInit_3: (+1)
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \       0x52   0x6801             LDR      R1,[R0, #+0]
   \       0x54   0xF051 0x4180      ORRS     R1,R1,#0x40000000
   \       0x58   0x6001             STR      R1,[R0, #+0]
    225          
    226            /* Reset CFGR register */
    227            CLEAR_REG(RCC->CFGR);
   \       0x5A   0x.... 0x....      LDR.W    R6,??DataTable11_3
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x6030             STR      R0,[R6, #+0]
    228          
    229            /* Update the SystemCoreClock and SystemD2Clock global variables */
    230            SystemCoreClock = HSI_VALUE;
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable11_4
   \       0x66   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \       0x6A   0x6008             STR      R0,[R1, #+0]
    231            SystemD2Clock = HSI_VALUE;
   \       0x6C   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \       0x70   0x6008             STR      R0,[R1, #+0]
    232          
    233            /* Adapt Systick interrupt period */
    234            if(HAL_InitTick(uwTickPrio) != HAL_OK)
   \       0x72   0x.... 0x....      LDR.W    R0,??DataTable11_7
   \       0x76   0x6800             LDR      R0,[R0, #+0]
   \       0x78   0x.... 0x....      BL       HAL_InitTick
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD001             BEQ.N    ??HAL_RCC_DeInit_4
    235            {
    236              return HAL_ERROR;
   \       0x80   0x2001             MOVS     R0,#+1
   \       0x82   0xE0AA             B.N      ??HAL_RCC_DeInit_1
    237            }
    238          
    239            /* Get Start Tick */
    240            tickstart = HAL_GetTick();
   \                     ??HAL_RCC_DeInit_4: (+1)
   \       0x84   0x.... 0x....      BL       HAL_GetTick
   \       0x88   0x0007             MOVS     R7,R0
    241          
    242            /* Wait till clock switch is ready */
    243            while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != 0U)
   \                     ??HAL_RCC_DeInit_5: (+1)
   \       0x8A   0x6830             LDR      R0,[R6, #+0]
   \       0x8C   0xF010 0x0F38      TST      R0,#0x38
   \       0x90   0xD008             BEQ.N    ??HAL_RCC_DeInit_6
    244            {
    245              if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
   \       0x92   0x.... 0x....      BL       HAL_GetTick
   \       0x96   0x1BC0             SUBS     R0,R0,R7
   \       0x98   0xF241 0x3189      MOVW     R1,#+5001
   \       0x9C   0x4288             CMP      R0,R1
   \       0x9E   0xD3F4             BCC.N    ??HAL_RCC_DeInit_5
    246              {
    247                return HAL_TIMEOUT;
   \       0xA0   0x2003             MOVS     R0,#+3
   \       0xA2   0xE09A             B.N      ??HAL_RCC_DeInit_1
    248              }
    249            }
    250          
    251            /* Get Start Tick */
    252            tickstart = HAL_GetTick();
   \                     ??HAL_RCC_DeInit_6: (+1)
   \       0xA4   0x.... 0x....      BL       HAL_GetTick
   \       0xA8   0x0006             MOVS     R6,R0
    253          
    254            /* Reset CSION, CSIKERON, HSEON, HSI48ON, HSECSSON, HSIDIV bits */
    255            CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSIKERON| RCC_CR_HSIDIV| RCC_CR_HSIDIVF| RCC_CR_CSION | RCC_CR_CSIKERON  \
    256            | RCC_CR_HSI48ON | RCC_CR_CSSHSEON);
   \       0xAA   0x6829             LDR      R1,[R5, #+0]
   \       0xAC   0x.... 0x....      LDR.W    R0,??DataTable11_8
   \       0xB0   0x4001             ANDS     R1,R0,R1
   \       0xB2   0x6029             STR      R1,[R5, #+0]
    257          
    258            /* Wait till HSE is disabled */
    259            while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
   \                     ??HAL_RCC_DeInit_7: (+1)
   \       0xB4   0x6828             LDR      R0,[R5, #+0]
   \       0xB6   0x0380             LSLS     R0,R0,#+14
   \       0xB8   0xD506             BPL.N    ??HAL_RCC_DeInit_8
    260            {
    261              if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
   \       0xBA   0x.... 0x....      BL       HAL_GetTick
   \       0xBE   0x1B80             SUBS     R0,R0,R6
   \       0xC0   0x2865             CMP      R0,#+101
   \       0xC2   0xD3F7             BCC.N    ??HAL_RCC_DeInit_7
    262              {
    263                return HAL_TIMEOUT;
   \       0xC4   0x2003             MOVS     R0,#+3
   \       0xC6   0xE088             B.N      ??HAL_RCC_DeInit_1
    264              }
    265            }
    266          
    267            /* Get Start Tick */
    268            tickstart = HAL_GetTick();
   \                     ??HAL_RCC_DeInit_8: (+1)
   \       0xC8   0x.... 0x....      BL       HAL_GetTick
   \       0xCC   0x0006             MOVS     R6,R0
    269          
    270            /* Clear PLLON bit */
    271            CLEAR_BIT(RCC->CR, RCC_CR_PLL1ON);
   \       0xCE   0x6828             LDR      R0,[R5, #+0]
   \       0xD0   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \       0xD4   0x6028             STR      R0,[R5, #+0]
    272          
    273            /* Wait till PLL is disabled */
    274            while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
   \                     ??HAL_RCC_DeInit_9: (+1)
   \       0xD6   0x6828             LDR      R0,[R5, #+0]
   \       0xD8   0x0180             LSLS     R0,R0,#+6
   \       0xDA   0xD506             BPL.N    ??HAL_RCC_DeInit_10
    275            {
    276              if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
   \       0xDC   0x.... 0x....      BL       HAL_GetTick
   \       0xE0   0x1B80             SUBS     R0,R0,R6
   \       0xE2   0x2803             CMP      R0,#+3
   \       0xE4   0xD3F7             BCC.N    ??HAL_RCC_DeInit_9
    277              {
    278                return HAL_TIMEOUT;
   \       0xE6   0x2003             MOVS     R0,#+3
   \       0xE8   0xE077             B.N      ??HAL_RCC_DeInit_1
    279              }
    280            }
    281          
    282            /* Get Start Tick */
    283            tickstart = HAL_GetTick();
   \                     ??HAL_RCC_DeInit_10: (+1)
   \       0xEA   0x.... 0x....      BL       HAL_GetTick
   \       0xEE   0x0006             MOVS     R6,R0
    284          
    285            /* Reset PLL2ON bit */
    286            CLEAR_BIT(RCC->CR, RCC_CR_PLL2ON);
   \       0xF0   0x6828             LDR      R0,[R5, #+0]
   \       0xF2   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \       0xF6   0x6028             STR      R0,[R5, #+0]
    287          
    288            /* Wait till PLL2 is disabled */
    289            while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)
   \                     ??HAL_RCC_DeInit_11: (+1)
   \       0xF8   0x6828             LDR      R0,[R5, #+0]
   \       0xFA   0x0100             LSLS     R0,R0,#+4
   \       0xFC   0xD506             BPL.N    ??HAL_RCC_DeInit_12
    290            {
    291              if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
   \       0xFE   0x.... 0x....      BL       HAL_GetTick
   \      0x102   0x1B80             SUBS     R0,R0,R6
   \      0x104   0x2803             CMP      R0,#+3
   \      0x106   0xD3F7             BCC.N    ??HAL_RCC_DeInit_11
    292              {
    293                return HAL_TIMEOUT;
   \      0x108   0x2003             MOVS     R0,#+3
   \      0x10A   0xE066             B.N      ??HAL_RCC_DeInit_1
    294              }
    295            }
    296          
    297            /* Get Start Tick */
    298            tickstart = HAL_GetTick();
   \                     ??HAL_RCC_DeInit_12: (+1)
   \      0x10C   0x.... 0x....      BL       HAL_GetTick
   \      0x110   0x0006             MOVS     R6,R0
    299          
    300            /* Reset PLL3 bit */
    301            CLEAR_BIT(RCC->CR, RCC_CR_PLL3ON);
   \      0x112   0x6828             LDR      R0,[R5, #+0]
   \      0x114   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \      0x118   0x6028             STR      R0,[R5, #+0]
    302          
    303            /* Wait till PLL3 is disabled */
    304            while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)
   \                     ??HAL_RCC_DeInit_13: (+1)
   \      0x11A   0x6828             LDR      R0,[R5, #+0]
   \      0x11C   0x0080             LSLS     R0,R0,#+2
   \      0x11E   0xD506             BPL.N    ??HAL_RCC_DeInit_14
    305            {
    306              if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
   \      0x120   0x.... 0x....      BL       HAL_GetTick
   \      0x124   0x1B80             SUBS     R0,R0,R6
   \      0x126   0x2803             CMP      R0,#+3
   \      0x128   0xD3F7             BCC.N    ??HAL_RCC_DeInit_13
    307              {
    308                return HAL_TIMEOUT;
   \      0x12A   0x2003             MOVS     R0,#+3
   \      0x12C   0xE055             B.N      ??HAL_RCC_DeInit_1
    309              }
    310            }
    311          
    312          #if defined(RCC_D1CFGR_HPRE)
    313            /* Reset D1CFGR register */
    314            CLEAR_REG(RCC->D1CFGR);
    315          
    316            /* Reset D2CFGR register */
    317            CLEAR_REG(RCC->D2CFGR);
    318          
    319            /* Reset D3CFGR register */
    320            CLEAR_REG(RCC->D3CFGR);
    321          #else
    322            /* Reset CDCFGR1 register */
    323            CLEAR_REG(RCC->CDCFGR1);
   \                     ??HAL_RCC_DeInit_14: (+1)
   \      0x12E   0x2000             MOVS     R0,#+0
   \      0x130   0x.... 0x....      LDR.W    R1,??DataTable11_9
   \      0x134   0x6008             STR      R0,[R1, #+0]
    324          
    325            /* Reset CDCFGR2 register */
    326            CLEAR_REG(RCC->CDCFGR2);
   \      0x136   0x2000             MOVS     R0,#+0
   \      0x138   0x.... 0x....      LDR.W    R1,??DataTable11_10
   \      0x13C   0x6008             STR      R0,[R1, #+0]
    327          
    328            /* Reset SRDCFGR register */
    329            CLEAR_REG(RCC->SRDCFGR);
   \      0x13E   0x2000             MOVS     R0,#+0
   \      0x140   0x.... 0x....      LDR.W    R1,??DataTable11_11
   \      0x144   0x6008             STR      R0,[R1, #+0]
    330          #endif
    331          
    332            /* Reset PLLCKSELR register to default value */
    333            RCC->PLLCKSELR= RCC_PLLCKSELR_DIVM1_5|RCC_PLLCKSELR_DIVM2_5|RCC_PLLCKSELR_DIVM3_5;
   \      0x146   0x.... 0x....      LDR.W    R0,??DataTable11_12
   \      0x14A   0x.... 0x....      LDR.W    R1,??DataTable11_13
   \      0x14E   0x6008             STR      R0,[R1, #+0]
    334          
    335            /* Reset PLLCFGR register to default value */
    336            WRITE_REG(RCC->PLLCFGR, 0x01FF0000U);
   \      0x150   0x.... 0x....      LDR.W    R0,??DataTable11_14
   \      0x154   0x.... 0x....      LDR.W    R1,??DataTable11_15
   \      0x158   0x6008             STR      R0,[R1, #+0]
    337          
    338            /* Reset PLL1DIVR register to default value */
    339            WRITE_REG(RCC->PLL1DIVR,0x01010280U);
   \      0x15A   0x.... 0x....      LDR.W    R0,??DataTable11_16
   \      0x15E   0x.... 0x....      LDR.W    R1,??DataTable11_17
   \      0x162   0x6008             STR      R0,[R1, #+0]
    340          
    341            /* Reset PLL1FRACR register */
    342            CLEAR_REG(RCC->PLL1FRACR);
   \      0x164   0x2100             MOVS     R1,#+0
   \      0x166   0x.... 0x....      LDR.W    R2,??DataTable11_18
   \      0x16A   0x6011             STR      R1,[R2, #+0]
    343          
    344            /* Reset PLL2DIVR register to default value */
    345            WRITE_REG(RCC->PLL2DIVR,0x01010280U);
   \      0x16C   0x.... 0x....      LDR.W    R1,??DataTable11_19
   \      0x170   0x6008             STR      R0,[R1, #+0]
    346          
    347            /* Reset PLL2FRACR register */
    348            CLEAR_REG(RCC->PLL2FRACR);
   \      0x172   0x2100             MOVS     R1,#+0
   \      0x174   0x.... 0x....      LDR.W    R2,??DataTable11_20
   \      0x178   0x6011             STR      R1,[R2, #+0]
    349          
    350            /* Reset PLL3DIVR register to default value */
    351            WRITE_REG(RCC->PLL3DIVR,0x01010280U);
   \      0x17A   0x.... 0x....      LDR.W    R1,??DataTable11_21
   \      0x17E   0x6008             STR      R0,[R1, #+0]
    352          
    353            /* Reset PLL3FRACR register */
    354            CLEAR_REG(RCC->PLL3FRACR);
   \      0x180   0x2000             MOVS     R0,#+0
   \      0x182   0x.... 0x....      LDR.W    R1,??DataTable11_22
   \      0x186   0x6008             STR      R0,[R1, #+0]
    355          
    356          #if defined(RCC_CR_HSEEXT)
    357            /* Reset HSEEXT  */
    358            CLEAR_BIT(RCC->CR, RCC_CR_HSEEXT);
   \      0x188   0x6828             LDR      R0,[R5, #+0]
   \      0x18A   0xF430 0x1080      BICS     R0,R0,#0x100000
   \      0x18E   0x6028             STR      R0,[R5, #+0]
    359          #endif /* RCC_CR_HSEEXT */
    360          
    361            /* Reset HSEBYP bit */
    362            CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
   \      0x190   0x6828             LDR      R0,[R5, #+0]
   \      0x192   0xF430 0x2080      BICS     R0,R0,#0x40000
   \      0x196   0x6028             STR      R0,[R5, #+0]
    363          
    364            /* Disable all interrupts */
    365            CLEAR_REG(RCC->CIER);
   \      0x198   0x2000             MOVS     R0,#+0
   \      0x19A   0x.... 0x....      LDR.W    R1,??DataTable11_23
   \      0x19E   0x6008             STR      R0,[R1, #+0]
    366          
    367            /* Clear all interrupts flags */
    368            WRITE_REG(RCC->CICR,0xFFFFFFFFU);
   \      0x1A0   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x1A4   0x.... 0x....      LDR.W    R1,??DataTable11_24
   \      0x1A8   0x6008             STR      R0,[R1, #+0]
    369          
    370            /* Reset all RSR flags */
    371            SET_BIT(RCC->RSR, RCC_RSR_RMVF);
   \      0x1AA   0x.... 0x....      LDR.W    R0,??DataTable11_25
   \      0x1AE   0x6801             LDR      R1,[R0, #+0]
   \      0x1B0   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \      0x1B4   0x6001             STR      R1,[R0, #+0]
    372          
    373                /* Decreasing the number of wait states because of lower CPU frequency */
    374            if(FLASH_LATENCY_DEFAULT  < __HAL_FLASH_GET_LATENCY())
   \      0x1B6   0x6820             LDR      R0,[R4, #+0]
   \      0x1B8   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x1BC   0x2804             CMP      R0,#+4
   \      0x1BE   0xD30B             BCC.N    ??HAL_RCC_DeInit_15
    375            {
    376              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    377              __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);
   \      0x1C0   0x2003             MOVS     R0,#+3
   \      0x1C2   0x6821             LDR      R1,[R4, #+0]
   \      0x1C4   0xF360 0x0103      BFI      R1,R0,#+0,#+4
   \      0x1C8   0x6021             STR      R1,[R4, #+0]
    378          
    379              /* Check that the new number of wait states is taken into account to access the Flash
    380              memory by reading the FLASH_ACR register */
    381              if(__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)
   \      0x1CA   0x6820             LDR      R0,[R4, #+0]
   \      0x1CC   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x1D0   0x2803             CMP      R0,#+3
   \      0x1D2   0xD001             BEQ.N    ??HAL_RCC_DeInit_15
    382              {
    383                return HAL_ERROR;
   \      0x1D4   0x2001             MOVS     R0,#+1
   \      0x1D6   0xE000             B.N      ??HAL_RCC_DeInit_1
    384              }
    385          
    386          }
    387          
    388            return HAL_OK;
   \                     ??HAL_RCC_DeInit_15: (+1)
   \      0x1D8   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_DeInit_1: (+1)
   \      0x1DA   0xBDF2             POP      {R1,R4-R7,PC}
    389          }
    390          
    391          /**
    392            * @brief  Initializes the RCC Oscillators according to the specified parameters in the
    393            *         RCC_OscInitTypeDef.
    394            * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that
    395            *         contains the configuration information for the RCC Oscillators.
    396            * @note   The PLL is not disabled when used as system clock.
    397            * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not
    398            *         supported by this function. User should request a transition to LSE Off
    399            *         first and then LSE On or LSE Bypass.
    400            * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not
    401            *         supported by this function. User should request a transition to HSE Off
    402            *         first and then HSE On or HSE Bypass.
    403            * @retval HAL status
    404            */

   \                                 In section .text, align 4
    405          __weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
    406          {
   \                     HAL_RCC_OscConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    407            uint32_t tickstart;
    408            uint32_t temp1_pllckcfg, temp2_pllckcfg;
    409          
    410              /* Check Null pointer */
    411            if(RCC_OscInitStruct == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_RCC_OscConfig_1
    412            {
    413              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE2E5             B.N      ??HAL_RCC_OscConfig_2
    414            }
    415          
    416            /* Check the parameters */
    417            assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
    418            /*------------------------------- HSE Configuration ------------------------*/
    419            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   \                     ??HAL_RCC_OscConfig_1: (+1)
   \        0xC   0x7820             LDRB     R0,[R4, #+0]
   \        0xE   0x07C0             LSLS     R0,R0,#+31
   \       0x10   0xF140 0x808C      BPL.W    ??HAL_RCC_OscConfig_3
    420            {
    421              /* Check the parameters */
    422              assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    423          
    424              const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
   \       0x14   0xF8DF 0x05C4      LDR.W    R0,??HAL_RCC_OscConfig_0
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0xF010 0x0038      ANDS     R0,R0,#0x38
    425              const uint32_t temp_pllckselr = RCC->PLLCKSELR;
   \       0x1E   0xF8DF 0x15C0      LDR.W    R1,??HAL_RCC_OscConfig_0+0x4
   \       0x22   0x6809             LDR      R1,[R1, #+0]
    426              /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    427              if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
   \       0x24   0x2810             CMP      R0,#+16
   \       0x26   0xD005             BEQ.N    ??HAL_RCC_OscConfig_4
   \       0x28   0x2818             CMP      R0,#+24
   \       0x2A   0xD10D             BNE.N    ??HAL_RCC_OscConfig_5
   \       0x2C   0xF011 0x0103      ANDS     R1,R1,#0x3
   \       0x30   0x2902             CMP      R1,#+2
   \       0x32   0xD109             BNE.N    ??HAL_RCC_OscConfig_5
    428              {
    429                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
   \                     ??HAL_RCC_OscConfig_4: (+1)
   \       0x34   0xF8DF 0x05AC      LDR.W    R0,??HAL_RCC_OscConfig_0+0x8
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0x0380             LSLS     R0,R0,#+14
   \       0x3C   0xD576             BPL.N    ??HAL_RCC_OscConfig_3
   \       0x3E   0x6860             LDR      R0,[R4, #+4]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD173             BNE.N    ??HAL_RCC_OscConfig_3
    430                {
    431                  return HAL_ERROR;
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xE2C7             B.N      ??HAL_RCC_OscConfig_2
    432                }
    433              }
    434              else
    435              {
    436                /* Set the new HSE configuration ---------------------------------------*/
    437                __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
   \                     ??HAL_RCC_OscConfig_5: (+1)
   \       0x48   0x6860             LDR      R0,[R4, #+4]
   \       0x4A   0xF5B0 0x3F80      CMP      R0,#+65536
   \       0x4E   0xD106             BNE.N    ??HAL_RCC_OscConfig_6
   \       0x50   0xF8DF 0x0590      LDR.W    R0,??HAL_RCC_OscConfig_0+0x8
   \       0x54   0x6801             LDR      R1,[R0, #+0]
   \       0x56   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \       0x5A   0x6001             STR      R1,[R0, #+0]
   \       0x5C   0xE045             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_6: (+1)
   \       0x5E   0x6860             LDR      R0,[R4, #+4]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD10E             BNE.N    ??HAL_RCC_OscConfig_8
   \       0x64   0xF8DF 0x057C      LDR.W    R0,??HAL_RCC_OscConfig_0+0x8
   \       0x68   0x6801             LDR      R1,[R0, #+0]
   \       0x6A   0xF431 0x3180      BICS     R1,R1,#0x10000
   \       0x6E   0x6001             STR      R1,[R0, #+0]
   \       0x70   0x6801             LDR      R1,[R0, #+0]
   \       0x72   0xF431 0x1180      BICS     R1,R1,#0x100000
   \       0x76   0x6001             STR      R1,[R0, #+0]
   \       0x78   0x6801             LDR      R1,[R0, #+0]
   \       0x7A   0xF431 0x2180      BICS     R1,R1,#0x40000
   \       0x7E   0x6001             STR      R1,[R0, #+0]
   \       0x80   0xE033             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_8: (+1)
   \       0x82   0x6860             LDR      R0,[R4, #+4]
   \       0x84   0xF5B0 0x2FA0      CMP      R0,#+327680
   \       0x88   0xD10E             BNE.N    ??HAL_RCC_OscConfig_9
   \       0x8A   0xF8DF 0x0558      LDR.W    R0,??HAL_RCC_OscConfig_0+0x8
   \       0x8E   0x6801             LDR      R1,[R0, #+0]
   \       0x90   0xF451 0x2180      ORRS     R1,R1,#0x40000
   \       0x94   0x6001             STR      R1,[R0, #+0]
   \       0x96   0x6801             LDR      R1,[R0, #+0]
   \       0x98   0xF431 0x1180      BICS     R1,R1,#0x100000
   \       0x9C   0x6001             STR      R1,[R0, #+0]
   \       0x9E   0x6801             LDR      R1,[R0, #+0]
   \       0xA0   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \       0xA4   0x6001             STR      R1,[R0, #+0]
   \       0xA6   0xE020             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_9: (+1)
   \       0xA8   0x6860             LDR      R0,[R4, #+4]
   \       0xAA   0xF5B0 0x1FA8      CMP      R0,#+1376256
   \       0xAE   0xD10E             BNE.N    ??HAL_RCC_OscConfig_10
   \       0xB0   0xF8DF 0x0530      LDR.W    R0,??HAL_RCC_OscConfig_0+0x8
   \       0xB4   0x6801             LDR      R1,[R0, #+0]
   \       0xB6   0xF451 0x2180      ORRS     R1,R1,#0x40000
   \       0xBA   0x6001             STR      R1,[R0, #+0]
   \       0xBC   0x6801             LDR      R1,[R0, #+0]
   \       0xBE   0xF451 0x1180      ORRS     R1,R1,#0x100000
   \       0xC2   0x6001             STR      R1,[R0, #+0]
   \       0xC4   0x6801             LDR      R1,[R0, #+0]
   \       0xC6   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \       0xCA   0x6001             STR      R1,[R0, #+0]
   \       0xCC   0xE00D             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_10: (+1)
   \       0xCE   0xF8DF 0x0514      LDR.W    R0,??HAL_RCC_OscConfig_0+0x8
   \       0xD2   0x6801             LDR      R1,[R0, #+0]
   \       0xD4   0xF431 0x3180      BICS     R1,R1,#0x10000
   \       0xD8   0x6001             STR      R1,[R0, #+0]
   \       0xDA   0x6801             LDR      R1,[R0, #+0]
   \       0xDC   0xF431 0x2180      BICS     R1,R1,#0x40000
   \       0xE0   0x6001             STR      R1,[R0, #+0]
   \       0xE2   0x6801             LDR      R1,[R0, #+0]
   \       0xE4   0xF431 0x1180      BICS     R1,R1,#0x100000
   \       0xE8   0x6001             STR      R1,[R0, #+0]
    438          
    439                /* Check the HSE State */
    440                if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
   \                     ??HAL_RCC_OscConfig_7: (+1)
   \       0xEA   0x6860             LDR      R0,[R4, #+4]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD00E             BEQ.N    ??HAL_RCC_OscConfig_11
    441                {
    442                  /* Get Start Tick*/
    443                  tickstart = HAL_GetTick();
   \       0xF0   0x.... 0x....      BL       HAL_GetTick
   \       0xF4   0x0005             MOVS     R5,R0
    444          
    445                  /* Wait till HSE is ready */
    446                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
   \                     ??HAL_RCC_OscConfig_12: (+1)
   \       0xF6   0xF8DF 0x04EC      LDR.W    R0,??HAL_RCC_OscConfig_0+0x8
   \       0xFA   0x6800             LDR      R0,[R0, #+0]
   \       0xFC   0x0380             LSLS     R0,R0,#+14
   \       0xFE   0xD415             BMI.N    ??HAL_RCC_OscConfig_3
    447                  {
    448                    if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
   \      0x100   0x.... 0x....      BL       HAL_GetTick
   \      0x104   0x1B40             SUBS     R0,R0,R5
   \      0x106   0x2865             CMP      R0,#+101
   \      0x108   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_12
    449                    {
    450                      return HAL_TIMEOUT;
   \      0x10A   0x2003             MOVS     R0,#+3
   \      0x10C   0xE264             B.N      ??HAL_RCC_OscConfig_2
    451                    }
    452                  }
    453                }
    454                else
    455                {
    456                  /* Get Start Tick*/
    457                  tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_11: (+1)
   \      0x10E   0x.... 0x....      BL       HAL_GetTick
   \      0x112   0x0005             MOVS     R5,R0
    458          
    459                  /* Wait till HSE is disabled */
    460                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
   \                     ??HAL_RCC_OscConfig_13: (+1)
   \      0x114   0xF8DF 0x04CC      LDR.W    R0,??HAL_RCC_OscConfig_0+0x8
   \      0x118   0x6800             LDR      R0,[R0, #+0]
   \      0x11A   0x0380             LSLS     R0,R0,#+14
   \      0x11C   0xD506             BPL.N    ??HAL_RCC_OscConfig_3
    461                  {
    462                    if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
   \      0x11E   0x.... 0x....      BL       HAL_GetTick
   \      0x122   0x1B40             SUBS     R0,R0,R5
   \      0x124   0x2865             CMP      R0,#+101
   \      0x126   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_13
    463                    {
    464                      return HAL_TIMEOUT;
   \      0x128   0x2003             MOVS     R0,#+3
   \      0x12A   0xE255             B.N      ??HAL_RCC_OscConfig_2
    465                    }
    466                  }
    467                }
    468              }
    469            }
    470            /*----------------------------- HSI Configuration --------------------------*/
    471            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   \                     ??HAL_RCC_OscConfig_3: (+1)
   \      0x12C   0x7820             LDRB     R0,[R4, #+0]
   \      0x12E   0x0780             LSLS     R0,R0,#+30
   \      0x130   0xD534             BPL.N    ??HAL_RCC_OscConfig_14
    472            {
    473              /* Check the parameters */
    474              assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    475              assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    476          
    477              /* When the HSI is used as system clock it will not be disabled */
    478              const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
   \      0x132   0xF8DF 0x04A8      LDR.W    R0,??HAL_RCC_OscConfig_0
   \      0x136   0x6800             LDR      R0,[R0, #+0]
   \      0x138   0xF010 0x0038      ANDS     R0,R0,#0x38
    479              const uint32_t temp_pllckselr = RCC->PLLCKSELR;
   \      0x13C   0xF8DF 0x14A0      LDR.W    R1,??HAL_RCC_OscConfig_0+0x4
   \      0x140   0x6809             LDR      R1,[R1, #+0]
    480              if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
   \      0x142   0x2800             CMP      R0,#+0
   \      0x144   0xD004             BEQ.N    ??HAL_RCC_OscConfig_15
   \      0x146   0x2818             CMP      R0,#+24
   \      0x148   0xD145             BNE.N    ??HAL_RCC_OscConfig_16
   \      0x14A   0xF011 0x0F03      TST      R1,#0x3
   \      0x14E   0xD142             BNE.N    ??HAL_RCC_OscConfig_16
    481              {
    482                /* When HSI is used as system clock it will not be disabled */
    483                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
   \                     ??HAL_RCC_OscConfig_15: (+1)
   \      0x150   0xF8DF 0x5490      LDR.W    R5,??HAL_RCC_OscConfig_0+0x8
   \      0x154   0x6828             LDR      R0,[R5, #+0]
   \      0x156   0x0740             LSLS     R0,R0,#+29
   \      0x158   0xD504             BPL.N    ??HAL_RCC_OscConfig_17
   \      0x15A   0x68E0             LDR      R0,[R4, #+12]
   \      0x15C   0x2800             CMP      R0,#+0
   \      0x15E   0xD101             BNE.N    ??HAL_RCC_OscConfig_17
    484                {
    485                  return HAL_ERROR;
   \      0x160   0x2001             MOVS     R0,#+1
   \      0x162   0xE239             B.N      ??HAL_RCC_OscConfig_2
    486                }
    487                /* Otherwise, only HSI division and calibration are allowed */
    488                else
    489                {
    490                    /* Enable the Internal High Speed oscillator (HSI, HSIDIV2, HSIDIV4, or HSIDIV8) */
    491                    __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
   \                     ??HAL_RCC_OscConfig_17: (+1)
   \      0x164   0x6829             LDR      R1,[R5, #+0]
   \      0x166   0xF031 0x0119      BICS     R1,R1,#0x19
   \      0x16A   0x68E0             LDR      R0,[R4, #+12]
   \      0x16C   0x4301             ORRS     R1,R0,R1
   \      0x16E   0x6029             STR      R1,[R5, #+0]
    492          
    493                    /* Get Start Tick*/
    494                    tickstart = HAL_GetTick();
   \      0x170   0x.... 0x....      BL       HAL_GetTick
   \      0x174   0x0006             MOVS     R6,R0
    495          
    496                    /* Wait till HSI is ready */
    497                    while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
   \                     ??HAL_RCC_OscConfig_18: (+1)
   \      0x176   0x6828             LDR      R0,[R5, #+0]
   \      0x178   0x0740             LSLS     R0,R0,#+29
   \      0x17A   0xD406             BMI.N    ??HAL_RCC_OscConfig_19
    498                    {
    499                      if((uint32_t) (HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
   \      0x17C   0x.... 0x....      BL       HAL_GetTick
   \      0x180   0x1B80             SUBS     R0,R0,R6
   \      0x182   0x2803             CMP      R0,#+3
   \      0x184   0xD3F7             BCC.N    ??HAL_RCC_OscConfig_18
    500                      {
    501                        return HAL_TIMEOUT;
   \      0x186   0x2003             MOVS     R0,#+3
   \      0x188   0xE226             B.N      ??HAL_RCC_OscConfig_2
    502                      }
    503                    }
    504                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    505                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
   \                     ??HAL_RCC_OscConfig_19: (+1)
   \      0x18A   0xF8DF 0x045C      LDR.W    R0,??HAL_RCC_OscConfig_0+0xC
   \      0x18E   0x6801             LDR      R1,[R0, #+0]
   \      0x190   0xF031 0x41FE      BICS     R1,R1,#0x7F000000
   \      0x194   0x6922             LDR      R2,[R4, #+16]
   \      0x196   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \      0x19A   0x6001             STR      R1,[R0, #+0]
    506                }
    507              }
    508          
    509              else
    510              {
    511                /* Check the HSI State */
    512                if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
    513                {
    514               /* Enable the Internal High Speed oscillator (HSI, HSIDIV2,HSIDIV4, or HSIDIV8) */
    515                  __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
    516          
    517                  /* Get Start Tick*/
    518                  tickstart = HAL_GetTick();
    519          
    520                  /* Wait till HSI is ready */
    521                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
    522                  {
    523                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
    524                    {
    525                      return HAL_TIMEOUT;
    526                    }
    527                  }
    528          
    529                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    530                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    531                }
    532                else
    533                {
    534                  /* Disable the Internal High Speed oscillator (HSI). */
    535                  __HAL_RCC_HSI_DISABLE();
    536          
    537                  /* Get Start Tick*/
    538                  tickstart = HAL_GetTick();
    539          
    540                  /* Wait till HSI is disabled */
    541                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
    542                  {
    543                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
    544                    {
    545                      return HAL_TIMEOUT;
    546                    }
    547                  }
    548                }
    549              }
    550            }
    551            /*----------------------------- CSI Configuration --------------------------*/
    552            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
   \                     ??HAL_RCC_OscConfig_14: (+1)
   \      0x19C   0x7820             LDRB     R0,[R4, #+0]
   \      0x19E   0x06C0             LSLS     R0,R0,#+27
   \      0x1A0   0xD557             BPL.N    ??HAL_RCC_OscConfig_20
    553            {
    554              /* Check the parameters */
    555              assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    556              assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));
    557          
    558              /* When the CSI is used as system clock it will not disabled */
    559              const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
   \      0x1A2   0xF8DF 0x0438      LDR.W    R0,??HAL_RCC_OscConfig_0
   \      0x1A6   0x6800             LDR      R0,[R0, #+0]
   \      0x1A8   0xF010 0x0038      ANDS     R0,R0,#0x38
    560              const uint32_t temp_pllckselr = RCC->PLLCKSELR;
   \      0x1AC   0xF8DF 0x1430      LDR.W    R1,??HAL_RCC_OscConfig_0+0x4
   \      0x1B0   0x6809             LDR      R1,[R1, #+0]
    561              if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
   \      0x1B2   0x2808             CMP      R0,#+8
   \      0x1B4   0xD005             BEQ.N    ??HAL_RCC_OscConfig_21
   \      0x1B6   0x2818             CMP      R0,#+24
   \      0x1B8   0xD164             BNE.N    ??HAL_RCC_OscConfig_22
   \      0x1BA   0xF011 0x0103      ANDS     R1,R1,#0x3
   \      0x1BE   0x2901             CMP      R1,#+1
   \      0x1C0   0xD160             BNE.N    ??HAL_RCC_OscConfig_22
    562              {
    563                /* When CSI is used as system clock it will not disabled */
    564                if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
   \                     ??HAL_RCC_OscConfig_21: (+1)
   \      0x1C2   0xF8DF 0x0420      LDR.W    R0,??HAL_RCC_OscConfig_0+0x8
   \      0x1C6   0x6800             LDR      R0,[R0, #+0]
   \      0x1C8   0x05C0             LSLS     R0,R0,#+23
   \      0x1CA   0xD539             BPL.N    ??HAL_RCC_OscConfig_23
   \      0x1CC   0x69E0             LDR      R0,[R4, #+28]
   \      0x1CE   0x2880             CMP      R0,#+128
   \      0x1D0   0xD036             BEQ.N    ??HAL_RCC_OscConfig_23
    565                {
    566                  return HAL_ERROR;
   \      0x1D2   0x2001             MOVS     R0,#+1
   \      0x1D4   0xE200             B.N      ??HAL_RCC_OscConfig_2
    567                }
   \                     ??HAL_RCC_OscConfig_16: (+1)
   \      0x1D6   0x68E0             LDR      R0,[R4, #+12]
   \      0x1D8   0x2800             CMP      R0,#+0
   \      0x1DA   0xD01E             BEQ.N    ??HAL_RCC_OscConfig_24
   \      0x1DC   0xF8DF 0x6404      LDR.W    R6,??HAL_RCC_OscConfig_0+0x8
   \      0x1E0   0x6831             LDR      R1,[R6, #+0]
   \      0x1E2   0xF031 0x0119      BICS     R1,R1,#0x19
   \      0x1E6   0x68E0             LDR      R0,[R4, #+12]
   \      0x1E8   0x4301             ORRS     R1,R0,R1
   \      0x1EA   0x6031             STR      R1,[R6, #+0]
   \      0x1EC   0x.... 0x....      BL       HAL_GetTick
   \      0x1F0   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_25: (+1)
   \      0x1F2   0x6830             LDR      R0,[R6, #+0]
   \      0x1F4   0x0740             LSLS     R0,R0,#+29
   \      0x1F6   0xD406             BMI.N    ??HAL_RCC_OscConfig_26
   \      0x1F8   0x.... 0x....      BL       HAL_GetTick
   \      0x1FC   0x1B40             SUBS     R0,R0,R5
   \      0x1FE   0x2803             CMP      R0,#+3
   \      0x200   0xD3F7             BCC.N    ??HAL_RCC_OscConfig_25
   \      0x202   0x2003             MOVS     R0,#+3
   \      0x204   0xE1E8             B.N      ??HAL_RCC_OscConfig_2
   \                     ??HAL_RCC_OscConfig_26: (+1)
   \      0x206   0xF8DF 0x03E0      LDR.W    R0,??HAL_RCC_OscConfig_0+0xC
   \      0x20A   0x6801             LDR      R1,[R0, #+0]
   \      0x20C   0xF031 0x41FE      BICS     R1,R1,#0x7F000000
   \      0x210   0x6922             LDR      R2,[R4, #+16]
   \      0x212   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \      0x216   0x6001             STR      R1,[R0, #+0]
   \      0x218   0xE7C0             B.N      ??HAL_RCC_OscConfig_14
   \                     ??HAL_RCC_OscConfig_24: (+1)
   \      0x21A   0xF8DF 0x63C8      LDR.W    R6,??HAL_RCC_OscConfig_0+0x8
   \      0x21E   0x6830             LDR      R0,[R6, #+0]
   \      0x220   0x0840             LSRS     R0,R0,#+1
   \      0x222   0x0040             LSLS     R0,R0,#+1
   \      0x224   0x6030             STR      R0,[R6, #+0]
   \      0x226   0x.... 0x....      BL       HAL_GetTick
   \      0x22A   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_27: (+1)
   \      0x22C   0x6830             LDR      R0,[R6, #+0]
   \      0x22E   0x0740             LSLS     R0,R0,#+29
   \      0x230   0xD5B4             BPL.N    ??HAL_RCC_OscConfig_14
   \      0x232   0x.... 0x....      BL       HAL_GetTick
   \      0x236   0x1B40             SUBS     R0,R0,R5
   \      0x238   0x2803             CMP      R0,#+3
   \      0x23A   0xD3F7             BCC.N    ??HAL_RCC_OscConfig_27
   \      0x23C   0x2003             MOVS     R0,#+3
   \      0x23E   0xE1CB             B.N      ??HAL_RCC_OscConfig_2
    568                /* Otherwise, just the calibration is allowed */
    569                else
    570                {
    571                  /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
    572                  __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
   \                     ??HAL_RCC_OscConfig_23: (+1)
   \      0x240   0xF8DF 0x03A8      LDR.W    R0,??HAL_RCC_OscConfig_0+0x10
   \      0x244   0x6801             LDR      R1,[R0, #+0]
   \      0x246   0xF031 0x517C      BICS     R1,R1,#0x3F000000
   \      0x24A   0x6A22             LDR      R2,[R4, #+32]
   \      0x24C   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \      0x250   0x6001             STR      R1,[R0, #+0]
    573                }
    574              }
    575              else
    576              {
    577                /* Check the CSI State */
    578                if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
    579                {
    580                  /* Enable the Internal High Speed oscillator (CSI). */
    581                  __HAL_RCC_CSI_ENABLE();
    582          
    583                  /* Get Start Tick*/
    584                  tickstart = HAL_GetTick();
    585          
    586                  /* Wait till CSI is ready */
    587                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
    588                  {
    589                    if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
    590                    {
    591                      return HAL_TIMEOUT;
    592                    }
    593                  }
    594          
    595                  /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
    596                  __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
    597                }
    598                else
    599                {
    600                  /* Disable the Internal High Speed oscillator (CSI). */
    601                  __HAL_RCC_CSI_DISABLE();
    602          
    603                  /* Get Start Tick*/
    604                  tickstart = HAL_GetTick();
    605          
    606                  /* Wait till CSI is disabled */
    607                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
    608                  {
    609                    if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
    610                    {
    611                      return HAL_TIMEOUT;
    612                    }
    613                  }
    614                }
    615              }
    616            }
    617            /*------------------------------ LSI Configuration -------------------------*/
    618            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
   \                     ??HAL_RCC_OscConfig_20: (+1)
   \      0x252   0x7820             LDRB     R0,[R4, #+0]
   \      0x254   0x0700             LSLS     R0,R0,#+28
   \      0x256   0xD55A             BPL.N    ??HAL_RCC_OscConfig_28
    619            {
    620              /* Check the parameters */
    621              assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    622          
    623              /* Check the LSI State */
    624              if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
   \      0x258   0x6960             LDR      R0,[R4, #+20]
   \      0x25A   0x2800             CMP      R0,#+0
   \      0x25C   0xD045             BEQ.N    ??HAL_RCC_OscConfig_29
    625              {
    626                /* Enable the Internal Low Speed oscillator (LSI). */
    627                __HAL_RCC_LSI_ENABLE();
   \      0x25E   0xF8DF 0x6390      LDR.W    R6,??HAL_RCC_OscConfig_0+0x14
   \      0x262   0x6830             LDR      R0,[R6, #+0]
   \      0x264   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x268   0x6030             STR      R0,[R6, #+0]
    628          
    629                /* Get Start Tick*/
    630                tickstart = HAL_GetTick();
   \      0x26A   0x.... 0x....      BL       HAL_GetTick
   \      0x26E   0x0005             MOVS     R5,R0
    631          
    632                /* Wait till LSI is ready */
    633                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
   \                     ??HAL_RCC_OscConfig_30: (+1)
   \      0x270   0x6830             LDR      R0,[R6, #+0]
   \      0x272   0x0780             LSLS     R0,R0,#+30
   \      0x274   0xD44B             BMI.N    ??HAL_RCC_OscConfig_28
    634                {
    635                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
   \      0x276   0x.... 0x....      BL       HAL_GetTick
   \      0x27A   0x1B40             SUBS     R0,R0,R5
   \      0x27C   0x2803             CMP      R0,#+3
   \      0x27E   0xD3F7             BCC.N    ??HAL_RCC_OscConfig_30
    636                  {
    637                    return HAL_TIMEOUT;
   \      0x280   0x2003             MOVS     R0,#+3
   \      0x282   0xE1A9             B.N      ??HAL_RCC_OscConfig_2
    638                  }
    639                }
    640              }
   \                     ??HAL_RCC_OscConfig_22: (+1)
   \      0x284   0x69E0             LDR      R0,[R4, #+28]
   \      0x286   0x2800             CMP      R0,#+0
   \      0x288   0xD01C             BEQ.N    ??HAL_RCC_OscConfig_31
   \      0x28A   0xF8DF 0x6358      LDR.W    R6,??HAL_RCC_OscConfig_0+0x8
   \      0x28E   0x6830             LDR      R0,[R6, #+0]
   \      0x290   0xF050 0x0080      ORRS     R0,R0,#0x80
   \      0x294   0x6030             STR      R0,[R6, #+0]
   \      0x296   0x.... 0x....      BL       HAL_GetTick
   \      0x29A   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_32: (+1)
   \      0x29C   0x6830             LDR      R0,[R6, #+0]
   \      0x29E   0x05C0             LSLS     R0,R0,#+23
   \      0x2A0   0xD406             BMI.N    ??HAL_RCC_OscConfig_33
   \      0x2A2   0x.... 0x....      BL       HAL_GetTick
   \      0x2A6   0x1B40             SUBS     R0,R0,R5
   \      0x2A8   0x2803             CMP      R0,#+3
   \      0x2AA   0xD3F7             BCC.N    ??HAL_RCC_OscConfig_32
   \      0x2AC   0x2003             MOVS     R0,#+3
   \      0x2AE   0xE193             B.N      ??HAL_RCC_OscConfig_2
   \                     ??HAL_RCC_OscConfig_33: (+1)
   \      0x2B0   0xF8DF 0x0338      LDR.W    R0,??HAL_RCC_OscConfig_0+0x10
   \      0x2B4   0x6801             LDR      R1,[R0, #+0]
   \      0x2B6   0xF031 0x517C      BICS     R1,R1,#0x3F000000
   \      0x2BA   0x6A22             LDR      R2,[R4, #+32]
   \      0x2BC   0xEA51 0x6102      ORRS     R1,R1,R2, LSL #+24
   \      0x2C0   0x6001             STR      R1,[R0, #+0]
   \      0x2C2   0xE7C6             B.N      ??HAL_RCC_OscConfig_20
   \                     ??HAL_RCC_OscConfig_31: (+1)
   \      0x2C4   0xF8DF 0x631C      LDR.W    R6,??HAL_RCC_OscConfig_0+0x8
   \      0x2C8   0x6830             LDR      R0,[R6, #+0]
   \      0x2CA   0xF030 0x0080      BICS     R0,R0,#0x80
   \      0x2CE   0x6030             STR      R0,[R6, #+0]
   \      0x2D0   0x.... 0x....      BL       HAL_GetTick
   \      0x2D4   0x0005             MOVS     R5,R0
   \                     ??HAL_RCC_OscConfig_34: (+1)
   \      0x2D6   0x6830             LDR      R0,[R6, #+0]
   \      0x2D8   0x05C0             LSLS     R0,R0,#+23
   \      0x2DA   0xD5BA             BPL.N    ??HAL_RCC_OscConfig_20
   \      0x2DC   0x.... 0x....      BL       HAL_GetTick
   \      0x2E0   0x1B40             SUBS     R0,R0,R5
   \      0x2E2   0x2803             CMP      R0,#+3
   \      0x2E4   0xD3F7             BCC.N    ??HAL_RCC_OscConfig_34
   \      0x2E6   0x2003             MOVS     R0,#+3
   \      0x2E8   0xE176             B.N      ??HAL_RCC_OscConfig_2
    641              else
    642              {
    643                /* Disable the Internal Low Speed oscillator (LSI). */
    644                __HAL_RCC_LSI_DISABLE();
   \                     ??HAL_RCC_OscConfig_29: (+1)
   \      0x2EA   0x4EC1             LDR.N    R6,??HAL_RCC_OscConfig_0+0x14
   \      0x2EC   0x6830             LDR      R0,[R6, #+0]
   \      0x2EE   0x0840             LSRS     R0,R0,#+1
   \      0x2F0   0x0040             LSLS     R0,R0,#+1
   \      0x2F2   0x6030             STR      R0,[R6, #+0]
    645          
    646                /* Get Start Tick*/
    647                tickstart = HAL_GetTick();
   \      0x2F4   0x.... 0x....      BL       HAL_GetTick
   \      0x2F8   0x0005             MOVS     R5,R0
    648          
    649                /* Wait till LSI is ready */
    650                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
   \                     ??HAL_RCC_OscConfig_35: (+1)
   \      0x2FA   0x6830             LDR      R0,[R6, #+0]
   \      0x2FC   0x0780             LSLS     R0,R0,#+30
   \      0x2FE   0xD506             BPL.N    ??HAL_RCC_OscConfig_28
    651                {
    652                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
   \      0x300   0x.... 0x....      BL       HAL_GetTick
   \      0x304   0x1B40             SUBS     R0,R0,R5
   \      0x306   0x2803             CMP      R0,#+3
   \      0x308   0xD3F7             BCC.N    ??HAL_RCC_OscConfig_35
    653                  {
    654                    return HAL_TIMEOUT;
   \      0x30A   0x2003             MOVS     R0,#+3
   \      0x30C   0xE164             B.N      ??HAL_RCC_OscConfig_2
    655                  }
    656                }
    657              }
    658            }
    659          
    660            /*------------------------------ HSI48 Configuration -------------------------*/
    661            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
   \                     ??HAL_RCC_OscConfig_28: (+1)
   \      0x30E   0x7820             LDRB     R0,[R4, #+0]
   \      0x310   0x0680             LSLS     R0,R0,#+26
   \      0x312   0xD526             BPL.N    ??HAL_RCC_OscConfig_36
    662            {
    663              /* Check the parameters */
    664              assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
    665          
    666              /* Check the HSI48 State */
    667              if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
   \      0x314   0x69A0             LDR      R0,[R4, #+24]
   \      0x316   0x2800             CMP      R0,#+0
   \      0x318   0xD011             BEQ.N    ??HAL_RCC_OscConfig_37
    668              {
    669                /* Enable the Internal Low Speed oscillator (HSI48). */
    670                __HAL_RCC_HSI48_ENABLE();
   \      0x31A   0x4EB2             LDR.N    R6,??HAL_RCC_OscConfig_0+0x8
   \      0x31C   0x6830             LDR      R0,[R6, #+0]
   \      0x31E   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \      0x322   0x6030             STR      R0,[R6, #+0]
    671          
    672                /* Get time-out */
    673                tickstart = HAL_GetTick();
   \      0x324   0x.... 0x....      BL       HAL_GetTick
   \      0x328   0x0005             MOVS     R5,R0
    674          
    675                /* Wait till HSI48 is ready */
    676                while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
   \                     ??HAL_RCC_OscConfig_38: (+1)
   \      0x32A   0x6830             LDR      R0,[R6, #+0]
   \      0x32C   0x0480             LSLS     R0,R0,#+18
   \      0x32E   0xD418             BMI.N    ??HAL_RCC_OscConfig_36
    677                {
    678                  if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
   \      0x330   0x.... 0x....      BL       HAL_GetTick
   \      0x334   0x1B40             SUBS     R0,R0,R5
   \      0x336   0x2803             CMP      R0,#+3
   \      0x338   0xD3F7             BCC.N    ??HAL_RCC_OscConfig_38
    679                  {
    680                    return HAL_TIMEOUT;
   \      0x33A   0x2003             MOVS     R0,#+3
   \      0x33C   0xE14C             B.N      ??HAL_RCC_OscConfig_2
    681                  }
    682                }
    683              }
    684              else
    685              {
    686                /* Disable the Internal Low Speed oscillator (HSI48). */
    687                __HAL_RCC_HSI48_DISABLE();
   \                     ??HAL_RCC_OscConfig_37: (+1)
   \      0x33E   0x4EA9             LDR.N    R6,??HAL_RCC_OscConfig_0+0x8
   \      0x340   0x6830             LDR      R0,[R6, #+0]
   \      0x342   0xF430 0x5080      BICS     R0,R0,#0x1000
   \      0x346   0x6030             STR      R0,[R6, #+0]
    688          
    689                /* Get time-out */
    690                tickstart = HAL_GetTick();
   \      0x348   0x.... 0x....      BL       HAL_GetTick
   \      0x34C   0x0005             MOVS     R5,R0
    691          
    692                /* Wait till HSI48 is ready */
    693                while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
   \                     ??HAL_RCC_OscConfig_39: (+1)
   \      0x34E   0x6830             LDR      R0,[R6, #+0]
   \      0x350   0x0480             LSLS     R0,R0,#+18
   \      0x352   0xD506             BPL.N    ??HAL_RCC_OscConfig_36
    694                {
    695                  if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
   \      0x354   0x.... 0x....      BL       HAL_GetTick
   \      0x358   0x1B40             SUBS     R0,R0,R5
   \      0x35A   0x2803             CMP      R0,#+3
   \      0x35C   0xD3F7             BCC.N    ??HAL_RCC_OscConfig_39
    696                  {
    697                    return HAL_TIMEOUT;
   \      0x35E   0x2003             MOVS     R0,#+3
   \      0x360   0xE13A             B.N      ??HAL_RCC_OscConfig_2
    698                  }
    699                }
    700              }
    701            }
    702            /*------------------------------ LSE Configuration -------------------------*/
    703            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
   \                     ??HAL_RCC_OscConfig_36: (+1)
   \      0x362   0x7820             LDRB     R0,[R4, #+0]
   \      0x364   0x0740             LSLS     R0,R0,#+29
   \      0x366   0xD57D             BPL.N    ??HAL_RCC_OscConfig_40
    704            {
    705              /* Check the parameters */
    706              assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    707          
    708              /* Enable write access to Backup domain */
    709              PWR->CR1 |= PWR_CR1_DBP;
   \      0x368   0x4EA2             LDR.N    R6,??HAL_RCC_OscConfig_0+0x18
   \      0x36A   0x6830             LDR      R0,[R6, #+0]
   \      0x36C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x370   0x6030             STR      R0,[R6, #+0]
    710          
    711              /* Wait for Backup domain Write protection disable */
    712              tickstart = HAL_GetTick();
   \      0x372   0x.... 0x....      BL       HAL_GetTick
   \      0x376   0x0005             MOVS     R5,R0
    713          
    714              while((PWR->CR1 & PWR_CR1_DBP) == 0U)
   \                     ??HAL_RCC_OscConfig_41: (+1)
   \      0x378   0x6830             LDR      R0,[R6, #+0]
   \      0x37A   0x05C0             LSLS     R0,R0,#+23
   \      0x37C   0xD406             BMI.N    ??HAL_RCC_OscConfig_42
    715              {
    716                if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
   \      0x37E   0x.... 0x....      BL       HAL_GetTick
   \      0x382   0x1B40             SUBS     R0,R0,R5
   \      0x384   0x2865             CMP      R0,#+101
   \      0x386   0xD3F7             BCC.N    ??HAL_RCC_OscConfig_41
    717                {
    718                  return HAL_TIMEOUT;
   \      0x388   0x2003             MOVS     R0,#+3
   \      0x38A   0xE125             B.N      ??HAL_RCC_OscConfig_2
    719                }
    720              }
    721          
    722              /* Set the new LSE configuration -----------------------------------------*/
    723              __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
   \                     ??HAL_RCC_OscConfig_42: (+1)
   \      0x38C   0x68A0             LDR      R0,[R4, #+8]
   \      0x38E   0x2801             CMP      R0,#+1
   \      0x390   0xD105             BNE.N    ??HAL_RCC_OscConfig_43
   \      0x392   0x4899             LDR.N    R0,??HAL_RCC_OscConfig_0+0x1C
   \      0x394   0x6801             LDR      R1,[R0, #+0]
   \      0x396   0xF051 0x0101      ORRS     R1,R1,#0x1
   \      0x39A   0x6001             STR      R1,[R0, #+0]
   \      0x39C   0xE03F             B.N      ??HAL_RCC_OscConfig_44
   \                     ??HAL_RCC_OscConfig_43: (+1)
   \      0x39E   0x68A0             LDR      R0,[R4, #+8]
   \      0x3A0   0x2800             CMP      R0,#+0
   \      0x3A2   0xD10D             BNE.N    ??HAL_RCC_OscConfig_45
   \      0x3A4   0x4894             LDR.N    R0,??HAL_RCC_OscConfig_0+0x1C
   \      0x3A6   0x6801             LDR      R1,[R0, #+0]
   \      0x3A8   0x0849             LSRS     R1,R1,#+1
   \      0x3AA   0x0049             LSLS     R1,R1,#+1
   \      0x3AC   0x6001             STR      R1,[R0, #+0]
   \      0x3AE   0x6801             LDR      R1,[R0, #+0]
   \      0x3B0   0xF031 0x0180      BICS     R1,R1,#0x80
   \      0x3B4   0x6001             STR      R1,[R0, #+0]
   \      0x3B6   0x6801             LDR      R1,[R0, #+0]
   \      0x3B8   0xF031 0x0104      BICS     R1,R1,#0x4
   \      0x3BC   0x6001             STR      R1,[R0, #+0]
   \      0x3BE   0xE02E             B.N      ??HAL_RCC_OscConfig_44
   \                     ??HAL_RCC_OscConfig_45: (+1)
   \      0x3C0   0x68A0             LDR      R0,[R4, #+8]
   \      0x3C2   0x2805             CMP      R0,#+5
   \      0x3C4   0xD10D             BNE.N    ??HAL_RCC_OscConfig_46
   \      0x3C6   0x488C             LDR.N    R0,??HAL_RCC_OscConfig_0+0x1C
   \      0x3C8   0x6801             LDR      R1,[R0, #+0]
   \      0x3CA   0xF051 0x0104      ORRS     R1,R1,#0x4
   \      0x3CE   0x6001             STR      R1,[R0, #+0]
   \      0x3D0   0x6801             LDR      R1,[R0, #+0]
   \      0x3D2   0xF031 0x0180      BICS     R1,R1,#0x80
   \      0x3D6   0x6001             STR      R1,[R0, #+0]
   \      0x3D8   0x6801             LDR      R1,[R0, #+0]
   \      0x3DA   0xF051 0x0101      ORRS     R1,R1,#0x1
   \      0x3DE   0x6001             STR      R1,[R0, #+0]
   \      0x3E0   0xE01D             B.N      ??HAL_RCC_OscConfig_44
   \                     ??HAL_RCC_OscConfig_46: (+1)
   \      0x3E2   0x68A0             LDR      R0,[R4, #+8]
   \      0x3E4   0x2885             CMP      R0,#+133
   \      0x3E6   0xD10D             BNE.N    ??HAL_RCC_OscConfig_47
   \      0x3E8   0x4883             LDR.N    R0,??HAL_RCC_OscConfig_0+0x1C
   \      0x3EA   0x6801             LDR      R1,[R0, #+0]
   \      0x3EC   0xF051 0x0104      ORRS     R1,R1,#0x4
   \      0x3F0   0x6001             STR      R1,[R0, #+0]
   \      0x3F2   0x6801             LDR      R1,[R0, #+0]
   \      0x3F4   0xF051 0x0180      ORRS     R1,R1,#0x80
   \      0x3F8   0x6001             STR      R1,[R0, #+0]
   \      0x3FA   0x6801             LDR      R1,[R0, #+0]
   \      0x3FC   0xF051 0x0101      ORRS     R1,R1,#0x1
   \      0x400   0x6001             STR      R1,[R0, #+0]
   \      0x402   0xE00C             B.N      ??HAL_RCC_OscConfig_44
   \                     ??HAL_RCC_OscConfig_47: (+1)
   \      0x404   0x487C             LDR.N    R0,??HAL_RCC_OscConfig_0+0x1C
   \      0x406   0x6801             LDR      R1,[R0, #+0]
   \      0x408   0x0849             LSRS     R1,R1,#+1
   \      0x40A   0x0049             LSLS     R1,R1,#+1
   \      0x40C   0x6001             STR      R1,[R0, #+0]
   \      0x40E   0x6801             LDR      R1,[R0, #+0]
   \      0x410   0xF031 0x0104      BICS     R1,R1,#0x4
   \      0x414   0x6001             STR      R1,[R0, #+0]
   \      0x416   0x6801             LDR      R1,[R0, #+0]
   \      0x418   0xF031 0x0180      BICS     R1,R1,#0x80
   \      0x41C   0x6001             STR      R1,[R0, #+0]
    724              /* Check the LSE State */
    725              if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
   \                     ??HAL_RCC_OscConfig_44: (+1)
   \      0x41E   0x68A0             LDR      R0,[R4, #+8]
   \      0x420   0x2800             CMP      R0,#+0
   \      0x422   0xD00F             BEQ.N    ??HAL_RCC_OscConfig_48
    726              {
    727                /* Get Start Tick*/
    728                tickstart = HAL_GetTick();
   \      0x424   0x.... 0x....      BL       HAL_GetTick
   \      0x428   0x0005             MOVS     R5,R0
    729          
    730                /* Wait till LSE is ready */
    731                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
   \                     ??HAL_RCC_OscConfig_49: (+1)
   \      0x42A   0x4873             LDR.N    R0,??HAL_RCC_OscConfig_0+0x1C
   \      0x42C   0x6800             LDR      R0,[R0, #+0]
   \      0x42E   0x0780             LSLS     R0,R0,#+30
   \      0x430   0xD418             BMI.N    ??HAL_RCC_OscConfig_40
    732                {
    733                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \      0x432   0x.... 0x....      BL       HAL_GetTick
   \      0x436   0x1B40             SUBS     R0,R0,R5
   \      0x438   0xF241 0x3189      MOVW     R1,#+5001
   \      0x43C   0x4288             CMP      R0,R1
   \      0x43E   0xD3F4             BCC.N    ??HAL_RCC_OscConfig_49
    734                  {
    735                    return HAL_TIMEOUT;
   \      0x440   0x2003             MOVS     R0,#+3
   \      0x442   0xE0C9             B.N      ??HAL_RCC_OscConfig_2
    736                  }
    737                }
    738              }
    739              else
    740              {
    741                /* Get Start Tick*/
    742                tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_48: (+1)
   \      0x444   0x.... 0x....      BL       HAL_GetTick
   \      0x448   0x0005             MOVS     R5,R0
    743          
    744                /* Wait till LSE is disabled */
    745                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
   \                     ??HAL_RCC_OscConfig_50: (+1)
   \      0x44A   0x486B             LDR.N    R0,??HAL_RCC_OscConfig_0+0x1C
   \      0x44C   0x6800             LDR      R0,[R0, #+0]
   \      0x44E   0x0780             LSLS     R0,R0,#+30
   \      0x450   0xD508             BPL.N    ??HAL_RCC_OscConfig_40
    746                {
    747                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \      0x452   0x.... 0x....      BL       HAL_GetTick
   \      0x456   0x1B40             SUBS     R0,R0,R5
   \      0x458   0xF241 0x3189      MOVW     R1,#+5001
   \      0x45C   0x4288             CMP      R0,R1
   \      0x45E   0xD3F4             BCC.N    ??HAL_RCC_OscConfig_50
    748                  {
    749                    return HAL_TIMEOUT;
   \      0x460   0x2003             MOVS     R0,#+3
   \      0x462   0xE0B9             B.N      ??HAL_RCC_OscConfig_2
    750                  }
    751                }
    752              }
    753            }
    754            /*-------------------------------- PLL Configuration -----------------------*/
    755            /* Check the parameters */
    756            assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
    757            if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
   \                     ??HAL_RCC_OscConfig_40: (+1)
   \      0x464   0x6A60             LDR      R0,[R4, #+36]
   \      0x466   0x2800             CMP      R0,#+0
   \      0x468   0xF000 0x80B5      BEQ.W    ??HAL_RCC_OscConfig_51
    758            {
    759              /* Check if the PLL is used as system clock or not */
    760              if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
   \      0x46C   0x485B             LDR.N    R0,??HAL_RCC_OscConfig_0
   \      0x46E   0x6800             LDR      R0,[R0, #+0]
   \      0x470   0xF010 0x0038      ANDS     R0,R0,#0x38
   \      0x474   0x2818             CMP      R0,#+24
   \      0x476   0xF000 0x8083      BEQ.W    ??HAL_RCC_OscConfig_52
    761              {
    762                if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
   \      0x47A   0x6A60             LDR      R0,[R4, #+36]
   \      0x47C   0x2802             CMP      R0,#+2
   \      0x47E   0xD16D             BNE.N    ??HAL_RCC_OscConfig_53
    763                {
    764                  /* Check the parameters */
    765                  assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
    766                  assert_param(IS_RCC_PLLRGE_VALUE(RCC_OscInitStruct->PLL.PLLRGE));
    767                  assert_param(IS_RCC_PLLVCO_VALUE(RCC_OscInitStruct->PLL.PLLVCOSEL));
    768                  assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
    769                  assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
    770                  assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
    771                  assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
    772                  assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
    773                  assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
    774          
    775                  /* Disable the main PLL. */
    776                  __HAL_RCC_PLL_DISABLE();
   \      0x480   0x4D58             LDR.N    R5,??HAL_RCC_OscConfig_0+0x8
   \      0x482   0x6828             LDR      R0,[R5, #+0]
   \      0x484   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \      0x488   0x6028             STR      R0,[R5, #+0]
    777          
    778                  /* Get Start Tick*/
    779                  tickstart = HAL_GetTick();
   \      0x48A   0x.... 0x....      BL       HAL_GetTick
   \      0x48E   0x0006             MOVS     R6,R0
    780          
    781                  /* Wait till PLL is disabled */
    782                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
   \                     ??HAL_RCC_OscConfig_54: (+1)
   \      0x490   0x6828             LDR      R0,[R5, #+0]
   \      0x492   0x0180             LSLS     R0,R0,#+6
   \      0x494   0xD506             BPL.N    ??HAL_RCC_OscConfig_55
    783                  {
    784                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \      0x496   0x.... 0x....      BL       HAL_GetTick
   \      0x49A   0x1B80             SUBS     R0,R0,R6
   \      0x49C   0x2803             CMP      R0,#+3
   \      0x49E   0xD3F7             BCC.N    ??HAL_RCC_OscConfig_54
    785                    {
    786                      return HAL_TIMEOUT;
   \      0x4A0   0x2003             MOVS     R0,#+3
   \      0x4A2   0xE099             B.N      ??HAL_RCC_OscConfig_2
    787                    }
    788                  }
    789          
    790                  /* Configure the main PLL clock source, multiplication and division factors. */
    791                  __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    792                                       RCC_OscInitStruct->PLL.PLLM,
    793                                       RCC_OscInitStruct->PLL.PLLN,
    794                                       RCC_OscInitStruct->PLL.PLLP,
    795                                       RCC_OscInitStruct->PLL.PLLQ,
    796                                       RCC_OscInitStruct->PLL.PLLR);
   \                     ??HAL_RCC_OscConfig_55: (+1)
   \      0x4A4   0x494E             LDR.N    R1,??HAL_RCC_OscConfig_0+0x4
   \      0x4A6   0x680A             LDR      R2,[R1, #+0]
   \      0x4A8   0x4854             LDR.N    R0,??HAL_RCC_OscConfig_0+0x20
   \      0x4AA   0x4002             ANDS     R2,R0,R2
   \      0x4AC   0x6AA0             LDR      R0,[R4, #+40]
   \      0x4AE   0x4302             ORRS     R2,R0,R2
   \      0x4B0   0x6AE0             LDR      R0,[R4, #+44]
   \      0x4B2   0xEA52 0x1200      ORRS     R2,R2,R0, LSL #+4
   \      0x4B6   0x600A             STR      R2,[R1, #+0]
   \      0x4B8   0x6B20             LDR      R0,[R4, #+48]
   \      0x4BA   0x1E40             SUBS     R0,R0,#+1
   \      0x4BC   0x05C0             LSLS     R0,R0,#+23
   \      0x4BE   0x0DC0             LSRS     R0,R0,#+23
   \      0x4C0   0x6B61             LDR      R1,[R4, #+52]
   \      0x4C2   0x1E49             SUBS     R1,R1,#+1
   \      0x4C4   0x0249             LSLS     R1,R1,#+9
   \      0x4C6   0xF411 0x417E      ANDS     R1,R1,#0xFE00
   \      0x4CA   0x4308             ORRS     R0,R1,R0
   \      0x4CC   0x6BA1             LDR      R1,[R4, #+56]
   \      0x4CE   0x1E49             SUBS     R1,R1,#+1
   \      0x4D0   0x0409             LSLS     R1,R1,#+16
   \      0x4D2   0xF411 0x01FE      ANDS     R1,R1,#0x7F0000
   \      0x4D6   0x4308             ORRS     R0,R1,R0
   \      0x4D8   0x6BE1             LDR      R1,[R4, #+60]
   \      0x4DA   0x1E49             SUBS     R1,R1,#+1
   \      0x4DC   0x0609             LSLS     R1,R1,#+24
   \      0x4DE   0xF011 0x41FE      ANDS     R1,R1,#0x7F000000
   \      0x4E2   0x4308             ORRS     R0,R1,R0
   \      0x4E4   0x4946             LDR.N    R1,??HAL_RCC_OscConfig_0+0x24
   \      0x4E6   0x6008             STR      R0,[R1, #+0]
    797          
    798                   /* Disable PLLFRACN . */
    799                   __HAL_RCC_PLLFRACN_DISABLE();
   \      0x4E8   0x4946             LDR.N    R1,??HAL_RCC_OscConfig_0+0x28
   \      0x4EA   0x6808             LDR      R0,[R1, #+0]
   \      0x4EC   0x0840             LSRS     R0,R0,#+1
   \      0x4EE   0x0040             LSLS     R0,R0,#+1
   \      0x4F0   0x6008             STR      R0,[R1, #+0]
    800          
    801                   /* Configure PLL PLL1FRACN */
    802                   __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
   \      0x4F2   0x4845             LDR.N    R0,??HAL_RCC_OscConfig_0+0x2C
   \      0x4F4   0x6802             LDR      R2,[R0, #+0]
   \      0x4F6   0xF36F 0x02CF      BFC      R2,#+3,#+13
   \      0x4FA   0x6CA3             LDR      R3,[R4, #+72]
   \      0x4FC   0xEA52 0x02C3      ORRS     R2,R2,R3, LSL #+3
   \      0x500   0x6002             STR      R2,[R0, #+0]
    803          
    804                  /* Select PLL1 input reference frequency range: VCI */
    805                  __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
   \      0x502   0x680A             LDR      R2,[R1, #+0]
   \      0x504   0xF032 0x020C      BICS     R2,R2,#0xC
   \      0x508   0x6C20             LDR      R0,[R4, #+64]
   \      0x50A   0x4302             ORRS     R2,R0,R2
   \      0x50C   0x600A             STR      R2,[R1, #+0]
    806          
    807                  /* Select PLL1 output frequency range : VCO */
    808                  __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
   \      0x50E   0x680A             LDR      R2,[R1, #+0]
   \      0x510   0xF032 0x0202      BICS     R2,R2,#0x2
   \      0x514   0x6C60             LDR      R0,[R4, #+68]
   \      0x516   0x4302             ORRS     R2,R0,R2
   \      0x518   0x600A             STR      R2,[R1, #+0]
    809          
    810                  /* Enable PLL System Clock output. */
    811                   __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
   \      0x51A   0x6808             LDR      R0,[R1, #+0]
   \      0x51C   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \      0x520   0x6008             STR      R0,[R1, #+0]
    812          
    813                  /* Enable PLL1Q Clock output. */
    814                   __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
   \      0x522   0x6808             LDR      R0,[R1, #+0]
   \      0x524   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \      0x528   0x6008             STR      R0,[R1, #+0]
    815          
    816                  /* Enable PLL1R  Clock output. */
    817                   __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
   \      0x52A   0x6808             LDR      R0,[R1, #+0]
   \      0x52C   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \      0x530   0x6008             STR      R0,[R1, #+0]
    818          
    819                  /* Enable PLL1FRACN . */
    820                   __HAL_RCC_PLLFRACN_ENABLE();
   \      0x532   0x6808             LDR      R0,[R1, #+0]
   \      0x534   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x538   0x6008             STR      R0,[R1, #+0]
    821          
    822                  /* Enable the main PLL. */
    823                  __HAL_RCC_PLL_ENABLE();
   \      0x53A   0x6828             LDR      R0,[R5, #+0]
   \      0x53C   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \      0x540   0x6028             STR      R0,[R5, #+0]
    824          
    825                  /* Get Start Tick*/
    826                  tickstart = HAL_GetTick();
   \      0x542   0x.... 0x....      BL       HAL_GetTick
   \      0x546   0x0004             MOVS     R4,R0
    827          
    828                  /* Wait till PLL is ready */
    829                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
   \                     ??HAL_RCC_OscConfig_56: (+1)
   \      0x548   0x6828             LDR      R0,[R5, #+0]
   \      0x54A   0x0180             LSLS     R0,R0,#+6
   \      0x54C   0xD443             BMI.N    ??HAL_RCC_OscConfig_51
    830                  {
    831                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \      0x54E   0x.... 0x....      BL       HAL_GetTick
   \      0x552   0x1B00             SUBS     R0,R0,R4
   \      0x554   0x2803             CMP      R0,#+3
   \      0x556   0xD3F7             BCC.N    ??HAL_RCC_OscConfig_56
    832                    {
    833                      return HAL_TIMEOUT;
   \      0x558   0x2003             MOVS     R0,#+3
   \      0x55A   0xE03D             B.N      ??HAL_RCC_OscConfig_2
    834                    }
    835                  }
    836                }
    837                else
    838                {
    839                  /* Disable the main PLL. */
    840                  __HAL_RCC_PLL_DISABLE();
   \                     ??HAL_RCC_OscConfig_53: (+1)
   \      0x55C   0x4D21             LDR.N    R5,??HAL_RCC_OscConfig_0+0x8
   \      0x55E   0x6828             LDR      R0,[R5, #+0]
   \      0x560   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \      0x564   0x6028             STR      R0,[R5, #+0]
    841          
    842                  /* Get Start Tick*/
    843                  tickstart = HAL_GetTick();
   \      0x566   0x.... 0x....      BL       HAL_GetTick
   \      0x56A   0x0004             MOVS     R4,R0
    844          
    845                  /* Wait till PLL is disabled */
    846                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
   \                     ??HAL_RCC_OscConfig_57: (+1)
   \      0x56C   0x6828             LDR      R0,[R5, #+0]
   \      0x56E   0x0180             LSLS     R0,R0,#+6
   \      0x570   0xD531             BPL.N    ??HAL_RCC_OscConfig_51
    847                  {
    848                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \      0x572   0x.... 0x....      BL       HAL_GetTick
   \      0x576   0x1B00             SUBS     R0,R0,R4
   \      0x578   0x2803             CMP      R0,#+3
   \      0x57A   0xD3F7             BCC.N    ??HAL_RCC_OscConfig_57
    849                    {
    850                      return HAL_TIMEOUT;
   \      0x57C   0x2003             MOVS     R0,#+3
   \      0x57E   0xE02B             B.N      ??HAL_RCC_OscConfig_2
    851                    }
    852                  }
    853                }
    854              }
    855              else
    856              {
    857                /* Do not return HAL_ERROR if request repeats the current configuration */
    858                temp1_pllckcfg = RCC->PLLCKSELR;
   \                     ??HAL_RCC_OscConfig_52: (+1)
   \      0x580   0x4817             LDR.N    R0,??HAL_RCC_OscConfig_0+0x4
   \      0x582   0x6800             LDR      R0,[R0, #+0]
    859                temp2_pllckcfg = RCC->PLL1DIVR;
   \      0x584   0x491E             LDR.N    R1,??HAL_RCC_OscConfig_0+0x24
   \      0x586   0x6809             LDR      R1,[R1, #+0]
    860                if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
    861          	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
    862                   ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
    863                   (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
    864                   ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
    865                   ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
    866                   ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
   \      0x588   0x6A62             LDR      R2,[R4, #+36]
   \      0x58A   0x2A01             CMP      R2,#+1
   \      0x58C   0xD021             BEQ.N    ??HAL_RCC_OscConfig_58
   \      0x58E   0xF010 0x0203      ANDS     R2,R0,#0x3
   \      0x592   0x6AA3             LDR      R3,[R4, #+40]
   \      0x594   0x429A             CMP      R2,R3
   \      0x596   0xD11C             BNE.N    ??HAL_RCC_OscConfig_58
   \      0x598   0xF3C0 0x1005      UBFX     R0,R0,#+4,#+6
   \      0x59C   0x6AE2             LDR      R2,[R4, #+44]
   \      0x59E   0x4290             CMP      R0,R2
   \      0x5A0   0xD117             BNE.N    ??HAL_RCC_OscConfig_58
   \      0x5A2   0x05C8             LSLS     R0,R1,#+23
   \      0x5A4   0x0DC0             LSRS     R0,R0,#+23
   \      0x5A6   0x6B22             LDR      R2,[R4, #+48]
   \      0x5A8   0x1E52             SUBS     R2,R2,#+1
   \      0x5AA   0x4290             CMP      R0,R2
   \      0x5AC   0xD111             BNE.N    ??HAL_RCC_OscConfig_58
   \      0x5AE   0xF3C1 0x2046      UBFX     R0,R1,#+9,#+7
   \      0x5B2   0x6B62             LDR      R2,[R4, #+52]
   \      0x5B4   0x1E52             SUBS     R2,R2,#+1
   \      0x5B6   0x4290             CMP      R0,R2
   \      0x5B8   0xD10B             BNE.N    ??HAL_RCC_OscConfig_58
   \      0x5BA   0xF3C1 0x4006      UBFX     R0,R1,#+16,#+7
   \      0x5BE   0x6BA2             LDR      R2,[R4, #+56]
   \      0x5C0   0x1E52             SUBS     R2,R2,#+1
   \      0x5C2   0x4290             CMP      R0,R2
   \      0x5C4   0xD105             BNE.N    ??HAL_RCC_OscConfig_58
   \      0x5C6   0xF3C1 0x6006      UBFX     R0,R1,#+24,#+7
   \      0x5CA   0x6BE1             LDR      R1,[R4, #+60]
   \      0x5CC   0x1E49             SUBS     R1,R1,#+1
   \      0x5CE   0x4288             CMP      R0,R1
   \      0x5D0   0xD001             BEQ.N    ??HAL_RCC_OscConfig_51
    867                {
    868                  return HAL_ERROR;
   \                     ??HAL_RCC_OscConfig_58: (+1)
   \      0x5D2   0x2001             MOVS     R0,#+1
   \      0x5D4   0xE000             B.N      ??HAL_RCC_OscConfig_2
    869                }
    870              }
    871            }
    872            return HAL_OK;
   \                     ??HAL_RCC_OscConfig_51: (+1)
   \      0x5D6   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_OscConfig_2: (+1)
   \      0x5D8   0xBD70             POP      {R4-R6,PC}
   \      0x5DA   0xBF00             Nop
   \                     ??HAL_RCC_OscConfig_0:
   \      0x5DC   0x5802'4410        DC32     0x58024410
   \      0x5E0   0x5802'4428        DC32     0x58024428
   \      0x5E4   0x5802'4400        DC32     0x58024400
   \      0x5E8   0x5802'4404        DC32     0x58024404
   \      0x5EC   0x5802'440C        DC32     0x5802440c
   \      0x5F0   0x5802'4474        DC32     0x58024474
   \      0x5F4   0x5802'4800        DC32     0x58024800
   \      0x5F8   0x5802'4470        DC32     0x58024470
   \      0x5FC   0xFFFF'FC0C        DC32     0xfffffc0c
   \      0x600   0x5802'4430        DC32     0x58024430
   \      0x604   0x5802'442C        DC32     0x5802442c
   \      0x608   0x5802'4434        DC32     0x58024434
    873          }
    874          
    875          /**
    876            * @brief  Initializes the CPU, AHB and APB buses clocks according to the specified
    877            *         parameters in the RCC_ClkInitStruct.
    878            * @param  RCC_ClkInitStruct: pointer to an RCC_OscInitTypeDef structure that
    879            *         contains the configuration information for the RCC peripheral.
    880            * @param  FLatency: FLASH Latency, this parameter depend on device selected
    881            *
    882            * @note   The SystemCoreClock CMSIS variable is used to store System Core Clock Frequency
    883            *         and updated by HAL_InitTick() function called within this function
    884            *
    885            * @note   The HSI is used (enabled by hardware) as system clock source after
    886            *         start-up from Reset, wake-up from STOP and STANDBY mode, or in case
    887            *         of failure of the HSE used directly or indirectly as system clock
    888            *         (if the Clock Security System CSS is enabled).
    889            *
    890            * @note   A switch from one clock source to another occurs only if the target
    891            *         clock source is ready (clock stable after start-up delay or PLL locked).
    892            *         If a clock source which is not yet ready is selected, the switch will
    893            *         occur when the clock source will be ready.
    894            *         You can use HAL_RCC_GetClockConfig() function to know which clock is
    895            *         currently used as system clock source.
    896            * @note   Depending on the device voltage range, the software has to set correctly
    897            *         D1CPRE[3:0] bits to ensure that  Domain1 core clock not exceed the maximum allowed frequency
    898            *         (for more details refer to section above "Initialization/de-initialization functions")
    899            * @retval None
    900            */

   \                                 In section .text, align 2, keep-with-next
    901          HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
    902          {
   \                     HAL_RCC_ClockConfig: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000E             MOVS     R6,R1
    903            HAL_StatusTypeDef halstatus;
    904            uint32_t tickstart;
    905            uint32_t common_system_clock;
    906          
    907             /* Check Null pointer */
    908            if(RCC_ClkInitStruct == NULL)
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD101             BNE.N    ??HAL_RCC_ClockConfig_0
    909            {
    910              return HAL_ERROR;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE13A             B.N      ??HAL_RCC_ClockConfig_1
    911            }
    912          
    913            /* Check the parameters */
    914            assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
    915            assert_param(IS_FLASH_LATENCY(FLatency));
    916          
    917            /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    918              must be correctly programmed according to the frequency of the CPU clock
    919              (HCLK) and the supply voltage of the device. */
    920          
    921            /* Increasing the CPU frequency */
    922            if(FLatency > __HAL_FLASH_GET_LATENCY())
   \                     ??HAL_RCC_ClockConfig_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R5,??DataTable11
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x1A   0x42B0             CMP      R0,R6
   \       0x1C   0xD20B             BCS.N    ??HAL_RCC_ClockConfig_2
    923            {
    924              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    925              __HAL_FLASH_SET_LATENCY(FLatency);
   \       0x1E   0x6828             LDR      R0,[R5, #+0]
   \       0x20   0x0900             LSRS     R0,R0,#+4
   \       0x22   0x0100             LSLS     R0,R0,#+4
   \       0x24   0x4330             ORRS     R0,R6,R0
   \       0x26   0x6028             STR      R0,[R5, #+0]
    926          
    927              /* Check that the new number of wait states is taken into account to access the Flash
    928              memory by reading the FLASH_ACR register */
    929              if(__HAL_FLASH_GET_LATENCY() != FLatency)
   \       0x28   0x6828             LDR      R0,[R5, #+0]
   \       0x2A   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x2E   0x42B0             CMP      R0,R6
   \       0x30   0xD001             BEQ.N    ??HAL_RCC_ClockConfig_2
    930              {
    931                return HAL_ERROR;
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xE127             B.N      ??HAL_RCC_ClockConfig_1
    932              }
    933          
    934            }
    935          
    936            /* Increasing the BUS frequency divider */
    937            /*-------------------------- D1PCLK1/CDPCLK1 Configuration ---------------------------*/
    938            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
   \                     ??HAL_RCC_ClockConfig_2: (+1)
   \       0x36   0x7820             LDRB     R0,[R4, #+0]
   \       0x38   0x0740             LSLS     R0,R0,#+29
   \       0x3A   0xD50D             BPL.N    ??HAL_RCC_ClockConfig_3
    939            {
    940          #if defined (RCC_D1CFGR_D1PPRE)
    941              if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
    942              {
    943                assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
    944                MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
    945              }
    946          #else
    947              if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE))
   \       0x3C   0x.... 0x....      LDR.W    R1,??DataTable11_9
   \       0x40   0x6808             LDR      R0,[R1, #+0]
   \       0x42   0xF010 0x0070      ANDS     R0,R0,#0x70
   \       0x46   0x6922             LDR      R2,[R4, #+16]
   \       0x48   0x4290             CMP      R0,R2
   \       0x4A   0xD205             BCS.N    ??HAL_RCC_ClockConfig_3
    948              {
    949                assert_param(IS_RCC_CDPCLK1(RCC_ClkInitStruct->APB3CLKDivider));
    950                MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDPPRE, RCC_ClkInitStruct->APB3CLKDivider);
   \       0x4C   0x680A             LDR      R2,[R1, #+0]
   \       0x4E   0xF032 0x0270      BICS     R2,R2,#0x70
   \       0x52   0x6920             LDR      R0,[R4, #+16]
   \       0x54   0x4302             ORRS     R2,R0,R2
   \       0x56   0x600A             STR      R2,[R1, #+0]
    951              }
    952          #endif
    953            }
    954          
    955            /*-------------------------- PCLK1 Configuration ---------------------------*/
    956            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
   \                     ??HAL_RCC_ClockConfig_3: (+1)
   \       0x58   0x7820             LDRB     R0,[R4, #+0]
   \       0x5A   0x0700             LSLS     R0,R0,#+28
   \       0x5C   0xD50D             BPL.N    ??HAL_RCC_ClockConfig_4
    957            {
    958          #if defined (RCC_D2CFGR_D2PPRE1)
    959              if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
    960              {
    961                assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
    962                MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
    963              }
    964          #else
    965              if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1))
   \       0x5E   0x.... 0x....      LDR.W    R1,??DataTable11_10
   \       0x62   0x6808             LDR      R0,[R1, #+0]
   \       0x64   0xF010 0x0070      ANDS     R0,R0,#0x70
   \       0x68   0x6962             LDR      R2,[R4, #+20]
   \       0x6A   0x4290             CMP      R0,R2
   \       0x6C   0xD205             BCS.N    ??HAL_RCC_ClockConfig_4
    966              {
    967                assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
    968                MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
   \       0x6E   0x680A             LDR      R2,[R1, #+0]
   \       0x70   0xF032 0x0270      BICS     R2,R2,#0x70
   \       0x74   0x6960             LDR      R0,[R4, #+20]
   \       0x76   0x4302             ORRS     R2,R0,R2
   \       0x78   0x600A             STR      R2,[R1, #+0]
    969            }
    970          #endif
    971              }
    972            /*-------------------------- PCLK2 Configuration ---------------------------*/
    973            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
   \                     ??HAL_RCC_ClockConfig_4: (+1)
   \       0x7A   0x7820             LDRB     R0,[R4, #+0]
   \       0x7C   0x06C0             LSLS     R0,R0,#+27
   \       0x7E   0xD50D             BPL.N    ??HAL_RCC_ClockConfig_5
    974            {
    975          #if defined(RCC_D2CFGR_D2PPRE2)
    976              if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
    977              {
    978                assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
    979                MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
    980              }
    981          #else
    982               if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2))
   \       0x80   0x.... 0x....      LDR.W    R1,??DataTable11_10
   \       0x84   0x6808             LDR      R0,[R1, #+0]
   \       0x86   0xF410 0x60E0      ANDS     R0,R0,#0x700
   \       0x8A   0x69A2             LDR      R2,[R4, #+24]
   \       0x8C   0x4290             CMP      R0,R2
   \       0x8E   0xD205             BCS.N    ??HAL_RCC_ClockConfig_5
    983              {
    984                assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
    985                MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
   \       0x90   0x680A             LDR      R2,[R1, #+0]
   \       0x92   0xF432 0x62E0      BICS     R2,R2,#0x700
   \       0x96   0x69A0             LDR      R0,[R4, #+24]
   \       0x98   0x4302             ORRS     R2,R0,R2
   \       0x9A   0x600A             STR      R2,[R1, #+0]
    986              }
    987          #endif
    988            }
    989          
    990            /*-------------------------- D3PCLK1 Configuration ---------------------------*/
    991            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
   \                     ??HAL_RCC_ClockConfig_5: (+1)
   \       0x9C   0x7820             LDRB     R0,[R4, #+0]
   \       0x9E   0x0680             LSLS     R0,R0,#+26
   \       0xA0   0xD50D             BPL.N    ??HAL_RCC_ClockConfig_6
    992            {
    993          #if defined(RCC_D3CFGR_D3PPRE)
    994              if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
    995              {
    996                assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
    997                MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
    998              }
    999          #else
   1000              if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE))
   \       0xA2   0x.... 0x....      LDR.W    R1,??DataTable11_11
   \       0xA6   0x6808             LDR      R0,[R1, #+0]
   \       0xA8   0xF010 0x0070      ANDS     R0,R0,#0x70
   \       0xAC   0x69E2             LDR      R2,[R4, #+28]
   \       0xAE   0x4290             CMP      R0,R2
   \       0xB0   0xD205             BCS.N    ??HAL_RCC_ClockConfig_6
   1001              {
   1002                assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
   1003                MODIFY_REG(RCC->SRDCFGR, RCC_SRDCFGR_SRDPPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
   \       0xB2   0x680A             LDR      R2,[R1, #+0]
   \       0xB4   0xF032 0x0270      BICS     R2,R2,#0x70
   \       0xB8   0x69E0             LDR      R0,[R4, #+28]
   \       0xBA   0x4302             ORRS     R2,R0,R2
   \       0xBC   0x600A             STR      R2,[R1, #+0]
   1004              }
   1005          #endif
   1006            }
   1007          
   1008             /*-------------------------- HCLK Configuration --------------------------*/
   1009            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
   \                     ??HAL_RCC_ClockConfig_6: (+1)
   \       0xBE   0x7820             LDRB     R0,[R4, #+0]
   \       0xC0   0x0780             LSLS     R0,R0,#+30
   \       0xC2   0xD50D             BPL.N    ??HAL_RCC_ClockConfig_7
   1010            {
   1011          #if defined (RCC_D1CFGR_HPRE)
   1012              if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
   1013              {
   1014                /* Set the new HCLK clock divider */
   1015                assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
   1016                MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
   1017              }
   1018          #else
   1019                  if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->CDCFGR1 & RCC_CDCFGR1_HPRE))
   \       0xC4   0x.... 0x....      LDR.W    R1,??DataTable11_9
   \       0xC8   0x6808             LDR      R0,[R1, #+0]
   \       0xCA   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0xCE   0x68E2             LDR      R2,[R4, #+12]
   \       0xD0   0x4290             CMP      R0,R2
   \       0xD2   0xD205             BCS.N    ??HAL_RCC_ClockConfig_7
   1020              {
   1021                /* Set the new HCLK clock divider */
   1022                assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
   1023                MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
   \       0xD4   0x680A             LDR      R2,[R1, #+0]
   \       0xD6   0x0912             LSRS     R2,R2,#+4
   \       0xD8   0x0112             LSLS     R2,R2,#+4
   \       0xDA   0x68E0             LDR      R0,[R4, #+12]
   \       0xDC   0x4302             ORRS     R2,R0,R2
   \       0xDE   0x600A             STR      R2,[R1, #+0]
   1024              }
   1025          #endif
   1026            }
   1027          
   1028              /*------------------------- SYSCLK Configuration -------------------------*/
   1029              if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
   \                     ??HAL_RCC_ClockConfig_7: (+1)
   \       0xE0   0x7820             LDRB     R0,[R4, #+0]
   \       0xE2   0x07C0             LSLS     R0,R0,#+31
   \       0xE4   0xD548             BPL.N    ??HAL_RCC_ClockConfig_8
   1030              {
   1031                assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
   1032                assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
   1033          #if defined(RCC_D1CFGR_D1CPRE)
   1034                MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
   1035          #else
   1036                MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDCPRE, RCC_ClkInitStruct->SYSCLKDivider);
   \       0xE6   0x.... 0x....      LDR.W    R1,??DataTable11_9
   \       0xEA   0x680A             LDR      R2,[R1, #+0]
   \       0xEC   0xF432 0x6270      BICS     R2,R2,#0xF00
   \       0xF0   0x68A0             LDR      R0,[R4, #+8]
   \       0xF2   0x4302             ORRS     R2,R0,R2
   \       0xF4   0x600A             STR      R2,[R1, #+0]
   1037          #endif
   1038                /* HSE is selected as System Clock Source */
   1039                if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \       0xF6   0x6860             LDR      R0,[R4, #+4]
   \       0xF8   0x2802             CMP      R0,#+2
   \       0xFA   0xD106             BNE.N    ??HAL_RCC_ClockConfig_9
   1040                {
   1041                  /* Check the HSE ready flag */
   1042                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
   \       0xFC   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \      0x100   0x6800             LDR      R0,[R0, #+0]
   \      0x102   0x0380             LSLS     R0,R0,#+14
   \      0x104   0xD41C             BMI.N    ??HAL_RCC_ClockConfig_10
   1043                  {
   1044                    return HAL_ERROR;
   \      0x106   0x2001             MOVS     R0,#+1
   \      0x108   0xE0BD             B.N      ??HAL_RCC_ClockConfig_1
   1045                  }
   1046                }
   1047                /* PLL is selected as System Clock Source */
   1048                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_9: (+1)
   \      0x10A   0x6860             LDR      R0,[R4, #+4]
   \      0x10C   0x2803             CMP      R0,#+3
   \      0x10E   0xD106             BNE.N    ??HAL_RCC_ClockConfig_11
   1049                {
   1050                  /* Check the PLL ready flag */
   1051                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
   \      0x110   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \      0x114   0x6800             LDR      R0,[R0, #+0]
   \      0x116   0x0180             LSLS     R0,R0,#+6
   \      0x118   0xD412             BMI.N    ??HAL_RCC_ClockConfig_10
   1052                  {
   1053                    return HAL_ERROR;
   \      0x11A   0x2001             MOVS     R0,#+1
   \      0x11C   0xE0B3             B.N      ??HAL_RCC_ClockConfig_1
   1054                  }
   1055                }
   1056                /* CSI is selected as System Clock Source */
   1057                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
   \                     ??HAL_RCC_ClockConfig_11: (+1)
   \      0x11E   0x6860             LDR      R0,[R4, #+4]
   \      0x120   0x2801             CMP      R0,#+1
   \      0x122   0xD106             BNE.N    ??HAL_RCC_ClockConfig_12
   1058                {
   1059                  /* Check the PLL ready flag */
   1060                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
   \      0x124   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \      0x128   0x6800             LDR      R0,[R0, #+0]
   \      0x12A   0x05C0             LSLS     R0,R0,#+23
   \      0x12C   0xD408             BMI.N    ??HAL_RCC_ClockConfig_10
   1061                  {
   1062                    return HAL_ERROR;
   \      0x12E   0x2001             MOVS     R0,#+1
   \      0x130   0xE0A9             B.N      ??HAL_RCC_ClockConfig_1
   1063                  }
   1064                }
   1065                /* HSI is selected as System Clock Source */
   1066                else
   1067                {
   1068                  /* Check the HSI ready flag */
   1069                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
   \                     ??HAL_RCC_ClockConfig_12: (+1)
   \      0x132   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \      0x136   0x6800             LDR      R0,[R0, #+0]
   \      0x138   0x0740             LSLS     R0,R0,#+29
   \      0x13A   0xD401             BMI.N    ??HAL_RCC_ClockConfig_10
   1070                  {
   1071                    return HAL_ERROR;
   \      0x13C   0x2001             MOVS     R0,#+1
   \      0x13E   0xE0A2             B.N      ??HAL_RCC_ClockConfig_1
   1072                  }
   1073                }
   1074                MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
   \                     ??HAL_RCC_ClockConfig_10: (+1)
   \      0x140   0x.... 0x....      LDR.W    R7,??DataTable11_3
   \      0x144   0x6839             LDR      R1,[R7, #+0]
   \      0x146   0x08C9             LSRS     R1,R1,#+3
   \      0x148   0x00C9             LSLS     R1,R1,#+3
   \      0x14A   0x6860             LDR      R0,[R4, #+4]
   \      0x14C   0x4301             ORRS     R1,R0,R1
   \      0x14E   0x6039             STR      R1,[R7, #+0]
   1075          
   1076                /* Get Start Tick*/
   1077                tickstart = HAL_GetTick();
   \      0x150   0x.... 0x....      BL       HAL_GetTick
   \      0x154   0x4680             MOV      R8,R0
   1078          
   1079                  while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
   \                     ??HAL_RCC_ClockConfig_13: (+1)
   \      0x156   0x6838             LDR      R0,[R7, #+0]
   \      0x158   0xF010 0x0038      ANDS     R0,R0,#0x38
   \      0x15C   0x6861             LDR      R1,[R4, #+4]
   \      0x15E   0xEBB0 0x0FC1      CMP      R0,R1, LSL #+3
   \      0x162   0xD009             BEQ.N    ??HAL_RCC_ClockConfig_8
   1080                  {
   1081                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \      0x164   0x.... 0x....      BL       HAL_GetTick
   \      0x168   0xEBB0 0x0008      SUBS     R0,R0,R8
   \      0x16C   0xF241 0x3189      MOVW     R1,#+5001
   \      0x170   0x4288             CMP      R0,R1
   \      0x172   0xD3F0             BCC.N    ??HAL_RCC_ClockConfig_13
   1082                    {
   1083                      return HAL_TIMEOUT;
   \      0x174   0x2003             MOVS     R0,#+3
   \      0x176   0xE086             B.N      ??HAL_RCC_ClockConfig_1
   1084                    }
   1085                  }
   1086          
   1087              }
   1088          
   1089              /* Decreasing the BUS frequency divider */
   1090             /*-------------------------- HCLK Configuration --------------------------*/
   1091            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
   \                     ??HAL_RCC_ClockConfig_8: (+1)
   \      0x178   0x7820             LDRB     R0,[R4, #+0]
   \      0x17A   0x0780             LSLS     R0,R0,#+30
   \      0x17C   0xD50D             BPL.N    ??HAL_RCC_ClockConfig_14
   1092            {
   1093          #if defined(RCC_D1CFGR_HPRE)
   1094              if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
   1095              {
   1096                /* Set the new HCLK clock divider */
   1097                assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
   1098                MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
   1099              }
   1100          #else
   1101              if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->CDCFGR1 & RCC_CDCFGR1_HPRE))
   \      0x17E   0x.... 0x....      LDR.W    R1,??DataTable11_9
   \      0x182   0x68E0             LDR      R0,[R4, #+12]
   \      0x184   0x680A             LDR      R2,[R1, #+0]
   \      0x186   0xF012 0x020F      ANDS     R2,R2,#0xF
   \      0x18A   0x4290             CMP      R0,R2
   \      0x18C   0xD205             BCS.N    ??HAL_RCC_ClockConfig_14
   1102              {
   1103                /* Set the new HCLK clock divider */
   1104                assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
   1105                MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
   \      0x18E   0x680A             LDR      R2,[R1, #+0]
   \      0x190   0x0912             LSRS     R2,R2,#+4
   \      0x192   0x0112             LSLS     R2,R2,#+4
   \      0x194   0x68E0             LDR      R0,[R4, #+12]
   \      0x196   0x4302             ORRS     R2,R0,R2
   \      0x198   0x600A             STR      R2,[R1, #+0]
   1106              }
   1107          #endif
   1108            }
   1109          
   1110            /* Decreasing the number of wait states because of lower CPU frequency */
   1111            if(FLatency < __HAL_FLASH_GET_LATENCY())
   \                     ??HAL_RCC_ClockConfig_14: (+1)
   \      0x19A   0x6828             LDR      R0,[R5, #+0]
   \      0x19C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x1A0   0x4286             CMP      R6,R0
   \      0x1A2   0xD20B             BCS.N    ??HAL_RCC_ClockConfig_15
   1112            {
   1113              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
   1114              __HAL_FLASH_SET_LATENCY(FLatency);
   \      0x1A4   0x6828             LDR      R0,[R5, #+0]
   \      0x1A6   0x0900             LSRS     R0,R0,#+4
   \      0x1A8   0x0100             LSLS     R0,R0,#+4
   \      0x1AA   0x4330             ORRS     R0,R6,R0
   \      0x1AC   0x6028             STR      R0,[R5, #+0]
   1115          
   1116              /* Check that the new number of wait states is taken into account to access the Flash
   1117              memory by reading the FLASH_ACR register */
   1118              if(__HAL_FLASH_GET_LATENCY() != FLatency)
   \      0x1AE   0x6828             LDR      R0,[R5, #+0]
   \      0x1B0   0xF010 0x000F      ANDS     R0,R0,#0xF
   \      0x1B4   0x42B0             CMP      R0,R6
   \      0x1B6   0xD001             BEQ.N    ??HAL_RCC_ClockConfig_15
   1119              {
   1120                return HAL_ERROR;
   \      0x1B8   0x2001             MOVS     R0,#+1
   \      0x1BA   0xE064             B.N      ??HAL_RCC_ClockConfig_1
   1121              }
   1122           }
   1123          
   1124            /*-------------------------- D1PCLK1/CDPCLK Configuration ---------------------------*/
   1125           if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
   \                     ??HAL_RCC_ClockConfig_15: (+1)
   \      0x1BC   0x7820             LDRB     R0,[R4, #+0]
   \      0x1BE   0x0740             LSLS     R0,R0,#+29
   \      0x1C0   0xD50D             BPL.N    ??HAL_RCC_ClockConfig_16
   1126           {
   1127          #if defined(RCC_D1CFGR_D1PPRE)
   1128             if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
   1129             {
   1130               assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
   1131               MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
   1132             }
   1133          #else
   1134             if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE))
   \      0x1C2   0x.... 0x....      LDR.W    R1,??DataTable11_9
   \      0x1C6   0x6920             LDR      R0,[R4, #+16]
   \      0x1C8   0x680A             LDR      R2,[R1, #+0]
   \      0x1CA   0xF012 0x0270      ANDS     R2,R2,#0x70
   \      0x1CE   0x4290             CMP      R0,R2
   \      0x1D0   0xD205             BCS.N    ??HAL_RCC_ClockConfig_16
   1135             {
   1136               assert_param(IS_RCC_CDPCLK1(RCC_ClkInitStruct->APB3CLKDivider));
   1137               MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDPPRE, RCC_ClkInitStruct->APB3CLKDivider);
   \      0x1D2   0x680A             LDR      R2,[R1, #+0]
   \      0x1D4   0xF032 0x0270      BICS     R2,R2,#0x70
   \      0x1D8   0x6920             LDR      R0,[R4, #+16]
   \      0x1DA   0x4302             ORRS     R2,R0,R2
   \      0x1DC   0x600A             STR      R2,[R1, #+0]
   1138             }
   1139          #endif
   1140           }
   1141          
   1142            /*-------------------------- PCLK1 Configuration ---------------------------*/
   1143           if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
   \                     ??HAL_RCC_ClockConfig_16: (+1)
   \      0x1DE   0x7820             LDRB     R0,[R4, #+0]
   \      0x1E0   0x0700             LSLS     R0,R0,#+28
   \      0x1E2   0xD50D             BPL.N    ??HAL_RCC_ClockConfig_17
   1144           {
   1145          #if defined(RCC_D2CFGR_D2PPRE1)
   1146             if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
   1147             {
   1148               assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
   1149               MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
   1150             }
   1151          #else
   1152             if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1))
   \      0x1E4   0x.... 0x....      LDR.W    R1,??DataTable11_10
   \      0x1E8   0x6960             LDR      R0,[R4, #+20]
   \      0x1EA   0x680A             LDR      R2,[R1, #+0]
   \      0x1EC   0xF012 0x0270      ANDS     R2,R2,#0x70
   \      0x1F0   0x4290             CMP      R0,R2
   \      0x1F2   0xD205             BCS.N    ??HAL_RCC_ClockConfig_17
   1153             {
   1154               assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
   1155               MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
   \      0x1F4   0x680A             LDR      R2,[R1, #+0]
   \      0x1F6   0xF032 0x0270      BICS     R2,R2,#0x70
   \      0x1FA   0x6960             LDR      R0,[R4, #+20]
   \      0x1FC   0x4302             ORRS     R2,R0,R2
   \      0x1FE   0x600A             STR      R2,[R1, #+0]
   1156             }
   1157          #endif
   1158           }
   1159          
   1160            /*-------------------------- PCLK2 Configuration ---------------------------*/
   1161           if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
   \                     ??HAL_RCC_ClockConfig_17: (+1)
   \      0x200   0x7820             LDRB     R0,[R4, #+0]
   \      0x202   0x06C0             LSLS     R0,R0,#+27
   \      0x204   0xD50D             BPL.N    ??HAL_RCC_ClockConfig_18
   1162           {
   1163          #if defined (RCC_D2CFGR_D2PPRE2)
   1164             if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
   1165             {
   1166               assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
   1167               MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
   1168             }
   1169          #else
   1170             if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2))
   \      0x206   0x.... 0x....      LDR.W    R1,??DataTable11_10
   \      0x20A   0x69A0             LDR      R0,[R4, #+24]
   \      0x20C   0x680A             LDR      R2,[R1, #+0]
   \      0x20E   0xF412 0x62E0      ANDS     R2,R2,#0x700
   \      0x212   0x4290             CMP      R0,R2
   \      0x214   0xD205             BCS.N    ??HAL_RCC_ClockConfig_18
   1171             {
   1172               assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
   1173               MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
   \      0x216   0x680A             LDR      R2,[R1, #+0]
   \      0x218   0xF432 0x62E0      BICS     R2,R2,#0x700
   \      0x21C   0x69A0             LDR      R0,[R4, #+24]
   \      0x21E   0x4302             ORRS     R2,R0,R2
   \      0x220   0x600A             STR      R2,[R1, #+0]
   1174             }
   1175          #endif
   1176           }
   1177          
   1178            /*-------------------------- D3PCLK1/SRDPCLK1 Configuration ---------------------------*/
   1179           if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
   \                     ??HAL_RCC_ClockConfig_18: (+1)
   \      0x222   0x7820             LDRB     R0,[R4, #+0]
   \      0x224   0x0680             LSLS     R0,R0,#+26
   \      0x226   0xD50D             BPL.N    ??HAL_RCC_ClockConfig_19
   1180           {
   1181          #if defined(RCC_D3CFGR_D3PPRE)
   1182             if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
   1183             {
   1184               assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
   1185               MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
   1186             }
   1187          #else
   1188             if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE))
   \      0x228   0x.... 0x....      LDR.W    R1,??DataTable11_11
   \      0x22C   0x69E0             LDR      R0,[R4, #+28]
   \      0x22E   0x680A             LDR      R2,[R1, #+0]
   \      0x230   0xF012 0x0270      ANDS     R2,R2,#0x70
   \      0x234   0x4290             CMP      R0,R2
   \      0x236   0xD205             BCS.N    ??HAL_RCC_ClockConfig_19
   1189             {
   1190               assert_param(IS_RCC_SRDPCLK1(RCC_ClkInitStruct->APB4CLKDivider));
   1191               MODIFY_REG(RCC->SRDCFGR, RCC_SRDCFGR_SRDPPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
   \      0x238   0x680A             LDR      R2,[R1, #+0]
   \      0x23A   0xF032 0x0270      BICS     R2,R2,#0x70
   \      0x23E   0x69E0             LDR      R0,[R4, #+28]
   \      0x240   0x4302             ORRS     R2,R0,R2
   \      0x242   0x600A             STR      R2,[R1, #+0]
   1192             }
   1193          #endif
   1194           }
   1195          
   1196            /* Update the SystemCoreClock global variable */
   1197          #if defined(RCC_D1CFGR_D1CPRE)
   1198            common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
   1199          #else
   1200            common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
   \                     ??HAL_RCC_ClockConfig_19: (+1)
   \      0x244   0x.... 0x....      BL       HAL_RCC_GetSysClockFreq
   \      0x248   0x.... 0x....      LDR.W    R2,??DataTable11_26
   \      0x24C   0x.... 0x....      LDR.W    R1,??DataTable11_9
   \      0x250   0x680B             LDR      R3,[R1, #+0]
   \      0x252   0xF3C3 0x2303      UBFX     R3,R3,#+8,#+4
   \      0x256   0x5CD3             LDRB     R3,[R2, R3]
   \      0x258   0xF013 0x031F      ANDS     R3,R3,#0x1F
   \      0x25C   0x40D8             LSRS     R0,R0,R3
   1201          #endif
   1202          
   1203          #if defined(RCC_D1CFGR_HPRE)
   1204            SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
   1205          #else
   1206            SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));
   \      0x25E   0x6809             LDR      R1,[R1, #+0]
   \      0x260   0xF011 0x010F      ANDS     R1,R1,#0xF
   \      0x264   0x5C51             LDRB     R1,[R2, R1]
   \      0x266   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \      0x26A   0x0002             MOVS     R2,R0
   \      0x26C   0x40CA             LSRS     R2,R2,R1
   \      0x26E   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \      0x272   0x600A             STR      R2,[R1, #+0]
   1207          #endif
   1208          
   1209          #if defined(DUAL_CORE) && defined(CORE_CM4)
   1210            SystemCoreClock = SystemD2Clock;
   1211          #else
   1212            SystemCoreClock = common_system_clock;
   \      0x274   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \      0x278   0x6008             STR      R0,[R1, #+0]
   1213          #endif /* DUAL_CORE && CORE_CM4 */
   1214          
   1215            /* Configure the source of time base considering new system clocks settings*/
   1216            halstatus = HAL_InitTick (uwTickPrio);
   \      0x27A   0x.... 0x....      LDR.W    R0,??DataTable11_7
   \      0x27E   0x6800             LDR      R0,[R0, #+0]
   \      0x280   0x.... 0x....      BL       HAL_InitTick
   1217          
   1218            return halstatus;
   \      0x284   0xB2C0             UXTB     R0,R0
   \                     ??HAL_RCC_ClockConfig_1: (+1)
   \      0x286   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1219          }
   1220          
   1221          /**
   1222            * @}
   1223            */
   1224          
   1225          /** @defgroup RCC_Group2 Peripheral Control functions
   1226           *  @brief   RCC clocks control functions
   1227           *
   1228          @verbatim
   1229           ===============================================================================
   1230                                ##### Peripheral Control functions #####
   1231           ===============================================================================
   1232              [..]
   1233              This subsection provides a set of functions allowing to control the RCC Clocks
   1234              frequencies.
   1235          
   1236          @endverbatim
   1237            * @{
   1238            */
   1239          
   1240          /**
   1241            * @brief  Selects the clock source to output on MCO1 pin(PA8) or on MCO2 pin(PC9).
   1242            * @note   PA8/PC9 should be configured in alternate function mode.
   1243            * @param  RCC_MCOx: specifies the output direction for the clock source.
   1244            *          This parameter can be one of the following values:
   1245            *            @arg RCC_MCO1: Clock source to output on MCO1 pin(PA8).
   1246            *            @arg RCC_MCO2: Clock source to output on MCO2 pin(PC9).
   1247            * @param  RCC_MCOSource: specifies the clock source to output.
   1248            *          This parameter can be one of the following values:
   1249            *            @arg RCC_MCO1SOURCE_HSI: HSI clock selected as MCO1 source
   1250            *            @arg RCC_MCO1SOURCE_LSE: LSE clock selected as MCO1 source
   1251            *            @arg RCC_MCO1SOURCE_HSE: HSE clock selected as MCO1 source
   1252            *            @arg RCC_MCO1SOURCE_PLL1QCLK:  PLL1Q clock selected as MCO1 source
   1253            *            @arg RCC_MCO1SOURCE_HSI48: HSI48 (48MHZ) selected as MCO1 source
   1254            *            @arg RCC_MCO2SOURCE_SYSCLK: System clock (SYSCLK) selected as MCO2 source
   1255            *            @arg RCC_MCO2SOURCE_PLL2PCLK: PLL2P clock selected as MCO2 source
   1256            *            @arg RCC_MCO2SOURCE_HSE: HSE clock selected as MCO2 source
   1257            *            @arg RCC_MCO2SOURCE_PLLCLK:  PLL1P clock selected as MCO2 source
   1258            *            @arg RCC_MCO2SOURCE_CSICLK:  CSI clock selected as MCO2 source
   1259            *            @arg RCC_MCO2SOURCE_LSICLK:  LSI clock selected as MCO2 source
   1260            * @param  RCC_MCODiv: specifies the MCOx pre-scaler.
   1261            *          This parameter can be one of the following values:
   1262            *            @arg RCC_MCODIV_1 up to RCC_MCODIV_15  : divider applied to MCOx clock
   1263            * @retval None
   1264            */

   \                                 In section .text, align 2, keep-with-next
   1265          void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
   1266          {
   \                     HAL_RCC_MCOConfig: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0015             MOVS     R5,R2
   1267            GPIO_InitTypeDef GPIO_InitStruct;
   1268            /* Check the parameters */
   1269            assert_param(IS_RCC_MCO(RCC_MCOx));
   1270            assert_param(IS_RCC_MCODIV(RCC_MCODiv));
   1271            /* RCC_MCO1 */
   1272            if(RCC_MCOx == RCC_MCO1)
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD123             BNE.N    ??HAL_RCC_MCOConfig_0
   1273            {
   1274              assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
   1275          
   1276              /* MCO1 Clock Enable */
   1277              MCO1_CLK_ENABLE();
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable11_27
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x16   0x6001             STR      R1,[R0, #+0]
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x1E   0x9005             STR      R0,[SP, #+20]
   \       0x20   0x9805             LDR      R0,[SP, #+20]
   1278          
   1279              /* Configure the MCO1 pin in alternate function mode */
   1280              GPIO_InitStruct.Pin = MCO1_PIN;
   \       0x22   0xF44F 0x7080      MOV      R0,#+256
   \       0x26   0x9000             STR      R0,[SP, #+0]
   1281              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \       0x28   0x2002             MOVS     R0,#+2
   \       0x2A   0x9001             STR      R0,[SP, #+4]
   1282              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \       0x2C   0x2003             MOVS     R0,#+3
   \       0x2E   0x9003             STR      R0,[SP, #+12]
   1283              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x9002             STR      R0,[SP, #+8]
   1284              GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x9004             STR      R0,[SP, #+16]
   1285              HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
   \       0x38   0x4669             MOV      R1,SP
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable11_28
   \       0x3E   0x.... 0x....      BL       HAL_GPIO_Init
   1286          
   1287              /* Mask MCO1 and MCO1PRE[3:0] bits then Select MCO1 clock source and pre-scaler */
   1288              MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x46   0x6801             LDR      R1,[R0, #+0]
   \       0x48   0xF031 0x71FE      BICS     R1,R1,#0x1FC0000
   \       0x4C   0x430C             ORRS     R4,R4,R1
   \       0x4E   0x432C             ORRS     R4,R5,R4
   \       0x50   0x6004             STR      R4,[R0, #+0]
   \       0x52   0xE023             B.N      ??HAL_RCC_MCOConfig_1
   1289            }
   1290            else
   1291            {
   1292              assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));
   1293          
   1294              /* MCO2 Clock Enable */
   1295              MCO2_CLK_ENABLE();
   \                     ??HAL_RCC_MCOConfig_0: (+1)
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable11_27
   \       0x58   0x6801             LDR      R1,[R0, #+0]
   \       0x5A   0xF051 0x0104      ORRS     R1,R1,#0x4
   \       0x5E   0x6001             STR      R1,[R0, #+0]
   \       0x60   0x6800             LDR      R0,[R0, #+0]
   \       0x62   0xF010 0x0004      ANDS     R0,R0,#0x4
   \       0x66   0x9005             STR      R0,[SP, #+20]
   \       0x68   0x9805             LDR      R0,[SP, #+20]
   1296          
   1297              /* Configure the MCO2 pin in alternate function mode */
   1298              GPIO_InitStruct.Pin = MCO2_PIN;
   \       0x6A   0xF44F 0x7000      MOV      R0,#+512
   \       0x6E   0x9000             STR      R0,[SP, #+0]
   1299              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \       0x70   0x2002             MOVS     R0,#+2
   \       0x72   0x9001             STR      R0,[SP, #+4]
   1300              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \       0x74   0x2003             MOVS     R0,#+3
   \       0x76   0x9003             STR      R0,[SP, #+12]
   1301              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0x9002             STR      R0,[SP, #+8]
   1302              GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x9004             STR      R0,[SP, #+16]
   1303              HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
   \       0x80   0x4669             MOV      R1,SP
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable11_29
   \       0x86   0x.... 0x....      BL       HAL_GPIO_Init
   1304          
   1305              /* Mask MCO2 and MCO2PRE[3:0] bits then Select MCO2 clock source and pre-scaler */
   1306              MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
   \       0x8A   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x8E   0x6801             LDR      R1,[R0, #+0]
   \       0x90   0xF021 0x417E      BIC      R1,R1,#0xFE000000
   \       0x94   0x430C             ORRS     R4,R4,R1
   \       0x96   0xEA54 0x14C5      ORRS     R4,R4,R5, LSL #+7
   \       0x9A   0x6004             STR      R4,[R0, #+0]
   1307            }
   1308          }
   \                     ??HAL_RCC_MCOConfig_1: (+1)
   \       0x9C   0xB007             ADD      SP,SP,#+28
   \       0x9E   0xBD30             POP      {R4,R5,PC}
   1309          
   1310          /**
   1311            * @brief  Enables the Clock Security System.
   1312            * @note   If a failure is detected on the HSE oscillator clock, this oscillator
   1313            *         is automatically disabled and an interrupt is generated to inform the
   1314            *         software about the failure (Clock Security System Interrupt, CSSI),
   1315            *         allowing the MCU to perform rescue operations. The CSSI is linked to
   1316            *         the Cortex-M NMI (Non-Mask-able Interrupt) exception vector.
   1317            * @retval None
   1318            */

   \                                 In section .text, align 2, keep-with-next
   1319          void HAL_RCC_EnableCSS(void)
   1320          {
   1321            SET_BIT(RCC->CR, RCC_CR_CSSHSEON) ;
   \                     HAL_RCC_EnableCSS: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0xF451 0x2100      ORRS     R1,R1,#0x80000
   \        0xA   0x6001             STR      R1,[R0, #+0]
   1322          }
   \        0xC   0x4770             BX       LR
   1323          
   1324          /**
   1325            * @brief  Disables the Clock Security System.
   1326            * @retval None
   1327            */

   \                                 In section .text, align 2, keep-with-next
   1328          void HAL_RCC_DisableCSS(void)
   1329          {
   1330            CLEAR_BIT(RCC->CR, RCC_CR_CSSHSEON);
   \                     HAL_RCC_DisableCSS: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0xF431 0x2100      BICS     R1,R1,#0x80000
   \        0xA   0x6001             STR      R1,[R0, #+0]
   1331          }
   \        0xC   0x4770             BX       LR
   1332          
   1333          /**
   1334            * @brief  Returns the SYSCLK frequency
   1335            *
   1336            * @note   The system frequency computed by this function is not the real
   1337            *         frequency in the chip. It is calculated based on the predefined
   1338            *         constant and the selected clock source:
   1339            * @note     If SYSCLK source is CSI, function returns values based on CSI_VALUE(*)
   1340            * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(**)
   1341            * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(***)
   1342            * @note     If SYSCLK source is PLL, function returns values based on CSI_VALUE(*),
   1343            *           HSI_VALUE(**) or HSE_VALUE(***) multiplied/divided by the PLL factors.
   1344            * @note     (*) CSI_VALUE is a constant defined in stm32h7xx_hal_conf.h file (default value
   1345            *               4 MHz) but the real value may vary depending on the variations
   1346            *               in voltage and temperature.
   1347            * @note     (**) HSI_VALUE is a constant defined in stm32h7xx_hal_conf.h file (default value
   1348            *               64 MHz) but the real value may vary depending on the variations
   1349            *               in voltage and temperature.
   1350            * @note     (***) HSE_VALUE is a constant defined in stm32h7xx_hal_conf.h file (default value
   1351            *                25 MHz), user has to ensure that HSE_VALUE is same as the real
   1352            *                frequency of the crystal used. Otherwise, this function may
   1353            *                have wrong result.
   1354            *
   1355            * @note   The result of this function could be not correct when using fractional
   1356            *         value for HSE crystal.
   1357            *
   1358            * @note   This function can be used by the user application to compute the
   1359            *         baud rate for the communication peripherals or configure other parameters.
   1360            *
   1361            * @note   Each time SYSCLK changes, this function must be called to update the
   1362            *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
   1363            *
   1364            *
   1365            * @retval SYSCLK frequency
   1366            */

   \                                 In section .text, align 4, keep-with-next
   1367          uint32_t HAL_RCC_GetSysClockFreq(void)
   1368          {
   1369            uint32_t pllp, pllsource, pllm, pllfracen, hsivalue;
   1370            float_t fracn1, pllvco;
   1371            uint32_t sysclockfreq;
   1372          
   1373            /* Get SYSCLK source -------------------------------------------------------*/
   1374          
   1375            switch (RCC->CFGR & RCC_CFGR_SWS)
   \                     HAL_RCC_GetSysClockFreq: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0xF010 0x0038      ANDS     R0,R0,#0x38
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD006             BEQ.N    ??HAL_RCC_GetSysClockFreq_0
   \        0xE   0x2808             CMP      R0,#+8
   \       0x10   0xD013             BEQ.N    ??HAL_RCC_GetSysClockFreq_1
   \       0x12   0x2810             CMP      R0,#+16
   \       0x14   0xD014             BEQ.N    ??HAL_RCC_GetSysClockFreq_2
   \       0x16   0x2818             CMP      R0,#+24
   \       0x18   0xD015             BEQ.N    ??HAL_RCC_GetSysClockFreq_3
   \       0x1A   0xE0E4             B.N      ??HAL_RCC_GetSysClockFreq_4
   1376            {
   1377            case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
   1378          
   1379             if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
   \                     ??HAL_RCC_GetSysClockFreq_0: (+1)
   \       0x1C   0x.... 0x....      LDR.W    R1,??DataTable11_1
   \       0x20   0x6808             LDR      R0,[R1, #+0]
   \       0x22   0x0680             LSLS     R0,R0,#+26
   \       0x24   0xD506             BPL.N    ??HAL_RCC_GetSysClockFreq_5
   1380                {
   1381                  sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable11_4
   \       0x2A   0x6809             LDR      R1,[R1, #+0]
   \       0x2C   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \       0x30   0x40C8             LSRS     R0,R0,R1
   \       0x32   0xE001             B.N      ??HAL_RCC_GetSysClockFreq_6
   1382                }
   1383                else
   1384                {
   1385                  sysclockfreq = (uint32_t) HSI_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_5: (+1)
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable11_4
   1386                }
   1387          
   1388              break;
   \                     ??HAL_RCC_GetSysClockFreq_6: (+1)
   \       0x38   0xE0D6             B.N      ??HAL_RCC_GetSysClockFreq_7
   1389          
   1390            case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
   1391              sysclockfreq = CSI_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_1: (+1)
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable11_30
   1392              break;
   \       0x3E   0xE0D3             B.N      ??HAL_RCC_GetSysClockFreq_7
   1393          
   1394            case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
   1395              sysclockfreq = HSE_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_2: (+1)
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable11_31
   1396              break;
   \       0x44   0xE0D0             B.N      ??HAL_RCC_GetSysClockFreq_7
   1397          
   1398            case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */
   1399          
   1400              /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
   1401              SYSCLK = PLL_VCO / PLLR
   1402              */
   1403              pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   \                     ??HAL_RCC_GetSysClockFreq_3: (+1)
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable11_13
   \       0x4A   0x6802             LDR      R2,[R0, #+0]
   \       0x4C   0xF012 0x0203      ANDS     R2,R2,#0x3
   1404              pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
   \       0x50   0x6800             LDR      R0,[R0, #+0]
   \       0x52   0xF3C0 0x1005      UBFX     R0,R0,#+4,#+6
   1405              pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
   \       0x56   0x.... 0x....      LDR.W    R1,??DataTable11_15
   \       0x5A   0x680B             LDR      R3,[R1, #+0]
   \       0x5C   0xF013 0x0301      ANDS     R3,R3,#0x1
   1406              fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
   \       0x60   0x.... 0x....      LDR.W    R1,??DataTable11_18
   \       0x64   0x6809             LDR      R1,[R1, #+0]
   \       0x66   0xF3C1 0x01CC      UBFX     R1,R1,#+3,#+13
   \       0x6A   0x434B             MULS     R3,R1,R3
   \       0x6C   0xEE00 0x3A10      VMOV     S0,R3
   \       0x70   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   1407          
   1408              if (pllm != 0U)
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xF000 0x80B4      BEQ.W    ??HAL_RCC_GetSysClockFreq_8
   1409              {
   1410                switch (pllsource)
   \       0x7A   0x2A00             CMP      R2,#+0
   \       0x7C   0xD003             BEQ.N    ??HAL_RCC_GetSysClockFreq_9
   \       0x7E   0x2A02             CMP      R2,#+2
   \       0x80   0xD066             BEQ.N    ??HAL_RCC_GetSysClockFreq_10
   \       0x82   0xD348             BCC.N    ??HAL_RCC_GetSysClockFreq_11
   \       0x84   0xE081             B.N      ??HAL_RCC_GetSysClockFreq_12
   1411                {
   1412                case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
   1413          
   1414                 if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
   \                     ??HAL_RCC_GetSysClockFreq_9: (+1)
   \       0x86   0x.... 0x....      LDR.W    R1,??DataTable11_1
   \       0x8A   0x680A             LDR      R2,[R1, #+0]
   \       0x8C   0x0692             LSLS     R2,R2,#+26
   \       0x8E   0xD525             BPL.N    ??HAL_RCC_GetSysClockFreq_13
   1415                  {
   1416                    hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
   \       0x90   0x.... 0x....      LDR.W    R2,??DataTable11_4
   \       0x94   0x6809             LDR      R1,[R1, #+0]
   \       0x96   0xF3C1 0x01C1      UBFX     R1,R1,#+3,#+2
   \       0x9A   0x40CA             LSRS     R2,R2,R1
   \       0x9C   0xEE00 0x2A90      VMOV     S1,R2
   1417                    pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   \       0xA0   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \       0xA4   0xEE01 0x0A10      VMOV     S2,R0
   \       0xA8   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \       0xAC   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \       0xB0   0x.... 0x....      LDR.W    R0,??DataTable11_17
   \       0xB4   0x6800             LDR      R0,[R0, #+0]
   \       0xB6   0x05C0             LSLS     R0,R0,#+23
   \       0xB8   0x0DC0             LSRS     R0,R0,#+23
   \       0xBA   0xEE01 0x0A10      VMOV     S2,R0
   \       0xBE   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \       0xC2   0xEDDF 0x....      VLDR.W   S3,??DataTable8
   \       0xC6   0xEE80 0x0A21      VDIV.F32 S0,S0,S3
   \       0xCA   0xEE31 0x0A00      VADD.F32 S0,S2,S0
   \       0xCE   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \       0xD2   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \       0xD6   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \       0xDA   0xE01B             B.N      ??HAL_RCC_GetSysClockFreq_14
   1418                  }
   1419                  else
   1420                  {
   1421                    pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   \                     ??HAL_RCC_GetSysClockFreq_13: (+1)
   \       0xDC   0xEE00 0x0A90      VMOV     S1,R0
   \       0xE0   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \       0xE4   0xED9F 0x....      VLDR.W   S2,??DataTable8_1
   \       0xE8   0xEEC1 0x0A20      VDIV.F32 S1,S2,S1
   \       0xEC   0x....             LDR.N    R0,??DataTable11_17
   \       0xEE   0x6800             LDR      R0,[R0, #+0]
   \       0xF0   0x05C0             LSLS     R0,R0,#+23
   \       0xF2   0x0DC0             LSRS     R0,R0,#+23
   \       0xF4   0xEE01 0x0A10      VMOV     S2,R0
   \       0xF8   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \       0xFC   0xEDDF 0x....      VLDR.W   S3,??DataTable8
   \      0x100   0xEE80 0x0A21      VDIV.F32 S0,S0,S3
   \      0x104   0xEE31 0x0A00      VADD.F32 S0,S2,S0
   \      0x108   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x10C   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \      0x110   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   1422                  }
   1423                  break;
   \                     ??HAL_RCC_GetSysClockFreq_14: (+1)
   \      0x114   0xE055             B.N      ??HAL_RCC_GetSysClockFreq_15
   1424          
   1425                case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
   1426                  pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   \                     ??HAL_RCC_GetSysClockFreq_11: (+1)
   \      0x116   0xEE00 0x0A90      VMOV     S1,R0
   \      0x11A   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \      0x11E   0xED9F 0x....      VLDR.W   S2,??DataTable9
   \      0x122   0xEEC1 0x0A20      VDIV.F32 S1,S2,S1
   \      0x126   0x....             LDR.N    R0,??DataTable11_17
   \      0x128   0x6800             LDR      R0,[R0, #+0]
   \      0x12A   0x05C0             LSLS     R0,R0,#+23
   \      0x12C   0x0DC0             LSRS     R0,R0,#+23
   \      0x12E   0xEE01 0x0A10      VMOV     S2,R0
   \      0x132   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \      0x136   0xEDDF 0x....      VLDR.W   S3,??DataTable8
   \      0x13A   0xEE80 0x0A21      VDIV.F32 S0,S0,S3
   \      0x13E   0xEE31 0x0A00      VADD.F32 S0,S2,S0
   \      0x142   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x146   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \      0x14A   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   1427                  break;
   \      0x14E   0xE038             B.N      ??HAL_RCC_GetSysClockFreq_15
   1428          
   1429                case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
   1430                  pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   \                     ??HAL_RCC_GetSysClockFreq_10: (+1)
   \      0x150   0xEE00 0x0A90      VMOV     S1,R0
   \      0x154   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \      0x158   0xED9F 0x....      VLDR.W   S2,??DataTable9_1
   \      0x15C   0xEEC1 0x0A20      VDIV.F32 S1,S2,S1
   \      0x160   0x....             LDR.N    R0,??DataTable11_17
   \      0x162   0x6800             LDR      R0,[R0, #+0]
   \      0x164   0x05C0             LSLS     R0,R0,#+23
   \      0x166   0x0DC0             LSRS     R0,R0,#+23
   \      0x168   0xEE01 0x0A10      VMOV     S2,R0
   \      0x16C   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \      0x170   0xEDDF 0x....      VLDR.W   S3,??DataTable8
   \      0x174   0xEE80 0x0A21      VDIV.F32 S0,S0,S3
   \      0x178   0xEE31 0x0A00      VADD.F32 S0,S2,S0
   \      0x17C   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x180   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \      0x184   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   1431                  break;
   \      0x188   0xE01B             B.N      ??HAL_RCC_GetSysClockFreq_15
   1432          
   1433                default:
   1434                  pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
   \                     ??HAL_RCC_GetSysClockFreq_12: (+1)
   \      0x18A   0xEE00 0x0A90      VMOV     S1,R0
   \      0x18E   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \      0x192   0xED9F 0x....      VLDR.W   S2,??DataTable9
   \      0x196   0xEEC1 0x0A20      VDIV.F32 S1,S2,S1
   \      0x19A   0x....             LDR.N    R0,??DataTable11_17
   \      0x19C   0x6800             LDR      R0,[R0, #+0]
   \      0x19E   0x05C0             LSLS     R0,R0,#+23
   \      0x1A0   0x0DC0             LSRS     R0,R0,#+23
   \      0x1A2   0xEE01 0x0A10      VMOV     S2,R0
   \      0x1A6   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \      0x1AA   0xEDDF 0x....      VLDR.W   S3,??DataTable8
   \      0x1AE   0xEE80 0x0A21      VDIV.F32 S0,S0,S3
   \      0x1B2   0xEE31 0x0A00      VADD.F32 S0,S2,S0
   \      0x1B6   0xEEB7 0x1A00      VMOV.F32 S2,#1.0
   \      0x1BA   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \      0x1BE   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   1435                  break;
   1436                }
   1437                pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
   \                     ??HAL_RCC_GetSysClockFreq_15: (+1)
   \      0x1C2   0x....             LDR.N    R0,??DataTable11_17
   \      0x1C4   0x6800             LDR      R0,[R0, #+0]
   \      0x1C6   0xF3C0 0x2046      UBFX     R0,R0,#+9,#+7
   \      0x1CA   0x1C40             ADDS     R0,R0,#+1
   \      0x1CC   0xEE00 0x0A10      VMOV     S0,R0
   1438                sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
   \      0x1D0   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \      0x1D4   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \      0x1D8   0xEEBC 0x0AC0      VCVT.U32.F32 S0,S0
   \      0x1DC   0xEE10 0x0A10      VMOV     R0,S0
   \      0x1E0   0xE000             B.N      ??HAL_RCC_GetSysClockFreq_16
   1439              }
   1440              else
   1441              {
   1442                sysclockfreq = 0U;
   \                     ??HAL_RCC_GetSysClockFreq_8: (+1)
   \      0x1E2   0x2000             MOVS     R0,#+0
   1443              }
   1444              break;
   \                     ??HAL_RCC_GetSysClockFreq_16: (+1)
   \      0x1E4   0xE000             B.N      ??HAL_RCC_GetSysClockFreq_7
   1445          
   1446            default:
   1447              sysclockfreq = CSI_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_4: (+1)
   \      0x1E6   0x....             LDR.N    R0,??DataTable11_30
   1448              break;
   1449            }
   1450          
   1451            return sysclockfreq;
   \                     ??HAL_RCC_GetSysClockFreq_7: (+1)
   \      0x1E8   0x4770             BX       LR
   1452          }
   1453          
   1454          
   1455          /**
   1456            * @brief  Returns the HCLK frequency
   1457            * @note   Each time HCLK changes, this function must be called to update the
   1458            *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
   1459            *
   1460            * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
   1461            *         and updated within this function
   1462            * @retval HCLK frequency
   1463            */

   \                                 In section .text, align 2, keep-with-next
   1464          uint32_t HAL_RCC_GetHCLKFreq(void)
   1465          {
   \                     HAL_RCC_GetHCLKFreq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1466          uint32_t common_system_clock;
   1467          
   1468          #if defined(RCC_D1CFGR_D1CPRE)
   1469            common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
   1470          #else
   1471            common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
   \        0x2   0x.... 0x....      BL       HAL_RCC_GetSysClockFreq
   \        0x6   0x....             LDR.N    R1,??DataTable11_9
   \        0x8   0x....             LDR.N    R2,??DataTable11_26
   \        0xA   0x680B             LDR      R3,[R1, #+0]
   \        0xC   0xF3C3 0x2303      UBFX     R3,R3,#+8,#+4
   \       0x10   0x5CD3             LDRB     R3,[R2, R3]
   \       0x12   0xF013 0x031F      ANDS     R3,R3,#0x1F
   \       0x16   0x40D8             LSRS     R0,R0,R3
   1472          #endif
   1473          
   1474          #if defined(RCC_D1CFGR_HPRE)
   1475            SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
   1476          #else
   1477            SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));
   \       0x18   0x....             LDR.N    R3,??DataTable11_6
   \       0x1A   0x6809             LDR      R1,[R1, #+0]
   \       0x1C   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x20   0x5C51             LDRB     R1,[R2, R1]
   \       0x22   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \       0x26   0x0002             MOVS     R2,R0
   \       0x28   0x40CA             LSRS     R2,R2,R1
   \       0x2A   0x601A             STR      R2,[R3, #+0]
   1478          #endif
   1479          
   1480          #if defined(DUAL_CORE) && defined(CORE_CM4)
   1481            SystemCoreClock = SystemD2Clock;
   1482          #else
   1483            SystemCoreClock = common_system_clock;
   \       0x2C   0x....             LDR.N    R1,??DataTable11_5
   \       0x2E   0x6008             STR      R0,[R1, #+0]
   1484          #endif /* DUAL_CORE && CORE_CM4 */
   1485          
   1486            return SystemD2Clock;
   \       0x30   0x6818             LDR      R0,[R3, #+0]
   \       0x32   0xBD02             POP      {R1,PC}
   1487          }
   1488          
   1489          
   1490          /**
   1491            * @brief  Returns the PCLK1 frequency
   1492            * @note   Each time PCLK1 changes, this function must be called to update the
   1493            *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
   1494            * @retval PCLK1 frequency
   1495            */

   \                                 In section .text, align 2, keep-with-next
   1496          uint32_t HAL_RCC_GetPCLK1Freq(void)
   1497          {
   \                     HAL_RCC_GetPCLK1Freq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1498          #if defined (RCC_D2CFGR_D2PPRE1)
   1499            /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
   1500            return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1)>> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
   1501          #else
   1502           /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
   1503            return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1)>> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
   \        0x2   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \        0x6   0x....             LDR.N    R1,??DataTable11_26
   \        0x8   0x....             LDR.N    R2,??DataTable11_10
   \        0xA   0x6812             LDR      R2,[R2, #+0]
   \        0xC   0xF3C2 0x1202      UBFX     R2,R2,#+4,#+3
   \       0x10   0x5C89             LDRB     R1,[R1, R2]
   \       0x12   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \       0x16   0x40C8             LSRS     R0,R0,R1
   \       0x18   0xBD02             POP      {R1,PC}
   1504          #endif
   1505          }
   1506          
   1507          
   1508          /**
   1509            * @brief  Returns the PCLK2 frequency
   1510            * @note   Each time PCLK2 changes, this function must be called to update the
   1511            *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
   1512            * @retval PCLK1 frequency
   1513            */

   \                                 In section .text, align 2, keep-with-next
   1514          uint32_t HAL_RCC_GetPCLK2Freq(void)
   1515          {
   \                     HAL_RCC_GetPCLK2Freq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1516            /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
   1517          #if defined(RCC_D2CFGR_D2PPRE2)
   1518            return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2)>> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
   1519          #else
   1520            return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2)>> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
   \        0x2   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \        0x6   0x....             LDR.N    R1,??DataTable11_26
   \        0x8   0x....             LDR.N    R2,??DataTable11_10
   \        0xA   0x6812             LDR      R2,[R2, #+0]
   \        0xC   0xF3C2 0x2202      UBFX     R2,R2,#+8,#+3
   \       0x10   0x5C89             LDRB     R1,[R1, R2]
   \       0x12   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \       0x16   0x40C8             LSRS     R0,R0,R1
   \       0x18   0xBD02             POP      {R1,PC}
   1521          #endif
   1522          }
   1523          
   1524          /**
   1525            * @brief  Configures the RCC_OscInitStruct according to the internal
   1526            * RCC configuration registers.
   1527            * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that
   1528            * will be configured.
   1529            * @retval None
   1530            */

   \                                 In section .text, align 2, keep-with-next
   1531          void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
   1532          {
   1533            /* Set all possible values for the Oscillator type parameter ---------------*/
   1534            RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_CSI | \
   1535                                                RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI| RCC_OSCILLATORTYPE_HSI48;
   \                     HAL_RCC_GetOscConfig: (+1)
   \        0x0   0x213F             MOVS     R1,#+63
   \        0x2   0x6001             STR      R1,[R0, #+0]
   1536          
   1537            /* Get the HSE configuration -----------------------------------------------*/
   1538          #if defined(RCC_CR_HSEEXT)
   1539            if((RCC->CR &(RCC_CR_HSEBYP | RCC_CR_HSEEXT)) == RCC_CR_HSEBYP)
   \        0x4   0x....             LDR.N    R1,??DataTable11_1
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0xF412 0x12A0      ANDS     R2,R2,#0x140000
   \        0xC   0xF5B2 0x2F80      CMP      R2,#+262144
   \       0x10   0xD103             BNE.N    ??HAL_RCC_GetOscConfig_0
   1540            {
   1541              RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
   \       0x12   0xF45F 0x22A0      MOVS     R2,#+327680
   \       0x16   0x6042             STR      R2,[R0, #+4]
   \       0x18   0xE012             B.N      ??HAL_RCC_GetOscConfig_1
   1542            }
   1543            else if((RCC->CR &(RCC_CR_HSEBYP | RCC_CR_HSEEXT)) == (RCC_CR_HSEBYP | RCC_CR_HSEEXT))
   \                     ??HAL_RCC_GetOscConfig_0: (+1)
   \       0x1A   0x680A             LDR      R2,[R1, #+0]
   \       0x1C   0xF412 0x12A0      ANDS     R2,R2,#0x140000
   \       0x20   0xF5B2 0x1FA0      CMP      R2,#+1310720
   \       0x24   0xD103             BNE.N    ??HAL_RCC_GetOscConfig_2
   1544            {
   1545              RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS_DIGITAL;
   \       0x26   0xF45F 0x12A8      MOVS     R2,#+1376256
   \       0x2A   0x6042             STR      R2,[R0, #+4]
   \       0x2C   0xE008             B.N      ??HAL_RCC_GetOscConfig_1
   1546            }
   1547            else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
   \                     ??HAL_RCC_GetOscConfig_2: (+1)
   \       0x2E   0x680A             LDR      R2,[R1, #+0]
   \       0x30   0x03D2             LSLS     R2,R2,#+15
   \       0x32   0xD503             BPL.N    ??HAL_RCC_GetOscConfig_3
   1548            {
   1549              RCC_OscInitStruct->HSEState = RCC_HSE_ON;
   \       0x34   0xF45F 0x3280      MOVS     R2,#+65536
   \       0x38   0x6042             STR      R2,[R0, #+4]
   \       0x3A   0xE001             B.N      ??HAL_RCC_GetOscConfig_1
   1550            }
   1551            else
   1552            {
   1553              RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
   \                     ??HAL_RCC_GetOscConfig_3: (+1)
   \       0x3C   0x2200             MOVS     R2,#+0
   \       0x3E   0x6042             STR      R2,[R0, #+4]
   1554            }
   1555          #else
   1556            if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
   1557            {
   1558              RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
   1559            }
   1560            else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
   1561            {
   1562              RCC_OscInitStruct->HSEState = RCC_HSE_ON;
   1563            }
   1564            else
   1565            {
   1566              RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
   1567            }
   1568          #endif /* RCC_CR_HSEEXT */
   1569          
   1570             /* Get the CSI configuration -----------------------------------------------*/
   1571            if((RCC->CR &RCC_CR_CSION) == RCC_CR_CSION)
   \                     ??HAL_RCC_GetOscConfig_1: (+1)
   \       0x40   0x680A             LDR      R2,[R1, #+0]
   \       0x42   0x0612             LSLS     R2,R2,#+24
   \       0x44   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_4
   1572            {
   1573              RCC_OscInitStruct->CSIState = RCC_CSI_ON;
   \       0x46   0x2280             MOVS     R2,#+128
   \       0x48   0x61C2             STR      R2,[R0, #+28]
   \       0x4A   0xE001             B.N      ??HAL_RCC_GetOscConfig_5
   1574            }
   1575            else
   1576            {
   1577              RCC_OscInitStruct->CSIState = RCC_CSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_4: (+1)
   \       0x4C   0x2200             MOVS     R2,#+0
   \       0x4E   0x61C2             STR      R2,[R0, #+28]
   1578            }
   1579          
   1580          #if defined(RCC_VER_X)
   1581            if(HAL_GetREVID() <= REV_ID_Y)
   1582            {
   1583              RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_CSITRIM_Msk) >> HAL_RCC_REV_Y_CSITRIM_Pos);
   1584            }
   1585            else
   1586            {
   1587              RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);
   1588            }
   1589          #else
   1590           RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);
   \                     ??HAL_RCC_GetOscConfig_5: (+1)
   \       0x50   0x....             LDR.N    R2,??DataTable11_32
   \       0x52   0x6812             LDR      R2,[R2, #+0]
   \       0x54   0xF3C2 0x6205      UBFX     R2,R2,#+24,#+6
   \       0x58   0x6202             STR      R2,[R0, #+32]
   1591          #endif /*RCC_VER_X*/
   1592          
   1593            /* Get the HSI configuration -----------------------------------------------*/
   1594            if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
   \       0x5A   0x680A             LDR      R2,[R1, #+0]
   \       0x5C   0x07D2             LSLS     R2,R2,#+31
   \       0x5E   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_6
   1595            {
   1596              RCC_OscInitStruct->HSIState = RCC_HSI_ON;
   \       0x60   0x2201             MOVS     R2,#+1
   \       0x62   0x60C2             STR      R2,[R0, #+12]
   \       0x64   0xE001             B.N      ??HAL_RCC_GetOscConfig_7
   1597            }
   1598            else
   1599            {
   1600              RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_6: (+1)
   \       0x66   0x2200             MOVS     R2,#+0
   \       0x68   0x60C2             STR      R2,[R0, #+12]
   1601            }
   1602          
   1603          #if defined(RCC_VER_X)
   1604            if(HAL_GetREVID() <= REV_ID_Y)
   1605            {
   1606              RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_HSITRIM_Msk) >> HAL_RCC_REV_Y_HSITRIM_Pos);
   1607            }
   1608            else
   1609            {
   1610              RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM) >> RCC_HSICFGR_HSITRIM_Pos);
   1611            }
   1612          #else
   1613              RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM) >> RCC_HSICFGR_HSITRIM_Pos);
   \                     ??HAL_RCC_GetOscConfig_7: (+1)
   \       0x6A   0x....             LDR.N    R2,??DataTable11_2
   \       0x6C   0x6812             LDR      R2,[R2, #+0]
   \       0x6E   0xF3C2 0x6206      UBFX     R2,R2,#+24,#+7
   \       0x72   0x6102             STR      R2,[R0, #+16]
   1614          #endif /*RCC_VER_X*/
   1615          
   1616            /* Get the LSE configuration -----------------------------------------------*/
   1617          #if defined(RCC_BDCR_LSEEXT)
   1618            if((RCC->BDCR &(RCC_BDCR_LSEBYP|RCC_BDCR_LSEEXT)) == RCC_BDCR_LSEBYP)
   \       0x74   0x....             LDR.N    R2,??DataTable11_33
   \       0x76   0x6813             LDR      R3,[R2, #+0]
   \       0x78   0xF013 0x0384      ANDS     R3,R3,#0x84
   \       0x7C   0x2B04             CMP      R3,#+4
   \       0x7E   0xD102             BNE.N    ??HAL_RCC_GetOscConfig_8
   1619            {
   1620              RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
   \       0x80   0x2205             MOVS     R2,#+5
   \       0x82   0x6082             STR      R2,[R0, #+8]
   \       0x84   0xE00F             B.N      ??HAL_RCC_GetOscConfig_9
   1621            }
   1622            else if((RCC->BDCR &(RCC_BDCR_LSEBYP|RCC_BDCR_LSEEXT)) == (RCC_BDCR_LSEBYP|RCC_BDCR_LSEEXT))
   \                     ??HAL_RCC_GetOscConfig_8: (+1)
   \       0x86   0x6813             LDR      R3,[R2, #+0]
   \       0x88   0xF013 0x0384      ANDS     R3,R3,#0x84
   \       0x8C   0x2B84             CMP      R3,#+132
   \       0x8E   0xD102             BNE.N    ??HAL_RCC_GetOscConfig_10
   1623            {
   1624              RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS_DIGITAL;
   \       0x90   0x2285             MOVS     R2,#+133
   \       0x92   0x6082             STR      R2,[R0, #+8]
   \       0x94   0xE007             B.N      ??HAL_RCC_GetOscConfig_9
   1625            }
   1626            else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
   \                     ??HAL_RCC_GetOscConfig_10: (+1)
   \       0x96   0x6812             LDR      R2,[R2, #+0]
   \       0x98   0x07D2             LSLS     R2,R2,#+31
   \       0x9A   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_11
   1627            {
   1628              RCC_OscInitStruct->LSEState = RCC_LSE_ON;
   \       0x9C   0x2201             MOVS     R2,#+1
   \       0x9E   0x6082             STR      R2,[R0, #+8]
   \       0xA0   0xE001             B.N      ??HAL_RCC_GetOscConfig_9
   1629            }
   1630            else
   1631            {
   1632              RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
   \                     ??HAL_RCC_GetOscConfig_11: (+1)
   \       0xA2   0x2200             MOVS     R2,#+0
   \       0xA4   0x6082             STR      R2,[R0, #+8]
   1633            }
   1634          #else
   1635            if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
   1636            {
   1637              RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
   1638            }
   1639            else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
   1640            {
   1641              RCC_OscInitStruct->LSEState = RCC_LSE_ON;
   1642            }
   1643            else
   1644            {
   1645              RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
   1646            }
   1647          #endif /* RCC_BDCR_LSEEXT */
   1648          
   1649            /* Get the LSI configuration -----------------------------------------------*/
   1650            if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
   \                     ??HAL_RCC_GetOscConfig_9: (+1)
   \       0xA6   0x....             LDR.N    R2,??DataTable11_34
   \       0xA8   0x6812             LDR      R2,[R2, #+0]
   \       0xAA   0x07D2             LSLS     R2,R2,#+31
   \       0xAC   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_12
   1651            {
   1652              RCC_OscInitStruct->LSIState = RCC_LSI_ON;
   \       0xAE   0x2201             MOVS     R2,#+1
   \       0xB0   0x6142             STR      R2,[R0, #+20]
   \       0xB2   0xE001             B.N      ??HAL_RCC_GetOscConfig_13
   1653            }
   1654            else
   1655            {
   1656              RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_12: (+1)
   \       0xB4   0x2200             MOVS     R2,#+0
   \       0xB6   0x6142             STR      R2,[R0, #+20]
   1657            }
   1658          
   1659            /* Get the HSI48 configuration ---------------------------------------------*/
   1660            if((RCC->CR & RCC_CR_HSI48ON) == RCC_CR_HSI48ON)
   \                     ??HAL_RCC_GetOscConfig_13: (+1)
   \       0xB8   0x680A             LDR      R2,[R1, #+0]
   \       0xBA   0x04D2             LSLS     R2,R2,#+19
   \       0xBC   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_14
   1661            {
   1662              RCC_OscInitStruct->HSI48State = RCC_HSI48_ON;
   \       0xBE   0x2201             MOVS     R2,#+1
   \       0xC0   0x6182             STR      R2,[R0, #+24]
   \       0xC2   0xE001             B.N      ??HAL_RCC_GetOscConfig_15
   1663            }
   1664            else
   1665            {
   1666              RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
   \                     ??HAL_RCC_GetOscConfig_14: (+1)
   \       0xC4   0x2200             MOVS     R2,#+0
   \       0xC6   0x6182             STR      R2,[R0, #+24]
   1667            }
   1668          
   1669            /* Get the PLL configuration -----------------------------------------------*/
   1670            if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
   \                     ??HAL_RCC_GetOscConfig_15: (+1)
   \       0xC8   0x6809             LDR      R1,[R1, #+0]
   \       0xCA   0x01C9             LSLS     R1,R1,#+7
   \       0xCC   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_16
   1671            {
   1672              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
   \       0xCE   0x2102             MOVS     R1,#+2
   \       0xD0   0x6241             STR      R1,[R0, #+36]
   \       0xD2   0xE001             B.N      ??HAL_RCC_GetOscConfig_17
   1673            }
   1674            else
   1675            {
   1676              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
   \                     ??HAL_RCC_GetOscConfig_16: (+1)
   \       0xD4   0x2101             MOVS     R1,#+1
   \       0xD6   0x6241             STR      R1,[R0, #+36]
   1677            }
   1678            RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
   \                     ??HAL_RCC_GetOscConfig_17: (+1)
   \       0xD8   0x....             LDR.N    R1,??DataTable11_13
   \       0xDA   0x680A             LDR      R2,[R1, #+0]
   \       0xDC   0xF012 0x0203      ANDS     R2,R2,#0x3
   \       0xE0   0x6282             STR      R2,[R0, #+40]
   1679            RCC_OscInitStruct->PLL.PLLM = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> RCC_PLLCKSELR_DIVM1_Pos);
   \       0xE2   0x6809             LDR      R1,[R1, #+0]
   \       0xE4   0xF3C1 0x1105      UBFX     R1,R1,#+4,#+6
   \       0xE8   0x62C1             STR      R1,[R0, #+44]
   1680            RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_N1) >> RCC_PLL1DIVR_N1_Pos)+ 1U;
   \       0xEA   0x....             LDR.N    R1,??DataTable11_17
   \       0xEC   0x680A             LDR      R2,[R1, #+0]
   \       0xEE   0x05D2             LSLS     R2,R2,#+23
   \       0xF0   0x0DD2             LSRS     R2,R2,#+23
   \       0xF2   0x1C52             ADDS     R2,R2,#+1
   \       0xF4   0x6302             STR      R2,[R0, #+48]
   1681            RCC_OscInitStruct->PLL.PLLR = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos)+ 1U;
   \       0xF6   0x680A             LDR      R2,[R1, #+0]
   \       0xF8   0xF3C2 0x6206      UBFX     R2,R2,#+24,#+7
   \       0xFC   0x1C52             ADDS     R2,R2,#+1
   \       0xFE   0x63C2             STR      R2,[R0, #+60]
   1682            RCC_OscInitStruct->PLL.PLLP = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos)+ 1U;
   \      0x100   0x680A             LDR      R2,[R1, #+0]
   \      0x102   0xF3C2 0x2246      UBFX     R2,R2,#+9,#+7
   \      0x106   0x1C52             ADDS     R2,R2,#+1
   \      0x108   0x6342             STR      R2,[R0, #+52]
   1683            RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos)+ 1U;
   \      0x10A   0x6809             LDR      R1,[R1, #+0]
   \      0x10C   0xF3C1 0x4106      UBFX     R1,R1,#+16,#+7
   \      0x110   0x1C49             ADDS     R1,R1,#+1
   \      0x112   0x6381             STR      R1,[R0, #+56]
   1684            RCC_OscInitStruct->PLL.PLLRGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1RGE));
   \      0x114   0x....             LDR.N    R1,??DataTable11_15
   \      0x116   0x680A             LDR      R2,[R1, #+0]
   \      0x118   0xF012 0x020C      ANDS     R2,R2,#0xC
   \      0x11C   0x6402             STR      R2,[R0, #+64]
   1685            RCC_OscInitStruct->PLL.PLLVCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1VCOSEL) >> RCC_PLLCFGR_PLL1VCOSEL_Pos);
   \      0x11E   0x6809             LDR      R1,[R1, #+0]
   \      0x120   0xF3C1 0x0140      UBFX     R1,R1,#+1,#+1
   \      0x124   0x6441             STR      R1,[R0, #+68]
   1686            RCC_OscInitStruct->PLL.PLLFRACN = (uint32_t)(((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos));
   \      0x126   0x....             LDR.N    R1,??DataTable11_18
   \      0x128   0x6809             LDR      R1,[R1, #+0]
   \      0x12A   0xF3C1 0x01CC      UBFX     R1,R1,#+3,#+13
   \      0x12E   0x6481             STR      R1,[R0, #+72]
   1687          }
   \      0x130   0x4770             BX       LR
   1688          
   1689          /**
   1690            * @brief  Configures the RCC_ClkInitStruct according to the internal
   1691            * RCC configuration registers.
   1692            * @param  RCC_ClkInitStruct: pointer to an RCC_ClkInitTypeDef structure that
   1693            * will be configured.
   1694            * @param  pFLatency: Pointer on the Flash Latency.
   1695            * @retval None
   1696            */

   \                                 In section .text, align 2, keep-with-next
   1697          void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
   1698          {
   1699            /* Set all possible values for the Clock type parameter --------------------*/
   1700            RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |
   1701                                           RCC_CLOCKTYPE_PCLK2 |  RCC_CLOCKTYPE_D3PCLK1  ;
   \                     HAL_RCC_GetClockConfig: (+1)
   \        0x0   0x223F             MOVS     R2,#+63
   \        0x2   0x6002             STR      R2,[R0, #+0]
   1702          
   1703            /* Get the SYSCLK configuration --------------------------------------------*/
   1704            RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
   \        0x4   0x....             LDR.N    R2,??DataTable11_3
   \        0x6   0x6812             LDR      R2,[R2, #+0]
   \        0x8   0xF012 0x0207      ANDS     R2,R2,#0x7
   \        0xC   0x6042             STR      R2,[R0, #+4]
   1705          
   1706          #if defined(RCC_D1CFGR_D1CPRE)
   1707            /* Get the SYSCLK configuration ----------------------------------------------*/
   1708            RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1CPRE);
   1709          
   1710            /* Get the D1HCLK configuration ----------------------------------------------*/
   1711            RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_HPRE);
   1712          
   1713            /* Get the APB3 configuration ----------------------------------------------*/
   1714            RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1PPRE);
   1715          
   1716            /* Get the APB1 configuration ----------------------------------------------*/
   1717            RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1);
   1718          
   1719            /* Get the APB2 configuration ----------------------------------------------*/
   1720            RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2);
   1721          
   1722            /* Get the APB4 configuration ----------------------------------------------*/
   1723            RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);
   1724          #else
   1725            /* Get the SYSCLK configuration ----------------------------------------------*/
   1726            RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE);
   \        0xE   0x....             LDR.N    R2,??DataTable11_9
   \       0x10   0x6813             LDR      R3,[R2, #+0]
   \       0x12   0xF413 0x6370      ANDS     R3,R3,#0xF00
   \       0x16   0x6083             STR      R3,[R0, #+8]
   1727          
   1728            /* Get the D1HCLK configuration ----------------------------------------------*/
   1729            RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE);
   \       0x18   0x6813             LDR      R3,[R2, #+0]
   \       0x1A   0xF013 0x030F      ANDS     R3,R3,#0xF
   \       0x1E   0x60C3             STR      R3,[R0, #+12]
   1730          
   1731            /* Get the APB3 configuration ----------------------------------------------*/
   1732            RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE);
   \       0x20   0x6812             LDR      R2,[R2, #+0]
   \       0x22   0xF012 0x0270      ANDS     R2,R2,#0x70
   \       0x26   0x6102             STR      R2,[R0, #+16]
   1733          
   1734            /* Get the APB1 configuration ----------------------------------------------*/
   1735            RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1);
   \       0x28   0x....             LDR.N    R2,??DataTable11_10
   \       0x2A   0x6813             LDR      R3,[R2, #+0]
   \       0x2C   0xF013 0x0370      ANDS     R3,R3,#0x70
   \       0x30   0x6143             STR      R3,[R0, #+20]
   1736          
   1737            /* Get the APB2 configuration ----------------------------------------------*/
   1738            RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2);
   \       0x32   0x6812             LDR      R2,[R2, #+0]
   \       0x34   0xF412 0x62E0      ANDS     R2,R2,#0x700
   \       0x38   0x6182             STR      R2,[R0, #+24]
   1739          
   1740            /* Get the APB4 configuration ----------------------------------------------*/
   1741            RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE);
   \       0x3A   0x....             LDR.N    R2,??DataTable11_11
   \       0x3C   0x6812             LDR      R2,[R2, #+0]
   \       0x3E   0xF012 0x0270      ANDS     R2,R2,#0x70
   \       0x42   0x61C2             STR      R2,[R0, #+28]
   1742          #endif
   1743          
   1744            /* Get the Flash Wait State (Latency) configuration ------------------------*/
   1745            *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
   \       0x44   0x....             LDR.N    R0,??DataTable11
   \       0x46   0x6800             LDR      R0,[R0, #+0]
   \       0x48   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x4C   0x6008             STR      R0,[R1, #+0]
   1746          }
   \       0x4E   0x4770             BX       LR
   1747          
   1748          /**
   1749            * @brief This function handles the RCC CSS interrupt request.
   1750            * @note This API should be called under the NMI_Handler().
   1751            * @retval None
   1752            */

   \                                 In section .text, align 2, keep-with-next
   1753          void HAL_RCC_NMI_IRQHandler(void)
   1754          {
   \                     HAL_RCC_NMI_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1755            /* Check RCC CSSF flag  */
   1756            if(__HAL_RCC_GET_IT(RCC_IT_CSS))
   \        0x2   0x....             LDR.N    R0,??DataTable11_35
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x0540             LSLS     R0,R0,#+21
   \        0x8   0xD505             BPL.N    ??HAL_RCC_NMI_IRQHandler_0
   1757            {
   1758              /* RCC Clock Security System interrupt user callback */
   1759              HAL_RCC_CCSCallback();
   \        0xA   0x.... 0x....      BL       HAL_RCC_CSSCallback
   1760          
   1761              /* Clear RCC CSS pending bit */
   1762              __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
   \        0xE   0xF44F 0x6080      MOV      R0,#+1024
   \       0x12   0x....             LDR.N    R1,??DataTable11_24
   \       0x14   0x6008             STR      R0,[R1, #+0]
   1763            }
   1764          }
   \                     ??HAL_RCC_NMI_IRQHandler_0: (+1)
   \       0x16   0xBD01             POP      {R0,PC}
   1765          
   1766          /**
   1767            * @brief  RCC Clock Security System interrupt callback
   1768            * @retval none
   1769            */

   \                                 In section .text, align 2
   1770          __weak void HAL_RCC_CCSCallback(void)
   1771          {
   1772            /* NOTE : This function Should not be modified, when the callback is needed,
   1773                      the HAL_RCC_CCSCallback could be implemented in the user file
   1774             */
   1775          }
   \                     HAL_RCC_CSSCallback: (+1)
   \        0x0   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x4600'0000        DC32     0x46000000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x4C74'2400        DC32     0x4c742400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x4A74'2400        DC32     0x4a742400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x4BB7'1B00        DC32     0x4bb71b00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x5200'2000        DC32     0x52002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x5802'4400        DC32     0x58024400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0x5802'4404        DC32     0x58024404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0x5802'4410        DC32     0x58024410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0x03D0'9000        DC32     0x3d09000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \        0x0   0x....'....        DC32     SystemD2Clock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \        0x0   0x....'....        DC32     uwTickPrio

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \        0x0   0xFFF6'ED45        DC32     0xfff6ed45

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \        0x0   0x5802'4418        DC32     0x58024418

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \        0x0   0x5802'441C        DC32     0x5802441c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \        0x0   0x5802'4420        DC32     0x58024420

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \        0x0   0x0202'0200        DC32     0x2020200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \        0x0   0x5802'4428        DC32     0x58024428

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \        0x0   0x01FF'0000        DC32     0x1ff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \        0x0   0x5802'442C        DC32     0x5802442c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \        0x0   0x0101'0280        DC32     0x1010280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_17:
   \        0x0   0x5802'4430        DC32     0x58024430

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_18:
   \        0x0   0x5802'4434        DC32     0x58024434

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_19:
   \        0x0   0x5802'4438        DC32     0x58024438

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_20:
   \        0x0   0x5802'443C        DC32     0x5802443c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_21:
   \        0x0   0x5802'4440        DC32     0x58024440

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_22:
   \        0x0   0x5802'4444        DC32     0x58024444

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_23:
   \        0x0   0x5802'4460        DC32     0x58024460

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_24:
   \        0x0   0x5802'4468        DC32     0x58024468

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_25:
   \        0x0   0x5802'4530        DC32     0x58024530

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_26:
   \        0x0   0x....'....        DC32     D1CorePrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_27:
   \        0x0   0x5802'4540        DC32     0x58024540

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_28:
   \        0x0   0x5802'0000        DC32     0x58020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_29:
   \        0x0   0x5802'0800        DC32     0x58020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_30:
   \        0x0   0x003D'0900        DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_31:
   \        0x0   0x016E'3600        DC32     0x16e3600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_32:
   \        0x0   0x5802'440C        DC32     0x5802440c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_33:
   \        0x0   0x5802'4470        DC32     0x58024470

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_34:
   \        0x0   0x5802'4474        DC32     0x58024474

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_35:
   \        0x0   0x5802'4464        DC32     0x58024464
   1776          
   1777          /**
   1778            * @}
   1779            */
   1780          
   1781          /**
   1782            * @}
   1783            */
   1784          
   1785          #endif /* HAL_RCC_MODULE_ENABLED */
   1786          /**
   1787            * @}
   1788            */
   1789          
   1790          /**
   1791            * @}
   1792            */
   1793          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RCC_CSSCallback
      24   HAL_RCC_ClockConfig
        24   -> HAL_GetTick
        24   -> HAL_InitTick
        24   -> HAL_RCC_GetSysClockFreq
      24   HAL_RCC_DeInit
        24   -> HAL_GetTick
        24   -> HAL_InitTick
       0   HAL_RCC_DisableCSS
       0   HAL_RCC_EnableCSS
       0   HAL_RCC_GetClockConfig
       8   HAL_RCC_GetHCLKFreq
         8   -> HAL_RCC_GetSysClockFreq
       0   HAL_RCC_GetOscConfig
       8   HAL_RCC_GetPCLK1Freq
         8   -> HAL_RCC_GetHCLKFreq
       8   HAL_RCC_GetPCLK2Freq
         8   -> HAL_RCC_GetHCLKFreq
       0   HAL_RCC_GetSysClockFreq
      40   HAL_RCC_MCOConfig
        40   -> HAL_GPIO_Init
       8   HAL_RCC_NMI_IRQHandler
         8   -> HAL_RCC_CSSCallback
      16   HAL_RCC_OscConfig
        16   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_19
       4  ??DataTable11_2
       4  ??DataTable11_20
       4  ??DataTable11_21
       4  ??DataTable11_22
       4  ??DataTable11_23
       4  ??DataTable11_24
       4  ??DataTable11_25
       4  ??DataTable11_26
       4  ??DataTable11_27
       4  ??DataTable11_28
       4  ??DataTable11_29
       4  ??DataTable11_3
       4  ??DataTable11_30
       4  ??DataTable11_31
       4  ??DataTable11_32
       4  ??DataTable11_33
       4  ??DataTable11_34
       4  ??DataTable11_35
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable9
       4  ??DataTable9_1
       2  HAL_RCC_CSSCallback
     650  HAL_RCC_ClockConfig
     476  HAL_RCC_DeInit
      14  HAL_RCC_DisableCSS
      14  HAL_RCC_EnableCSS
      80  HAL_RCC_GetClockConfig
      52  HAL_RCC_GetHCLKFreq
     306  HAL_RCC_GetOscConfig
      26  HAL_RCC_GetPCLK1Freq
      26  HAL_RCC_GetPCLK2Freq
     490  HAL_RCC_GetSysClockFreq
     160  HAL_RCC_MCOConfig
      24  HAL_RCC_NMI_IRQHandler
   1'548  HAL_RCC_OscConfig

 
 4'028 bytes in section .text
 
 2'478 bytes of CODE memory (+ 1'550 bytes shared)

Errors: none
Warnings: none
