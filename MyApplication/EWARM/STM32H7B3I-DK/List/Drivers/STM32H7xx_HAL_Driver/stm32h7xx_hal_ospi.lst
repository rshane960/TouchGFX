###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         05/Feb/2022  17:09:37
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_ospi.c
#        [UTF-8]
#    Command line      =
#        -f
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_ospi.o.rsp
#        (D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_ospi.c
#        -D USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver
#        -lA
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver
#        -o
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Core/Inc\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/App\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_ospi.o.d
#    Locale            =  C
#    List file         =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_ospi.lst
#    Object file       =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Drivers\STM32H7xx_HAL_Driver\stm32h7xx_hal_ospi.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\99_Project\GitHub\TouchGFX\MyApplication\Drivers\STM32H7xx_HAL_Driver\Src\stm32h7xx_hal_ospi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32h7xx_hal_ospi.c
      4            * @author  MCD Application Team
      5            * @brief   OSPI HAL module driver.
      6                       This file provides firmware functions to manage the following
      7                       functionalities of the OctoSPI interface (OSPI).
      8                        + Initialization and de-initialization functions
      9                        + Hyperbus configuration
     10                        + Indirect functional mode management
     11                        + Memory-mapped functional mode management
     12                        + Auto-polling functional mode management
     13                        + Interrupts and flags management
     14                        + DMA channel configuration for indirect functional mode
     15                        + Errors management and abort functionality
     16                        + IO manager configuration
     17          
     18            ******************************************************************************
     19            * @attention
     20            *
     21            * Copyright (c) 2017 STMicroelectronics.
     22            * All rights reserved.
     23            *
     24            * This software is licensed under terms that can be found in the LICENSE file
     25            * in the root directory of this software component.
     26            * If no LICENSE file comes with this software, it is provided AS-IS.
     27            *
     28            ******************************************************************************
     29            @verbatim
     30           ===============================================================================
     31                                  ##### How to use this driver #####
     32           ===============================================================================
     33            [..]
     34              *** Initialization ***
     35              ======================
     36              [..]
     37               As prerequisite, fill in the HAL_OSPI_MspInit() :
     38               (+) Enable OctoSPI and OctoSPIM clocks interface with __HAL_RCC_OSPIx_CLK_ENABLE().
     39               (+) Reset OctoSPI Peripheral with __HAL_RCC_OSPIx_FORCE_RESET() and __HAL_RCC_OSPIx_RELEASE_RESET().
     40               (+) Enable the clocks for the OctoSPI GPIOS with __HAL_RCC_GPIOx_CLK_ENABLE().
     41               (+) Configure these OctoSPI pins in alternate mode using HAL_GPIO_Init().
     42               (+) If interrupt or DMA mode is used, enable and configure OctoSPI global
     43                   interrupt with HAL_NVIC_SetPriority() and HAL_NVIC_EnableIRQ().
     44               (+) If DMA mode is used, enable the clocks for the OctoSPI DMA channel
     45                   with __HAL_RCC_DMAx_CLK_ENABLE(), configure DMA with HAL_DMA_Init(),
     46                   link it with OctoSPI handle using __HAL_LINKDMA(), enable and configure
     47                   DMA channel global interrupt with HAL_NVIC_SetPriority() and HAL_NVIC_EnableIRQ().
     48              [..]
     49               Configure the fifo threshold, the dual-quad mode, the memory type, the
     50               device size, the CS high time, the free running clock, the clock mode,
     51               the wrap size, the clock prescaler, the sample shifting, the hold delay
     52               and the CS boundary using the HAL_OSPI_Init() function.
     53              [..]
     54               When using Hyperbus, configure the RW recovery time, the access time,
     55               the write latency and the latency mode unsing the HAL_OSPI_HyperbusCfg()
     56               function.
     57          
     58              *** Indirect functional mode ***
     59              ================================
     60              [..]
     61               In regular mode, configure the command sequence using the HAL_OSPI_Command()
     62               or HAL_OSPI_Command_IT() functions :
     63               (+) Instruction phase : the mode used and if present the size, the instruction
     64                   opcode and the DTR mode.
     65               (+) Address phase : the mode used and if present the size, the address
     66                   value and the DTR mode.
     67               (+) Alternate-bytes phase : the mode used and if present the size, the
     68                   alternate bytes values and the DTR mode.
     69               (+) Dummy-cycles phase : the number of dummy cycles (mode used is same as data phase).
     70               (+) Data phase : the mode used and if present the number of bytes and the DTR mode.
     71               (+) Data strobe (DQS) mode : the activation (or not) of this mode
     72               (+) Sending Instruction Only Once (SIOO) mode : the activation (or not) of this mode.
     73               (+) Flash identifier : in dual-quad mode, indicates which flash is concerned
     74               (+) Operation type : always common configuration
     75              [..]
     76               In Hyperbus mode, configure the command sequence using the HAL_OSPI_HyperbusCmd()
     77               function :
     78               (+) Address space : indicate if the access will be done in register or memory
     79               (+) Address size
     80               (+) Number of data
     81               (+) Data strobe (DQS) mode : the activation (or not) of this mode
     82              [..]
     83               If no data is required for the command (only for regular mode, not for
     84               Hyperbus mode), it is sent directly to the memory :
     85               (+) In polling mode, the output of the function is done when the transfer is complete.
     86               (+) In interrupt mode, HAL_OSPI_CmdCpltCallback() will be called when the transfer is complete.
     87              [..]
     88               For the indirect write mode, use HAL_OSPI_Transmit(), HAL_OSPI_Transmit_DMA() or
     89               HAL_OSPI_Transmit_IT() after the command configuration :
     90               (+) In polling mode, the output of the function is done when the transfer is complete.
     91               (+) In interrupt mode, HAL_OSPI_FifoThresholdCallback() will be called when the fifo threshold
     92                   is reached and HAL_OSPI_TxCpltCallback() will be called when the transfer is complete.
     93               (+) In DMA mode, HAL_OSPI_TxHalfCpltCallback() will be called at the half transfer and
     94                   HAL_OSPI_TxCpltCallback() will be called when the transfer is complete.
     95              [..]
     96               For the indirect read mode, use HAL_OSPI_Receive(), HAL_OSPI_Receive_DMA() or
     97               HAL_OSPI_Receive_IT() after the command configuration :
     98               (+) In polling mode, the output of the function is done when the transfer is complete.
     99               (+) In interrupt mode, HAL_OSPI_FifoThresholdCallback() will be called when the fifo threshold
    100                   is reached and HAL_OSPI_RxCpltCallback() will be called when the transfer is complete.
    101               (+) In DMA mode, HAL_OSPI_RxHalfCpltCallback() will be called at the half transfer and
    102                   HAL_OSPI_RxCpltCallback() will be called when the transfer is complete.
    103          
    104              *** Auto-polling functional mode ***
    105              ====================================
    106              [..]
    107               Configure the command sequence by the same way than the indirect mode
    108              [..]
    109               Configure the auto-polling functional mode using the HAL_OSPI_AutoPolling()
    110               or HAL_OSPI_AutoPolling_IT() functions :
    111               (+) The size of the status bytes, the match value, the mask used, the match mode (OR/AND),
    112                   the polling interval and the automatic stop activation.
    113              [..]
    114               After the configuration :
    115               (+) In polling mode, the output of the function is done when the status match is reached. The
    116                   automatic stop is activated to avoid an infinite loop.
    117               (+) In interrupt mode, HAL_OSPI_StatusMatchCallback() will be called each time the status match is reached.
    118          
    119              *** MDMA functional mode ***
    120              ====================================
    121              [..]
    122               Configure the SourceInc and DestinationInc of MDMA parameters in the HAL_OSPI_MspInit() function :
    123               (+) MDMA settings for write operation :
    124                   (++) The DestinationInc should be MDMA_DEST_INC_DISABLE
    125                   (++) The SourceInc must be a value of @ref MDMA_Source_increment_mode (Except the MDMA_SRC_INC_DOUBLEWORD).
    126                   (++) The SourceDataSize must be a value of @ref MDMA Source data size (Except the MDMA_SRC_DATASIZE_DOUBLEWORD)
    127                        aligned with @ref MDMA_Source_increment_mode .
    128                   (++) The DestDataSize must be a value of @ref MDMA Destination data size (Except the MDMA_DEST_DATASIZE_DOUBLEWORD)
    129               (+) MDMA settings for read operation :
    130                   (++) The SourceInc should be MDMA_SRC_INC_DISABLE
    131                   (++) The DestinationInc must be a value of @ref MDMA_Destination_increment_mode (Except the MDMA_DEST_INC_DOUBLEWORD).
    132                   (++) The SourceDataSize must be a value of @ref MDMA Source data size (Except the MDMA_SRC_DATASIZE_DOUBLEWORD) .
    133                   (++) The DestDataSize must be a value of @ref MDMA Destination data size (Except the MDMA_DEST_DATASIZE_DOUBLEWORD)
    134                        aligned with @ref MDMA_Destination_increment_mode.
    135               (+) The buffer Transfer Length (BufferTransferLength) = number of bytes in the FIFO (FifoThreshold) of the Octospi.
    136              [..]
    137               In case of wrong MDMA setting
    138               (+) For write operation :
    139                   (++) If the DestinationInc is different to MDMA_DEST_INC_DISABLE , it will be disabled by the HAL_OSPI_Transmit_DMA().
    140               (+) For read operation :
    141                   (++) If the SourceInc is not set to MDMA_SRC_INC_DISABLE , it will be disabled by the HAL_OSPI_Receive_DMA().
    142          
    143              *** Memory-mapped functional mode ***
    144              =====================================
    145              [..]
    146               Configure the command sequence by the same way than the indirect mode except
    147               for the operation type in regular mode :
    148               (+) Operation type equals to read configuration : the command configuration
    149                   applies to read access in memory-mapped mode
    150               (+) Operation type equals to write configuration : the command configuration
    151                   applies to write access in memory-mapped mode
    152               (+) Both read and write configuration should be performed before activating
    153                   memory-mapped mode
    154              [..]
    155               Configure the memory-mapped functional mode using the HAL_OSPI_MemoryMapped()
    156               functions :
    157               (+) The timeout activation and the timeout period.
    158              [..]
    159               After the configuration, the OctoSPI will be used as soon as an access on the AHB is done on
    160               the address range. HAL_OSPI_TimeOutCallback() will be called when the timeout expires.
    161          
    162              *** Errors management and abort functionality ***
    163              =================================================
    164              [..]
    165               HAL_OSPI_GetError() function gives the error raised during the last operation.
    166              [..]
    167               HAL_OSPI_Abort() and HAL_OSPI_AbortIT() functions aborts any on-going operation and
    168               flushes the fifo :
    169               (+) In polling mode, the output of the function is done when the transfer
    170                   complete bit is set and the busy bit cleared.
    171               (+) In interrupt mode, HAL_OSPI_AbortCpltCallback() will be called when
    172                   the transfer complete bit is set.
    173          
    174              *** Control functions ***
    175              =========================
    176              [..]
    177               HAL_OSPI_GetState() function gives the current state of the HAL OctoSPI driver.
    178              [..]
    179               HAL_OSPI_SetTimeout() function configures the timeout value used in the driver.
    180              [..]
    181               HAL_OSPI_SetFifoThreshold() function configures the threshold on the Fifo of the OSPI Peripheral.
    182              [..]
    183               HAL_OSPI_GetFifoThreshold() function gives the current of the Fifo's threshold
    184          
    185              *** IO manager configuration functions ***
    186              ==========================================
    187              [..]
    188               HAL_OSPIM_Config() function configures the IO manager for the OctoSPI instance.
    189          
    190              *** Callback registration ***
    191              =============================================
    192              [..]
    193               The compilation define  USE_HAL_OSPI_REGISTER_CALLBACKS when set to 1
    194               allows the user to configure dynamically the driver callbacks.
    195          
    196              [..]
    197               Use function HAL_OSPI_RegisterCallback() to register a user callback,
    198               it allows to register following callbacks:
    199               (+) ErrorCallback : callback when error occurs.
    200               (+) AbortCpltCallback : callback when abort is completed.
    201               (+) FifoThresholdCallback : callback when the fifo threshold is reached.
    202               (+) CmdCpltCallback : callback when a command without data is completed.
    203               (+) RxCpltCallback : callback when a reception transfer is completed.
    204               (+) TxCpltCallback : callback when a transmission transfer is completed.
    205               (+) RxHalfCpltCallback : callback when half of the reception transfer is completed.
    206               (+) TxHalfCpltCallback : callback when half of the transmission transfer is completed.
    207               (+) StatusMatchCallback : callback when a status match occurs.
    208               (+) TimeOutCallback : callback when the timeout perioed expires.
    209               (+) MspInitCallback    : OSPI MspInit.
    210               (+) MspDeInitCallback  : OSPI MspDeInit.
    211              [..]
    212               This function takes as parameters the HAL peripheral handle, the Callback ID
    213               and a pointer to the user callback function.
    214          
    215              [..]
    216               Use function HAL_OSPI_UnRegisterCallback() to reset a callback to the default
    217               weak (surcharged) function. It allows to reset following callbacks:
    218               (+) ErrorCallback : callback when error occurs.
    219               (+) AbortCpltCallback : callback when abort is completed.
    220               (+) FifoThresholdCallback : callback when the fifo threshold is reached.
    221               (+) CmdCpltCallback : callback when a command without data is completed.
    222               (+) RxCpltCallback : callback when a reception transfer is completed.
    223               (+) TxCpltCallback : callback when a transmission transfer is completed.
    224               (+) RxHalfCpltCallback : callback when half of the reception transfer is completed.
    225               (+) TxHalfCpltCallback : callback when half of the transmission transfer is completed.
    226               (+) StatusMatchCallback : callback when a status match occurs.
    227               (+) TimeOutCallback : callback when the timeout perioed expires.
    228               (+) MspInitCallback    : OSPI MspInit.
    229               (+) MspDeInitCallback  : OSPI MspDeInit.
    230              [..]
    231               This function) takes as parameters the HAL peripheral handle and the Callback ID.
    232          
    233              [..]
    234               By default, after the HAL_OSPI_Init() and if the state is HAL_OSPI_STATE_RESET
    235               all callbacks are reset to the corresponding legacy weak (surcharged) functions.
    236               Exception done for MspInit and MspDeInit callbacks that are respectively
    237               reset to the legacy weak (surcharged) functions in the HAL_OSPI_Init()
    238               and HAL_OSPI_DeInit() only when these callbacks are null (not registered beforehand).
    239               If not, MspInit or MspDeInit are not null, the HAL_OSPI_Init() and HAL_OSPI_DeInit()
    240               keep and use the user MspInit/MspDeInit callbacks (registered beforehand)
    241          
    242              [..]
    243               Callbacks can be registered/unregistered in READY state only.
    244               Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered
    245               in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used
    246               during the Init/DeInit.
    247               In that case first register the MspInit/MspDeInit user callbacks
    248               using HAL_OSPI_RegisterCallback() before calling HAL_OSPI_DeInit()
    249               or HAL_OSPI_Init() function.
    250          
    251              [..]
    252               When The compilation define USE_HAL_OSPI_REGISTER_CALLBACKS is set to 0 or
    253               not defined, the callback registering feature is not available
    254               and weak (surcharged) callbacks are used.
    255          
    256            @endverbatim
    257            ******************************************************************************
    258            */
    259          
    260          /* Includes ------------------------------------------------------------------*/
    261          #include "stm32h7xx_hal.h"
    262          
    263          #if defined(OCTOSPI) || defined(OCTOSPI1) || defined(OCTOSPI2)
    264          
    265          /** @addtogroup STM32H7xx_HAL_Driver
    266            * @{
    267            */
    268          
    269          /** @defgroup OSPI OSPI
    270            * @brief OSPI HAL module driver
    271            * @{
    272            */
    273          
    274          #ifdef HAL_OSPI_MODULE_ENABLED
    275          
    276          /**
    277            @cond 0
    278            */
    279          /* Private typedef -----------------------------------------------------------*/
    280          
    281          /* Private define ------------------------------------------------------------*/
    282          #define OSPI_FUNCTIONAL_MODE_INDIRECT_WRITE ((uint32_t)0x00000000)         /*!< Indirect write mode    */
    283          #define OSPI_FUNCTIONAL_MODE_INDIRECT_READ  ((uint32_t)OCTOSPI_CR_FMODE_0) /*!< Indirect read mode     */
    284          #define OSPI_FUNCTIONAL_MODE_AUTO_POLLING   ((uint32_t)OCTOSPI_CR_FMODE_1) /*!< Automatic polling mode */
    285          #define OSPI_FUNCTIONAL_MODE_MEMORY_MAPPED  ((uint32_t)OCTOSPI_CR_FMODE)   /*!< Memory-mapped mode     */
    286          
    287          #define OSPI_CFG_STATE_MASK  0x00000004U
    288          #define OSPI_BUSY_STATE_MASK 0x00000008U
    289          
    290          #define OSPI_NB_INSTANCE   2U
    291          #define OSPI_IOM_NB_PORTS  2U
    292          #define OSPI_IOM_PORT_MASK 0x1U
    293          
    294          /* Private macro -------------------------------------------------------------*/
    295          #define IS_OSPI_FUNCTIONAL_MODE(MODE) (((MODE) == OSPI_FUNCTIONAL_MODE_INDIRECT_WRITE) || \
    296                                                 ((MODE) == OSPI_FUNCTIONAL_MODE_INDIRECT_READ)  || \
    297                                                 ((MODE) == OSPI_FUNCTIONAL_MODE_AUTO_POLLING)   || \
    298                                                 ((MODE) == OSPI_FUNCTIONAL_MODE_MEMORY_MAPPED))
    299          
    300          /* Private variables ---------------------------------------------------------*/
    301          
    302          /* Private function prototypes -----------------------------------------------*/
    303          static void              OSPI_DMACplt                  (MDMA_HandleTypeDef *hmdma);
    304          static void              OSPI_DMAError                 (MDMA_HandleTypeDef *hmdma);
    305          static void              OSPI_DMAAbortCplt             (MDMA_HandleTypeDef *hmdma);
    306          static HAL_StatusTypeDef OSPI_WaitFlagStateUntilTimeout(OSPI_HandleTypeDef *hospi, uint32_t Flag, FlagStatus State,
    307                                                                  uint32_t Tickstart, uint32_t Timeout);
    308          static HAL_StatusTypeDef OSPI_ConfigCmd                (OSPI_HandleTypeDef *hospi, OSPI_RegularCmdTypeDef *cmd);
    309          static HAL_StatusTypeDef OSPIM_GetConfig               (uint8_t instance_nb, OSPIM_CfgTypeDef *cfg);
    310          /**
    311            @endcond
    312            */
    313          
    314          /* Exported functions --------------------------------------------------------*/
    315          
    316          /** @defgroup OSPI_Exported_Functions OSPI Exported Functions
    317            * @{
    318            */
    319          
    320          /** @defgroup OSPI_Exported_Functions_Group1 Initialization/de-initialization functions
    321            * @brief    Initialization and Configuration functions
    322            *
    323          @verbatim
    324          ===============================================================================
    325                      ##### Initialization and Configuration functions #####
    326           ===============================================================================
    327              [..]
    328              This subsection provides a set of functions allowing to :
    329                (+) Initialize the OctoSPI.
    330                (+) De-initialize the OctoSPI.
    331          
    332          @endverbatim
    333            * @{
    334            */
    335          
    336          /**
    337            * @brief  Initialize the OSPI mode according to the specified parameters
    338            *         in the OSPI_InitTypeDef and initialize the associated handle.
    339            * @param  hospi : OSPI handle
    340            * @retval HAL status
    341            */

   \                                 In section .text, align 2, keep-with-next
    342          HAL_StatusTypeDef HAL_OSPI_Init (OSPI_HandleTypeDef *hospi)
    343          {
   \                     HAL_OSPI_Init: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    344            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2600             MOVS     R6,#+0
    345            uint32_t tickstart = HAL_GetTick();
   \        0x6   0x.... 0x....      BL       HAL_GetTick
   \        0xA   0x0005             MOVS     R5,R0
    346          
    347            /* Check the OSPI handle allocation */
    348            if (hospi == NULL)
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD101             BNE.N    ??HAL_OSPI_Init_0
    349            {
    350              status = HAL_ERROR;
   \       0x10   0x2601             MOVS     R6,#+1
   \       0x12   0xE07F             B.N      ??HAL_OSPI_Init_1
    351              /* No error code can be set set as the handler is null */
    352            }
    353            else
    354            {
    355              /* Check the parameters of the initialization structure */
    356              assert_param(IS_OSPI_FIFO_THRESHOLD (hospi->Init.FifoThreshold));
    357              assert_param(IS_OSPI_DUALQUAD_MODE  (hospi->Init.DualQuad));
    358              assert_param(IS_OSPI_MEMORY_TYPE    (hospi->Init.MemoryType));
    359              assert_param(IS_OSPI_DEVICE_SIZE    (hospi->Init.DeviceSize));
    360              assert_param(IS_OSPI_CS_HIGH_TIME   (hospi->Init.ChipSelectHighTime));
    361              assert_param(IS_OSPI_FREE_RUN_CLK   (hospi->Init.FreeRunningClock));
    362              assert_param(IS_OSPI_CLOCK_MODE     (hospi->Init.ClockMode));
    363              assert_param(IS_OSPI_WRAP_SIZE      (hospi->Init.WrapSize));
    364              assert_param(IS_OSPI_CLK_PRESCALER  (hospi->Init.ClockPrescaler));
    365              assert_param(IS_OSPI_SAMPLE_SHIFTING(hospi->Init.SampleShifting));
    366              assert_param(IS_OSPI_DHQC           (hospi->Init.DelayHoldQuarterCycle));
    367              assert_param(IS_OSPI_CS_BOUNDARY    (hospi->Init.ChipSelectBoundary));
    368              assert_param(IS_OSPI_CKCSHT         (hospi->Init.ClkChipSelectHighTime));
    369              assert_param(IS_OSPI_MAXTRAN        (hospi->Init.MaxTran));
    370          
    371              /* Initialize error code */
    372              hospi->ErrorCode = HAL_OSPI_ERROR_NONE;
   \                     ??HAL_OSPI_Init_0: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x65A0             STR      R0,[R4, #+88]
    373          
    374              /* Check if the state is the reset state */
    375              if (hospi->State == HAL_OSPI_STATE_RESET)
   \       0x18   0x6D60             LDR      R0,[R4, #+84]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD17A             BNE.N    ??HAL_OSPI_Init_1
    376              {
    377          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
    378                /* Reset Callback pointers in HAL_OSPI_STATE_RESET only */
    379                hospi->ErrorCallback         = HAL_OSPI_ErrorCallback;
    380                hospi->AbortCpltCallback     = HAL_OSPI_AbortCpltCallback;
    381                hospi->FifoThresholdCallback = HAL_OSPI_FifoThresholdCallback;
    382                hospi->CmdCpltCallback       = HAL_OSPI_CmdCpltCallback;
    383                hospi->RxCpltCallback        = HAL_OSPI_RxCpltCallback;
    384                hospi->TxCpltCallback        = HAL_OSPI_TxCpltCallback;
    385                hospi->RxHalfCpltCallback    = HAL_OSPI_RxHalfCpltCallback;
    386                hospi->TxHalfCpltCallback    = HAL_OSPI_TxHalfCpltCallback;
    387                hospi->StatusMatchCallback   = HAL_OSPI_StatusMatchCallback;
    388                hospi->TimeOutCallback       = HAL_OSPI_TimeOutCallback;
    389          
    390                if(hospi->MspInitCallback == NULL)
    391                {
    392                  hospi->MspInitCallback = HAL_OSPI_MspInit;
    393                }
    394          
    395                /* Init the low level hardware */
    396                hospi->MspInitCallback(hospi);
    397          #else
    398                /* Initialization of the low level hardware */
    399                HAL_OSPI_MspInit(hospi);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       HAL_OSPI_MspInit
    400          #endif /* defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
    401          
    402                /* Configure the default timeout for the OSPI memory access */
    403                (void)HAL_OSPI_SetTimeout(hospi, HAL_OSPI_TIMEOUT_DEFAULT_VALUE);
   \       0x24   0xF241 0x3188      MOVW     R1,#+5000
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x.... 0x....      BL       HAL_OSPI_SetTimeout
    404          
    405                /* Configure memory type, device size, chip select high time, clocked chip select high time, free running clock, clock mode */
    406                MODIFY_REG(hospi->Instance->DCR1,
    407                           (OCTOSPI_DCR1_MTYP | OCTOSPI_DCR1_DEVSIZE | OCTOSPI_DCR1_CSHT | OCTOSPI_DCR1_CKCSHT |
    408                            OCTOSPI_DCR1_FRCK | OCTOSPI_DCR1_CKMODE),
    409                           (hospi->Init.MemoryType | ((hospi->Init.DeviceSize - 1U) << OCTOSPI_DCR1_DEVSIZE_Pos) |
    410                            ((hospi->Init.ChipSelectHighTime - 1U) << OCTOSPI_DCR1_CSHT_Pos) |
    411                            (hospi->Init.ClkChipSelectHighTime << OCTOSPI_DCR1_CKCSHT_Pos) | hospi->Init.ClockMode));
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x6881             LDR      R1,[R0, #+8]
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable4
   \       0x36   0x4001             ANDS     R1,R0,R1
   \       0x38   0x68E0             LDR      R0,[R4, #+12]
   \       0x3A   0x4301             ORRS     R1,R0,R1
   \       0x3C   0x6920             LDR      R0,[R4, #+16]
   \       0x3E   0x1E40             SUBS     R0,R0,#+1
   \       0x40   0xEA51 0x4100      ORRS     R1,R1,R0, LSL #+16
   \       0x44   0x6960             LDR      R0,[R4, #+20]
   \       0x46   0x1E40             SUBS     R0,R0,#+1
   \       0x48   0xEA51 0x2100      ORRS     R1,R1,R0, LSL #+8
   \       0x4C   0x6B60             LDR      R0,[R4, #+52]
   \       0x4E   0xEA51 0x1100      ORRS     R1,R1,R0, LSL #+4
   \       0x52   0x69E0             LDR      R0,[R4, #+28]
   \       0x54   0x4301             ORRS     R1,R0,R1
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x6081             STR      R1,[R0, #+8]
    412          
    413                /* Configure wrap size */
    414                MODIFY_REG(hospi->Instance->DCR2, OCTOSPI_DCR2_WRAPSIZE, hospi->Init.WrapSize);
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x68C1             LDR      R1,[R0, #+12]
   \       0x5E   0xF431 0x21E0      BICS     R1,R1,#0x70000
   \       0x62   0x6A20             LDR      R0,[R4, #+32]
   \       0x64   0x4301             ORRS     R1,R0,R1
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x60C1             STR      R1,[R0, #+12]
    415          
    416                /* Configure chip select boundary and maximum transfer */
    417                hospi->Instance->DCR3 = ((hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos) |
    418                                         (hospi->Init.MaxTran << OCTOSPI_DCR3_MAXTRAN_Pos));
   \       0x6A   0x6B20             LDR      R0,[R4, #+48]
   \       0x6C   0x6BE1             LDR      R1,[R4, #+60]
   \       0x6E   0xEA51 0x4100      ORRS     R1,R1,R0, LSL #+16
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x6101             STR      R1,[R0, #+16]
    419          
    420                /* Configure refresh */
    421                hospi->Instance->DCR4 = hospi->Init.Refresh;
   \       0x76   0x6C20             LDR      R0,[R4, #+64]
   \       0x78   0x6821             LDR      R1,[R4, #+0]
   \       0x7A   0x6148             STR      R0,[R1, #+20]
    422          
    423                /* Configure FIFO threshold */
    424                MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FTHRES, ((hospi->Init.FifoThreshold - 1U) << OCTOSPI_CR_FTHRES_Pos));
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x6800             LDR      R0,[R0, #+0]
   \       0x80   0xF430 0x50F8      BICS     R0,R0,#0x1F00
   \       0x84   0x6861             LDR      R1,[R4, #+4]
   \       0x86   0x1E49             SUBS     R1,R1,#+1
   \       0x88   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \       0x8C   0x6821             LDR      R1,[R4, #+0]
   \       0x8E   0x6008             STR      R0,[R1, #+0]
    425          
    426                /* Wait till busy flag is reset */
    427                status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
   \       0x90   0x6DE0             LDR      R0,[R4, #+92]
   \       0x92   0x9000             STR      R0,[SP, #+0]
   \       0x94   0x002B             MOVS     R3,R5
   \       0x96   0x2200             MOVS     R2,#+0
   \       0x98   0x2120             MOVS     R1,#+32
   \       0x9A   0x0020             MOVS     R0,R4
   \       0x9C   0x.... 0x....      BL       OSPI_WaitFlagStateUntilTimeout
   \       0xA0   0x0006             MOVS     R6,R0
    428          
    429                if (status == HAL_OK)
   \       0xA2   0x0030             MOVS     R0,R6
   \       0xA4   0xB2C0             UXTB     R0,R0
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD134             BNE.N    ??HAL_OSPI_Init_1
    430                {
    431                  /* Configure clock prescaler */
    432                  MODIFY_REG(hospi->Instance->DCR2, OCTOSPI_DCR2_PRESCALER,
    433                            ((hospi->Init.ClockPrescaler - 1U) << OCTOSPI_DCR2_PRESCALER_Pos));
   \       0xAA   0x6820             LDR      R0,[R4, #+0]
   \       0xAC   0x68C0             LDR      R0,[R0, #+12]
   \       0xAE   0x0A00             LSRS     R0,R0,#+8
   \       0xB0   0x0200             LSLS     R0,R0,#+8
   \       0xB2   0x6A61             LDR      R1,[R4, #+36]
   \       0xB4   0x1E49             SUBS     R1,R1,#+1
   \       0xB6   0x4308             ORRS     R0,R1,R0
   \       0xB8   0x6821             LDR      R1,[R4, #+0]
   \       0xBA   0x60C8             STR      R0,[R1, #+12]
    434          
    435                  /* Configure Dual Quad mode */
    436                  MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_DQM, hospi->Init.DualQuad);
   \       0xBC   0x6820             LDR      R0,[R4, #+0]
   \       0xBE   0x6801             LDR      R1,[R0, #+0]
   \       0xC0   0xF031 0x0140      BICS     R1,R1,#0x40
   \       0xC4   0x68A0             LDR      R0,[R4, #+8]
   \       0xC6   0x4301             ORRS     R1,R0,R1
   \       0xC8   0x6820             LDR      R0,[R4, #+0]
   \       0xCA   0x6001             STR      R1,[R0, #+0]
    437          
    438                  /* Configure sample shifting and delay hold quarter cycle */
    439                  MODIFY_REG(hospi->Instance->TCR, (OCTOSPI_TCR_SSHIFT | OCTOSPI_TCR_DHQC),
    440                            (hospi->Init.SampleShifting | hospi->Init.DelayHoldQuarterCycle));
   \       0xCC   0x6820             LDR      R0,[R4, #+0]
   \       0xCE   0xF8D0 0x1108      LDR      R1,[R0, #+264]
   \       0xD2   0xF031 0x41A0      BICS     R1,R1,#0x50000000
   \       0xD6   0x6AA0             LDR      R0,[R4, #+40]
   \       0xD8   0x4301             ORRS     R1,R0,R1
   \       0xDA   0x6AE0             LDR      R0,[R4, #+44]
   \       0xDC   0x4301             ORRS     R1,R0,R1
   \       0xDE   0x6820             LDR      R0,[R4, #+0]
   \       0xE0   0xF8C0 0x1108      STR      R1,[R0, #+264]
    441          
    442                  /* Enable OctoSPI */
    443                  __HAL_OSPI_ENABLE(hospi);
   \       0xE4   0x6820             LDR      R0,[R4, #+0]
   \       0xE6   0x6800             LDR      R0,[R0, #+0]
   \       0xE8   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xEC   0x6821             LDR      R1,[R4, #+0]
   \       0xEE   0x6008             STR      R0,[R1, #+0]
    444          
    445                  /* Enable free running clock if needed : must be done after OSPI enable */
    446                  if (hospi->Init.FreeRunningClock == HAL_OSPI_FREERUNCLK_ENABLE)
   \       0xF0   0x69A0             LDR      R0,[R4, #+24]
   \       0xF2   0x2802             CMP      R0,#+2
   \       0xF4   0xD105             BNE.N    ??HAL_OSPI_Init_2
    447                  {
    448                    SET_BIT(hospi->Instance->DCR1, OCTOSPI_DCR1_FRCK);
   \       0xF6   0x6820             LDR      R0,[R4, #+0]
   \       0xF8   0x6880             LDR      R0,[R0, #+8]
   \       0xFA   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0xFE   0x6821             LDR      R1,[R4, #+0]
   \      0x100   0x6088             STR      R0,[R1, #+8]
    449                  }
    450          
    451                  /* Initialize the OSPI state */
    452                  if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
   \                     ??HAL_OSPI_Init_2: (+1)
   \      0x102   0x68E0             LDR      R0,[R4, #+12]
   \      0x104   0xF1B0 0x6F80      CMP      R0,#+67108864
   \      0x108   0xD102             BNE.N    ??HAL_OSPI_Init_3
    453                  {
    454                    hospi->State = HAL_OSPI_STATE_HYPERBUS_INIT;
   \      0x10A   0x2001             MOVS     R0,#+1
   \      0x10C   0x6560             STR      R0,[R4, #+84]
   \      0x10E   0xE001             B.N      ??HAL_OSPI_Init_1
    455                  }
    456                  else
    457                  {
    458                    hospi->State = HAL_OSPI_STATE_READY;
   \                     ??HAL_OSPI_Init_3: (+1)
   \      0x110   0x2002             MOVS     R0,#+2
   \      0x112   0x6560             STR      R0,[R4, #+84]
    459                  }
    460                }
    461              }
    462            }
    463          
    464            /* Return function status */
    465            return status;
   \                     ??HAL_OSPI_Init_1: (+1)
   \      0x114   0x0030             MOVS     R0,R6
   \      0x116   0xB2C0             UXTB     R0,R0
   \      0x118   0xBD76             POP      {R1,R2,R4-R6,PC}
    466          }
    467          
    468          /**
    469            * @brief  Initialize the OSPI MSP.
    470            * @param  hospi : OSPI handle
    471            * @retval None
    472            */

   \                                 In section .text, align 2
    473          __weak void HAL_OSPI_MspInit(OSPI_HandleTypeDef *hospi)
    474          {
    475            /* Prevent unused argument(s) compilation warning */
    476            UNUSED(hospi);
    477          
    478            /* NOTE : This function should not be modified, when the callback is needed,
    479                      the HAL_OSPI_MspInit can be implemented in the user file
    480             */
    481          }
   \                     HAL_OSPI_MspInit: (+1)
   \        0x0   0x4770             BX       LR
    482          
    483          /**
    484            * @brief  De-Initialize the OSPI peripheral.
    485            * @param  hospi : OSPI handle
    486            * @retval HAL status
    487            */

   \                                 In section .text, align 2, keep-with-next
    488          HAL_StatusTypeDef HAL_OSPI_DeInit(OSPI_HandleTypeDef *hospi)
    489          {
   \                     HAL_OSPI_DeInit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    490            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
    491          
    492            /* Check the OSPI handle allocation */
    493            if (hospi == NULL)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??HAL_OSPI_DeInit_0
    494            {
    495              status = HAL_ERROR;
   \        0xA   0x2501             MOVS     R5,#+1
   \        0xC   0xE010             B.N      ??HAL_OSPI_DeInit_1
    496              /* No error code can be set set as the handler is null */
    497            }
    498            else
    499            {
    500               /* Disable OctoSPI */
    501               __HAL_OSPI_DISABLE(hospi);
   \                     ??HAL_OSPI_DeInit_0: (+1)
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x0840             LSRS     R0,R0,#+1
   \       0x14   0x0040             LSLS     R0,R0,#+1
   \       0x16   0x6821             LDR      R1,[R4, #+0]
   \       0x18   0x6008             STR      R0,[R1, #+0]
    502          
    503               /* Disable free running clock if needed : must be done after OSPI disable */
    504               CLEAR_BIT(hospi->Instance->DCR1, OCTOSPI_DCR1_FRCK);
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x6880             LDR      R0,[R0, #+8]
   \       0x1E   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x6088             STR      R0,[R1, #+8]
    505          
    506          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
    507               if(hospi->MspDeInitCallback == NULL)
    508               {
    509                 hospi->MspDeInitCallback = HAL_OSPI_MspDeInit;
    510               }
    511          
    512               /* DeInit the low level hardware */
    513               hospi->MspDeInitCallback(hospi);
    514          #else
    515               /* De-initialize the low-level hardware */
    516               HAL_OSPI_MspDeInit(hospi);
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x.... 0x....      BL       HAL_OSPI_MspDeInit
    517          #endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
    518          
    519               /* Reset the driver state */
    520               hospi->State = HAL_OSPI_STATE_RESET;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x6560             STR      R0,[R4, #+84]
    521            }
    522          
    523            return status;
   \                     ??HAL_OSPI_DeInit_1: (+1)
   \       0x30   0x0028             MOVS     R0,R5
   \       0x32   0xB2C0             UXTB     R0,R0
   \       0x34   0xBD32             POP      {R1,R4,R5,PC}
    524          }
    525          
    526          /**
    527            * @brief  DeInitialize the OSPI MSP.
    528            * @param  hospi : OSPI handle
    529            * @retval None
    530            */

   \                                 In section .text, align 2
    531          __weak void HAL_OSPI_MspDeInit(OSPI_HandleTypeDef *hospi)
    532          {
    533            /* Prevent unused argument(s) compilation warning */
    534            UNUSED(hospi);
    535          
    536            /* NOTE : This function should not be modified, when the callback is needed,
    537                      the HAL_OSPI_MspDeInit can be implemented in the user file
    538             */
    539          }
   \                     HAL_OSPI_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
    540          
    541          /**
    542            * @}
    543            */
    544          
    545          /** @defgroup OSPI_Exported_Functions_Group2 Input and Output operation functions
    546            *  @brief OSPI Transmit/Receive functions
    547            *
    548          @verbatim
    549           ===============================================================================
    550                                ##### IO operation functions #####
    551           ===============================================================================
    552              [..]
    553              This subsection provides a set of functions allowing to :
    554                (+) Handle the interrupts.
    555                (+) Handle the command sequence (regular and Hyperbus).
    556                (+) Handle the Hyperbus configuration.
    557                (+) Transmit data in blocking, interrupt or DMA mode.
    558                (+) Receive data in blocking, interrupt or DMA mode.
    559                (+) Manage the auto-polling functional mode.
    560                (+) Manage the memory-mapped functional mode.
    561          
    562          @endverbatim
    563            * @{
    564            */
    565          
    566          /**
    567            * @brief  Handle OSPI interrupt request.
    568            * @param  hospi : OSPI handle
    569            * @retval None
    570            */

   \                                 In section .text, align 2, keep-with-next
    571          void HAL_OSPI_IRQHandler(OSPI_HandleTypeDef *hospi)
    572          {
   \                     HAL_OSPI_IRQHandler: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    573            __IO uint32_t *data_reg = &hospi->Instance->DR;
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0xF110 0x0250      ADDS     R2,R0,#+80
    574            uint32_t flag           = hospi->Instance->SR;
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A01             LDR      R1,[R0, #+32]
    575            uint32_t itsource       = hospi->Instance->CR;
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x6803             LDR      R3,[R0, #+0]
    576            uint32_t currentstate   = hospi->State;
   \       0x12   0x6D60             LDR      R0,[R4, #+84]
    577          
    578            /* OctoSPI fifo threshold interrupt occurred -------------------------------*/
    579            if (((flag & HAL_OSPI_FLAG_FT) != 0U) && ((itsource & HAL_OSPI_IT_FT) != 0U))
   \       0x14   0x074D             LSLS     R5,R1,#+29
   \       0x16   0xD525             BPL.N    ??HAL_OSPI_IRQHandler_0
   \       0x18   0x035D             LSLS     R5,R3,#+13
   \       0x1A   0xD523             BPL.N    ??HAL_OSPI_IRQHandler_0
    580            {
    581              if (currentstate == HAL_OSPI_STATE_BUSY_TX)
   \       0x1C   0x2818             CMP      R0,#+24
   \       0x1E   0xD109             BNE.N    ??HAL_OSPI_IRQHandler_1
    582              {
    583                /* Write a data in the fifo */
    584                *((__IO uint8_t *)data_reg) = *hospi->pBuffPtr;
   \       0x20   0x6C60             LDR      R0,[R4, #+68]
   \       0x22   0x7800             LDRB     R0,[R0, #+0]
   \       0x24   0x7010             STRB     R0,[R2, #+0]
    585                hospi->pBuffPtr++;
   \       0x26   0x6C60             LDR      R0,[R4, #+68]
   \       0x28   0x1C40             ADDS     R0,R0,#+1
   \       0x2A   0x6460             STR      R0,[R4, #+68]
    586                hospi->XferCount--;
   \       0x2C   0x6CE0             LDR      R0,[R4, #+76]
   \       0x2E   0x1E40             SUBS     R0,R0,#+1
   \       0x30   0x64E0             STR      R0,[R4, #+76]
   \       0x32   0xE00A             B.N      ??HAL_OSPI_IRQHandler_2
    587              }
    588              else if (currentstate == HAL_OSPI_STATE_BUSY_RX)
   \                     ??HAL_OSPI_IRQHandler_1: (+1)
   \       0x34   0x2828             CMP      R0,#+40
   \       0x36   0xD108             BNE.N    ??HAL_OSPI_IRQHandler_2
    589              {
    590                /* Read a data from the fifo */
    591                *hospi->pBuffPtr = *((__IO uint8_t *)data_reg);
   \       0x38   0x7810             LDRB     R0,[R2, #+0]
   \       0x3A   0x6C61             LDR      R1,[R4, #+68]
   \       0x3C   0x7008             STRB     R0,[R1, #+0]
    592                hospi->pBuffPtr++;
   \       0x3E   0x6C60             LDR      R0,[R4, #+68]
   \       0x40   0x1C40             ADDS     R0,R0,#+1
   \       0x42   0x6460             STR      R0,[R4, #+68]
    593                hospi->XferCount--;
   \       0x44   0x6CE0             LDR      R0,[R4, #+76]
   \       0x46   0x1E40             SUBS     R0,R0,#+1
   \       0x48   0x64E0             STR      R0,[R4, #+76]
    594              }
    595              else
    596              {
    597                /* Nothing to do */
    598              }
    599          
    600              if (hospi->XferCount == 0U)
   \                     ??HAL_OSPI_IRQHandler_2: (+1)
   \       0x4A   0x6CE0             LDR      R0,[R4, #+76]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD105             BNE.N    ??HAL_OSPI_IRQHandler_3
    601              {
    602                /* All data have been received or transmitted for the transfer */
    603                /* Disable fifo threshold interrupt */
    604                __HAL_OSPI_DISABLE_IT(hospi, HAL_OSPI_IT_FT);
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x6800             LDR      R0,[R0, #+0]
   \       0x54   0xF430 0x2080      BICS     R0,R0,#0x40000
   \       0x58   0x6821             LDR      R1,[R4, #+0]
   \       0x5A   0x6008             STR      R0,[R1, #+0]
    605              }
    606          
    607              /* Fifo threshold callback */
    608          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
    609              hospi->FifoThresholdCallback(hospi);
    610          #else
    611              HAL_OSPI_FifoThresholdCallback(hospi);
   \                     ??HAL_OSPI_IRQHandler_3: (+1)
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0x.... 0x....      BL       HAL_OSPI_FifoThresholdCallback
   \       0x62   0xE09F             B.N      ??HAL_OSPI_IRQHandler_4
    612          #endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)*/
    613            }
    614            /* OctoSPI transfer complete interrupt occurred ----------------------------*/
    615            else if (((flag & HAL_OSPI_FLAG_TC) != 0U) && ((itsource & HAL_OSPI_IT_TC) != 0U))
   \                     ??HAL_OSPI_IRQHandler_0: (+1)
   \       0x64   0x078D             LSLS     R5,R1,#+30
   \       0x66   0xD54B             BPL.N    ??HAL_OSPI_IRQHandler_5
   \       0x68   0x039D             LSLS     R5,R3,#+14
   \       0x6A   0xD549             BPL.N    ??HAL_OSPI_IRQHandler_5
    616            {
    617              if (currentstate == HAL_OSPI_STATE_BUSY_RX)
   \       0x6C   0x2828             CMP      R0,#+40
   \       0x6E   0xD122             BNE.N    ??HAL_OSPI_IRQHandler_6
    618              {
    619                if ((hospi->XferCount > 0U) && ((flag & OCTOSPI_SR_FLEVEL) != 0U))
   \       0x70   0x6CE0             LDR      R0,[R4, #+76]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD00C             BEQ.N    ??HAL_OSPI_IRQHandler_7
   \       0x76   0xF411 0x5F7C      TST      R1,#0x3F00
   \       0x7A   0xD009             BEQ.N    ??HAL_OSPI_IRQHandler_7
    620                {
    621                  /* Read the last data received in the fifo */
    622                  *hospi->pBuffPtr = *((__IO uint8_t *)data_reg);
   \       0x7C   0x7810             LDRB     R0,[R2, #+0]
   \       0x7E   0x6C61             LDR      R1,[R4, #+68]
   \       0x80   0x7008             STRB     R0,[R1, #+0]
    623                  hospi->pBuffPtr++;
   \       0x82   0x6C60             LDR      R0,[R4, #+68]
   \       0x84   0x1C40             ADDS     R0,R0,#+1
   \       0x86   0x6460             STR      R0,[R4, #+68]
    624                  hospi->XferCount--;
   \       0x88   0x6CE0             LDR      R0,[R4, #+76]
   \       0x8A   0x1E40             SUBS     R0,R0,#+1
   \       0x8C   0x64E0             STR      R0,[R4, #+76]
   \       0x8E   0xE089             B.N      ??HAL_OSPI_IRQHandler_4
    625                }
    626                else if(hospi->XferCount == 0U)
   \                     ??HAL_OSPI_IRQHandler_7: (+1)
   \       0x90   0x6CE0             LDR      R0,[R4, #+76]
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xF040 0x8086      BNE.W    ??HAL_OSPI_IRQHandler_4
    627                {
    628                  /* Clear flag */
    629                  hospi->Instance->FCR = HAL_OSPI_FLAG_TC;
   \       0x98   0x2002             MOVS     R0,#+2
   \       0x9A   0x6821             LDR      R1,[R4, #+0]
   \       0x9C   0x6248             STR      R0,[R1, #+36]
    630          
    631                  /* Disable the interrupts */
    632                  __HAL_OSPI_DISABLE_IT(hospi, HAL_OSPI_IT_TC | HAL_OSPI_IT_FT | HAL_OSPI_IT_TE);
   \       0x9E   0x6820             LDR      R0,[R4, #+0]
   \       0xA0   0x6800             LDR      R0,[R0, #+0]
   \       0xA2   0xF430 0x20E0      BICS     R0,R0,#0x70000
   \       0xA6   0x6821             LDR      R1,[R4, #+0]
   \       0xA8   0x6008             STR      R0,[R1, #+0]
    633          
    634                  /* Update state */
    635                  hospi->State = HAL_OSPI_STATE_READY;
   \       0xAA   0x2002             MOVS     R0,#+2
   \       0xAC   0x6560             STR      R0,[R4, #+84]
    636          
    637                  /* RX complete callback */
    638          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
    639                  hospi->RxCpltCallback(hospi);
    640          #else
    641                  HAL_OSPI_RxCpltCallback(hospi);
   \       0xAE   0x0020             MOVS     R0,R4
   \       0xB0   0x.... 0x....      BL       HAL_OSPI_RxCpltCallback
   \       0xB4   0xE076             B.N      ??HAL_OSPI_IRQHandler_4
    642          #endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
    643                }
    644                else
    645                {
    646                  /* Nothing to do */
    647                }
    648              }
    649              else
    650              {
    651                /* Clear flag */
    652                hospi->Instance->FCR = HAL_OSPI_FLAG_TC;
   \                     ??HAL_OSPI_IRQHandler_6: (+1)
   \       0xB6   0x2102             MOVS     R1,#+2
   \       0xB8   0x6822             LDR      R2,[R4, #+0]
   \       0xBA   0x6251             STR      R1,[R2, #+36]
    653          
    654                /* Disable the interrupts */
    655                __HAL_OSPI_DISABLE_IT(hospi, HAL_OSPI_IT_TC | HAL_OSPI_IT_FT | HAL_OSPI_IT_TE);
   \       0xBC   0x6821             LDR      R1,[R4, #+0]
   \       0xBE   0x6809             LDR      R1,[R1, #+0]
   \       0xC0   0xF431 0x21E0      BICS     R1,R1,#0x70000
   \       0xC4   0x6822             LDR      R2,[R4, #+0]
   \       0xC6   0x6011             STR      R1,[R2, #+0]
    656          
    657                /* Update state */
    658                hospi->State = HAL_OSPI_STATE_READY;
   \       0xC8   0x2102             MOVS     R1,#+2
   \       0xCA   0x6561             STR      R1,[R4, #+84]
    659          
    660                if (currentstate == HAL_OSPI_STATE_BUSY_TX)
   \       0xCC   0x2818             CMP      R0,#+24
   \       0xCE   0xD103             BNE.N    ??HAL_OSPI_IRQHandler_8
    661                {
    662                  /* TX complete callback */
    663          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
    664                  hospi->TxCpltCallback(hospi);
    665          #else
    666                  HAL_OSPI_TxCpltCallback(hospi);
   \       0xD0   0x0020             MOVS     R0,R4
   \       0xD2   0x.... 0x....      BL       HAL_OSPI_TxCpltCallback
   \       0xD6   0xE065             B.N      ??HAL_OSPI_IRQHandler_4
    667          #endif /* defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
    668                }
    669                else if (currentstate == HAL_OSPI_STATE_BUSY_CMD)
   \                     ??HAL_OSPI_IRQHandler_8: (+1)
   \       0xD8   0x2808             CMP      R0,#+8
   \       0xDA   0xD103             BNE.N    ??HAL_OSPI_IRQHandler_9
    670                {
    671                  /* Command complete callback */
    672          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
    673                  hospi->CmdCpltCallback(hospi);
    674          #else
    675                  HAL_OSPI_CmdCpltCallback(hospi);
   \       0xDC   0x0020             MOVS     R0,R4
   \       0xDE   0x.... 0x....      BL       HAL_OSPI_CmdCpltCallback
   \       0xE2   0xE05F             B.N      ??HAL_OSPI_IRQHandler_4
    676          #endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
    677                }
    678                else if (currentstate == HAL_OSPI_STATE_ABORT)
   \                     ??HAL_OSPI_IRQHandler_9: (+1)
   \       0xE4   0xF5B0 0x7F80      CMP      R0,#+256
   \       0xE8   0xD15C             BNE.N    ??HAL_OSPI_IRQHandler_4
    679                {
    680                  if (hospi->ErrorCode == HAL_OSPI_ERROR_NONE)
   \       0xEA   0x6DA0             LDR      R0,[R4, #+88]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD103             BNE.N    ??HAL_OSPI_IRQHandler_10
    681                  {
    682                    /* Abort called by the user */
    683                    /* Abort complete callback */
    684          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
    685                    hospi->AbortCpltCallback(hospi);
    686          #else
    687                    HAL_OSPI_AbortCpltCallback(hospi);
   \       0xF0   0x0020             MOVS     R0,R4
   \       0xF2   0x.... 0x....      BL       HAL_OSPI_AbortCpltCallback
   \       0xF6   0xE055             B.N      ??HAL_OSPI_IRQHandler_4
    688          #endif /* defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)*/
    689                  }
    690                  else
    691                  {
    692                    /* Abort due to an error (eg : DMA error) */
    693                    /* Error callback */
    694          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
    695                    hospi->ErrorCallback(hospi);
    696          #else
    697                    HAL_OSPI_ErrorCallback(hospi);
   \                     ??HAL_OSPI_IRQHandler_10: (+1)
   \       0xF8   0x0020             MOVS     R0,R4
   \       0xFA   0x.... 0x....      BL       HAL_OSPI_ErrorCallback
   \       0xFE   0xE051             B.N      ??HAL_OSPI_IRQHandler_4
    698          #endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
    699                  }
    700                }
    701                else
    702                {
    703                  /* Nothing to do */
    704                }
    705              }
    706            }
    707            /* OctoSPI status match interrupt occurred ---------------------------------*/
    708            else if (((flag & HAL_OSPI_FLAG_SM) != 0U) && ((itsource & HAL_OSPI_IT_SM) != 0U))
   \                     ??HAL_OSPI_IRQHandler_5: (+1)
   \      0x100   0x0708             LSLS     R0,R1,#+28
   \      0x102   0xD514             BPL.N    ??HAL_OSPI_IRQHandler_11
   \      0x104   0x0318             LSLS     R0,R3,#+12
   \      0x106   0xD512             BPL.N    ??HAL_OSPI_IRQHandler_11
    709            {
    710              /* Clear flag */
    711              hospi->Instance->FCR = HAL_OSPI_FLAG_SM;
   \      0x108   0x2008             MOVS     R0,#+8
   \      0x10A   0x6821             LDR      R1,[R4, #+0]
   \      0x10C   0x6248             STR      R0,[R1, #+36]
    712          
    713              /* Check if automatic poll mode stop is activated */
    714              if ((hospi->Instance->CR & OCTOSPI_CR_APMS) != 0U)
   \      0x10E   0x6820             LDR      R0,[R4, #+0]
   \      0x110   0x6800             LDR      R0,[R0, #+0]
   \      0x112   0x0240             LSLS     R0,R0,#+9
   \      0x114   0xD507             BPL.N    ??HAL_OSPI_IRQHandler_12
    715              {
    716                /* Disable the interrupts */
    717                __HAL_OSPI_DISABLE_IT(hospi, HAL_OSPI_IT_SM | HAL_OSPI_IT_TE);
   \      0x116   0x6820             LDR      R0,[R4, #+0]
   \      0x118   0x6800             LDR      R0,[R0, #+0]
   \      0x11A   0xF430 0x2010      BICS     R0,R0,#0x90000
   \      0x11E   0x6821             LDR      R1,[R4, #+0]
   \      0x120   0x6008             STR      R0,[R1, #+0]
    718          
    719                /* Update state */
    720                hospi->State = HAL_OSPI_STATE_READY;
   \      0x122   0x2002             MOVS     R0,#+2
   \      0x124   0x6560             STR      R0,[R4, #+84]
    721              }
    722          
    723              /* Status match callback */
    724          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
    725              hospi->StatusMatchCallback(hospi);
    726          #else
    727              HAL_OSPI_StatusMatchCallback(hospi);
   \                     ??HAL_OSPI_IRQHandler_12: (+1)
   \      0x126   0x0020             MOVS     R0,R4
   \      0x128   0x.... 0x....      BL       HAL_OSPI_StatusMatchCallback
   \      0x12C   0xE03A             B.N      ??HAL_OSPI_IRQHandler_4
    728          #endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
    729            }
    730            /* OctoSPI transfer error interrupt occurred -------------------------------*/
    731            else if (((flag & HAL_OSPI_FLAG_TE) != 0U) && ((itsource & HAL_OSPI_IT_TE) != 0U))
   \                     ??HAL_OSPI_IRQHandler_11: (+1)
   \      0x12E   0xF011 0x0001      ANDS     R0,R1,#0x1
   \      0x132   0xB2C0             UXTB     R0,R0
   \      0x134   0x2800             CMP      R0,#+0
   \      0x136   0xD02B             BEQ.N    ??HAL_OSPI_IRQHandler_13
   \      0x138   0x03D8             LSLS     R0,R3,#+15
   \      0x13A   0xD529             BPL.N    ??HAL_OSPI_IRQHandler_13
    732            {
    733              /* Clear flag */
    734              hospi->Instance->FCR = HAL_OSPI_FLAG_TE;
   \      0x13C   0x2001             MOVS     R0,#+1
   \      0x13E   0x6821             LDR      R1,[R4, #+0]
   \      0x140   0x6248             STR      R0,[R1, #+36]
    735          
    736              /* Disable all interrupts */
    737              __HAL_OSPI_DISABLE_IT(hospi, (HAL_OSPI_IT_TO | HAL_OSPI_IT_SM | HAL_OSPI_IT_FT | HAL_OSPI_IT_TC | HAL_OSPI_IT_TE));
   \      0x142   0x6820             LDR      R0,[R4, #+0]
   \      0x144   0x6800             LDR      R0,[R0, #+0]
   \      0x146   0xF430 0x10F8      BICS     R0,R0,#0x1F0000
   \      0x14A   0x6821             LDR      R1,[R4, #+0]
   \      0x14C   0x6008             STR      R0,[R1, #+0]
    738          
    739              /* Set error code */
    740              hospi->ErrorCode = HAL_OSPI_ERROR_TRANSFER;
   \      0x14E   0x2002             MOVS     R0,#+2
   \      0x150   0x65A0             STR      R0,[R4, #+88]
    741          
    742              /* Check if the DMA is enabled */
    743              if ((hospi->Instance->CR & OCTOSPI_CR_DMAEN) != 0U)
   \      0x152   0x6820             LDR      R0,[R4, #+0]
   \      0x154   0x6800             LDR      R0,[R0, #+0]
   \      0x156   0x0740             LSLS     R0,R0,#+29
   \      0x158   0xD514             BPL.N    ??HAL_OSPI_IRQHandler_14
    744              {
    745                /* Disable the DMA transfer on the OctoSPI side */
    746                CLEAR_BIT(hospi->Instance->CR, OCTOSPI_CR_DMAEN);
   \      0x15A   0x6820             LDR      R0,[R4, #+0]
   \      0x15C   0x6800             LDR      R0,[R0, #+0]
   \      0x15E   0xF030 0x0004      BICS     R0,R0,#0x4
   \      0x162   0x6821             LDR      R1,[R4, #+0]
   \      0x164   0x6008             STR      R0,[R1, #+0]
    747          
    748                /* Disable the DMA transfer on the DMA side */
    749                hospi->hmdma->XferAbortCallback = OSPI_DMAAbortCplt;
   \      0x166   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \      0x16A   0x6D21             LDR      R1,[R4, #+80]
   \      0x16C   0x6588             STR      R0,[R1, #+88]
    750                if (HAL_MDMA_Abort_IT(hospi->hmdma) != HAL_OK)
   \      0x16E   0x6D20             LDR      R0,[R4, #+80]
   \      0x170   0x.... 0x....      BL       HAL_MDMA_Abort_IT
   \      0x174   0x2800             CMP      R0,#+0
   \      0x176   0xD015             BEQ.N    ??HAL_OSPI_IRQHandler_4
    751                {
    752                  /* Update state */
    753                  hospi->State = HAL_OSPI_STATE_READY;
   \      0x178   0x2002             MOVS     R0,#+2
   \      0x17A   0x6560             STR      R0,[R4, #+84]
    754          
    755                  /* Error callback */
    756          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
    757                  hospi->ErrorCallback(hospi);
    758          #else
    759                  HAL_OSPI_ErrorCallback(hospi);
   \      0x17C   0x0020             MOVS     R0,R4
   \      0x17E   0x.... 0x....      BL       HAL_OSPI_ErrorCallback
   \      0x182   0xE00F             B.N      ??HAL_OSPI_IRQHandler_4
    760          #endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)*/
    761                }
    762              }
    763              else
    764              {
    765                /* Update state */
    766                hospi->State = HAL_OSPI_STATE_READY;
   \                     ??HAL_OSPI_IRQHandler_14: (+1)
   \      0x184   0x2002             MOVS     R0,#+2
   \      0x186   0x6560             STR      R0,[R4, #+84]
    767          
    768                /* Error callback */
    769          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
    770                hospi->ErrorCallback(hospi);
    771          #else
    772                HAL_OSPI_ErrorCallback(hospi);
   \      0x188   0x0020             MOVS     R0,R4
   \      0x18A   0x.... 0x....      BL       HAL_OSPI_ErrorCallback
   \      0x18E   0xE009             B.N      ??HAL_OSPI_IRQHandler_4
    773          #endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
    774              }
    775            }
    776            /* OctoSPI timeout interrupt occurred --------------------------------------*/
    777            else if (((flag & HAL_OSPI_FLAG_TO) != 0U) && ((itsource & HAL_OSPI_IT_TO) != 0U))
   \                     ??HAL_OSPI_IRQHandler_13: (+1)
   \      0x190   0x06C8             LSLS     R0,R1,#+27
   \      0x192   0xD507             BPL.N    ??HAL_OSPI_IRQHandler_4
   \      0x194   0x02D8             LSLS     R0,R3,#+11
   \      0x196   0xD505             BPL.N    ??HAL_OSPI_IRQHandler_4
    778            {
    779              /* Clear flag */
    780              hospi->Instance->FCR = HAL_OSPI_FLAG_TO;
   \      0x198   0x2010             MOVS     R0,#+16
   \      0x19A   0x6821             LDR      R1,[R4, #+0]
   \      0x19C   0x6248             STR      R0,[R1, #+36]
    781          
    782              /* Timeout callback */
    783          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
    784              hospi->TimeOutCallback(hospi);
    785          #else
    786              HAL_OSPI_TimeOutCallback(hospi);
   \      0x19E   0x0020             MOVS     R0,R4
   \      0x1A0   0x.... 0x....      BL       HAL_OSPI_TimeOutCallback
    787          #endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
    788            }
    789            else
    790            {
    791              /* Nothing to do */
    792            }
    793          }
   \                     ??HAL_OSPI_IRQHandler_4: (+1)
   \      0x1A4   0xBD31             POP      {R0,R4,R5,PC}
    794          
    795          /**
    796            * @brief  Set the command configuration.
    797            * @param  hospi   : OSPI handle
    798            * @param  cmd     : structure that contains the command configuration information
    799            * @param  Timeout : Timeout duration
    800            * @retval HAL status
    801            */

   \                                 In section .text, align 2, keep-with-next
    802          HAL_StatusTypeDef HAL_OSPI_Command(OSPI_HandleTypeDef *hospi, OSPI_RegularCmdTypeDef *cmd, uint32_t Timeout)
    803          {
   \                     HAL_OSPI_Command: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000F             MOVS     R7,R1
   \        0x6   0x0015             MOVS     R5,R2
    804            HAL_StatusTypeDef status;
    805            uint32_t state;
    806            uint32_t tickstart = HAL_GetTick();
   \        0x8   0x.... 0x....      BL       HAL_GetTick
   \        0xC   0x0006             MOVS     R6,R0
    807          
    808            /* Check the parameters of the command structure */
    809            assert_param(IS_OSPI_OPERATION_TYPE(cmd->OperationType));
    810          
    811            if (hospi->Init.DualQuad == HAL_OSPI_DUALQUAD_DISABLE)
   \        0xE   0x68A0             LDR      R0,[R4, #+8]
   \       0x10   0x2800             CMP      R0,#+0
    812            {
    813              assert_param(IS_OSPI_FLASH_ID(cmd->FlashId));
    814            }
    815          
    816            assert_param(IS_OSPI_INSTRUCTION_MODE(cmd->InstructionMode));
    817            if (cmd->InstructionMode != HAL_OSPI_INSTRUCTION_NONE)
   \                     ??HAL_OSPI_Command_0: (+1)
   \       0x12   0x68F8             LDR      R0,[R7, #+12]
   \       0x14   0x2800             CMP      R0,#+0
    818            {
    819              assert_param(IS_OSPI_INSTRUCTION_SIZE    (cmd->InstructionSize));
    820              assert_param(IS_OSPI_INSTRUCTION_DTR_MODE(cmd->InstructionDtrMode));
    821            }
    822          
    823            assert_param(IS_OSPI_ADDRESS_MODE(cmd->AddressMode));
    824            if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
   \                     ??HAL_OSPI_Command_1: (+1)
   \       0x16   0x69F8             LDR      R0,[R7, #+28]
   \       0x18   0x2800             CMP      R0,#+0
    825            {
    826              assert_param(IS_OSPI_ADDRESS_SIZE    (cmd->AddressSize));
    827              assert_param(IS_OSPI_ADDRESS_DTR_MODE(cmd->AddressDtrMode));
    828            }
    829          
    830            assert_param(IS_OSPI_ALT_BYTES_MODE(cmd->AlternateBytesMode));
    831            if (cmd->AlternateBytesMode != HAL_OSPI_ALTERNATE_BYTES_NONE)
   \                     ??HAL_OSPI_Command_2: (+1)
   \       0x1A   0x6AF8             LDR      R0,[R7, #+44]
   \       0x1C   0x2800             CMP      R0,#+0
    832            {
    833              assert_param(IS_OSPI_ALT_BYTES_SIZE    (cmd->AlternateBytesSize));
    834              assert_param(IS_OSPI_ALT_BYTES_DTR_MODE(cmd->AlternateBytesDtrMode));
    835            }
    836          
    837            assert_param(IS_OSPI_DATA_MODE(cmd->DataMode));
    838            if (cmd->DataMode != HAL_OSPI_DATA_NONE)
   \                     ??HAL_OSPI_Command_3: (+1)
   \       0x1E   0x6BB8             LDR      R0,[R7, #+56]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD001             BEQ.N    ??HAL_OSPI_Command_4
    839            {
    840              if (cmd->OperationType == HAL_OSPI_OPTYPE_COMMON_CFG)
   \       0x24   0x6838             LDR      R0,[R7, #+0]
   \       0x26   0x2800             CMP      R0,#+0
    841              {
    842                assert_param(IS_OSPI_NUMBER_DATA  (cmd->NbData));
    843              }
    844              assert_param(IS_OSPI_DATA_DTR_MODE(cmd->DataDtrMode));
    845              assert_param(IS_OSPI_DUMMY_CYCLES (cmd->DummyCycles));
    846            }
    847          
    848            assert_param(IS_OSPI_DQS_MODE (cmd->DQSMode));
    849            assert_param(IS_OSPI_SIOO_MODE(cmd->SIOOMode));
    850          
    851            /* Check the state of the driver */
    852            state = hospi->State;
   \                     ??HAL_OSPI_Command_5: (+1)
   \                     ??HAL_OSPI_Command_4: (+1)
   \       0x28   0x6D60             LDR      R0,[R4, #+84]
    853            if (((state == HAL_OSPI_STATE_READY)         && (hospi->Init.MemoryType != HAL_OSPI_MEMTYPE_HYPERBUS)) ||
    854                ((state == HAL_OSPI_STATE_READ_CMD_CFG)  && ((cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG)
    855                                                          || (cmd->OperationType == HAL_OSPI_OPTYPE_WRAP_CFG))) ||
    856                ((state == HAL_OSPI_STATE_WRITE_CMD_CFG) && ((cmd->OperationType == HAL_OSPI_OPTYPE_READ_CFG)  ||
    857                                                             (cmd->OperationType == HAL_OSPI_OPTYPE_WRAP_CFG))))
   \       0x2A   0x2802             CMP      R0,#+2
   \       0x2C   0xD103             BNE.N    ??HAL_OSPI_Command_6
   \       0x2E   0x68E1             LDR      R1,[R4, #+12]
   \       0x30   0xF1B1 0x6F80      CMP      R1,#+67108864
   \       0x34   0xD10F             BNE.N    ??HAL_OSPI_Command_7
   \                     ??HAL_OSPI_Command_6: (+1)
   \       0x36   0x2814             CMP      R0,#+20
   \       0x38   0xD105             BNE.N    ??HAL_OSPI_Command_8
   \       0x3A   0x6839             LDR      R1,[R7, #+0]
   \       0x3C   0x2902             CMP      R1,#+2
   \       0x3E   0xD00A             BEQ.N    ??HAL_OSPI_Command_7
   \       0x40   0x6839             LDR      R1,[R7, #+0]
   \       0x42   0x2903             CMP      R1,#+3
   \       0x44   0xD007             BEQ.N    ??HAL_OSPI_Command_7
   \                     ??HAL_OSPI_Command_8: (+1)
   \       0x46   0x2824             CMP      R0,#+36
   \       0x48   0xD146             BNE.N    ??HAL_OSPI_Command_9
   \       0x4A   0x6838             LDR      R0,[R7, #+0]
   \       0x4C   0x2801             CMP      R0,#+1
   \       0x4E   0xD002             BEQ.N    ??HAL_OSPI_Command_7
   \       0x50   0x6838             LDR      R0,[R7, #+0]
   \       0x52   0x2803             CMP      R0,#+3
   \       0x54   0xD140             BNE.N    ??HAL_OSPI_Command_9
    858            {
    859              /* Wait till busy flag is reset */
    860              status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);
   \                     ??HAL_OSPI_Command_7: (+1)
   \       0x56   0x9500             STR      R5,[SP, #+0]
   \       0x58   0x0033             MOVS     R3,R6
   \       0x5A   0x2200             MOVS     R2,#+0
   \       0x5C   0x2120             MOVS     R1,#+32
   \       0x5E   0x0020             MOVS     R0,R4
   \       0x60   0x.... 0x....      BL       OSPI_WaitFlagStateUntilTimeout
    861          
    862              if (status == HAL_OK)
   \       0x64   0x0001             MOVS     R1,R0
   \       0x66   0xB2C9             UXTB     R1,R1
   \       0x68   0x2900             CMP      R1,#+0
   \       0x6A   0xD138             BNE.N    ??HAL_OSPI_Command_10
    863              {
    864                /* Initialize error code */
    865                hospi->ErrorCode = HAL_OSPI_ERROR_NONE;
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x65A0             STR      R0,[R4, #+88]
    866          
    867                /* Configure the registers */
    868                status = OSPI_ConfigCmd(hospi, cmd);
   \       0x70   0x0039             MOVS     R1,R7
   \       0x72   0x0020             MOVS     R0,R4
   \       0x74   0x.... 0x....      BL       OSPI_ConfigCmd
    869          
    870                if (status == HAL_OK)
   \       0x78   0x0001             MOVS     R1,R0
   \       0x7A   0xB2C9             UXTB     R1,R1
   \       0x7C   0x2900             CMP      R1,#+0
   \       0x7E   0xD12E             BNE.N    ??HAL_OSPI_Command_10
    871                {
    872                  if (cmd->DataMode == HAL_OSPI_DATA_NONE)
   \       0x80   0x6BB9             LDR      R1,[R7, #+56]
   \       0x82   0x2900             CMP      R1,#+0
   \       0x84   0xD10A             BNE.N    ??HAL_OSPI_Command_11
    873                  {
    874                    /* When there is no data phase, the transfer start as soon as the configuration is done
    875                       so wait until TC flag is set to go back in idle state */
    876                    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, Timeout);
   \       0x86   0x9500             STR      R5,[SP, #+0]
   \       0x88   0x0033             MOVS     R3,R6
   \       0x8A   0x2201             MOVS     R2,#+1
   \       0x8C   0x2102             MOVS     R1,#+2
   \       0x8E   0x0020             MOVS     R0,R4
   \       0x90   0x.... 0x....      BL       OSPI_WaitFlagStateUntilTimeout
    877          
    878                    __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
   \       0x94   0x2102             MOVS     R1,#+2
   \       0x96   0x6822             LDR      R2,[R4, #+0]
   \       0x98   0x6251             STR      R1,[R2, #+36]
   \       0x9A   0xE020             B.N      ??HAL_OSPI_Command_10
    879                  }
    880                  else
    881                  {
    882                    /* Update the state */
    883                    if (cmd->OperationType == HAL_OSPI_OPTYPE_COMMON_CFG)
   \                     ??HAL_OSPI_Command_11: (+1)
   \       0x9C   0x6839             LDR      R1,[R7, #+0]
   \       0x9E   0x2900             CMP      R1,#+0
   \       0xA0   0xD102             BNE.N    ??HAL_OSPI_Command_12
    884                    {
    885                      hospi->State = HAL_OSPI_STATE_CMD_CFG;
   \       0xA2   0x2104             MOVS     R1,#+4
   \       0xA4   0x6561             STR      R1,[R4, #+84]
   \       0xA6   0xE01A             B.N      ??HAL_OSPI_Command_10
    886                    }
    887                    else if (cmd->OperationType == HAL_OSPI_OPTYPE_READ_CFG)
   \                     ??HAL_OSPI_Command_12: (+1)
   \       0xA8   0x6839             LDR      R1,[R7, #+0]
   \       0xAA   0x2901             CMP      R1,#+1
   \       0xAC   0xD108             BNE.N    ??HAL_OSPI_Command_13
    888                    {
    889                      if (hospi->State == HAL_OSPI_STATE_WRITE_CMD_CFG)
   \       0xAE   0x6D61             LDR      R1,[R4, #+84]
   \       0xB0   0x2924             CMP      R1,#+36
   \       0xB2   0xD102             BNE.N    ??HAL_OSPI_Command_14
    890                      {
    891                        hospi->State = HAL_OSPI_STATE_CMD_CFG;
   \       0xB4   0x2104             MOVS     R1,#+4
   \       0xB6   0x6561             STR      R1,[R4, #+84]
   \       0xB8   0xE011             B.N      ??HAL_OSPI_Command_10
    892                      }
    893                      else
    894                      {
    895                        hospi->State = HAL_OSPI_STATE_READ_CMD_CFG;
   \                     ??HAL_OSPI_Command_14: (+1)
   \       0xBA   0x2114             MOVS     R1,#+20
   \       0xBC   0x6561             STR      R1,[R4, #+84]
   \       0xBE   0xE00E             B.N      ??HAL_OSPI_Command_10
    896                      }
    897                    }
    898                    else if (cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG)
   \                     ??HAL_OSPI_Command_13: (+1)
   \       0xC0   0x6839             LDR      R1,[R7, #+0]
   \       0xC2   0x2902             CMP      R1,#+2
   \       0xC4   0xD10B             BNE.N    ??HAL_OSPI_Command_10
    899                    {
    900                      if (hospi->State == HAL_OSPI_STATE_READ_CMD_CFG)
   \       0xC6   0x6D61             LDR      R1,[R4, #+84]
   \       0xC8   0x2914             CMP      R1,#+20
   \       0xCA   0xD102             BNE.N    ??HAL_OSPI_Command_15
    901                      {
    902                        hospi->State = HAL_OSPI_STATE_CMD_CFG;
   \       0xCC   0x2104             MOVS     R1,#+4
   \       0xCE   0x6561             STR      R1,[R4, #+84]
   \       0xD0   0xE005             B.N      ??HAL_OSPI_Command_10
    903                      }
    904                      else
    905                      {
    906                        hospi->State = HAL_OSPI_STATE_WRITE_CMD_CFG;
   \                     ??HAL_OSPI_Command_15: (+1)
   \       0xD2   0x2124             MOVS     R1,#+36
   \       0xD4   0x6561             STR      R1,[R4, #+84]
   \       0xD6   0xE002             B.N      ??HAL_OSPI_Command_10
    907                      }
    908                    }
    909                    else
    910                    {
    911                      /* Wrap configuration, no state change */
    912                    }
    913                  }
    914                }
    915              }
    916            }
    917            else
    918            {
    919              status = HAL_ERROR;
   \                     ??HAL_OSPI_Command_9: (+1)
   \       0xD8   0x2001             MOVS     R0,#+1
    920              hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
   \       0xDA   0x2110             MOVS     R1,#+16
   \       0xDC   0x65A1             STR      R1,[R4, #+88]
    921            }
    922          
    923            /* Return function status */
    924            return status;
   \                     ??HAL_OSPI_Command_10: (+1)
   \       0xDE   0xB2C0             UXTB     R0,R0
   \       0xE0   0xBDF2             POP      {R1,R4-R7,PC}
    925          }
    926          
    927          /**
    928            * @brief  Set the command configuration in interrupt mode.
    929            * @param  hospi : OSPI handle
    930            * @param  cmd   : structure that contains the command configuration information
    931            * @note   This function is used only in Indirect Read or Write Modes
    932            * @retval HAL status
    933            */

   \                                 In section .text, align 2, keep-with-next
    934          HAL_StatusTypeDef HAL_OSPI_Command_IT(OSPI_HandleTypeDef *hospi, OSPI_RegularCmdTypeDef *cmd)
    935          {
   \                     HAL_OSPI_Command_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    936            HAL_StatusTypeDef status;
    937            uint32_t tickstart = HAL_GetTick();
   \        0x6   0x.... 0x....      BL       HAL_GetTick
   \        0xA   0x0003             MOVS     R3,R0
    938          
    939            /* Check the parameters of the command structure */
    940            assert_param(IS_OSPI_OPERATION_TYPE(cmd->OperationType));
    941          
    942            if (hospi->Init.DualQuad == HAL_OSPI_DUALQUAD_DISABLE)
   \        0xC   0x68A0             LDR      R0,[R4, #+8]
   \        0xE   0x2800             CMP      R0,#+0
    943            {
    944              assert_param(IS_OSPI_FLASH_ID(cmd->FlashId));
    945            }
    946          
    947            assert_param(IS_OSPI_INSTRUCTION_MODE(cmd->InstructionMode));
    948            if (cmd->InstructionMode != HAL_OSPI_INSTRUCTION_NONE)
   \                     ??HAL_OSPI_Command_IT_0: (+1)
   \       0x10   0x68E8             LDR      R0,[R5, #+12]
   \       0x12   0x2800             CMP      R0,#+0
    949            {
    950              assert_param(IS_OSPI_INSTRUCTION_SIZE    (cmd->InstructionSize));
    951              assert_param(IS_OSPI_INSTRUCTION_DTR_MODE(cmd->InstructionDtrMode));
    952            }
    953          
    954            assert_param(IS_OSPI_ADDRESS_MODE(cmd->AddressMode));
    955            if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
   \                     ??HAL_OSPI_Command_IT_1: (+1)
   \       0x14   0x69E8             LDR      R0,[R5, #+28]
   \       0x16   0x2800             CMP      R0,#+0
    956            {
    957              assert_param(IS_OSPI_ADDRESS_SIZE    (cmd->AddressSize));
    958              assert_param(IS_OSPI_ADDRESS_DTR_MODE(cmd->AddressDtrMode));
    959            }
    960          
    961            assert_param(IS_OSPI_ALT_BYTES_MODE(cmd->AlternateBytesMode));
    962            if (cmd->AlternateBytesMode != HAL_OSPI_ALTERNATE_BYTES_NONE)
   \                     ??HAL_OSPI_Command_IT_2: (+1)
   \       0x18   0x6AE8             LDR      R0,[R5, #+44]
   \       0x1A   0x2800             CMP      R0,#+0
    963            {
    964              assert_param(IS_OSPI_ALT_BYTES_SIZE    (cmd->AlternateBytesSize));
    965              assert_param(IS_OSPI_ALT_BYTES_DTR_MODE(cmd->AlternateBytesDtrMode));
    966            }
    967          
    968            assert_param(IS_OSPI_DATA_MODE(cmd->DataMode));
    969            if (cmd->DataMode != HAL_OSPI_DATA_NONE)
   \                     ??HAL_OSPI_Command_IT_3: (+1)
   \       0x1C   0x6BA8             LDR      R0,[R5, #+56]
   \       0x1E   0x2800             CMP      R0,#+0
    970            {
    971              assert_param(IS_OSPI_NUMBER_DATA  (cmd->NbData));
    972              assert_param(IS_OSPI_DATA_DTR_MODE(cmd->DataDtrMode));
    973              assert_param(IS_OSPI_DUMMY_CYCLES (cmd->DummyCycles));
    974            }
    975          
    976            assert_param(IS_OSPI_DQS_MODE (cmd->DQSMode));
    977            assert_param(IS_OSPI_SIOO_MODE(cmd->SIOOMode));
    978          
    979            /* Check the state of the driver */
    980            if ((hospi->State  == HAL_OSPI_STATE_READY) && (cmd->OperationType     == HAL_OSPI_OPTYPE_COMMON_CFG) &&
    981                (cmd->DataMode == HAL_OSPI_DATA_NONE)   && (hospi->Init.MemoryType != HAL_OSPI_MEMTYPE_HYPERBUS))
   \                     ??HAL_OSPI_Command_IT_4: (+1)
   \       0x20   0x6D60             LDR      R0,[R4, #+84]
   \       0x22   0x2802             CMP      R0,#+2
   \       0x24   0xD12A             BNE.N    ??HAL_OSPI_Command_IT_5
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD127             BNE.N    ??HAL_OSPI_Command_IT_5
   \       0x2C   0x6BA8             LDR      R0,[R5, #+56]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD124             BNE.N    ??HAL_OSPI_Command_IT_5
   \       0x32   0x68E0             LDR      R0,[R4, #+12]
   \       0x34   0xF1B0 0x6F80      CMP      R0,#+67108864
   \       0x38   0xD020             BEQ.N    ??HAL_OSPI_Command_IT_5
    982            {
    983              /* Wait till busy flag is reset */
    984              status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
   \       0x3A   0x6DE0             LDR      R0,[R4, #+92]
   \       0x3C   0x9000             STR      R0,[SP, #+0]
   \       0x3E   0x2200             MOVS     R2,#+0
   \       0x40   0x2120             MOVS     R1,#+32
   \       0x42   0x0020             MOVS     R0,R4
   \       0x44   0x.... 0x....      BL       OSPI_WaitFlagStateUntilTimeout
    985          
    986              if (status == HAL_OK)
   \       0x48   0x0001             MOVS     R1,R0
   \       0x4A   0xB2C9             UXTB     R1,R1
   \       0x4C   0x2900             CMP      R1,#+0
   \       0x4E   0xD118             BNE.N    ??HAL_OSPI_Command_IT_6
    987              {
    988                /* Initialize error code */
    989                hospi->ErrorCode = HAL_OSPI_ERROR_NONE;
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x65A0             STR      R0,[R4, #+88]
    990          
    991                /* Clear flags related to interrupt */
    992                __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TE | HAL_OSPI_FLAG_TC);
   \       0x54   0x2003             MOVS     R0,#+3
   \       0x56   0x6821             LDR      R1,[R4, #+0]
   \       0x58   0x6248             STR      R0,[R1, #+36]
    993          
    994                /* Configure the registers */
    995                status = OSPI_ConfigCmd(hospi, cmd);
   \       0x5A   0x0029             MOVS     R1,R5
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0x.... 0x....      BL       OSPI_ConfigCmd
    996          
    997                if (status == HAL_OK)
   \       0x62   0x0001             MOVS     R1,R0
   \       0x64   0xB2C9             UXTB     R1,R1
   \       0x66   0x2900             CMP      R1,#+0
   \       0x68   0xD10B             BNE.N    ??HAL_OSPI_Command_IT_6
    998                {
    999                  /* Update the state */
   1000                    hospi->State = HAL_OSPI_STATE_BUSY_CMD;
   \       0x6A   0x2108             MOVS     R1,#+8
   \       0x6C   0x6561             STR      R1,[R4, #+84]
   1001          
   1002                  /* Enable the transfer complete and transfer error interrupts */
   1003                  __HAL_OSPI_ENABLE_IT(hospi, HAL_OSPI_IT_TC | HAL_OSPI_IT_TE);
   \       0x6E   0x6821             LDR      R1,[R4, #+0]
   \       0x70   0x6809             LDR      R1,[R1, #+0]
   \       0x72   0xF451 0x3140      ORRS     R1,R1,#0x30000
   \       0x76   0x6822             LDR      R2,[R4, #+0]
   \       0x78   0x6011             STR      R1,[R2, #+0]
   \       0x7A   0xE002             B.N      ??HAL_OSPI_Command_IT_6
   1004                }
   1005              }
   1006            }
   1007            else
   1008            {
   1009              status = HAL_ERROR;
   \                     ??HAL_OSPI_Command_IT_5: (+1)
   \       0x7C   0x2001             MOVS     R0,#+1
   1010              hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
   \       0x7E   0x2110             MOVS     R1,#+16
   \       0x80   0x65A1             STR      R1,[R4, #+88]
   1011            }
   1012          
   1013            /* Return function status */
   1014            return status;
   \                     ??HAL_OSPI_Command_IT_6: (+1)
   \       0x82   0xB2C0             UXTB     R0,R0
   \       0x84   0xBD32             POP      {R1,R4,R5,PC}
   1015          }
   1016          
   1017          /**
   1018            * @brief  Configure the Hyperbus parameters.
   1019            * @param  hospi   : OSPI handle
   1020            * @param  cfg     : Structure containing the Hyperbus configuration
   1021            * @param  Timeout : Timeout duration
   1022            * @retval HAL status
   1023            */

   \                                 In section .text, align 2, keep-with-next
   1024          HAL_StatusTypeDef HAL_OSPI_HyperbusCfg(OSPI_HandleTypeDef *hospi, OSPI_HyperbusCfgTypeDef *cfg, uint32_t Timeout)
   1025          {
   \                     HAL_OSPI_HyperbusCfg: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   1026            HAL_StatusTypeDef status;
   1027            uint32_t state;
   1028            uint32_t tickstart = HAL_GetTick();
   \        0x8   0x.... 0x....      BL       HAL_GetTick
   \        0xC   0x0003             MOVS     R3,R0
   1029          
   1030            /* Check the parameters of the hyperbus configuration structure */
   1031            assert_param(IS_OSPI_RW_RECOVERY_TIME  (cfg->RWRecoveryTime));
   1032            assert_param(IS_OSPI_ACCESS_TIME       (cfg->AccessTime));
   1033            assert_param(IS_OSPI_WRITE_ZERO_LATENCY(cfg->WriteZeroLatency));
   1034            assert_param(IS_OSPI_LATENCY_MODE      (cfg->LatencyMode));
   1035          
   1036            /* Check the state of the driver */
   1037            state = hospi->State;
   \        0xE   0x6D60             LDR      R0,[R4, #+84]
   1038            if ((state == HAL_OSPI_STATE_HYPERBUS_INIT) || (state == HAL_OSPI_STATE_READY))
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD001             BEQ.N    ??HAL_OSPI_HyperbusCfg_0
   \       0x14   0x2802             CMP      R0,#+2
   \       0x16   0xD118             BNE.N    ??HAL_OSPI_HyperbusCfg_1
   1039            {
   1040              /* Wait till busy flag is reset */
   1041              status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);
   \                     ??HAL_OSPI_HyperbusCfg_0: (+1)
   \       0x18   0x9600             STR      R6,[SP, #+0]
   \       0x1A   0x2200             MOVS     R2,#+0
   \       0x1C   0x2120             MOVS     R1,#+32
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       OSPI_WaitFlagStateUntilTimeout
   1042          
   1043              if (status == HAL_OK)
   \       0x24   0x0001             MOVS     R1,R0
   \       0x26   0xB2C9             UXTB     R1,R1
   \       0x28   0x2900             CMP      R1,#+0
   \       0x2A   0xD111             BNE.N    ??HAL_OSPI_HyperbusCfg_2
   1044              {
   1045                /* Configure Hyperbus configuration Latency register */
   1046                WRITE_REG(hospi->Instance->HLCR, ((cfg->RWRecoveryTime << OCTOSPI_HLCR_TRWR_Pos) |
   1047                                                  (cfg->AccessTime << OCTOSPI_HLCR_TACC_Pos)     |
   1048                                                  cfg->WriteZeroLatency | cfg->LatencyMode));
   \       0x2C   0x6829             LDR      R1,[R5, #+0]
   \       0x2E   0x686A             LDR      R2,[R5, #+4]
   \       0x30   0x0212             LSLS     R2,R2,#+8
   \       0x32   0xEA52 0x4201      ORRS     R2,R2,R1, LSL #+16
   \       0x36   0x68A9             LDR      R1,[R5, #+8]
   \       0x38   0x430A             ORRS     R2,R1,R2
   \       0x3A   0x68E9             LDR      R1,[R5, #+12]
   \       0x3C   0x430A             ORRS     R2,R1,R2
   \       0x3E   0x6821             LDR      R1,[R4, #+0]
   \       0x40   0xF8C1 0x2200      STR      R2,[R1, #+512]
   1049          
   1050                /* Update the state */
   1051                hospi->State = HAL_OSPI_STATE_READY;
   \       0x44   0x2102             MOVS     R1,#+2
   \       0x46   0x6561             STR      R1,[R4, #+84]
   \       0x48   0xE002             B.N      ??HAL_OSPI_HyperbusCfg_2
   1052              }
   1053            }
   1054            else
   1055            {
   1056              status = HAL_ERROR;
   \                     ??HAL_OSPI_HyperbusCfg_1: (+1)
   \       0x4A   0x2001             MOVS     R0,#+1
   1057              hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
   \       0x4C   0x2110             MOVS     R1,#+16
   \       0x4E   0x65A1             STR      R1,[R4, #+88]
   1058            }
   1059          
   1060            /* Return function status */
   1061            return status;
   \                     ??HAL_OSPI_HyperbusCfg_2: (+1)
   \       0x50   0xB2C0             UXTB     R0,R0
   \       0x52   0xBD76             POP      {R1,R2,R4-R6,PC}
   1062          }
   1063          
   1064          /**
   1065            * @brief  Set the Hyperbus command configuration.
   1066            * @param  hospi   : OSPI handle
   1067            * @param  cmd     : Structure containing the Hyperbus command
   1068            * @param  Timeout : Timeout duration
   1069            * @retval HAL status
   1070            */

   \                                 In section .text, align 2, keep-with-next
   1071          HAL_StatusTypeDef HAL_OSPI_HyperbusCmd(OSPI_HandleTypeDef *hospi, OSPI_HyperbusCmdTypeDef *cmd, uint32_t Timeout)
   1072          {
   \                     HAL_OSPI_HyperbusCmd: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   1073            HAL_StatusTypeDef status;
   1074            uint32_t tickstart = HAL_GetTick();
   \        0x8   0x.... 0x....      BL       HAL_GetTick
   \        0xC   0x0003             MOVS     R3,R0
   1075          
   1076            /* Check the parameters of the hyperbus command structure */
   1077            assert_param(IS_OSPI_ADDRESS_SPACE(cmd->AddressSpace));
   1078            assert_param(IS_OSPI_ADDRESS_SIZE (cmd->AddressSize));
   1079            assert_param(IS_OSPI_NUMBER_DATA  (cmd->NbData));
   1080            assert_param(IS_OSPI_DQS_MODE     (cmd->DQSMode));
   1081          
   1082            /* Check the state of the driver */
   1083            if ((hospi->State == HAL_OSPI_STATE_READY) && (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS))
   \        0xE   0x6D60             LDR      R0,[R4, #+84]
   \       0x10   0x2802             CMP      R0,#+2
   \       0x12   0xD135             BNE.N    ??HAL_OSPI_HyperbusCmd_0
   \       0x14   0x68E0             LDR      R0,[R4, #+12]
   \       0x16   0xF1B0 0x6F80      CMP      R0,#+67108864
   \       0x1A   0xD131             BNE.N    ??HAL_OSPI_HyperbusCmd_0
   1084            {
   1085              /* Wait till busy flag is reset */
   1086              status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);
   \       0x1C   0x9600             STR      R6,[SP, #+0]
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0x2120             MOVS     R1,#+32
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       OSPI_WaitFlagStateUntilTimeout
   1087          
   1088              if (status == HAL_OK)
   \       0x28   0x0001             MOVS     R1,R0
   \       0x2A   0xB2C9             UXTB     R1,R1
   \       0x2C   0x2900             CMP      R1,#+0
   \       0x2E   0xD12A             BNE.N    ??HAL_OSPI_HyperbusCmd_1
   1089              {
   1090                /* Re-initialize the value of the functional mode */
   1091                MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, 0U);
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x6809             LDR      R1,[R1, #+0]
   \       0x34   0xF031 0x5140      BICS     R1,R1,#0x30000000
   \       0x38   0x6822             LDR      R2,[R4, #+0]
   \       0x3A   0x6011             STR      R1,[R2, #+0]
   1092          
   1093                /* Configure the address space in the DCR1 register */
   1094                MODIFY_REG(hospi->Instance->DCR1, OCTOSPI_DCR1_MTYP_0, cmd->AddressSpace);
   \       0x3C   0x6821             LDR      R1,[R4, #+0]
   \       0x3E   0x688A             LDR      R2,[R1, #+8]
   \       0x40   0xF032 0x7280      BICS     R2,R2,#0x1000000
   \       0x44   0x6829             LDR      R1,[R5, #+0]
   \       0x46   0x430A             ORRS     R2,R1,R2
   \       0x48   0x6821             LDR      R1,[R4, #+0]
   \       0x4A   0x608A             STR      R2,[R1, #+8]
   1095          
   1096                /* Configure the CCR and WCCR registers with the address size and the following configuration :
   1097                   - DQS signal enabled (used as RWDS)
   1098                   - DTR mode enabled on address and data
   1099                   - address and data on 8 lines */
   1100                WRITE_REG(hospi->Instance->CCR, (cmd->DQSMode | OCTOSPI_CCR_DDTR | OCTOSPI_CCR_DMODE_2 |
   1101                                                 cmd->AddressSize | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADMODE_2));
   \       0x4C   0x692A             LDR      R2,[R5, #+16]
   \       0x4E   0x68A9             LDR      R1,[R5, #+8]
   \       0x50   0x430A             ORRS     R2,R1,R2
   \       0x52   0xF052 0x220C      ORRS     R2,R2,#0xC000C00
   \       0x56   0x6821             LDR      R1,[R4, #+0]
   \       0x58   0xF8C1 0x2100      STR      R2,[R1, #+256]
   1102                WRITE_REG(hospi->Instance->WCCR, (cmd->DQSMode | OCTOSPI_WCCR_DDTR | OCTOSPI_WCCR_DMODE_2 |
   1103                                                  cmd->AddressSize | OCTOSPI_WCCR_ADDTR | OCTOSPI_WCCR_ADMODE_2));
   \       0x5C   0x692A             LDR      R2,[R5, #+16]
   \       0x5E   0x68A9             LDR      R1,[R5, #+8]
   \       0x60   0x430A             ORRS     R2,R1,R2
   \       0x62   0xF052 0x220C      ORRS     R2,R2,#0xC000C00
   \       0x66   0x6821             LDR      R1,[R4, #+0]
   \       0x68   0xF8C1 0x2180      STR      R2,[R1, #+384]
   1104          
   1105                /* Configure the DLR register with the number of data */
   1106                WRITE_REG(hospi->Instance->DLR, (cmd->NbData - 1U));
   \       0x6C   0x68E9             LDR      R1,[R5, #+12]
   \       0x6E   0x1E49             SUBS     R1,R1,#+1
   \       0x70   0x6822             LDR      R2,[R4, #+0]
   \       0x72   0x6411             STR      R1,[R2, #+64]
   1107          
   1108                /* Configure the AR register with the address value */
   1109                WRITE_REG(hospi->Instance->AR, cmd->Address);
   \       0x74   0x6869             LDR      R1,[R5, #+4]
   \       0x76   0x6822             LDR      R2,[R4, #+0]
   \       0x78   0x6491             STR      R1,[R2, #+72]
   1110          
   1111                /* Update the state */
   1112                hospi->State = HAL_OSPI_STATE_CMD_CFG;
   \       0x7A   0x2104             MOVS     R1,#+4
   \       0x7C   0x6561             STR      R1,[R4, #+84]
   \       0x7E   0xE002             B.N      ??HAL_OSPI_HyperbusCmd_1
   1113              }
   1114            }
   1115            else
   1116            {
   1117              status = HAL_ERROR;
   \                     ??HAL_OSPI_HyperbusCmd_0: (+1)
   \       0x80   0x2001             MOVS     R0,#+1
   1118              hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
   \       0x82   0x2110             MOVS     R1,#+16
   \       0x84   0x65A1             STR      R1,[R4, #+88]
   1119            }
   1120          
   1121            /* Return function status */
   1122            return status;
   \                     ??HAL_OSPI_HyperbusCmd_1: (+1)
   \       0x86   0xB2C0             UXTB     R0,R0
   \       0x88   0xBD76             POP      {R1,R2,R4-R6,PC}
   1123          }
   1124          
   1125          /**
   1126            * @brief  Transmit an amount of data in blocking mode.
   1127            * @param  hospi   : OSPI handle
   1128            * @param  pData   : pointer to data buffer
   1129            * @param  Timeout : Timeout duration
   1130            * @note   This function is used only in Indirect Write Mode
   1131            * @retval HAL status
   1132            */

   \                                 In section .text, align 2, keep-with-next
   1133          HAL_StatusTypeDef HAL_OSPI_Transmit(OSPI_HandleTypeDef *hospi, uint8_t *pData, uint32_t Timeout)
   1134          {
   \                     HAL_OSPI_Transmit: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0016             MOVS     R6,R2
   1135            HAL_StatusTypeDef status;
   1136            uint32_t tickstart = HAL_GetTick();
   \        0xA   0x.... 0x....      BL       HAL_GetTick
   \        0xE   0x0007             MOVS     R7,R0
   1137            __IO uint32_t *data_reg = &hospi->Instance->DR;
   \       0x10   0x6828             LDR      R0,[R5, #+0]
   \       0x12   0xF110 0x0850      ADDS     R8,R0,#+80
   1138          
   1139            /* Check the data pointer allocation */
   1140            if (pData == NULL)
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD103             BNE.N    ??HAL_OSPI_Transmit_0
   1141            {
   1142              status = HAL_ERROR;
   \       0x1A   0x2001             MOVS     R0,#+1
   1143              hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
   \       0x1C   0x2108             MOVS     R1,#+8
   \       0x1E   0x65A9             STR      R1,[R5, #+88]
   \       0x20   0xE040             B.N      ??HAL_OSPI_Transmit_1
   1144            }
   1145            else
   1146            {
   1147              /* Check the state */
   1148              if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
   \                     ??HAL_OSPI_Transmit_0: (+1)
   \       0x22   0x6D68             LDR      R0,[R5, #+84]
   \       0x24   0x2804             CMP      R0,#+4
   \       0x26   0xD13A             BNE.N    ??HAL_OSPI_Transmit_2
   1149              {
   1150                /* Configure counters and size */
   1151                hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
   \       0x28   0x6828             LDR      R0,[R5, #+0]
   \       0x2A   0x6C00             LDR      R0,[R0, #+64]
   \       0x2C   0x1C40             ADDS     R0,R0,#+1
   \       0x2E   0x64E8             STR      R0,[R5, #+76]
   1152                hospi->XferSize  = hospi->XferCount;
   \       0x30   0x6CE8             LDR      R0,[R5, #+76]
   \       0x32   0x64A8             STR      R0,[R5, #+72]
   1153                hospi->pBuffPtr  = pData;
   \       0x34   0x646C             STR      R4,[R5, #+68]
   1154          
   1155                /* Configure CR register with functional mode as indirect write */
   1156                MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, OSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
   \       0x36   0x6828             LDR      R0,[R5, #+0]
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0xF030 0x5040      BICS     R0,R0,#0x30000000
   \       0x3E   0x6829             LDR      R1,[R5, #+0]
   \       0x40   0x6008             STR      R0,[R1, #+0]
   1157          
   1158                do
   1159                {
   1160                  /* Wait till fifo threshold flag is set to send data */
   1161                  status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_FT, SET, tickstart, Timeout);
   \                     ??HAL_OSPI_Transmit_3: (+1)
   \       0x42   0x9600             STR      R6,[SP, #+0]
   \       0x44   0x003B             MOVS     R3,R7
   \       0x46   0x2201             MOVS     R2,#+1
   \       0x48   0x2104             MOVS     R1,#+4
   \       0x4A   0x0028             MOVS     R0,R5
   \       0x4C   0x.... 0x....      BL       OSPI_WaitFlagStateUntilTimeout
   1162          
   1163                  if (status != HAL_OK)
   \       0x50   0x0001             MOVS     R1,R0
   \       0x52   0xB2C9             UXTB     R1,R1
   \       0x54   0x2900             CMP      R1,#+0
   \       0x56   0xD10D             BNE.N    ??HAL_OSPI_Transmit_4
   1164                  {
   1165                    break;
   1166                  }
   1167          
   1168                  *((__IO uint8_t *)data_reg) = *hospi->pBuffPtr;
   \                     ??HAL_OSPI_Transmit_5: (+1)
   \       0x58   0x6C69             LDR      R1,[R5, #+68]
   \       0x5A   0x7809             LDRB     R1,[R1, #+0]
   \       0x5C   0xF888 0x1000      STRB     R1,[R8, #+0]
   1169                  hospi->pBuffPtr++;
   \       0x60   0x6C69             LDR      R1,[R5, #+68]
   \       0x62   0x1C49             ADDS     R1,R1,#+1
   \       0x64   0x6469             STR      R1,[R5, #+68]
   1170                  hospi->XferCount--;
   \       0x66   0x6CE9             LDR      R1,[R5, #+76]
   \       0x68   0x1E49             SUBS     R1,R1,#+1
   \       0x6A   0x64E9             STR      R1,[R5, #+76]
   1171                } while (hospi->XferCount > 0U);
   \       0x6C   0x6CE9             LDR      R1,[R5, #+76]
   \       0x6E   0x2900             CMP      R1,#+0
   \       0x70   0xD1E7             BNE.N    ??HAL_OSPI_Transmit_3
   \       0x72   0xE7FF             B.N      ??HAL_OSPI_Transmit_6
   1172          
   1173                if (status == HAL_OK)
   \                     ??HAL_OSPI_Transmit_4: (+1)
   \                     ??HAL_OSPI_Transmit_6: (+1)
   \       0x74   0x0001             MOVS     R1,R0
   \       0x76   0xB2C9             UXTB     R1,R1
   \       0x78   0x2900             CMP      R1,#+0
   \       0x7A   0xD113             BNE.N    ??HAL_OSPI_Transmit_1
   1174                {
   1175                  /* Wait till transfer complete flag is set to go back in idle state */
   1176                  status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, Timeout);
   \       0x7C   0x9600             STR      R6,[SP, #+0]
   \       0x7E   0x003B             MOVS     R3,R7
   \       0x80   0x2201             MOVS     R2,#+1
   \       0x82   0x2102             MOVS     R1,#+2
   \       0x84   0x0028             MOVS     R0,R5
   \       0x86   0x.... 0x....      BL       OSPI_WaitFlagStateUntilTimeout
   1177          
   1178                  if (status == HAL_OK)
   \       0x8A   0x0001             MOVS     R1,R0
   \       0x8C   0xB2C9             UXTB     R1,R1
   \       0x8E   0x2900             CMP      R1,#+0
   \       0x90   0xD108             BNE.N    ??HAL_OSPI_Transmit_1
   1179                  {
   1180                    /* Clear transfer complete flag */
   1181                    __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
   \       0x92   0x2102             MOVS     R1,#+2
   \       0x94   0x682A             LDR      R2,[R5, #+0]
   \       0x96   0x6251             STR      R1,[R2, #+36]
   1182          
   1183                    /* Update state */
   1184                    hospi->State = HAL_OSPI_STATE_READY;
   \       0x98   0x2102             MOVS     R1,#+2
   \       0x9A   0x6569             STR      R1,[R5, #+84]
   \       0x9C   0xE002             B.N      ??HAL_OSPI_Transmit_1
   1185                  }
   1186                }
   1187              }
   1188              else
   1189              {
   1190                status = HAL_ERROR;
   \                     ??HAL_OSPI_Transmit_2: (+1)
   \       0x9E   0x2001             MOVS     R0,#+1
   1191                hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
   \       0xA0   0x2110             MOVS     R1,#+16
   \       0xA2   0x65A9             STR      R1,[R5, #+88]
   1192              }
   1193            }
   1194          
   1195            /* Return function status */
   1196            return status;
   \                     ??HAL_OSPI_Transmit_1: (+1)
   \       0xA4   0xB2C0             UXTB     R0,R0
   \       0xA6   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   1197          }
   1198          
   1199          /**
   1200            * @brief  Receive an amount of data in blocking mode.
   1201            * @param  hospi   : OSPI handle
   1202            * @param  pData   : pointer to data buffer
   1203            * @param  Timeout : Timeout duration
   1204            * @note   This function is used only in Indirect Read Mode
   1205            * @retval HAL status
   1206            */

   \                                 In section .text, align 2, keep-with-next
   1207          HAL_StatusTypeDef HAL_OSPI_Receive(OSPI_HandleTypeDef *hospi, uint8_t *pData, uint32_t Timeout)
   1208          {
   \                     HAL_OSPI_Receive: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0016             MOVS     R6,R2
   1209            HAL_StatusTypeDef status;
   1210            uint32_t tickstart = HAL_GetTick();
   \        0xA   0x.... 0x....      BL       HAL_GetTick
   \        0xE   0x0007             MOVS     R7,R0
   1211            __IO uint32_t *data_reg = &hospi->Instance->DR;
   \       0x10   0x6828             LDR      R0,[R5, #+0]
   \       0x12   0xF110 0x0850      ADDS     R8,R0,#+80
   1212            uint32_t addr_reg = hospi->Instance->AR;
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x6C80             LDR      R0,[R0, #+72]
   1213            uint32_t ir_reg = hospi->Instance->IR;
   \       0x1A   0x6829             LDR      R1,[R5, #+0]
   \       0x1C   0xF8D1 0x1110      LDR      R1,[R1, #+272]
   1214          
   1215            /* Check the data pointer allocation */
   1216            if (pData == NULL)
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD103             BNE.N    ??HAL_OSPI_Receive_0
   1217            {
   1218              status = HAL_ERROR;
   \       0x24   0x2001             MOVS     R0,#+1
   1219              hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
   \       0x26   0x2108             MOVS     R1,#+8
   \       0x28   0x65A9             STR      R1,[R5, #+88]
   \       0x2A   0xE054             B.N      ??HAL_OSPI_Receive_1
   1220            }
   1221            else
   1222            {
   1223              /* Check the state */
   1224              if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
   \                     ??HAL_OSPI_Receive_0: (+1)
   \       0x2C   0x6D6A             LDR      R2,[R5, #+84]
   \       0x2E   0x2A04             CMP      R2,#+4
   \       0x30   0xD14E             BNE.N    ??HAL_OSPI_Receive_2
   1225              {
   1226                /* Configure counters and size */
   1227                hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
   \       0x32   0x682A             LDR      R2,[R5, #+0]
   \       0x34   0x6C12             LDR      R2,[R2, #+64]
   \       0x36   0x1C52             ADDS     R2,R2,#+1
   \       0x38   0x64EA             STR      R2,[R5, #+76]
   1228                hospi->XferSize  = hospi->XferCount;
   \       0x3A   0x6CEA             LDR      R2,[R5, #+76]
   \       0x3C   0x64AA             STR      R2,[R5, #+72]
   1229                hospi->pBuffPtr  = pData;
   \       0x3E   0x646C             STR      R4,[R5, #+68]
   1230          
   1231                /* Configure CR register with functional mode as indirect read */
   1232                MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, OSPI_FUNCTIONAL_MODE_INDIRECT_READ);
   \       0x40   0x2201             MOVS     R2,#+1
   \       0x42   0x682B             LDR      R3,[R5, #+0]
   \       0x44   0x681B             LDR      R3,[R3, #+0]
   \       0x46   0xF362 0x731D      BFI      R3,R2,#+28,#+2
   \       0x4A   0x682A             LDR      R2,[R5, #+0]
   \       0x4C   0x6013             STR      R3,[R2, #+0]
   1233          
   1234                /* Trig the transfer by re-writing address or instruction register */
   1235                if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
   \       0x4E   0x68EA             LDR      R2,[R5, #+12]
   \       0x50   0xF1B2 0x6F80      CMP      R2,#+67108864
   \       0x54   0xD102             BNE.N    ??HAL_OSPI_Receive_3
   1236                {
   1237                  WRITE_REG(hospi->Instance->AR, addr_reg);
   \       0x56   0x6829             LDR      R1,[R5, #+0]
   \       0x58   0x6488             STR      R0,[R1, #+72]
   \       0x5A   0xE00B             B.N      ??HAL_OSPI_Receive_4
   1238                }
   1239                else
   1240                {
   1241                  if (READ_BIT(hospi->Instance->CCR, OCTOSPI_CCR_ADMODE) != HAL_OSPI_ADDRESS_NONE)
   \                     ??HAL_OSPI_Receive_3: (+1)
   \       0x5C   0x682A             LDR      R2,[R5, #+0]
   \       0x5E   0xF8D2 0x2100      LDR      R2,[R2, #+256]
   \       0x62   0xF412 0x6FE0      TST      R2,#0x700
   \       0x66   0xD002             BEQ.N    ??HAL_OSPI_Receive_5
   1242                  {
   1243                    WRITE_REG(hospi->Instance->AR, addr_reg);
   \       0x68   0x6829             LDR      R1,[R5, #+0]
   \       0x6A   0x6488             STR      R0,[R1, #+72]
   \       0x6C   0xE002             B.N      ??HAL_OSPI_Receive_4
   1244                  }
   1245                  else
   1246                  {
   1247                    WRITE_REG(hospi->Instance->IR, ir_reg);
   \                     ??HAL_OSPI_Receive_5: (+1)
   \       0x6E   0x6828             LDR      R0,[R5, #+0]
   \       0x70   0xF8C0 0x1110      STR      R1,[R0, #+272]
   1248                  }
   1249                }
   1250          
   1251                do
   1252                {
   1253                  /* Wait till fifo threshold or transfer complete flags are set to read received data */
   1254                  status = OSPI_WaitFlagStateUntilTimeout(hospi, (HAL_OSPI_FLAG_FT | HAL_OSPI_FLAG_TC), SET, tickstart, Timeout);
   \                     ??HAL_OSPI_Receive_4: (+1)
   \       0x74   0x9600             STR      R6,[SP, #+0]
   \       0x76   0x003B             MOVS     R3,R7
   \       0x78   0x2201             MOVS     R2,#+1
   \       0x7A   0x2106             MOVS     R1,#+6
   \       0x7C   0x0028             MOVS     R0,R5
   \       0x7E   0x.... 0x....      BL       OSPI_WaitFlagStateUntilTimeout
   1255          
   1256                  if (status != HAL_OK)
   \       0x82   0x0001             MOVS     R1,R0
   \       0x84   0xB2C9             UXTB     R1,R1
   \       0x86   0x2900             CMP      R1,#+0
   \       0x88   0xD10D             BNE.N    ??HAL_OSPI_Receive_6
   1257                  {
   1258                    break;
   1259                  }
   1260          
   1261                  *hospi->pBuffPtr = *((__IO uint8_t *)data_reg);
   \                     ??HAL_OSPI_Receive_7: (+1)
   \       0x8A   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \       0x8E   0x6C6A             LDR      R2,[R5, #+68]
   \       0x90   0x7011             STRB     R1,[R2, #+0]
   1262                  hospi->pBuffPtr++;
   \       0x92   0x6C69             LDR      R1,[R5, #+68]
   \       0x94   0x1C49             ADDS     R1,R1,#+1
   \       0x96   0x6469             STR      R1,[R5, #+68]
   1263                  hospi->XferCount--;
   \       0x98   0x6CE9             LDR      R1,[R5, #+76]
   \       0x9A   0x1E49             SUBS     R1,R1,#+1
   \       0x9C   0x64E9             STR      R1,[R5, #+76]
   1264                } while(hospi->XferCount > 0U);
   \       0x9E   0x6CE9             LDR      R1,[R5, #+76]
   \       0xA0   0x2900             CMP      R1,#+0
   \       0xA2   0xD1E7             BNE.N    ??HAL_OSPI_Receive_4
   \       0xA4   0xE7FF             B.N      ??HAL_OSPI_Receive_8
   1265          
   1266                if (status == HAL_OK)
   \                     ??HAL_OSPI_Receive_6: (+1)
   \                     ??HAL_OSPI_Receive_8: (+1)
   \       0xA6   0x0001             MOVS     R1,R0
   \       0xA8   0xB2C9             UXTB     R1,R1
   \       0xAA   0x2900             CMP      R1,#+0
   \       0xAC   0xD113             BNE.N    ??HAL_OSPI_Receive_1
   1267                {
   1268                  /* Wait till transfer complete flag is set to go back in idle state */
   1269                  status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, Timeout);
   \       0xAE   0x9600             STR      R6,[SP, #+0]
   \       0xB0   0x003B             MOVS     R3,R7
   \       0xB2   0x2201             MOVS     R2,#+1
   \       0xB4   0x2102             MOVS     R1,#+2
   \       0xB6   0x0028             MOVS     R0,R5
   \       0xB8   0x.... 0x....      BL       OSPI_WaitFlagStateUntilTimeout
   1270          
   1271                  if (status == HAL_OK)
   \       0xBC   0x0001             MOVS     R1,R0
   \       0xBE   0xB2C9             UXTB     R1,R1
   \       0xC0   0x2900             CMP      R1,#+0
   \       0xC2   0xD108             BNE.N    ??HAL_OSPI_Receive_1
   1272                  {
   1273                    /* Clear transfer complete flag */
   1274                    __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
   \       0xC4   0x2102             MOVS     R1,#+2
   \       0xC6   0x682A             LDR      R2,[R5, #+0]
   \       0xC8   0x6251             STR      R1,[R2, #+36]
   1275          
   1276                    /* Update state */
   1277                    hospi->State = HAL_OSPI_STATE_READY;
   \       0xCA   0x2102             MOVS     R1,#+2
   \       0xCC   0x6569             STR      R1,[R5, #+84]
   \       0xCE   0xE002             B.N      ??HAL_OSPI_Receive_1
   1278                  }
   1279                }
   1280              }
   1281              else
   1282              {
   1283                status = HAL_ERROR;
   \                     ??HAL_OSPI_Receive_2: (+1)
   \       0xD0   0x2001             MOVS     R0,#+1
   1284                hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
   \       0xD2   0x2110             MOVS     R1,#+16
   \       0xD4   0x65A9             STR      R1,[R5, #+88]
   1285              }
   1286            }
   1287          
   1288            /* Return function status */
   1289            return status;
   \                     ??HAL_OSPI_Receive_1: (+1)
   \       0xD6   0xB2C0             UXTB     R0,R0
   \       0xD8   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   1290          }
   1291          
   1292          /**
   1293            * @brief  Send an amount of data in non-blocking mode with interrupt.
   1294            * @param  hospi : OSPI handle
   1295            * @param  pData : pointer to data buffer
   1296            * @note   This function is used only in Indirect Write Mode
   1297            * @retval HAL status
   1298            */

   \                                 In section .text, align 2, keep-with-next
   1299          HAL_StatusTypeDef HAL_OSPI_Transmit_IT(OSPI_HandleTypeDef *hospi, uint8_t *pData)
   1300          {
   1301            HAL_StatusTypeDef status = HAL_OK;
   \                     HAL_OSPI_Transmit_IT: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   1302          
   1303            /* Check the data pointer allocation */
   1304            if (pData == NULL)
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD103             BNE.N    ??HAL_OSPI_Transmit_IT_0
   1305            {
   1306              status = HAL_ERROR;
   \        0x6   0x2201             MOVS     R2,#+1
   1307              hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
   \        0x8   0x2108             MOVS     R1,#+8
   \        0xA   0x6581             STR      R1,[R0, #+88]
   \        0xC   0xE01E             B.N      ??HAL_OSPI_Transmit_IT_1
   1308            }
   1309            else
   1310            {
   1311              /* Check the state */
   1312              if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
   \                     ??HAL_OSPI_Transmit_IT_0: (+1)
   \        0xE   0x6D43             LDR      R3,[R0, #+84]
   \       0x10   0x2B04             CMP      R3,#+4
   \       0x12   0xD118             BNE.N    ??HAL_OSPI_Transmit_IT_2
   1313              {
   1314                /* Configure counters and size */
   1315                hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
   \       0x14   0x6803             LDR      R3,[R0, #+0]
   \       0x16   0x6C1B             LDR      R3,[R3, #+64]
   \       0x18   0x1C5B             ADDS     R3,R3,#+1
   \       0x1A   0x64C3             STR      R3,[R0, #+76]
   1316                hospi->XferSize  = hospi->XferCount;
   \       0x1C   0x6CC3             LDR      R3,[R0, #+76]
   \       0x1E   0x6483             STR      R3,[R0, #+72]
   1317                hospi->pBuffPtr  = pData;
   \       0x20   0x6441             STR      R1,[R0, #+68]
   1318          
   1319                /* Configure CR register with functional mode as indirect write */
   1320                MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, OSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
   \       0x22   0x6801             LDR      R1,[R0, #+0]
   \       0x24   0x6809             LDR      R1,[R1, #+0]
   \       0x26   0xF031 0x5140      BICS     R1,R1,#0x30000000
   \       0x2A   0x6803             LDR      R3,[R0, #+0]
   \       0x2C   0x6019             STR      R1,[R3, #+0]
   1321          
   1322                /* Clear flags related to interrupt */
   1323                __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TE | HAL_OSPI_FLAG_TC);
   \       0x2E   0x2103             MOVS     R1,#+3
   \       0x30   0x6803             LDR      R3,[R0, #+0]
   \       0x32   0x6259             STR      R1,[R3, #+36]
   1324          
   1325                /* Update the state */
   1326                hospi->State = HAL_OSPI_STATE_BUSY_TX;
   \       0x34   0x2118             MOVS     R1,#+24
   \       0x36   0x6541             STR      R1,[R0, #+84]
   1327          
   1328                /* Enable the transfer complete, fifo threshold and transfer error interrupts */
   1329                __HAL_OSPI_ENABLE_IT(hospi, HAL_OSPI_IT_TC | HAL_OSPI_IT_FT | HAL_OSPI_IT_TE);
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0x6809             LDR      R1,[R1, #+0]
   \       0x3C   0xF451 0x21E0      ORRS     R1,R1,#0x70000
   \       0x40   0x6800             LDR      R0,[R0, #+0]
   \       0x42   0x6001             STR      R1,[R0, #+0]
   \       0x44   0xE002             B.N      ??HAL_OSPI_Transmit_IT_1
   1330              }
   1331              else
   1332              {
   1333                status = HAL_ERROR;
   \                     ??HAL_OSPI_Transmit_IT_2: (+1)
   \       0x46   0x2201             MOVS     R2,#+1
   1334                hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
   \       0x48   0x2110             MOVS     R1,#+16
   \       0x4A   0x6581             STR      R1,[R0, #+88]
   1335              }
   1336            }
   1337          
   1338            /* Return function status */
   1339            return status;
   \                     ??HAL_OSPI_Transmit_IT_1: (+1)
   \       0x4C   0x0010             MOVS     R0,R2
   \       0x4E   0xB2C0             UXTB     R0,R0
   \       0x50   0x4770             BX       LR
   1340          }
   1341          
   1342          /**
   1343            * @brief  Receive an amount of data in non-blocking mode with interrupt.
   1344            * @param  hospi : OSPI handle
   1345            * @param  pData : pointer to data buffer
   1346            * @note   This function is used only in Indirect Read Mode
   1347            * @retval HAL status
   1348            */

   \                                 In section .text, align 2, keep-with-next
   1349          HAL_StatusTypeDef HAL_OSPI_Receive_IT(OSPI_HandleTypeDef *hospi, uint8_t *pData)
   1350          {
   \                     HAL_OSPI_Receive_IT: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   1351            HAL_StatusTypeDef status = HAL_OK;
   \        0x2   0x2200             MOVS     R2,#+0
   1352            uint32_t addr_reg = hospi->Instance->AR;
   \        0x4   0x6803             LDR      R3,[R0, #+0]
   \        0x6   0x6C9B             LDR      R3,[R3, #+72]
   1353            uint32_t ir_reg = hospi->Instance->IR;
   \        0x8   0x6804             LDR      R4,[R0, #+0]
   \        0xA   0xF8D4 0x4110      LDR      R4,[R4, #+272]
   1354          
   1355            /* Check the data pointer allocation */
   1356            if (pData == NULL)
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD103             BNE.N    ??HAL_OSPI_Receive_IT_0
   1357            {
   1358              status = HAL_ERROR;
   \       0x12   0x2201             MOVS     R2,#+1
   1359              hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
   \       0x14   0x2108             MOVS     R1,#+8
   \       0x16   0x6581             STR      R1,[R0, #+88]
   \       0x18   0xE032             B.N      ??HAL_OSPI_Receive_IT_1
   1360            }
   1361            else
   1362            {
   1363              /* Check the state */
   1364              if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
   \                     ??HAL_OSPI_Receive_IT_0: (+1)
   \       0x1A   0x6D45             LDR      R5,[R0, #+84]
   \       0x1C   0x2D04             CMP      R5,#+4
   \       0x1E   0xD12C             BNE.N    ??HAL_OSPI_Receive_IT_2
   1365              {
   1366                /* Configure counters and size */
   1367                hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
   \       0x20   0x6805             LDR      R5,[R0, #+0]
   \       0x22   0x6C2D             LDR      R5,[R5, #+64]
   \       0x24   0x1C6D             ADDS     R5,R5,#+1
   \       0x26   0x64C5             STR      R5,[R0, #+76]
   1368                hospi->XferSize  = hospi->XferCount;
   \       0x28   0x6CC5             LDR      R5,[R0, #+76]
   \       0x2A   0x6485             STR      R5,[R0, #+72]
   1369                hospi->pBuffPtr  = pData;
   \       0x2C   0x6441             STR      R1,[R0, #+68]
   1370          
   1371                /* Configure CR register with functional mode as indirect read */
   1372                MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, OSPI_FUNCTIONAL_MODE_INDIRECT_READ);
   \       0x2E   0x2101             MOVS     R1,#+1
   \       0x30   0x6805             LDR      R5,[R0, #+0]
   \       0x32   0x682D             LDR      R5,[R5, #+0]
   \       0x34   0xF361 0x751D      BFI      R5,R1,#+28,#+2
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0x600D             STR      R5,[R1, #+0]
   1373          
   1374                /* Clear flags related to interrupt */
   1375                __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TE | HAL_OSPI_FLAG_TC);
   \       0x3C   0x2103             MOVS     R1,#+3
   \       0x3E   0x6805             LDR      R5,[R0, #+0]
   \       0x40   0x6269             STR      R1,[R5, #+36]
   1376          
   1377                /* Update the state */
   1378                hospi->State = HAL_OSPI_STATE_BUSY_RX;
   \       0x42   0x2128             MOVS     R1,#+40
   \       0x44   0x6541             STR      R1,[R0, #+84]
   1379          
   1380                /* Enable the transfer complete, fifo threshold and transfer error interrupts */
   1381                __HAL_OSPI_ENABLE_IT(hospi, HAL_OSPI_IT_TC | HAL_OSPI_IT_FT | HAL_OSPI_IT_TE);
   \       0x46   0x6801             LDR      R1,[R0, #+0]
   \       0x48   0x6809             LDR      R1,[R1, #+0]
   \       0x4A   0xF451 0x21E0      ORRS     R1,R1,#0x70000
   \       0x4E   0x6805             LDR      R5,[R0, #+0]
   \       0x50   0x6029             STR      R1,[R5, #+0]
   1382          
   1383                /* Trig the transfer by re-writing address or instruction register */
   1384                if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
   \       0x52   0x68C1             LDR      R1,[R0, #+12]
   \       0x54   0xF1B1 0x6F80      CMP      R1,#+67108864
   \       0x58   0xD102             BNE.N    ??HAL_OSPI_Receive_IT_3
   1385                {
   1386                  WRITE_REG(hospi->Instance->AR, addr_reg);
   \       0x5A   0x6800             LDR      R0,[R0, #+0]
   \       0x5C   0x6483             STR      R3,[R0, #+72]
   \       0x5E   0xE00F             B.N      ??HAL_OSPI_Receive_IT_1
   1387                }
   1388                else
   1389                {
   1390                  if (READ_BIT(hospi->Instance->CCR, OCTOSPI_CCR_ADMODE) != HAL_OSPI_ADDRESS_NONE)
   \                     ??HAL_OSPI_Receive_IT_3: (+1)
   \       0x60   0x6801             LDR      R1,[R0, #+0]
   \       0x62   0xF8D1 0x1100      LDR      R1,[R1, #+256]
   \       0x66   0xF411 0x6FE0      TST      R1,#0x700
   \       0x6A   0xD002             BEQ.N    ??HAL_OSPI_Receive_IT_4
   1391                  {
   1392                    WRITE_REG(hospi->Instance->AR, addr_reg);
   \       0x6C   0x6800             LDR      R0,[R0, #+0]
   \       0x6E   0x6483             STR      R3,[R0, #+72]
   \       0x70   0xE006             B.N      ??HAL_OSPI_Receive_IT_1
   1393                  }
   1394                  else
   1395                  {
   1396                    WRITE_REG(hospi->Instance->IR, ir_reg);
   \                     ??HAL_OSPI_Receive_IT_4: (+1)
   \       0x72   0x6800             LDR      R0,[R0, #+0]
   \       0x74   0xF8C0 0x4110      STR      R4,[R0, #+272]
   \       0x78   0xE002             B.N      ??HAL_OSPI_Receive_IT_1
   1397                  }
   1398                }
   1399              }
   1400              else
   1401              {
   1402                status = HAL_ERROR;
   \                     ??HAL_OSPI_Receive_IT_2: (+1)
   \       0x7A   0x2201             MOVS     R2,#+1
   1403                hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
   \       0x7C   0x2110             MOVS     R1,#+16
   \       0x7E   0x6581             STR      R1,[R0, #+88]
   1404              }
   1405            }
   1406          
   1407            /* Return function status */
   1408            return status;
   \                     ??HAL_OSPI_Receive_IT_1: (+1)
   \       0x80   0x0010             MOVS     R0,R2
   \       0x82   0xB2C0             UXTB     R0,R0
   \       0x84   0xBC30             POP      {R4,R5}
   \       0x86   0x4770             BX       LR
   1409          }
   1410          
   1411          /**
   1412            * @brief  Send an amount of data in non-blocking mode with DMA.
   1413            * @param  hospi : OSPI handle
   1414            * @param  pData : pointer to data buffer
   1415            * @note   This function is used only in Indirect Write Mode
   1416            * @note   If DMA peripheral access is configured as halfword, the number
   1417            *         of data and the fifo threshold should be aligned on halfword
   1418            * @note   If DMA peripheral access is configured as word, the number
   1419            *         of data and the fifo threshold should be aligned on word
   1420            * @retval HAL status
   1421            */

   \                                 In section .text, align 2, keep-with-next
   1422          HAL_StatusTypeDef HAL_OSPI_Transmit_DMA(OSPI_HandleTypeDef *hospi, uint8_t *pData)
   1423          {
   \                     HAL_OSPI_Transmit_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   1424            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2400             MOVS     R4,#+0
   1425            uint32_t data_size = hospi->Instance->DLR + 1U;
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0x6C00             LDR      R0,[R0, #+64]
   \        0xA   0x1C40             ADDS     R0,R0,#+1
   1426          
   1427            /* Check the data pointer allocation */
   1428            if (pData == NULL)
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD103             BNE.N    ??HAL_OSPI_Transmit_DMA_0
   1429            {
   1430              status = HAL_ERROR;
   \       0x10   0x2401             MOVS     R4,#+1
   1431              hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
   \       0x12   0x2008             MOVS     R0,#+8
   \       0x14   0x65A8             STR      R0,[R5, #+88]
   \       0x16   0xE076             B.N      ??HAL_OSPI_Transmit_DMA_1
   1432            }
   1433            else
   1434            {
   1435              /* Check the state */
   1436              if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
   \                     ??HAL_OSPI_Transmit_DMA_0: (+1)
   \       0x18   0x6D6A             LDR      R2,[R5, #+84]
   \       0x1A   0x2A04             CMP      R2,#+4
   \       0x1C   0xD170             BNE.N    ??HAL_OSPI_Transmit_DMA_2
   1437              {
   1438                hospi->XferCount = data_size;
   \       0x1E   0x64E8             STR      R0,[R5, #+76]
   1439          
   1440                {
   1441                  hospi->XferSize = hospi->XferCount;
   \       0x20   0x6CE8             LDR      R0,[R5, #+76]
   \       0x22   0x64A8             STR      R0,[R5, #+72]
   1442                  hospi->pBuffPtr = pData;
   \       0x24   0x6469             STR      R1,[R5, #+68]
   1443          
   1444                  /* Configure CR register with functional mode as indirect write */
   1445                  MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, OSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0xF030 0x5040      BICS     R0,R0,#0x30000000
   \       0x2E   0x682A             LDR      R2,[R5, #+0]
   \       0x30   0x6010             STR      R0,[R2, #+0]
   1446          
   1447                  /* Clear flags related to interrupt */
   1448                  __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TE | HAL_OSPI_FLAG_TC);
   \       0x32   0x2003             MOVS     R0,#+3
   \       0x34   0x682A             LDR      R2,[R5, #+0]
   \       0x36   0x6250             STR      R0,[R2, #+36]
   1449          
   1450                  /* Update the state */
   1451                  hospi->State = HAL_OSPI_STATE_BUSY_TX;
   \       0x38   0x2018             MOVS     R0,#+24
   \       0x3A   0x6568             STR      R0,[R5, #+84]
   1452          
   1453                  /* Set the MDMA transfer complete callback */
   1454                  hospi->hmdma->XferCpltCallback = OSPI_DMACplt;
   \       0x3C   0x.... 0x....      ADR.W    R0,OSPI_DMACplt
   \       0x40   0x6D2A             LDR      R2,[R5, #+80]
   \       0x42   0x6450             STR      R0,[R2, #+68]
   1455          
   1456                  /* Set the MDMA error callback */
   1457                  hospi->hmdma->XferErrorCallback = OSPI_DMAError;
   \       0x44   0x.... 0x....      ADR.W    R0,OSPI_DMAError
   \       0x48   0x6D2A             LDR      R2,[R5, #+80]
   \       0x4A   0x6550             STR      R0,[R2, #+84]
   1458          
   1459                  /* Clear the MDMA abort callback */
   1460                  hospi->hmdma->XferAbortCallback = NULL;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x6D2A             LDR      R2,[R5, #+80]
   \       0x50   0x6590             STR      R0,[R2, #+88]
   1461          
   1462                  /* In Transmit mode , the MDMA destination is the OSPI DR register : Force the MDMA Destination Increment to disable */
   1463                  MODIFY_REG(hospi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) ,MDMA_DEST_INC_DISABLE);
   \       0x52   0x6D28             LDR      R0,[R5, #+80]
   \       0x54   0x6800             LDR      R0,[R0, #+0]
   \       0x56   0x6902             LDR      R2,[R0, #+16]
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable5
   \       0x5C   0x4002             ANDS     R2,R0,R2
   \       0x5E   0x6D28             LDR      R0,[R5, #+80]
   \       0x60   0x6800             LDR      R0,[R0, #+0]
   \       0x62   0x6102             STR      R2,[R0, #+16]
   1464          
   1465                  /* Update MDMA configuration with the correct SourceInc field for Write operation */
   1466                  if (hospi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_BYTE)
   \       0x64   0x6D28             LDR      R0,[R5, #+80]
   \       0x66   0x69C0             LDR      R0,[R0, #+28]
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD10B             BNE.N    ??HAL_OSPI_Transmit_DMA_3
   1467                  {
   1468                    MODIFY_REG(hospi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_BYTE);
   \       0x6C   0x6D28             LDR      R0,[R5, #+80]
   \       0x6E   0x6800             LDR      R0,[R0, #+0]
   \       0x70   0x6902             LDR      R2,[R0, #+16]
   \       0x72   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \       0x76   0x4002             ANDS     R2,R0,R2
   \       0x78   0xF052 0x0202      ORRS     R2,R2,#0x2
   \       0x7C   0x6D28             LDR      R0,[R5, #+80]
   \       0x7E   0x6800             LDR      R0,[R0, #+0]
   \       0x80   0x6102             STR      R2,[R0, #+16]
   \       0x82   0xE025             B.N      ??HAL_OSPI_Transmit_DMA_4
   1469                  }
   1470                  else if (hospi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_HALFWORD)
   \                     ??HAL_OSPI_Transmit_DMA_3: (+1)
   \       0x84   0x6D28             LDR      R0,[R5, #+80]
   \       0x86   0x69C0             LDR      R0,[R0, #+28]
   \       0x88   0x2810             CMP      R0,#+16
   \       0x8A   0xD10B             BNE.N    ??HAL_OSPI_Transmit_DMA_5
   1471                  {
   1472                    MODIFY_REG(hospi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_HALFWORD);
   \       0x8C   0x6D28             LDR      R0,[R5, #+80]
   \       0x8E   0x6800             LDR      R0,[R0, #+0]
   \       0x90   0x6902             LDR      R2,[R0, #+16]
   \       0x92   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \       0x96   0x4002             ANDS     R2,R0,R2
   \       0x98   0xF452 0x7281      ORRS     R2,R2,#0x102
   \       0x9C   0x6D28             LDR      R0,[R5, #+80]
   \       0x9E   0x6800             LDR      R0,[R0, #+0]
   \       0xA0   0x6102             STR      R2,[R0, #+16]
   \       0xA2   0xE015             B.N      ??HAL_OSPI_Transmit_DMA_4
   1473                  }
   1474                  else if (hospi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_WORD)
   \                     ??HAL_OSPI_Transmit_DMA_5: (+1)
   \       0xA4   0x6D28             LDR      R0,[R5, #+80]
   \       0xA6   0x69C0             LDR      R0,[R0, #+28]
   \       0xA8   0x2820             CMP      R0,#+32
   \       0xAA   0xD10C             BNE.N    ??HAL_OSPI_Transmit_DMA_6
   1475                  {
   1476                    MODIFY_REG(hospi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_WORD);
   \       0xAC   0x6D28             LDR      R0,[R5, #+80]
   \       0xAE   0x6800             LDR      R0,[R0, #+0]
   \       0xB0   0x6902             LDR      R2,[R0, #+16]
   \       0xB2   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \       0xB6   0x4002             ANDS     R2,R0,R2
   \       0xB8   0xF240 0x2002      MOVW     R0,#+514
   \       0xBC   0x4302             ORRS     R2,R0,R2
   \       0xBE   0x6D28             LDR      R0,[R5, #+80]
   \       0xC0   0x6800             LDR      R0,[R0, #+0]
   \       0xC2   0x6102             STR      R2,[R0, #+16]
   \       0xC4   0xE004             B.N      ??HAL_OSPI_Transmit_DMA_4
   1477                  }
   1478                  else
   1479                  {
   1480                    /* in case of incorrect source data size */
   1481                    hospi->ErrorCode |= HAL_OSPI_ERROR_DMA;
   \                     ??HAL_OSPI_Transmit_DMA_6: (+1)
   \       0xC6   0x6DA8             LDR      R0,[R5, #+88]
   \       0xC8   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0xCC   0x65A8             STR      R0,[R5, #+88]
   1482                    status = HAL_ERROR;
   \       0xCE   0x2401             MOVS     R4,#+1
   1483                  }
   1484          
   1485                  /* Enable the transmit MDMA Channel */
   1486                  if (HAL_MDMA_Start_IT(hospi->hmdma, (uint32_t)pData, (uint32_t)&hospi->Instance->DR, hospi->XferSize,1) == HAL_OK)
   \                     ??HAL_OSPI_Transmit_DMA_4: (+1)
   \       0xD0   0x2001             MOVS     R0,#+1
   \       0xD2   0x9000             STR      R0,[SP, #+0]
   \       0xD4   0x6CAB             LDR      R3,[R5, #+72]
   \       0xD6   0x6828             LDR      R0,[R5, #+0]
   \       0xD8   0xF110 0x0250      ADDS     R2,R0,#+80
   \       0xDC   0x6D28             LDR      R0,[R5, #+80]
   \       0xDE   0x.... 0x....      BL       HAL_MDMA_Start_IT
   \       0xE2   0x2800             CMP      R0,#+0
   \       0xE4   0xD106             BNE.N    ??HAL_OSPI_Transmit_DMA_7
   1487                      {
   1488                        /* Enable the transfer error interrupt */
   1489                        __HAL_OSPI_ENABLE_IT(hospi, HAL_OSPI_IT_TE);
   \       0xE6   0x6828             LDR      R0,[R5, #+0]
   \       0xE8   0x6800             LDR      R0,[R0, #+0]
   \       0xEA   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \       0xEE   0x6829             LDR      R1,[R5, #+0]
   \       0xF0   0x6008             STR      R0,[R1, #+0]
   \       0xF2   0xE008             B.N      ??HAL_OSPI_Transmit_DMA_1
   1490          
   1491                        /* Enable the MDMA transfer by setting the DMAEN bit not needed for MDMA*/
   1492                      }
   1493                      else
   1494                      {
   1495                        status = HAL_ERROR;
   \                     ??HAL_OSPI_Transmit_DMA_7: (+1)
   \       0xF4   0x2401             MOVS     R4,#+1
   1496                        hospi->ErrorCode = HAL_OSPI_ERROR_DMA;
   \       0xF6   0x2004             MOVS     R0,#+4
   \       0xF8   0x65A8             STR      R0,[R5, #+88]
   1497                        hospi->State = HAL_OSPI_STATE_READY;
   \       0xFA   0x2002             MOVS     R0,#+2
   \       0xFC   0x6568             STR      R0,[R5, #+84]
   \       0xFE   0xE002             B.N      ??HAL_OSPI_Transmit_DMA_1
   1498                      }
   1499                }
   1500              }
   1501              else
   1502              {
   1503                status = HAL_ERROR;
   \                     ??HAL_OSPI_Transmit_DMA_2: (+1)
   \      0x100   0x2401             MOVS     R4,#+1
   1504                hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
   \      0x102   0x2010             MOVS     R0,#+16
   \      0x104   0x65A8             STR      R0,[R5, #+88]
   1505              }
   1506            }
   1507          
   1508            /* Return function status */
   1509            return status;
   \                     ??HAL_OSPI_Transmit_DMA_1: (+1)
   \      0x106   0x0020             MOVS     R0,R4
   \      0x108   0xB2C0             UXTB     R0,R0
   \      0x10A   0xBD32             POP      {R1,R4,R5,PC}
   1510          }
   1511          
   1512          /**
   1513            * @brief  Receive an amount of data in non-blocking mode with DMA.
   1514            * @param  hospi : OSPI handle
   1515            * @param  pData : pointer to data buffer.
   1516            * @note   This function is used only in Indirect Read Mode
   1517            * @note   If DMA peripheral access is configured as halfword, the number
   1518            *         of data and the fifo threshold should be aligned on halfword
   1519            * @note   If DMA peripheral access is configured as word, the number
   1520            *         of data and the fifo threshold should be aligned on word
   1521            * @retval HAL status
   1522            */

   \                                 In section .text, align 2, keep-with-next
   1523          HAL_StatusTypeDef HAL_OSPI_Receive_DMA(OSPI_HandleTypeDef *hospi, uint8_t *pData)
   1524          {
   \                     HAL_OSPI_Receive_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000A             MOVS     R2,R1
   1525            HAL_StatusTypeDef status = HAL_OK;
   \        0x6   0x2400             MOVS     R4,#+0
   1526            uint32_t data_size = hospi->Instance->DLR + 1U;
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x6C00             LDR      R0,[R0, #+64]
   \        0xC   0x1C40             ADDS     R0,R0,#+1
   1527            uint32_t addr_reg = hospi->Instance->AR;
   \        0xE   0x6829             LDR      R1,[R5, #+0]
   \       0x10   0x6C8E             LDR      R6,[R1, #+72]
   1528            uint32_t ir_reg = hospi->Instance->IR;
   \       0x12   0x6829             LDR      R1,[R5, #+0]
   \       0x14   0xF8D1 0x7110      LDR      R7,[R1, #+272]
   1529            /* Check the data pointer allocation */
   1530            if (pData == NULL)
   \       0x18   0x2A00             CMP      R2,#+0
   \       0x1A   0xD103             BNE.N    ??HAL_OSPI_Receive_DMA_0
   1531            {
   1532              status = HAL_ERROR;
   \       0x1C   0x2401             MOVS     R4,#+1
   1533              hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
   \       0x1E   0x2008             MOVS     R0,#+8
   \       0x20   0x65A8             STR      R0,[R5, #+88]
   \       0x22   0xE08B             B.N      ??HAL_OSPI_Receive_DMA_1
   1534            }
   1535            else
   1536            {
   1537              /* Check the state */
   1538              if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
   \                     ??HAL_OSPI_Receive_DMA_0: (+1)
   \       0x24   0x6D69             LDR      R1,[R5, #+84]
   \       0x26   0x2904             CMP      R1,#+4
   \       0x28   0xF040 0x8085      BNE.W    ??HAL_OSPI_Receive_DMA_2
   1539              {
   1540                hospi->XferCount = data_size;
   \       0x2C   0x64E8             STR      R0,[R5, #+76]
   1541          
   1542                {
   1543                  hospi->XferSize  = hospi->XferCount;
   \       0x2E   0x6CE8             LDR      R0,[R5, #+76]
   \       0x30   0x64A8             STR      R0,[R5, #+72]
   1544                  hospi->pBuffPtr  = pData;
   \       0x32   0x646A             STR      R2,[R5, #+68]
   1545          
   1546                  /* Configure CR register with functional mode as indirect read */
   1547                  MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, OSPI_FUNCTIONAL_MODE_INDIRECT_READ);
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0x6829             LDR      R1,[R5, #+0]
   \       0x38   0x6809             LDR      R1,[R1, #+0]
   \       0x3A   0xF360 0x711D      BFI      R1,R0,#+28,#+2
   \       0x3E   0x6828             LDR      R0,[R5, #+0]
   \       0x40   0x6001             STR      R1,[R0, #+0]
   1548          
   1549                  /* Clear flags related to interrupt */
   1550                  __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TE | HAL_OSPI_FLAG_TC);
   \       0x42   0x2003             MOVS     R0,#+3
   \       0x44   0x6829             LDR      R1,[R5, #+0]
   \       0x46   0x6248             STR      R0,[R1, #+36]
   1551          
   1552                  /* Update the state */
   1553                  hospi->State = HAL_OSPI_STATE_BUSY_RX;
   \       0x48   0x2028             MOVS     R0,#+40
   \       0x4A   0x6568             STR      R0,[R5, #+84]
   1554          
   1555                  /* Set the DMA transfer complete callback */
   1556                  hospi->hmdma->XferCpltCallback = OSPI_DMACplt;
   \       0x4C   0x.... 0x....      ADR.W    R0,OSPI_DMACplt
   \       0x50   0x6D29             LDR      R1,[R5, #+80]
   \       0x52   0x6448             STR      R0,[R1, #+68]
   1557          
   1558                  /* Set the DMA error callback */
   1559                  hospi->hmdma->XferErrorCallback = OSPI_DMAError;
   \       0x54   0x.... 0x....      ADR.W    R0,OSPI_DMAError
   \       0x58   0x6D29             LDR      R1,[R5, #+80]
   \       0x5A   0x6548             STR      R0,[R1, #+84]
   1560          
   1561                  /* Clear the DMA abort callback */
   1562                  hospi->hmdma->XferAbortCallback = NULL;
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x6D29             LDR      R1,[R5, #+80]
   \       0x60   0x6588             STR      R0,[R1, #+88]
   1563          
   1564                  /* In Receive mode , the MDMA source is the OSPI DR register : Force the MDMA Source Increment to disable */
   1565                  MODIFY_REG(hospi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_DISABLE);
   \       0x62   0x6D28             LDR      R0,[R5, #+80]
   \       0x64   0x6800             LDR      R0,[R0, #+0]
   \       0x66   0x6901             LDR      R1,[R0, #+16]
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \       0x6C   0x4001             ANDS     R1,R0,R1
   \       0x6E   0x6D28             LDR      R0,[R5, #+80]
   \       0x70   0x6800             LDR      R0,[R0, #+0]
   \       0x72   0x6101             STR      R1,[R0, #+16]
   1566          
   1567                  /* Update MDMA configuration with the correct DestinationInc field for read operation */
   1568                  if (hospi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_BYTE)
   \       0x74   0x6D28             LDR      R0,[R5, #+80]
   \       0x76   0x6A00             LDR      R0,[R0, #+32]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD10B             BNE.N    ??HAL_OSPI_Receive_DMA_3
   1569                  {
   1570                    MODIFY_REG(hospi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_BYTE);
   \       0x7C   0x6D28             LDR      R0,[R5, #+80]
   \       0x7E   0x6800             LDR      R0,[R0, #+0]
   \       0x80   0x6901             LDR      R1,[R0, #+16]
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable5
   \       0x86   0x4001             ANDS     R1,R0,R1
   \       0x88   0xF051 0x0108      ORRS     R1,R1,#0x8
   \       0x8C   0x6D28             LDR      R0,[R5, #+80]
   \       0x8E   0x6800             LDR      R0,[R0, #+0]
   \       0x90   0x6101             STR      R1,[R0, #+16]
   \       0x92   0xE025             B.N      ??HAL_OSPI_Receive_DMA_4
   1571                  }
   1572                  else if (hospi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_HALFWORD)
   \                     ??HAL_OSPI_Receive_DMA_3: (+1)
   \       0x94   0x6D28             LDR      R0,[R5, #+80]
   \       0x96   0x6A00             LDR      R0,[R0, #+32]
   \       0x98   0x2840             CMP      R0,#+64
   \       0x9A   0xD10B             BNE.N    ??HAL_OSPI_Receive_DMA_5
   1573                  {
   1574                    MODIFY_REG(hospi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_HALFWORD);
   \       0x9C   0x6D28             LDR      R0,[R5, #+80]
   \       0x9E   0x6800             LDR      R0,[R0, #+0]
   \       0xA0   0x6901             LDR      R1,[R0, #+16]
   \       0xA2   0x.... 0x....      LDR.W    R0,??DataTable5
   \       0xA6   0x4001             ANDS     R1,R0,R1
   \       0xA8   0xF451 0x6181      ORRS     R1,R1,#0x408
   \       0xAC   0x6D28             LDR      R0,[R5, #+80]
   \       0xAE   0x6800             LDR      R0,[R0, #+0]
   \       0xB0   0x6101             STR      R1,[R0, #+16]
   \       0xB2   0xE015             B.N      ??HAL_OSPI_Receive_DMA_4
   1575                  }
   1576                  else if (hospi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_WORD)
   \                     ??HAL_OSPI_Receive_DMA_5: (+1)
   \       0xB4   0x6D28             LDR      R0,[R5, #+80]
   \       0xB6   0x6A00             LDR      R0,[R0, #+32]
   \       0xB8   0x2880             CMP      R0,#+128
   \       0xBA   0xD10C             BNE.N    ??HAL_OSPI_Receive_DMA_6
   1577                  {
   1578                    MODIFY_REG(hospi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_WORD);
   \       0xBC   0x6D28             LDR      R0,[R5, #+80]
   \       0xBE   0x6800             LDR      R0,[R0, #+0]
   \       0xC0   0x6901             LDR      R1,[R0, #+16]
   \       0xC2   0x.... 0x....      LDR.W    R0,??DataTable5
   \       0xC6   0x4001             ANDS     R1,R0,R1
   \       0xC8   0xF640 0x0008      MOVW     R0,#+2056
   \       0xCC   0x4301             ORRS     R1,R0,R1
   \       0xCE   0x6D28             LDR      R0,[R5, #+80]
   \       0xD0   0x6800             LDR      R0,[R0, #+0]
   \       0xD2   0x6101             STR      R1,[R0, #+16]
   \       0xD4   0xE004             B.N      ??HAL_OSPI_Receive_DMA_4
   1579                  }
   1580                  else
   1581                  {
   1582                    /* in case of incorrect destination data size */
   1583                    hospi->ErrorCode |= HAL_OSPI_ERROR_DMA;
   \                     ??HAL_OSPI_Receive_DMA_6: (+1)
   \       0xD6   0x6DA8             LDR      R0,[R5, #+88]
   \       0xD8   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0xDC   0x65A8             STR      R0,[R5, #+88]
   1584                    status = HAL_ERROR;
   \       0xDE   0x2401             MOVS     R4,#+1
   1585                  }
   1586          
   1587                  /* Enable the transmit MDMA Channel */
   1588                  if (HAL_MDMA_Start_IT(hospi->hmdma, (uint32_t)&hospi->Instance->DR, (uint32_t)pData, hospi->XferSize, 1) == HAL_OK)
   \                     ??HAL_OSPI_Receive_DMA_4: (+1)
   \       0xE0   0x2001             MOVS     R0,#+1
   \       0xE2   0x9000             STR      R0,[SP, #+0]
   \       0xE4   0x6CAB             LDR      R3,[R5, #+72]
   \       0xE6   0x6828             LDR      R0,[R5, #+0]
   \       0xE8   0xF110 0x0150      ADDS     R1,R0,#+80
   \       0xEC   0x6D28             LDR      R0,[R5, #+80]
   \       0xEE   0x.... 0x....      BL       HAL_MDMA_Start_IT
   \       0xF2   0x2800             CMP      R0,#+0
   \       0xF4   0xD119             BNE.N    ??HAL_OSPI_Receive_DMA_7
   1589                    {
   1590                      /* Enable the transfer error interrupt */
   1591                      __HAL_OSPI_ENABLE_IT(hospi, HAL_OSPI_IT_TE);
   \       0xF6   0x6828             LDR      R0,[R5, #+0]
   \       0xF8   0x6800             LDR      R0,[R0, #+0]
   \       0xFA   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \       0xFE   0x6829             LDR      R1,[R5, #+0]
   \      0x100   0x6008             STR      R0,[R1, #+0]
   1592          
   1593                      /* Trig the transfer by re-writing address or instruction register */
   1594                      if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
   \      0x102   0x68E8             LDR      R0,[R5, #+12]
   \      0x104   0xF1B0 0x6F80      CMP      R0,#+67108864
   \      0x108   0xD102             BNE.N    ??HAL_OSPI_Receive_DMA_8
   1595                      {
   1596                        WRITE_REG(hospi->Instance->AR, addr_reg);
   \      0x10A   0x6828             LDR      R0,[R5, #+0]
   \      0x10C   0x6486             STR      R6,[R0, #+72]
   \      0x10E   0xE015             B.N      ??HAL_OSPI_Receive_DMA_1
   1597                      }
   1598                      else
   1599                      {
   1600                        if (READ_BIT(hospi->Instance->CCR, OCTOSPI_CCR_ADMODE) != HAL_OSPI_ADDRESS_NONE)
   \                     ??HAL_OSPI_Receive_DMA_8: (+1)
   \      0x110   0x6828             LDR      R0,[R5, #+0]
   \      0x112   0xF8D0 0x0100      LDR      R0,[R0, #+256]
   \      0x116   0xF410 0x6FE0      TST      R0,#0x700
   \      0x11A   0xD002             BEQ.N    ??HAL_OSPI_Receive_DMA_9
   1601                        {
   1602                          WRITE_REG(hospi->Instance->AR, addr_reg);
   \      0x11C   0x6828             LDR      R0,[R5, #+0]
   \      0x11E   0x6486             STR      R6,[R0, #+72]
   \      0x120   0xE00C             B.N      ??HAL_OSPI_Receive_DMA_1
   1603                        }
   1604                        else
   1605                        {
   1606                          WRITE_REG(hospi->Instance->IR, ir_reg);
   \                     ??HAL_OSPI_Receive_DMA_9: (+1)
   \      0x122   0x6828             LDR      R0,[R5, #+0]
   \      0x124   0xF8C0 0x7110      STR      R7,[R0, #+272]
   \      0x128   0xE008             B.N      ??HAL_OSPI_Receive_DMA_1
   1607                        }
   1608                      }
   1609          
   1610                      /* Enable the MDMA transfer by setting the DMAEN bit not needed for MDMA*/
   1611                    }
   1612                    else
   1613                    {
   1614                      status = HAL_ERROR;
   \                     ??HAL_OSPI_Receive_DMA_7: (+1)
   \      0x12A   0x2401             MOVS     R4,#+1
   1615                      hospi->ErrorCode = HAL_OSPI_ERROR_DMA;
   \      0x12C   0x2004             MOVS     R0,#+4
   \      0x12E   0x65A8             STR      R0,[R5, #+88]
   1616                      hospi->State = HAL_OSPI_STATE_READY;
   \      0x130   0x2002             MOVS     R0,#+2
   \      0x132   0x6568             STR      R0,[R5, #+84]
   \      0x134   0xE002             B.N      ??HAL_OSPI_Receive_DMA_1
   1617                    }
   1618                }
   1619              }
   1620              else
   1621              {
   1622                status = HAL_ERROR;
   \                     ??HAL_OSPI_Receive_DMA_2: (+1)
   \      0x136   0x2401             MOVS     R4,#+1
   1623                hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
   \      0x138   0x2010             MOVS     R0,#+16
   \      0x13A   0x65A8             STR      R0,[R5, #+88]
   1624              }
   1625            }
   1626          
   1627            /* Return function status */
   1628            return status;
   \                     ??HAL_OSPI_Receive_DMA_1: (+1)
   \      0x13C   0x0020             MOVS     R0,R4
   \      0x13E   0xB2C0             UXTB     R0,R0
   \      0x140   0xBDF2             POP      {R1,R4-R7,PC}
   1629          }
   1630          
   1631          /**
   1632            * @brief  Configure the OSPI Automatic Polling Mode in blocking mode.
   1633            * @param  hospi   : OSPI handle
   1634            * @param  cfg     : structure that contains the polling configuration information.
   1635            * @param  Timeout : Timeout duration
   1636            * @note   This function is used only in Automatic Polling Mode
   1637            * @retval HAL status
   1638            */

   \                                 In section .text, align 2, keep-with-next
   1639          HAL_StatusTypeDef HAL_OSPI_AutoPolling(OSPI_HandleTypeDef *hospi, OSPI_AutoPollingTypeDef *cfg, uint32_t Timeout)
   1640          {
   \                     HAL_OSPI_AutoPolling: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x4689             MOV      R9,R1
   \        0x8   0x0015             MOVS     R5,R2
   1641            HAL_StatusTypeDef status;
   1642            uint32_t tickstart = HAL_GetTick();
   \        0xA   0x.... 0x....      BL       HAL_GetTick
   \        0xE   0x0006             MOVS     R6,R0
   1643            uint32_t addr_reg = hospi->Instance->AR;
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6C87             LDR      R7,[R0, #+72]
   1644            uint32_t ir_reg = hospi->Instance->IR;
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0xF8D0 0x8110      LDR      R8,[R0, #+272]
   1645          #ifdef USE_FULL_ASSERT
   1646            uint32_t dlr_reg = hospi->Instance->DLR;
   1647          #endif /* USE_FULL_ASSERT */
   1648          
   1649            /* Check the parameters of the autopolling configuration structure */
   1650            assert_param(IS_OSPI_MATCH_MODE       (cfg->MatchMode));
   1651            assert_param(IS_OSPI_AUTOMATIC_STOP   (cfg->AutomaticStop));
   1652            assert_param(IS_OSPI_INTERVAL         (cfg->Interval));
   1653            assert_param(IS_OSPI_STATUS_BYTES_SIZE(dlr_reg+1U));
   1654          
   1655            /* Check the state */
   1656            if ((hospi->State == HAL_OSPI_STATE_CMD_CFG) && (cfg->AutomaticStop == HAL_OSPI_AUTOMATIC_STOP_ENABLE))
   \       0x1A   0x6D60             LDR      R0,[R4, #+84]
   \       0x1C   0x2804             CMP      R0,#+4
   \       0x1E   0xD150             BNE.N    ??HAL_OSPI_AutoPolling_0
   \       0x20   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \       0x24   0xF5B0 0x0F80      CMP      R0,#+4194304
   \       0x28   0xD14B             BNE.N    ??HAL_OSPI_AutoPolling_0
   1657            {
   1658              /* Wait till busy flag is reset */
   1659              status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);
   \       0x2A   0x9500             STR      R5,[SP, #+0]
   \       0x2C   0x0033             MOVS     R3,R6
   \       0x2E   0x2200             MOVS     R2,#+0
   \       0x30   0x2120             MOVS     R1,#+32
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       OSPI_WaitFlagStateUntilTimeout
   1660          
   1661              if (status == HAL_OK)
   \       0x38   0x0001             MOVS     R1,R0
   \       0x3A   0xB2C9             UXTB     R1,R1
   \       0x3C   0x2900             CMP      R1,#+0
   \       0x3E   0xD143             BNE.N    ??HAL_OSPI_AutoPolling_1
   1662              {
   1663                /* Configure registers */
   1664                WRITE_REG (hospi->Instance->PSMAR, cfg->Match);
   \       0x40   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x44   0x6821             LDR      R1,[R4, #+0]
   \       0x46   0xF8C1 0x0088      STR      R0,[R1, #+136]
   1665                WRITE_REG (hospi->Instance->PSMKR, cfg->Mask);
   \       0x4A   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \       0x4E   0x6821             LDR      R1,[R4, #+0]
   \       0x50   0xF8C1 0x0080      STR      R0,[R1, #+128]
   1666                WRITE_REG (hospi->Instance->PIR,   cfg->Interval);
   \       0x54   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \       0x58   0x6821             LDR      R1,[R4, #+0]
   \       0x5A   0xF8C1 0x0090      STR      R0,[R1, #+144]
   1667                MODIFY_REG(hospi->Instance->CR,    (OCTOSPI_CR_PMM | OCTOSPI_CR_APMS | OCTOSPI_CR_FMODE),
   1668                           (cfg->MatchMode | cfg->AutomaticStop | OSPI_FUNCTIONAL_MODE_AUTO_POLLING));
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6801             LDR      R1,[R0, #+0]
   \       0x62   0xF031 0x5143      BICS     R1,R1,#0x30C00000
   \       0x66   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \       0x6A   0x4301             ORRS     R1,R0,R1
   \       0x6C   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \       0x70   0x4301             ORRS     R1,R0,R1
   \       0x72   0xF051 0x5100      ORRS     R1,R1,#0x20000000
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x6001             STR      R1,[R0, #+0]
   1669          
   1670                /* Trig the transfer by re-writing address or instruction register */
   1671                if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
   \       0x7A   0x68E0             LDR      R0,[R4, #+12]
   \       0x7C   0xF1B0 0x6F80      CMP      R0,#+67108864
   \       0x80   0xD102             BNE.N    ??HAL_OSPI_AutoPolling_2
   1672                {
   1673                  WRITE_REG(hospi->Instance->AR, addr_reg);
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x6487             STR      R7,[R0, #+72]
   \       0x86   0xE00B             B.N      ??HAL_OSPI_AutoPolling_3
   1674                }
   1675                else
   1676                {
   1677                  if (READ_BIT(hospi->Instance->CCR, OCTOSPI_CCR_ADMODE) != HAL_OSPI_ADDRESS_NONE)
   \                     ??HAL_OSPI_AutoPolling_2: (+1)
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0xF8D0 0x0100      LDR      R0,[R0, #+256]
   \       0x8E   0xF410 0x6FE0      TST      R0,#0x700
   \       0x92   0xD002             BEQ.N    ??HAL_OSPI_AutoPolling_4
   1678                  {
   1679                    WRITE_REG(hospi->Instance->AR, addr_reg);
   \       0x94   0x6820             LDR      R0,[R4, #+0]
   \       0x96   0x6487             STR      R7,[R0, #+72]
   \       0x98   0xE002             B.N      ??HAL_OSPI_AutoPolling_3
   1680                  }
   1681                  else
   1682                  {
   1683                    WRITE_REG(hospi->Instance->IR, ir_reg);
   \                     ??HAL_OSPI_AutoPolling_4: (+1)
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0xF8C0 0x8110      STR      R8,[R0, #+272]
   1684                  }
   1685                }
   1686          
   1687                /* Wait till status match flag is set to go back in idle state */
   1688                status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_SM, SET, tickstart, Timeout);
   \                     ??HAL_OSPI_AutoPolling_3: (+1)
   \       0xA0   0x9500             STR      R5,[SP, #+0]
   \       0xA2   0x0033             MOVS     R3,R6
   \       0xA4   0x2201             MOVS     R2,#+1
   \       0xA6   0x2108             MOVS     R1,#+8
   \       0xA8   0x0020             MOVS     R0,R4
   \       0xAA   0x.... 0x....      BL       OSPI_WaitFlagStateUntilTimeout
   1689          
   1690                if (status == HAL_OK)
   \       0xAE   0x0001             MOVS     R1,R0
   \       0xB0   0xB2C9             UXTB     R1,R1
   \       0xB2   0x2900             CMP      R1,#+0
   \       0xB4   0xD108             BNE.N    ??HAL_OSPI_AutoPolling_1
   1691                {
   1692                  /* Clear status match flag */
   1693                  __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_SM);
   \       0xB6   0x2108             MOVS     R1,#+8
   \       0xB8   0x6822             LDR      R2,[R4, #+0]
   \       0xBA   0x6251             STR      R1,[R2, #+36]
   1694          
   1695                  /* Update state */
   1696                  hospi->State = HAL_OSPI_STATE_READY;
   \       0xBC   0x2102             MOVS     R1,#+2
   \       0xBE   0x6561             STR      R1,[R4, #+84]
   \       0xC0   0xE002             B.N      ??HAL_OSPI_AutoPolling_1
   1697                }
   1698              }
   1699            }
   1700            else
   1701            {
   1702              status = HAL_ERROR;
   \                     ??HAL_OSPI_AutoPolling_0: (+1)
   \       0xC2   0x2001             MOVS     R0,#+1
   1703              hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
   \       0xC4   0x2110             MOVS     R1,#+16
   \       0xC6   0x65A1             STR      R1,[R4, #+88]
   1704            }
   1705          
   1706            /* Return function status */
   1707            return status;
   \                     ??HAL_OSPI_AutoPolling_1: (+1)
   \       0xC8   0xB2C0             UXTB     R0,R0
   \       0xCA   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1708          }
   1709          
   1710          /**
   1711            * @brief  Configure the OSPI Automatic Polling Mode in non-blocking mode.
   1712            * @param  hospi : OSPI handle
   1713            * @param  cfg   : structure that contains the polling configuration information.
   1714            * @note   This function is used only in Automatic Polling Mode
   1715            * @retval HAL status
   1716            */

   \                                 In section .text, align 2, keep-with-next
   1717          HAL_StatusTypeDef HAL_OSPI_AutoPolling_IT(OSPI_HandleTypeDef *hospi, OSPI_AutoPollingTypeDef *cfg)
   1718          {
   \                     HAL_OSPI_AutoPolling_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1719            HAL_StatusTypeDef status;
   1720            uint32_t tickstart = HAL_GetTick();
   \        0x6   0x.... 0x....      BL       HAL_GetTick
   \        0xA   0x0003             MOVS     R3,R0
   1721            uint32_t addr_reg = hospi->Instance->AR;
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x6C86             LDR      R6,[R0, #+72]
   1722            uint32_t ir_reg = hospi->Instance->IR;
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0xF8D0 0x7110      LDR      R7,[R0, #+272]
   1723          #ifdef USE_FULL_ASSERT
   1724            uint32_t dlr_reg = hospi->Instance->DLR;
   1725          #endif /* USE_FULL_ASSERT */
   1726          
   1727            /* Check the parameters of the autopolling configuration structure */
   1728            assert_param(IS_OSPI_MATCH_MODE       (cfg->MatchMode));
   1729            assert_param(IS_OSPI_AUTOMATIC_STOP   (cfg->AutomaticStop));
   1730            assert_param(IS_OSPI_INTERVAL         (cfg->Interval));
   1731            assert_param(IS_OSPI_STATUS_BYTES_SIZE(dlr_reg+1U));
   1732          
   1733            /* Check the state */
   1734            if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
   \       0x16   0x6D60             LDR      R0,[R4, #+84]
   \       0x18   0x2804             CMP      R0,#+4
   \       0x1A   0xD141             BNE.N    ??HAL_OSPI_AutoPolling_IT_0
   1735            {
   1736              /* Wait till busy flag is reset */
   1737              status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
   \       0x1C   0x6DE0             LDR      R0,[R4, #+92]
   \       0x1E   0x9000             STR      R0,[SP, #+0]
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x2120             MOVS     R1,#+32
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       OSPI_WaitFlagStateUntilTimeout
   1738          
   1739              if (status == HAL_OK)
   \       0x2A   0x0001             MOVS     R1,R0
   \       0x2C   0xB2C9             UXTB     R1,R1
   \       0x2E   0x2900             CMP      R1,#+0
   \       0x30   0xD139             BNE.N    ??HAL_OSPI_AutoPolling_IT_1
   1740              {
   1741                /* Configure registers */
   1742                WRITE_REG (hospi->Instance->PSMAR, cfg->Match);
   \       0x32   0x6829             LDR      R1,[R5, #+0]
   \       0x34   0x6822             LDR      R2,[R4, #+0]
   \       0x36   0xF8C2 0x1088      STR      R1,[R2, #+136]
   1743                WRITE_REG (hospi->Instance->PSMKR, cfg->Mask);
   \       0x3A   0x6869             LDR      R1,[R5, #+4]
   \       0x3C   0x6822             LDR      R2,[R4, #+0]
   \       0x3E   0xF8C2 0x1080      STR      R1,[R2, #+128]
   1744                WRITE_REG (hospi->Instance->PIR,   cfg->Interval);
   \       0x42   0x6929             LDR      R1,[R5, #+16]
   \       0x44   0x6822             LDR      R2,[R4, #+0]
   \       0x46   0xF8C2 0x1090      STR      R1,[R2, #+144]
   1745                MODIFY_REG(hospi->Instance->CR,    (OCTOSPI_CR_PMM | OCTOSPI_CR_APMS | OCTOSPI_CR_FMODE),
   1746                           (cfg->MatchMode | cfg->AutomaticStop | OSPI_FUNCTIONAL_MODE_AUTO_POLLING));
   \       0x4A   0x6821             LDR      R1,[R4, #+0]
   \       0x4C   0x680A             LDR      R2,[R1, #+0]
   \       0x4E   0xF032 0x5243      BICS     R2,R2,#0x30C00000
   \       0x52   0x68A9             LDR      R1,[R5, #+8]
   \       0x54   0x430A             ORRS     R2,R1,R2
   \       0x56   0x68E9             LDR      R1,[R5, #+12]
   \       0x58   0x430A             ORRS     R2,R1,R2
   \       0x5A   0xF052 0x5200      ORRS     R2,R2,#0x20000000
   \       0x5E   0x6821             LDR      R1,[R4, #+0]
   \       0x60   0x600A             STR      R2,[R1, #+0]
   1747          
   1748                /* Clear flags related to interrupt */
   1749                __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TE | HAL_OSPI_FLAG_SM);
   \       0x62   0x2109             MOVS     R1,#+9
   \       0x64   0x6822             LDR      R2,[R4, #+0]
   \       0x66   0x6251             STR      R1,[R2, #+36]
   1750          
   1751                /* Update state */
   1752                hospi->State = HAL_OSPI_STATE_BUSY_AUTO_POLLING;
   \       0x68   0x2148             MOVS     R1,#+72
   \       0x6A   0x6561             STR      R1,[R4, #+84]
   1753          
   1754                /* Enable the status match and transfer error interrupts */
   1755                __HAL_OSPI_ENABLE_IT(hospi, HAL_OSPI_IT_SM | HAL_OSPI_IT_TE);
   \       0x6C   0x6821             LDR      R1,[R4, #+0]
   \       0x6E   0x6809             LDR      R1,[R1, #+0]
   \       0x70   0xF451 0x2110      ORRS     R1,R1,#0x90000
   \       0x74   0x6822             LDR      R2,[R4, #+0]
   \       0x76   0x6011             STR      R1,[R2, #+0]
   1756          
   1757                /* Trig the transfer by re-writing address or instruction register */
   1758                if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
   \       0x78   0x68E1             LDR      R1,[R4, #+12]
   \       0x7A   0xF1B1 0x6F80      CMP      R1,#+67108864
   \       0x7E   0xD102             BNE.N    ??HAL_OSPI_AutoPolling_IT_2
   1759                {
   1760                  WRITE_REG(hospi->Instance->AR, addr_reg);
   \       0x80   0x6821             LDR      R1,[R4, #+0]
   \       0x82   0x648E             STR      R6,[R1, #+72]
   \       0x84   0xE00F             B.N      ??HAL_OSPI_AutoPolling_IT_1
   1761                }
   1762                else
   1763                {
   1764                  if (READ_BIT(hospi->Instance->CCR, OCTOSPI_CCR_ADMODE) != HAL_OSPI_ADDRESS_NONE)
   \                     ??HAL_OSPI_AutoPolling_IT_2: (+1)
   \       0x86   0x6821             LDR      R1,[R4, #+0]
   \       0x88   0xF8D1 0x1100      LDR      R1,[R1, #+256]
   \       0x8C   0xF411 0x6FE0      TST      R1,#0x700
   \       0x90   0xD002             BEQ.N    ??HAL_OSPI_AutoPolling_IT_3
   1765                  {
   1766                    WRITE_REG(hospi->Instance->AR, addr_reg);
   \       0x92   0x6821             LDR      R1,[R4, #+0]
   \       0x94   0x648E             STR      R6,[R1, #+72]
   \       0x96   0xE006             B.N      ??HAL_OSPI_AutoPolling_IT_1
   1767                  }
   1768                  else
   1769                  {
   1770                    WRITE_REG(hospi->Instance->IR, ir_reg);
   \                     ??HAL_OSPI_AutoPolling_IT_3: (+1)
   \       0x98   0x6821             LDR      R1,[R4, #+0]
   \       0x9A   0xF8C1 0x7110      STR      R7,[R1, #+272]
   \       0x9E   0xE002             B.N      ??HAL_OSPI_AutoPolling_IT_1
   1771                  }
   1772                }
   1773              }
   1774            }
   1775            else
   1776            {
   1777              status = HAL_ERROR;
   \                     ??HAL_OSPI_AutoPolling_IT_0: (+1)
   \       0xA0   0x2001             MOVS     R0,#+1
   1778              hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
   \       0xA2   0x2110             MOVS     R1,#+16
   \       0xA4   0x65A1             STR      R1,[R4, #+88]
   1779            }
   1780          
   1781            /* Return function status */
   1782            return status;
   \                     ??HAL_OSPI_AutoPolling_IT_1: (+1)
   \       0xA6   0xB2C0             UXTB     R0,R0
   \       0xA8   0xBDF2             POP      {R1,R4-R7,PC}
   1783          }
   1784          
   1785          /**
   1786            * @brief  Configure the Memory Mapped mode.
   1787            * @param  hospi : OSPI handle
   1788            * @param  cfg   : structure that contains the memory mapped configuration information.
   1789            * @note   This function is used only in Memory mapped Mode
   1790            * @retval HAL status
   1791            */

   \                                 In section .text, align 2, keep-with-next
   1792          HAL_StatusTypeDef HAL_OSPI_MemoryMapped(OSPI_HandleTypeDef *hospi, OSPI_MemoryMappedTypeDef *cfg)
   1793          {
   \                     HAL_OSPI_MemoryMapped: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1794            HAL_StatusTypeDef status;
   1795            uint32_t tickstart = HAL_GetTick();
   \        0x6   0x.... 0x....      BL       HAL_GetTick
   \        0xA   0x0003             MOVS     R3,R0
   1796          
   1797            /* Check the parameters of the memory-mapped configuration structure */
   1798            assert_param(IS_OSPI_TIMEOUT_ACTIVATION(cfg->TimeOutActivation));
   1799          
   1800            /* Check the state */
   1801            if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
   \        0xC   0x6D60             LDR      R0,[R4, #+84]
   \        0xE   0x2804             CMP      R0,#+4
   \       0x10   0xD128             BNE.N    ??HAL_OSPI_MemoryMapped_0
   1802            {
   1803              /* Wait till busy flag is reset */
   1804              status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
   \       0x12   0x6DE0             LDR      R0,[R4, #+92]
   \       0x14   0x9000             STR      R0,[SP, #+0]
   \       0x16   0x2200             MOVS     R2,#+0
   \       0x18   0x2120             MOVS     R1,#+32
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       OSPI_WaitFlagStateUntilTimeout
   1805          
   1806              if (status == HAL_OK)
   \       0x20   0x0001             MOVS     R1,R0
   \       0x22   0xB2C9             UXTB     R1,R1
   \       0x24   0x2900             CMP      R1,#+0
   \       0x26   0xD120             BNE.N    ??HAL_OSPI_MemoryMapped_1
   1807              {
   1808                /* Update state */
   1809                hospi->State = HAL_OSPI_STATE_BUSY_MEM_MAPPED;
   \       0x28   0x2188             MOVS     R1,#+136
   \       0x2A   0x6561             STR      R1,[R4, #+84]
   1810          
   1811                if (cfg->TimeOutActivation == HAL_OSPI_TIMEOUT_COUNTER_ENABLE)
   \       0x2C   0x6829             LDR      R1,[R5, #+0]
   \       0x2E   0x2908             CMP      R1,#+8
   \       0x30   0xD10C             BNE.N    ??HAL_OSPI_MemoryMapped_2
   1812                {
   1813                  assert_param(IS_OSPI_TIMEOUT_PERIOD(cfg->TimeOutPeriod));
   1814          
   1815                  /* Configure register */
   1816                  WRITE_REG(hospi->Instance->LPTR, cfg->TimeOutPeriod);
   \       0x32   0x6869             LDR      R1,[R5, #+4]
   \       0x34   0x6822             LDR      R2,[R4, #+0]
   \       0x36   0xF8C2 0x1130      STR      R1,[R2, #+304]
   1817          
   1818                  /* Clear flags related to interrupt */
   1819                  __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TO);
   \       0x3A   0x2110             MOVS     R1,#+16
   \       0x3C   0x6822             LDR      R2,[R4, #+0]
   \       0x3E   0x6251             STR      R1,[R2, #+36]
   1820          
   1821                  /* Enable the timeout interrupt */
   1822                  __HAL_OSPI_ENABLE_IT(hospi, HAL_OSPI_IT_TO);
   \       0x40   0x6821             LDR      R1,[R4, #+0]
   \       0x42   0x6809             LDR      R1,[R1, #+0]
   \       0x44   0xF451 0x1180      ORRS     R1,R1,#0x100000
   \       0x48   0x6822             LDR      R2,[R4, #+0]
   \       0x4A   0x6011             STR      R1,[R2, #+0]
   1823                }
   1824          
   1825                /* Configure CR register with functional mode as memory-mapped */
   1826                MODIFY_REG(hospi->Instance->CR, (OCTOSPI_CR_TCEN | OCTOSPI_CR_FMODE),
   1827                           (cfg->TimeOutActivation | OSPI_FUNCTIONAL_MODE_MEMORY_MAPPED));
   \                     ??HAL_OSPI_MemoryMapped_2: (+1)
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x680A             LDR      R2,[R1, #+0]
   \       0x50   0x.... 0x....      LDR.W    R1,??DataTable7
   \       0x54   0x400A             ANDS     R2,R1,R2
   \       0x56   0x6829             LDR      R1,[R5, #+0]
   \       0x58   0x430A             ORRS     R2,R1,R2
   \       0x5A   0xF052 0x5240      ORRS     R2,R2,#0x30000000
   \       0x5E   0x6821             LDR      R1,[R4, #+0]
   \       0x60   0x600A             STR      R2,[R1, #+0]
   \       0x62   0xE002             B.N      ??HAL_OSPI_MemoryMapped_1
   1828              }
   1829            }
   1830            else
   1831            {
   1832              status = HAL_ERROR;
   \                     ??HAL_OSPI_MemoryMapped_0: (+1)
   \       0x64   0x2001             MOVS     R0,#+1
   1833              hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
   \       0x66   0x2110             MOVS     R1,#+16
   \       0x68   0x65A1             STR      R1,[R4, #+88]
   1834            }
   1835          
   1836            /* Return function status */
   1837            return status;
   \                     ??HAL_OSPI_MemoryMapped_1: (+1)
   \       0x6A   0xB2C0             UXTB     R0,R0
   \       0x6C   0xBD32             POP      {R1,R4,R5,PC}
   1838          }
   1839          
   1840          /**
   1841            * @brief  Transfer Error callback.
   1842            * @param  hospi : OSPI handle
   1843            * @retval None
   1844            */

   \                                 In section .text, align 2
   1845          __weak void HAL_OSPI_ErrorCallback(OSPI_HandleTypeDef *hospi)
   1846          {
   1847            /* Prevent unused argument(s) compilation warning */
   1848            UNUSED(hospi);
   1849          
   1850            /* NOTE : This function should not be modified, when the callback is needed,
   1851                      the HAL_OSPI_ErrorCallback could be implemented in the user file
   1852             */
   1853          }
   \                     HAL_OSPI_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR
   1854          
   1855          /**
   1856            * @brief  Abort completed callback.
   1857            * @param  hospi : OSPI handle
   1858            * @retval None
   1859            */

   \                                 In section .text, align 2
   1860          __weak void HAL_OSPI_AbortCpltCallback(OSPI_HandleTypeDef *hospi)
   1861          {
   1862            /* Prevent unused argument(s) compilation warning */
   1863            UNUSED(hospi);
   1864          
   1865            /* NOTE: This function should not be modified, when the callback is needed,
   1866                     the HAL_OSPI_AbortCpltCallback could be implemented in the user file
   1867             */
   1868          }
   \                     HAL_OSPI_AbortCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   1869          
   1870          /**
   1871            * @brief  FIFO Threshold callback.
   1872            * @param  hospi : OSPI handle
   1873            * @retval None
   1874            */

   \                                 In section .text, align 2
   1875          __weak void HAL_OSPI_FifoThresholdCallback(OSPI_HandleTypeDef *hospi)
   1876          {
   1877            /* Prevent unused argument(s) compilation warning */
   1878            UNUSED(hospi);
   1879          
   1880            /* NOTE : This function should not be modified, when the callback is needed,
   1881                      the HAL_OSPI_FIFOThresholdCallback could be implemented in the user file
   1882             */
   1883          }
   \                     HAL_OSPI_FifoThresholdCallback: (+1)
   \        0x0   0x4770             BX       LR
   1884          
   1885          /**
   1886            * @brief  Command completed callback.
   1887            * @param  hospi : OSPI handle
   1888            * @retval None
   1889            */

   \                                 In section .text, align 2
   1890          __weak void HAL_OSPI_CmdCpltCallback(OSPI_HandleTypeDef *hospi)
   1891          {
   1892            /* Prevent unused argument(s) compilation warning */
   1893            UNUSED(hospi);
   1894          
   1895            /* NOTE: This function should not be modified, when the callback is needed,
   1896                     the HAL_OSPI_CmdCpltCallback could be implemented in the user file
   1897             */
   1898          }
   \                     HAL_OSPI_CmdCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   1899          
   1900          /**
   1901            * @brief  Rx Transfer completed callback.
   1902            * @param  hospi : OSPI handle
   1903            * @retval None
   1904            */

   \                                 In section .text, align 2
   1905          __weak void HAL_OSPI_RxCpltCallback(OSPI_HandleTypeDef *hospi)
   1906          {
   1907            /* Prevent unused argument(s) compilation warning */
   1908            UNUSED(hospi);
   1909          
   1910            /* NOTE: This function should not be modified, when the callback is needed,
   1911                     the HAL_OSPI_RxCpltCallback could be implemented in the user file
   1912             */
   1913          }
   \                     HAL_OSPI_RxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   1914          
   1915          /**
   1916            * @brief  Tx Transfer completed callback.
   1917            * @param  hospi : OSPI handle
   1918            * @retval None
   1919            */

   \                                 In section .text, align 2
   1920           __weak void HAL_OSPI_TxCpltCallback(OSPI_HandleTypeDef *hospi)
   1921          {
   1922            /* Prevent unused argument(s) compilation warning */
   1923            UNUSED(hospi);
   1924          
   1925            /* NOTE: This function should not be modified, when the callback is needed,
   1926                     the HAL_OSPI_TxCpltCallback could be implemented in the user file
   1927             */
   1928          }
   \                     HAL_OSPI_TxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   1929          
   1930          /**
   1931            * @brief  Rx Half Transfer completed callback.
   1932            * @param  hospi : OSPI handle
   1933            * @retval None
   1934            */

   \                                 In section .text, align 2
   1935          __weak void HAL_OSPI_RxHalfCpltCallback(OSPI_HandleTypeDef *hospi)
   1936          {
   1937            /* Prevent unused argument(s) compilation warning */
   1938            UNUSED(hospi);
   1939          
   1940            /* NOTE: This function should not be modified, when the callback is needed,
   1941                     the HAL_OSPI_RxHalfCpltCallback could be implemented in the user file
   1942             */
   1943          }
   \                     HAL_OSPI_RxHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   1944          
   1945          /**
   1946            * @brief  Tx Half Transfer completed callback.
   1947            * @param  hospi : OSPI handle
   1948            * @retval None
   1949            */

   \                                 In section .text, align 2
   1950          __weak void HAL_OSPI_TxHalfCpltCallback(OSPI_HandleTypeDef *hospi)
   1951          {
   1952            /* Prevent unused argument(s) compilation warning */
   1953            UNUSED(hospi);
   1954          
   1955            /* NOTE: This function should not be modified, when the callback is needed,
   1956                     the HAL_OSPI_TxHalfCpltCallback could be implemented in the user file
   1957             */
   1958          }
   \                     HAL_OSPI_TxHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   1959          
   1960          /**
   1961            * @brief  Status Match callback.
   1962            * @param  hospi : OSPI handle
   1963            * @retval None
   1964            */

   \                                 In section .text, align 2
   1965          __weak void HAL_OSPI_StatusMatchCallback(OSPI_HandleTypeDef *hospi)
   1966          {
   1967            /* Prevent unused argument(s) compilation warning */
   1968            UNUSED(hospi);
   1969          
   1970            /* NOTE : This function should not be modified, when the callback is needed,
   1971                      the HAL_OSPI_StatusMatchCallback could be implemented in the user file
   1972             */
   1973          }
   \                     HAL_OSPI_StatusMatchCallback: (+1)
   \        0x0   0x4770             BX       LR
   1974          
   1975          /**
   1976            * @brief  Timeout callback.
   1977            * @param  hospi : OSPI handle
   1978            * @retval None
   1979            */

   \                                 In section .text, align 2
   1980          __weak void HAL_OSPI_TimeOutCallback(OSPI_HandleTypeDef *hospi)
   1981          {
   1982            /* Prevent unused argument(s) compilation warning */
   1983            UNUSED(hospi);
   1984          
   1985            /* NOTE : This function should not be modified, when the callback is needed,
   1986                      the HAL_OSPI_TimeOutCallback could be implemented in the user file
   1987             */
   1988          }
   \                     HAL_OSPI_TimeOutCallback: (+1)
   \        0x0   0x4770             BX       LR
   1989          
   1990          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
   1991          /**
   1992            * @brief  Register a User OSPI Callback
   1993            *         To be used instead of the weak (surcharged) predefined callback
   1994            * @param hospi : OSPI handle
   1995            * @param CallbackID : ID of the callback to be registered
   1996            *        This parameter can be one of the following values:
   1997            *          @arg @ref HAL_OSPI_ERROR_CB_ID          OSPI Error Callback ID
   1998            *          @arg @ref HAL_OSPI_ABORT_CB_ID          OSPI Abort Callback ID
   1999            *          @arg @ref HAL_OSPI_FIFO_THRESHOLD_CB_ID OSPI FIFO Threshold Callback ID
   2000            *          @arg @ref HAL_OSPI_CMD_CPLT_CB_ID       OSPI Command Complete Callback ID
   2001            *          @arg @ref HAL_OSPI_RX_CPLT_CB_ID        OSPI Rx Complete Callback ID
   2002            *          @arg @ref HAL_OSPI_TX_CPLT_CB_ID        OSPI Tx Complete Callback ID
   2003            *          @arg @ref HAL_OSPI_RX_HALF_CPLT_CB_ID   OSPI Rx Half Complete Callback ID
   2004            *          @arg @ref HAL_OSPI_TX_HALF_CPLT_CB_ID   OSPI Tx Half Complete Callback ID
   2005            *          @arg @ref HAL_OSPI_STATUS_MATCH_CB_ID   OSPI Status Match Callback ID
   2006            *          @arg @ref HAL_OSPI_TIMEOUT_CB_ID        OSPI Timeout Callback ID
   2007            *          @arg @ref HAL_OSPI_MSP_INIT_CB_ID       OSPI MspInit callback ID
   2008            *          @arg @ref HAL_OSPI_MSP_DEINIT_CB_ID     OSPI MspDeInit callback ID
   2009            * @param pCallback : pointer to the Callback function
   2010            * @retval status
   2011            */
   2012          HAL_StatusTypeDef HAL_OSPI_RegisterCallback(OSPI_HandleTypeDef *hospi, HAL_OSPI_CallbackIDTypeDef CallbackID,
   2013                                                      pOSPI_CallbackTypeDef pCallback)
   2014          {
   2015            HAL_StatusTypeDef status = HAL_OK;
   2016          
   2017            if(pCallback == NULL)
   2018            {
   2019              /* Update the error code */
   2020              hospi->ErrorCode |= HAL_OSPI_ERROR_INVALID_CALLBACK;
   2021              return HAL_ERROR;
   2022            }
   2023          
   2024            if(hospi->State == HAL_OSPI_STATE_READY)
   2025            {
   2026              switch (CallbackID)
   2027              {
   2028              case  HAL_OSPI_ERROR_CB_ID :
   2029                hospi->ErrorCallback = pCallback;
   2030                break;
   2031              case HAL_OSPI_ABORT_CB_ID :
   2032                hospi->AbortCpltCallback = pCallback;
   2033                break;
   2034              case HAL_OSPI_FIFO_THRESHOLD_CB_ID :
   2035                hospi->FifoThresholdCallback = pCallback;
   2036                break;
   2037              case HAL_OSPI_CMD_CPLT_CB_ID :
   2038                hospi->CmdCpltCallback = pCallback;
   2039                break;
   2040              case HAL_OSPI_RX_CPLT_CB_ID :
   2041                hospi->RxCpltCallback = pCallback;
   2042                break;
   2043              case HAL_OSPI_TX_CPLT_CB_ID :
   2044                hospi->TxCpltCallback = pCallback;
   2045                break;
   2046              case HAL_OSPI_RX_HALF_CPLT_CB_ID :
   2047                hospi->RxHalfCpltCallback = pCallback;
   2048                break;
   2049              case HAL_OSPI_TX_HALF_CPLT_CB_ID :
   2050                hospi->TxHalfCpltCallback = pCallback;
   2051                break;
   2052              case HAL_OSPI_STATUS_MATCH_CB_ID :
   2053                hospi->StatusMatchCallback = pCallback;
   2054                break;
   2055              case HAL_OSPI_TIMEOUT_CB_ID :
   2056                hospi->TimeOutCallback = pCallback;
   2057                break;
   2058              case HAL_OSPI_MSP_INIT_CB_ID :
   2059                hospi->MspInitCallback = pCallback;
   2060                break;
   2061              case HAL_OSPI_MSP_DEINIT_CB_ID :
   2062                hospi->MspDeInitCallback = pCallback;
   2063                break;
   2064              default :
   2065                /* Update the error code */
   2066                hospi->ErrorCode |= HAL_OSPI_ERROR_INVALID_CALLBACK;
   2067                /* update return status */
   2068                status =  HAL_ERROR;
   2069                break;
   2070              }
   2071            }
   2072            else if (hospi->State == HAL_OSPI_STATE_RESET)
   2073            {
   2074              switch (CallbackID)
   2075              {
   2076              case HAL_OSPI_MSP_INIT_CB_ID :
   2077                hospi->MspInitCallback = pCallback;
   2078                break;
   2079              case HAL_OSPI_MSP_DEINIT_CB_ID :
   2080                hospi->MspDeInitCallback = pCallback;
   2081                break;
   2082              default :
   2083                /* Update the error code */
   2084                hospi->ErrorCode |= HAL_OSPI_ERROR_INVALID_CALLBACK;
   2085                /* update return status */
   2086                status =  HAL_ERROR;
   2087                break;
   2088              }
   2089            }
   2090            else
   2091            {
   2092              /* Update the error code */
   2093              hospi->ErrorCode |= HAL_OSPI_ERROR_INVALID_CALLBACK;
   2094              /* update return status */
   2095              status =  HAL_ERROR;
   2096            }
   2097          
   2098            return status;
   2099          }
   2100          
   2101          /**
   2102            * @brief  Unregister a User OSPI Callback
   2103            *         OSPI Callback is redirected to the weak (surcharged) predefined callback
   2104            * @param hospi : OSPI handle
   2105            * @param CallbackID : ID of the callback to be unregistered
   2106            *        This parameter can be one of the following values:
   2107            *          @arg @ref HAL_OSPI_ERROR_CB_ID          OSPI Error Callback ID
   2108            *          @arg @ref HAL_OSPI_ABORT_CB_ID          OSPI Abort Callback ID
   2109            *          @arg @ref HAL_OSPI_FIFO_THRESHOLD_CB_ID OSPI FIFO Threshold Callback ID
   2110            *          @arg @ref HAL_OSPI_CMD_CPLT_CB_ID       OSPI Command Complete Callback ID
   2111            *          @arg @ref HAL_OSPI_RX_CPLT_CB_ID        OSPI Rx Complete Callback ID
   2112            *          @arg @ref HAL_OSPI_TX_CPLT_CB_ID        OSPI Tx Complete Callback ID
   2113            *          @arg @ref HAL_OSPI_RX_HALF_CPLT_CB_ID   OSPI Rx Half Complete Callback ID
   2114            *          @arg @ref HAL_OSPI_TX_HALF_CPLT_CB_ID   OSPI Tx Half Complete Callback ID
   2115            *          @arg @ref HAL_OSPI_STATUS_MATCH_CB_ID   OSPI Status Match Callback ID
   2116            *          @arg @ref HAL_OSPI_TIMEOUT_CB_ID        OSPI Timeout Callback ID
   2117            *          @arg @ref HAL_OSPI_MSP_INIT_CB_ID       OSPI MspInit callback ID
   2118            *          @arg @ref HAL_OSPI_MSP_DEINIT_CB_ID     OSPI MspDeInit callback ID
   2119            * @retval status
   2120            */
   2121          HAL_StatusTypeDef HAL_OSPI_UnRegisterCallback (OSPI_HandleTypeDef *hospi, HAL_OSPI_CallbackIDTypeDef CallbackID)
   2122          {
   2123            HAL_StatusTypeDef status = HAL_OK;
   2124          
   2125            if(hospi->State == HAL_OSPI_STATE_READY)
   2126            {
   2127              switch (CallbackID)
   2128              {
   2129              case  HAL_OSPI_ERROR_CB_ID :
   2130                hospi->ErrorCallback = HAL_OSPI_ErrorCallback;
   2131                break;
   2132              case HAL_OSPI_ABORT_CB_ID :
   2133                hospi->AbortCpltCallback = HAL_OSPI_AbortCpltCallback;
   2134                break;
   2135              case HAL_OSPI_FIFO_THRESHOLD_CB_ID :
   2136                hospi->FifoThresholdCallback = HAL_OSPI_FifoThresholdCallback;
   2137                break;
   2138              case HAL_OSPI_CMD_CPLT_CB_ID :
   2139                hospi->CmdCpltCallback = HAL_OSPI_CmdCpltCallback;
   2140                break;
   2141              case HAL_OSPI_RX_CPLT_CB_ID :
   2142                hospi->RxCpltCallback = HAL_OSPI_RxCpltCallback;
   2143                break;
   2144              case HAL_OSPI_TX_CPLT_CB_ID :
   2145                hospi->TxCpltCallback = HAL_OSPI_TxCpltCallback;
   2146                break;
   2147              case HAL_OSPI_RX_HALF_CPLT_CB_ID :
   2148                hospi->RxHalfCpltCallback = HAL_OSPI_RxHalfCpltCallback;
   2149                break;
   2150              case HAL_OSPI_TX_HALF_CPLT_CB_ID :
   2151                hospi->TxHalfCpltCallback = HAL_OSPI_TxHalfCpltCallback;
   2152                break;
   2153              case HAL_OSPI_STATUS_MATCH_CB_ID :
   2154                hospi->StatusMatchCallback = HAL_OSPI_StatusMatchCallback;
   2155                break;
   2156              case HAL_OSPI_TIMEOUT_CB_ID :
   2157                hospi->TimeOutCallback = HAL_OSPI_TimeOutCallback;
   2158                break;
   2159              case HAL_OSPI_MSP_INIT_CB_ID :
   2160                hospi->MspInitCallback = HAL_OSPI_MspInit;
   2161                break;
   2162              case HAL_OSPI_MSP_DEINIT_CB_ID :
   2163                hospi->MspDeInitCallback = HAL_OSPI_MspDeInit;
   2164                break;
   2165              default :
   2166                /* Update the error code */
   2167                hospi->ErrorCode |= HAL_OSPI_ERROR_INVALID_CALLBACK;
   2168                /* update return status */
   2169                status =  HAL_ERROR;
   2170                break;
   2171              }
   2172            }
   2173            else if (hospi->State == HAL_OSPI_STATE_RESET)
   2174            {
   2175              switch (CallbackID)
   2176              {
   2177              case HAL_OSPI_MSP_INIT_CB_ID :
   2178                hospi->MspInitCallback = HAL_OSPI_MspInit;
   2179                break;
   2180              case HAL_OSPI_MSP_DEINIT_CB_ID :
   2181                hospi->MspDeInitCallback = HAL_OSPI_MspDeInit;
   2182                break;
   2183              default :
   2184                /* Update the error code */
   2185                hospi->ErrorCode |= HAL_OSPI_ERROR_INVALID_CALLBACK;
   2186                /* update return status */
   2187                status =  HAL_ERROR;
   2188                break;
   2189              }
   2190            }
   2191            else
   2192            {
   2193              /* Update the error code */
   2194              hospi->ErrorCode |= HAL_OSPI_ERROR_INVALID_CALLBACK;
   2195              /* update return status */
   2196              status =  HAL_ERROR;
   2197            }
   2198          
   2199            return status;
   2200          }
   2201          #endif /* defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
   2202          
   2203          /**
   2204            * @}
   2205            */
   2206          
   2207          /** @defgroup OSPI_Exported_Functions_Group3 Peripheral Control and State functions
   2208            *  @brief   OSPI control and State functions
   2209            *
   2210          @verbatim
   2211           ===============================================================================
   2212                            ##### Peripheral Control and State functions #####
   2213           ===============================================================================
   2214              [..]
   2215              This subsection provides a set of functions allowing to :
   2216                (+) Check in run-time the state of the driver.
   2217                (+) Check the error code set during last operation.
   2218                (+) Abort any operation.
   2219                (+) Manage the Fifo threshold.
   2220                (+) Configure the timeout duration used in the driver.
   2221          
   2222          @endverbatim
   2223            * @{
   2224            */
   2225          
   2226          /**
   2227          * @brief  Abort the current transmission.
   2228          * @param  hospi : OSPI handle
   2229          * @retval HAL status
   2230          */

   \                                 In section .text, align 2, keep-with-next
   2231          HAL_StatusTypeDef HAL_OSPI_Abort(OSPI_HandleTypeDef *hospi)
   2232          {
   \                     HAL_OSPI_Abort: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2233            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2600             MOVS     R6,#+0
   2234            uint32_t state;
   2235            uint32_t tickstart = HAL_GetTick();
   \        0x6   0x.... 0x....      BL       HAL_GetTick
   \        0xA   0x0005             MOVS     R5,R0
   2236          
   2237            /* Check if the state is in one of the busy or configured states */
   2238            state = hospi->State;
   \        0xC   0x6D60             LDR      R0,[R4, #+84]
   2239            if (((state & OSPI_BUSY_STATE_MASK) != 0U) || ((state & OSPI_CFG_STATE_MASK) != 0U))
   \        0xE   0xF010 0x0F0C      TST      R0,#0xC
   \       0x12   0xD040             BEQ.N    ??HAL_OSPI_Abort_0
   2240            {
   2241              /* Check if the DMA is enabled */
   2242              if ((hospi->Instance->CR & OCTOSPI_CR_DMAEN) != 0U)
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x0740             LSLS     R0,R0,#+29
   \       0x1A   0xD50F             BPL.N    ??HAL_OSPI_Abort_1
   2243              {
   2244                /* Disable the DMA transfer on the OctoSPI side */
   2245                CLEAR_BIT(hospi->Instance->CR, OCTOSPI_CR_DMAEN);
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x6800             LDR      R0,[R0, #+0]
   \       0x20   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x24   0x6821             LDR      R1,[R4, #+0]
   \       0x26   0x6008             STR      R0,[R1, #+0]
   2246          
   2247                /* Disable the DMA transfer on the DMA side */
   2248                status = HAL_MDMA_Abort(hospi->hmdma);
   \       0x28   0x6D20             LDR      R0,[R4, #+80]
   \       0x2A   0x.... 0x....      BL       HAL_MDMA_Abort
   \       0x2E   0x0006             MOVS     R6,R0
   2249                if (status != HAL_OK)
   \       0x30   0x0030             MOVS     R0,R6
   \       0x32   0xB2C0             UXTB     R0,R0
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD001             BEQ.N    ??HAL_OSPI_Abort_1
   2250                {
   2251                  hospi->ErrorCode = HAL_OSPI_ERROR_DMA;
   \       0x38   0x2004             MOVS     R0,#+4
   \       0x3A   0x65A0             STR      R0,[R4, #+88]
   2252                }
   2253              }
   2254          
   2255              if (__HAL_OSPI_GET_FLAG(hospi, HAL_OSPI_FLAG_BUSY) != RESET)
   \                     ??HAL_OSPI_Abort_1: (+1)
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6A00             LDR      R0,[R0, #+32]
   \       0x40   0x0680             LSLS     R0,R0,#+26
   \       0x42   0xD525             BPL.N    ??HAL_OSPI_Abort_2
   2256              {
   2257                /* Perform an abort of the OctoSPI */
   2258                SET_BIT(hospi->Instance->CR, OCTOSPI_CR_ABORT);
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x6800             LDR      R0,[R0, #+0]
   \       0x48   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x6008             STR      R0,[R1, #+0]
   2259          
   2260                /* Wait until the transfer complete flag is set to go back in idle state */
   2261                status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, hospi->Timeout);
   \       0x50   0x6DE0             LDR      R0,[R4, #+92]
   \       0x52   0x9000             STR      R0,[SP, #+0]
   \       0x54   0x002B             MOVS     R3,R5
   \       0x56   0x2201             MOVS     R2,#+1
   \       0x58   0x2102             MOVS     R1,#+2
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x.... 0x....      BL       OSPI_WaitFlagStateUntilTimeout
   \       0x60   0x0006             MOVS     R6,R0
   2262          
   2263                if (status == HAL_OK)
   \       0x62   0x0030             MOVS     R0,R6
   \       0x64   0xB2C0             UXTB     R0,R0
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD118             BNE.N    ??HAL_OSPI_Abort_3
   2264                {
   2265                  /* Clear transfer complete flag */
   2266                  __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
   \       0x6A   0x2002             MOVS     R0,#+2
   \       0x6C   0x6821             LDR      R1,[R4, #+0]
   \       0x6E   0x6248             STR      R0,[R1, #+36]
   2267          
   2268                  /* Wait until the busy flag is reset to go back in idle state */
   2269                  status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
   \       0x70   0x6DE0             LDR      R0,[R4, #+92]
   \       0x72   0x9000             STR      R0,[SP, #+0]
   \       0x74   0x002B             MOVS     R3,R5
   \       0x76   0x2200             MOVS     R2,#+0
   \       0x78   0x2120             MOVS     R1,#+32
   \       0x7A   0x0020             MOVS     R0,R4
   \       0x7C   0x.... 0x....      BL       OSPI_WaitFlagStateUntilTimeout
   \       0x80   0x0006             MOVS     R6,R0
   2270          
   2271                  if (status == HAL_OK)
   \       0x82   0x0030             MOVS     R0,R6
   \       0x84   0xB2C0             UXTB     R0,R0
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD108             BNE.N    ??HAL_OSPI_Abort_3
   2272                  {
   2273                    /* Update state */
   2274                    hospi->State = HAL_OSPI_STATE_READY;
   \       0x8A   0x2002             MOVS     R0,#+2
   \       0x8C   0x6560             STR      R0,[R4, #+84]
   \       0x8E   0xE005             B.N      ??HAL_OSPI_Abort_3
   2275                  }
   2276                }
   2277              }
   2278              else
   2279              {
   2280                /* Update state */
   2281                hospi->State = HAL_OSPI_STATE_READY;
   \                     ??HAL_OSPI_Abort_2: (+1)
   \       0x90   0x2002             MOVS     R0,#+2
   \       0x92   0x6560             STR      R0,[R4, #+84]
   \       0x94   0xE002             B.N      ??HAL_OSPI_Abort_3
   2282              }
   2283            }
   2284            else
   2285            {
   2286              status = HAL_ERROR;
   \                     ??HAL_OSPI_Abort_0: (+1)
   \       0x96   0x2601             MOVS     R6,#+1
   2287              hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
   \       0x98   0x2010             MOVS     R0,#+16
   \       0x9A   0x65A0             STR      R0,[R4, #+88]
   2288            }
   2289          
   2290            /* Return function status */
   2291            return status;
   \                     ??HAL_OSPI_Abort_3: (+1)
   \       0x9C   0x0030             MOVS     R0,R6
   \       0x9E   0xB2C0             UXTB     R0,R0
   \       0xA0   0xBD76             POP      {R1,R2,R4-R6,PC}
   2292          }
   2293          
   2294          /**
   2295          * @brief  Abort the current transmission (non-blocking function)
   2296          * @param  hospi : OSPI handle
   2297          * @retval HAL status
   2298          */

   \                                 In section .text, align 2, keep-with-next
   2299          HAL_StatusTypeDef HAL_OSPI_Abort_IT(OSPI_HandleTypeDef *hospi)
   2300          {
   \                     HAL_OSPI_Abort_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2301            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
   2302            uint32_t state;
   2303          
   2304            /* Check if the state is in one of the busy or configured states */
   2305            state = hospi->State;
   \        0x6   0x6D60             LDR      R0,[R4, #+84]
   2306            if (((state & OSPI_BUSY_STATE_MASK) != 0U) || ((state & OSPI_CFG_STATE_MASK) != 0U))
   \        0x8   0xF010 0x0F0C      TST      R0,#0xC
   \        0xC   0xD03B             BEQ.N    ??HAL_OSPI_Abort_IT_0
   2307            {
   2308              /* Disable all interrupts */
   2309              __HAL_OSPI_DISABLE_IT(hospi, (HAL_OSPI_IT_TO | HAL_OSPI_IT_SM | HAL_OSPI_IT_FT | HAL_OSPI_IT_TC | HAL_OSPI_IT_TE));
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0xF430 0x10F8      BICS     R0,R0,#0x1F0000
   \       0x16   0x6821             LDR      R1,[R4, #+0]
   \       0x18   0x6008             STR      R0,[R1, #+0]
   2310          
   2311              /* Update state */
   2312              hospi->State = HAL_OSPI_STATE_ABORT;
   \       0x1A   0xF44F 0x7080      MOV      R0,#+256
   \       0x1E   0x6560             STR      R0,[R4, #+84]
   2313          
   2314              /* Check if the DMA is enabled */
   2315              if ((hospi->Instance->CR & OCTOSPI_CR_DMAEN) != 0U)
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x6800             LDR      R0,[R0, #+0]
   \       0x24   0x0740             LSLS     R0,R0,#+29
   \       0x26   0xD514             BPL.N    ??HAL_OSPI_Abort_IT_1
   2316              {
   2317                /* Disable the DMA transfer on the OctoSPI side */
   2318                CLEAR_BIT(hospi->Instance->CR, OCTOSPI_CR_DMAEN);
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x6008             STR      R0,[R1, #+0]
   2319          
   2320                /* Disable the DMA transfer on the DMA side */
   2321                hospi->hmdma->XferAbortCallback = OSPI_DMAAbortCplt;
   \       0x34   0x.... 0x....      ADR.W    R0,OSPI_DMAAbortCplt
   \       0x38   0x6D21             LDR      R1,[R4, #+80]
   \       0x3A   0x6588             STR      R0,[R1, #+88]
   2322                if (HAL_MDMA_Abort_IT(hospi->hmdma) != HAL_OK)
   \       0x3C   0x6D20             LDR      R0,[R4, #+80]
   \       0x3E   0x.... 0x....      BL       HAL_MDMA_Abort_IT
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD022             BEQ.N    ??HAL_OSPI_Abort_IT_2
   2323                {
   2324                  /* Update state */
   2325                  hospi->State = HAL_OSPI_STATE_READY;
   \       0x46   0x2002             MOVS     R0,#+2
   \       0x48   0x6560             STR      R0,[R4, #+84]
   2326          
   2327                  /* Abort callback */
   2328          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
   2329                  hospi->AbortCpltCallback(hospi);
   2330          #else
   2331                  HAL_OSPI_AbortCpltCallback(hospi);
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x.... 0x....      BL       HAL_OSPI_AbortCpltCallback
   \       0x50   0xE01C             B.N      ??HAL_OSPI_Abort_IT_2
   2332          #endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)*/
   2333                }
   2334              }
   2335              else
   2336              {
   2337                if (__HAL_OSPI_GET_FLAG(hospi, HAL_OSPI_FLAG_BUSY) != RESET)
   \                     ??HAL_OSPI_Abort_IT_1: (+1)
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x6A00             LDR      R0,[R0, #+32]
   \       0x56   0x0680             LSLS     R0,R0,#+26
   \       0x58   0xD50F             BPL.N    ??HAL_OSPI_Abort_IT_3
   2338                {
   2339                  /* Clear transfer complete flag */
   2340                  __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
   \       0x5A   0x2002             MOVS     R0,#+2
   \       0x5C   0x6821             LDR      R1,[R4, #+0]
   \       0x5E   0x6248             STR      R0,[R1, #+36]
   2341          
   2342                  /* Enable the transfer complete interrupts */
   2343                  __HAL_OSPI_ENABLE_IT(hospi, HAL_OSPI_IT_TC);
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x6800             LDR      R0,[R0, #+0]
   \       0x64   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \       0x68   0x6821             LDR      R1,[R4, #+0]
   \       0x6A   0x6008             STR      R0,[R1, #+0]
   2344          
   2345                  /* Perform an abort of the OctoSPI */
   2346                  SET_BIT(hospi->Instance->CR, OCTOSPI_CR_ABORT);
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x6800             LDR      R0,[R0, #+0]
   \       0x70   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x74   0x6821             LDR      R1,[R4, #+0]
   \       0x76   0x6008             STR      R0,[R1, #+0]
   \       0x78   0xE008             B.N      ??HAL_OSPI_Abort_IT_2
   2347                }
   2348                else
   2349                {
   2350                  /* Update state */
   2351                  hospi->State = HAL_OSPI_STATE_READY;
   \                     ??HAL_OSPI_Abort_IT_3: (+1)
   \       0x7A   0x2002             MOVS     R0,#+2
   \       0x7C   0x6560             STR      R0,[R4, #+84]
   2352          
   2353                  /* Abort callback */
   2354          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
   2355                  hospi->AbortCpltCallback(hospi);
   2356          #else
   2357                  HAL_OSPI_AbortCpltCallback(hospi);
   \       0x7E   0x0020             MOVS     R0,R4
   \       0x80   0x.... 0x....      BL       HAL_OSPI_AbortCpltCallback
   \       0x84   0xE002             B.N      ??HAL_OSPI_Abort_IT_2
   2358          #endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
   2359                }
   2360              }
   2361            }
   2362            else
   2363            {
   2364              status = HAL_ERROR;
   \                     ??HAL_OSPI_Abort_IT_0: (+1)
   \       0x86   0x2501             MOVS     R5,#+1
   2365              hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
   \       0x88   0x2010             MOVS     R0,#+16
   \       0x8A   0x65A0             STR      R0,[R4, #+88]
   2366            }
   2367          
   2368            /* Return function status */
   2369            return status;
   \                     ??HAL_OSPI_Abort_IT_2: (+1)
   \       0x8C   0x0028             MOVS     R0,R5
   \       0x8E   0xB2C0             UXTB     R0,R0
   \       0x90   0xBD32             POP      {R1,R4,R5,PC}
   2370          }
   2371          
   2372          /** @brief  Set OSPI Fifo threshold.
   2373            * @param  hospi     : OSPI handle.
   2374            * @param  Threshold : Threshold of the Fifo.
   2375            * @retval HAL status
   2376            */

   \                                 In section .text, align 2, keep-with-next
   2377          HAL_StatusTypeDef HAL_OSPI_SetFifoThreshold(OSPI_HandleTypeDef *hospi, uint32_t Threshold)
   2378          {
   \                     HAL_OSPI_SetFifoThreshold: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   2379            HAL_StatusTypeDef status = HAL_OK;
   \        0x2   0x2000             MOVS     R0,#+0
   2380          
   2381            /* Check the state */
   2382            if ((hospi->State & OSPI_BUSY_STATE_MASK) == 0U)
   \        0x4   0x6D53             LDR      R3,[R2, #+84]
   \        0x6   0x071B             LSLS     R3,R3,#+28
   \        0x8   0xD40B             BMI.N    ??HAL_OSPI_SetFifoThreshold_0
   2383            {
   2384              /* Synchronize initialization structure with the new fifo threshold value */
   2385              hospi->Init.FifoThreshold = Threshold;
   \        0xA   0x6051             STR      R1,[R2, #+4]
   2386          
   2387              /* Configure new fifo threshold */
   2388              MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FTHRES, ((hospi->Init.FifoThreshold-1U) << OCTOSPI_CR_FTHRES_Pos));
   \        0xC   0x6811             LDR      R1,[R2, #+0]
   \        0xE   0x6809             LDR      R1,[R1, #+0]
   \       0x10   0xF431 0x51F8      BICS     R1,R1,#0x1F00
   \       0x14   0x6853             LDR      R3,[R2, #+4]
   \       0x16   0x1E5B             SUBS     R3,R3,#+1
   \       0x18   0xEA51 0x2103      ORRS     R1,R1,R3, LSL #+8
   \       0x1C   0x6812             LDR      R2,[R2, #+0]
   \       0x1E   0x6011             STR      R1,[R2, #+0]
   \       0x20   0xE002             B.N      ??HAL_OSPI_SetFifoThreshold_1
   2389          
   2390            }
   2391            else
   2392            {
   2393              status = HAL_ERROR;
   \                     ??HAL_OSPI_SetFifoThreshold_0: (+1)
   \       0x22   0x2001             MOVS     R0,#+1
   2394              hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
   \       0x24   0x2110             MOVS     R1,#+16
   \       0x26   0x6591             STR      R1,[R2, #+88]
   2395            }
   2396          
   2397            /* Return function status */
   2398            return status;
   \                     ??HAL_OSPI_SetFifoThreshold_1: (+1)
   \       0x28   0xB2C0             UXTB     R0,R0
   \       0x2A   0x4770             BX       LR
   2399          }
   2400          
   2401          /** @brief  Get OSPI Fifo threshold.
   2402            * @param  hospi : OSPI handle.
   2403            * @retval Fifo threshold
   2404            */

   \                                 In section .text, align 2, keep-with-next
   2405          uint32_t HAL_OSPI_GetFifoThreshold(OSPI_HandleTypeDef *hospi)
   2406          {
   2407            return ((READ_BIT(hospi->Instance->CR, OCTOSPI_CR_FTHRES) >> OCTOSPI_CR_FTHRES_Pos) + 1U);
   \                     HAL_OSPI_GetFifoThreshold: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0xF3C0 0x2004      UBFX     R0,R0,#+8,#+5
   \        0x8   0x1C40             ADDS     R0,R0,#+1
   \        0xA   0x4770             BX       LR
   2408          }
   2409          
   2410          /** @brief Set OSPI timeout.
   2411            * @param  hospi   : OSPI handle.
   2412            * @param  Timeout : Timeout for the memory access.
   2413            * @retval None
   2414            */

   \                                 In section .text, align 2, keep-with-next
   2415          HAL_StatusTypeDef HAL_OSPI_SetTimeout(OSPI_HandleTypeDef *hospi, uint32_t Timeout)
   2416          {
   2417            hospi->Timeout = Timeout;
   \                     HAL_OSPI_SetTimeout: (+1)
   \        0x0   0x65C1             STR      R1,[R0, #+92]
   2418            return HAL_OK;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x4770             BX       LR
   2419          }
   2420          
   2421          /**
   2422          * @brief  Return the OSPI error code.
   2423          * @param  hospi : OSPI handle
   2424          * @retval OSPI Error Code
   2425          */

   \                                 In section .text, align 2, keep-with-next
   2426          uint32_t HAL_OSPI_GetError(OSPI_HandleTypeDef *hospi)
   2427          {
   2428            return hospi->ErrorCode;
   \                     HAL_OSPI_GetError: (+1)
   \        0x0   0x6D80             LDR      R0,[R0, #+88]
   \        0x2   0x4770             BX       LR
   2429          }
   2430          
   2431          /**
   2432            * @brief  Return the OSPI handle state.
   2433            * @param  hospi : OSPI handle
   2434            * @retval HAL state
   2435            */

   \                                 In section .text, align 2, keep-with-next
   2436          uint32_t HAL_OSPI_GetState(OSPI_HandleTypeDef *hospi)
   2437          {
   2438            /* Return OSPI handle state */
   2439            return hospi->State;
   \                     HAL_OSPI_GetState: (+1)
   \        0x0   0x6D40             LDR      R0,[R0, #+84]
   \        0x2   0x4770             BX       LR
   2440          }
   2441          
   2442          /**
   2443            * @}
   2444            */
   2445          
   2446          /** @defgroup OSPI_Exported_Functions_Group4 IO Manager configuration function
   2447            *  @brief   OSPI IO Manager configuration function
   2448            *
   2449          @verbatim
   2450           ===============================================================================
   2451                            ##### IO Manager configuration function #####
   2452           ===============================================================================
   2453              [..]
   2454              This subsection provides a set of functions allowing to :
   2455                (+) Configure the IO manager.
   2456          
   2457          @endverbatim
   2458            * @{
   2459            */
   2460          
   2461          /**
   2462            * @brief  Configure the OctoSPI IO manager.
   2463            * @param  hospi   : OSPI handle
   2464            * @param  cfg     : Configuration of the IO Manager for the instance
   2465            * @param  Timeout : Timeout duration
   2466            * @retval HAL status
   2467            */

   \                                 In section .text, align 2, keep-with-next
   2468          HAL_StatusTypeDef HAL_OSPIM_Config(OSPI_HandleTypeDef *hospi, OSPIM_CfgTypeDef *cfg, uint32_t Timeout)
   2469          {
   \                     HAL_OSPIM_Config: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB08C             SUB      SP,SP,#+48
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x000C             MOVS     R4,R1
   2470            HAL_StatusTypeDef status = HAL_OK;
   \        0xA   0xF05F 0x0800      MOVS     R8,#+0
   2471            uint32_t instance;
   2472            uint8_t index;
   2473            uint8_t ospi_enabled = 0U;
   \        0xE   0xF05F 0x0900      MOVS     R9,#+0
   2474            uint8_t other_instance;
   2475            OSPIM_CfgTypeDef IOM_cfg[OSPI_NB_INSTANCE];
   2476          
   2477            /* Prevent unused argument(s) compilation warning */
   2478            UNUSED(Timeout);
   2479          
   2480            /* Check the parameters of the OctoSPI IO Manager configuration structure */
   2481            assert_param(IS_OSPIM_PORT(cfg->ClkPort));
   2482            assert_param(IS_OSPIM_DQS_PORT(cfg->DQSPort));
   2483            assert_param(IS_OSPIM_PORT(cfg->NCSPort));
   2484            assert_param(IS_OSPIM_IO_PORT(cfg->IOLowPort));
   2485            assert_param(IS_OSPIM_IO_PORT(cfg->IOHighPort));
   2486            assert_param(IS_OSPIM_REQ2ACKTIME(cfg->Req2AckTime));
   2487          
   2488            if (hospi->Instance == OCTOSPI1)
   \       0x12   0x.... 0x....      LDR.W    R5,??DataTable7_1
   \       0x16   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x1A   0x42A8             CMP      R0,R5
   \       0x1C   0xD102             BNE.N    ??HAL_OSPIM_Config_0
   2489            {
   2490              instance = 0U;
   \       0x1E   0x2600             MOVS     R6,#+0
   2491              other_instance = 1U;
   \       0x20   0x2701             MOVS     R7,#+1
   \       0x22   0xE001             B.N      ??HAL_OSPIM_Config_1
   2492            }
   2493            else
   2494            {
   2495              instance = 1U;
   \                     ??HAL_OSPIM_Config_0: (+1)
   \       0x24   0x2601             MOVS     R6,#+1
   2496              other_instance = 0U;
   \       0x26   0x2700             MOVS     R7,#+0
   2497            }
   2498          
   2499            /**************** Get current configuration of the instances ****************/
   2500            for (index = 0U; index < OSPI_NB_INSTANCE; index++)
   \                     ??HAL_OSPIM_Config_1: (+1)
   \       0x28   0xF05F 0x0B00      MOVS     R11,#+0
   \       0x2C   0xE013             B.N      ??HAL_OSPIM_Config_2
   2501            {
   2502              if (OSPIM_GetConfig(index+1U, &(IOM_cfg[index])) != HAL_OK)
   \                     ??HAL_OSPIM_Config_3: (+1)
   \       0x2E   0x4669             MOV      R1,SP
   \       0x30   0x465A             MOV      R2,R11
   \       0x32   0xB2D2             UXTB     R2,R2
   \       0x34   0x2018             MOVS     R0,#+24
   \       0x36   0x4342             MULS     R2,R0,R2
   \       0x38   0x4411             ADD      R1,R1,R2
   \       0x3A   0xF11B 0x0001      ADDS     R0,R11,#+1
   \       0x3E   0xB2C0             UXTB     R0,R0
   \       0x40   0x.... 0x....      BL       OSPIM_GetConfig
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD004             BEQ.N    ??HAL_OSPIM_Config_4
   2503              {
   2504                status = HAL_ERROR;
   \       0x48   0xF05F 0x0801      MOVS     R8,#+1
   2505                hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
   \       0x4C   0x2008             MOVS     R0,#+8
   \       0x4E   0xF8CA 0x0058      STR      R0,[R10, #+88]
   2506              }
   2507            }
   \                     ??HAL_OSPIM_Config_4: (+1)
   \       0x52   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \                     ??HAL_OSPIM_Config_2: (+1)
   \       0x56   0x4658             MOV      R0,R11
   \       0x58   0xB2C0             UXTB     R0,R0
   \       0x5A   0x2802             CMP      R0,#+2
   \       0x5C   0xD3E7             BCC.N    ??HAL_OSPIM_Config_3
   2508          
   2509            if (status == HAL_OK)
   \       0x5E   0x4640             MOV      R0,R8
   \       0x60   0xB2C0             UXTB     R0,R0
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xF040 0x8374      BNE.W    ??HAL_OSPIM_Config_5
   2510            {
   2511              /********** Disable both OctoSPI to configure OctoSPI IO Manager **********/
   2512              if ((OCTOSPI1->CR & OCTOSPI_CR_EN) != 0U)
   \       0x68   0x6828             LDR      R0,[R5, #+0]
   \       0x6A   0x07C0             LSLS     R0,R0,#+31
   \       0x6C   0xD505             BPL.N    ??HAL_OSPIM_Config_6
   2513              {
   2514                CLEAR_BIT(OCTOSPI1->CR, OCTOSPI_CR_EN);
   \       0x6E   0x6828             LDR      R0,[R5, #+0]
   \       0x70   0x0840             LSRS     R0,R0,#+1
   \       0x72   0x0040             LSLS     R0,R0,#+1
   \       0x74   0x6028             STR      R0,[R5, #+0]
   2515                ospi_enabled |= 0x1U;
   \       0x76   0xF059 0x0901      ORRS     R9,R9,#0x1
   2516              }
   2517              if ((OCTOSPI2->CR & OCTOSPI_CR_EN) != 0U)
   \                     ??HAL_OSPIM_Config_6: (+1)
   \       0x7A   0x.... 0x....      LDR.W    R1,??DataTable7_2
   \       0x7E   0x6808             LDR      R0,[R1, #+0]
   \       0x80   0x07C0             LSLS     R0,R0,#+31
   \       0x82   0xD505             BPL.N    ??HAL_OSPIM_Config_7
   2518              {
   2519                CLEAR_BIT(OCTOSPI2->CR, OCTOSPI_CR_EN);
   \       0x84   0x6808             LDR      R0,[R1, #+0]
   \       0x86   0x0840             LSRS     R0,R0,#+1
   \       0x88   0x0040             LSLS     R0,R0,#+1
   \       0x8A   0x6008             STR      R0,[R1, #+0]
   2520                ospi_enabled |= 0x2U;
   \       0x8C   0xF059 0x0902      ORRS     R9,R9,#0x2
   2521              }
   2522          
   2523              /***************** Deactivation of previous configuration *****************/
   2524              CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].NCSPort-1U)], OCTOSPIM_PCR_NCSEN);
   \                     ??HAL_OSPIM_Config_7: (+1)
   \       0x90   0x.... 0x....      LDR.W    R2,??DataTable7_3
   \       0x94   0x2318             MOVS     R3,#+24
   \       0x96   0x4668             MOV      R0,SP
   \       0x98   0xFB03 0xFC06      MUL      R12,R3,R6
   \       0x9C   0x4460             ADD      R0,R0,R12
   \       0x9E   0x6880             LDR      R0,[R0, #+8]
   \       0xA0   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \       0xA4   0x46EC             MOV      R12,SP
   \       0xA6   0xFB03 0xFE06      MUL      LR,R3,R6
   \       0xAA   0x44F4             ADD      R12,R12,LR
   \       0xAC   0xF8DC 0xC008      LDR      R12,[R12, #+8]
   \       0xB0   0xEB02 0x0C8C      ADD      R12,R2,R12, LSL #+2
   \       0xB4   0xF85C 0xCC04      LDR      R12,[R12, #+4294967292]
   \       0xB8   0xF43C 0x7C80      BICS     R12,R12,#0x100
   \       0xBC   0xF840 0xCC04      STR      R12,[R0, #+4294967292]
   2525              if ((OCTOSPIM->CR & OCTOSPIM_CR_MUXEN) != 0U)
   \       0xC0   0x.... 0x....      LDR.W    R12,??DataTable7_4
   \       0xC4   0xF8DC 0x0000      LDR      R0,[R12, #+0]
   \       0xC8   0x07C0             LSLS     R0,R0,#+31
   \       0xCA   0xF140 0x809B      BPL.W    ??HAL_OSPIM_Config_8
   2526              {
   2527                /* De-multiplexing should be performed */
   2528                CLEAR_BIT(OCTOSPIM->CR, OCTOSPIM_CR_MUXEN);
   \       0xCE   0xF8DC 0x0000      LDR      R0,[R12, #+0]
   \       0xD2   0x0840             LSRS     R0,R0,#+1
   \       0xD4   0x0040             LSLS     R0,R0,#+1
   \       0xD6   0xF8CC 0x0000      STR      R0,[R12, #+0]
   2529          
   2530                if (other_instance == 1U)
   \       0xDA   0x0038             MOVS     R0,R7
   \       0xDC   0xB2C0             UXTB     R0,R0
   \       0xDE   0x2801             CMP      R0,#+1
   \       0xE0   0xF040 0x8105      BNE.W    ??HAL_OSPIM_Config_9
   2531                {
   2532                  SET_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].ClkPort-1U)], OCTOSPIM_PCR_CLKSRC);
   \       0xE4   0x4668             MOV      R0,SP
   \       0xE6   0x46BE             MOV      LR,R7
   \       0xE8   0xFA5F 0xFE8E      UXTB     LR,LR
   \       0xEC   0xFB03 0xFE0E      MUL      LR,R3,LR
   \       0xF0   0xF850 0xE00E      LDR      LR,[R0, LR]
   \       0xF4   0xEB02 0x0E8E      ADD      LR,R2,LR, LSL #+2
   \       0xF8   0x46BA             MOV      R10,R7
   \       0xFA   0xFA5F 0xFA8A      UXTB     R10,R10
   \       0xFE   0xFB03 0xFA0A      MUL      R10,R3,R10
   \      0x102   0xF850 0x000A      LDR      R0,[R0, R10]
   \      0x106   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \      0x10A   0xF850 0x0C04      LDR      R0,[R0, #+4294967292]
   \      0x10E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \      0x112   0xF84E 0x0C04      STR      R0,[LR, #+4294967292]
   2533                  if (IOM_cfg[other_instance].DQSPort != 0U)
   \      0x116   0x4668             MOV      R0,SP
   \      0x118   0x46BE             MOV      LR,R7
   \      0x11A   0xFA5F 0xFE8E      UXTB     LR,LR
   \      0x11E   0xFB03 0xFE0E      MUL      LR,R3,LR
   \      0x122   0x4470             ADD      R0,R0,LR
   \      0x124   0x6840             LDR      R0,[R0, #+4]
   \      0x126   0x2800             CMP      R0,#+0
   \      0x128   0xD01A             BEQ.N    ??HAL_OSPIM_Config_10
   2534                  {
   2535                    SET_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].DQSPort-1U)], OCTOSPIM_PCR_DQSSRC);
   \      0x12A   0x4668             MOV      R0,SP
   \      0x12C   0x46BE             MOV      LR,R7
   \      0x12E   0xFA5F 0xFE8E      UXTB     LR,LR
   \      0x132   0xFB03 0xFE0E      MUL      LR,R3,LR
   \      0x136   0x4470             ADD      R0,R0,LR
   \      0x138   0x6840             LDR      R0,[R0, #+4]
   \      0x13A   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \      0x13E   0x46EE             MOV      LR,SP
   \      0x140   0x46BA             MOV      R10,R7
   \      0x142   0xFA5F 0xFA8A      UXTB     R10,R10
   \      0x146   0xFB03 0xFA0A      MUL      R10,R3,R10
   \      0x14A   0x44D6             ADD      LR,LR,R10
   \      0x14C   0xF8DE 0xE004      LDR      LR,[LR, #+4]
   \      0x150   0xEB02 0x0E8E      ADD      LR,R2,LR, LSL #+2
   \      0x154   0xF85E 0xEC04      LDR      LR,[LR, #+4294967292]
   \      0x158   0xF05E 0x0E20      ORRS     LR,LR,#0x20
   \      0x15C   0xF840 0xEC04      STR      LR,[R0, #+4294967292]
   2536                  }
   2537                  if (IOM_cfg[other_instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
   \                     ??HAL_OSPIM_Config_10: (+1)
   \      0x160   0x4668             MOV      R0,SP
   \      0x162   0x46BE             MOV      LR,R7
   \      0x164   0xFA5F 0xFE8E      UXTB     LR,LR
   \      0x168   0xFB03 0xFE0E      MUL      LR,R3,LR
   \      0x16C   0x4470             ADD      R0,R0,LR
   \      0x16E   0x68C0             LDR      R0,[R0, #+12]
   \      0x170   0x2800             CMP      R0,#+0
   \      0x172   0xD01D             BEQ.N    ??HAL_OSPIM_Config_11
   2538                  {
   2539                    SET_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOLowPort-1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOLSRC_1);
   \      0x174   0x4668             MOV      R0,SP
   \      0x176   0x46BE             MOV      LR,R7
   \      0x178   0xFA5F 0xFE8E      UXTB     LR,LR
   \      0x17C   0xFB03 0xFE0E      MUL      LR,R3,LR
   \      0x180   0x4470             ADD      R0,R0,LR
   \      0x182   0x68C0             LDR      R0,[R0, #+12]
   \      0x184   0x1E40             SUBS     R0,R0,#+1
   \      0x186   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x18A   0x46EE             MOV      LR,SP
   \      0x18C   0x46BA             MOV      R10,R7
   \      0x18E   0xFA5F 0xFA8A      UXTB     R10,R10
   \      0x192   0xFB03 0xFA0A      MUL      R10,R3,R10
   \      0x196   0x44D6             ADD      LR,LR,R10
   \      0x198   0xF8DE 0xE00C      LDR      LR,[LR, #+12]
   \      0x19C   0xF1BE 0x0E01      SUBS     LR,LR,#+1
   \      0x1A0   0xF01E 0x0E01      ANDS     LR,LR,#0x1
   \      0x1A4   0xF852 0xE02E      LDR      LR,[R2, LR, LSL #+2]
   \      0x1A8   0xF45E 0x2E80      ORRS     LR,LR,#0x40000
   \      0x1AC   0xF842 0xE020      STR      LR,[R2, R0, LSL #+2]
   2540                  }
   2541                  if (IOM_cfg[other_instance].IOHighPort != HAL_OSPIM_IOPORT_NONE)
   \                     ??HAL_OSPIM_Config_11: (+1)
   \      0x1B0   0x4668             MOV      R0,SP
   \      0x1B2   0x46BE             MOV      LR,R7
   \      0x1B4   0xFA5F 0xFE8E      UXTB     LR,LR
   \      0x1B8   0xFB03 0xFE0E      MUL      LR,R3,LR
   \      0x1BC   0x4470             ADD      R0,R0,LR
   \      0x1BE   0x6900             LDR      R0,[R0, #+16]
   \      0x1C0   0x2800             CMP      R0,#+0
   \      0x1C2   0xF000 0x8094      BEQ.W    ??HAL_OSPIM_Config_9
   2542                  {
   2543                    SET_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOHighPort-1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOHSRC_1);
   \      0x1C6   0x4668             MOV      R0,SP
   \      0x1C8   0x46BE             MOV      LR,R7
   \      0x1CA   0xFA5F 0xFE8E      UXTB     LR,LR
   \      0x1CE   0xFB03 0xFE0E      MUL      LR,R3,LR
   \      0x1D2   0x4470             ADD      R0,R0,LR
   \      0x1D4   0x6900             LDR      R0,[R0, #+16]
   \      0x1D6   0x1E40             SUBS     R0,R0,#+1
   \      0x1D8   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x1DC   0x46EE             MOV      LR,SP
   \      0x1DE   0x46BA             MOV      R10,R7
   \      0x1E0   0xFA5F 0xFA8A      UXTB     R10,R10
   \      0x1E4   0xFB03 0xFA0A      MUL      R10,R3,R10
   \      0x1E8   0x44D6             ADD      LR,LR,R10
   \      0x1EA   0xF8DE 0xE010      LDR      LR,[LR, #+16]
   \      0x1EE   0xF1BE 0x0E01      SUBS     LR,LR,#+1
   \      0x1F2   0xF01E 0x0E01      ANDS     LR,LR,#0x1
   \      0x1F6   0xF852 0xE02E      LDR      LR,[R2, LR, LSL #+2]
   \      0x1FA   0xF05E 0x6E80      ORRS     LR,LR,#0x4000000
   \      0x1FE   0xF842 0xE020      STR      LR,[R2, R0, LSL #+2]
   \      0x202   0xE074             B.N      ??HAL_OSPIM_Config_9
   2544                  }
   2545                }
   2546              }
   2547              else
   2548              {
   2549                if (IOM_cfg[instance].ClkPort != 0U)
   \                     ??HAL_OSPIM_Config_8: (+1)
   \      0x204   0x46EE             MOV      LR,SP
   \      0x206   0xFB03 0xF006      MUL      R0,R3,R6
   \      0x20A   0xF85E 0x0000      LDR      R0,[LR, R0]
   \      0x20E   0x2800             CMP      R0,#+0
   \      0x210   0xD06D             BEQ.N    ??HAL_OSPIM_Config_9
   2550                {
   2551                  CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].ClkPort-1U)], OCTOSPIM_PCR_CLKEN);
   \      0x212   0xFB03 0xF006      MUL      R0,R3,R6
   \      0x216   0xF85E 0x0000      LDR      R0,[LR, R0]
   \      0x21A   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \      0x21E   0xFB03 0xFA06      MUL      R10,R3,R6
   \      0x222   0xF85E 0xE00A      LDR      LR,[LR, R10]
   \      0x226   0xEB02 0x0E8E      ADD      LR,R2,LR, LSL #+2
   \      0x22A   0xF85E 0xEC04      LDR      LR,[LR, #+4294967292]
   \      0x22E   0xEA5F 0x0E5E      LSRS     LR,LR,#+1
   \      0x232   0xEA5F 0x0E4E      LSLS     LR,LR,#+1
   \      0x236   0xF840 0xEC04      STR      LR,[R0, #+4294967292]
   2552                  if (IOM_cfg[instance].DQSPort != 0U)
   \      0x23A   0x4668             MOV      R0,SP
   \      0x23C   0xFB03 0xFE06      MUL      LR,R3,R6
   \      0x240   0x4470             ADD      R0,R0,LR
   \      0x242   0x6840             LDR      R0,[R0, #+4]
   \      0x244   0x2800             CMP      R0,#+0
   \      0x246   0xD014             BEQ.N    ??HAL_OSPIM_Config_12
   2553                  {
   2554                    CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].DQSPort-1U)], OCTOSPIM_PCR_DQSEN);
   \      0x248   0x4668             MOV      R0,SP
   \      0x24A   0xFB03 0xFE06      MUL      LR,R3,R6
   \      0x24E   0x4470             ADD      R0,R0,LR
   \      0x250   0x6840             LDR      R0,[R0, #+4]
   \      0x252   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \      0x256   0x46EE             MOV      LR,SP
   \      0x258   0xFB03 0xFA06      MUL      R10,R3,R6
   \      0x25C   0x44D6             ADD      LR,LR,R10
   \      0x25E   0xF8DE 0xE004      LDR      LR,[LR, #+4]
   \      0x262   0xEB02 0x0E8E      ADD      LR,R2,LR, LSL #+2
   \      0x266   0xF85E 0xEC04      LDR      LR,[LR, #+4294967292]
   \      0x26A   0xF03E 0x0E10      BICS     LR,LR,#0x10
   \      0x26E   0xF840 0xEC04      STR      LR,[R0, #+4294967292]
   2555                  }
   2556                  if (IOM_cfg[instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
   \                     ??HAL_OSPIM_Config_12: (+1)
   \      0x272   0x4668             MOV      R0,SP
   \      0x274   0xFB03 0xFE06      MUL      LR,R3,R6
   \      0x278   0x4470             ADD      R0,R0,LR
   \      0x27A   0x68C0             LDR      R0,[R0, #+12]
   \      0x27C   0x2800             CMP      R0,#+0
   \      0x27E   0xD017             BEQ.N    ??HAL_OSPIM_Config_13
   2557                  {
   2558                    CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[instance].IOLowPort-1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOLEN);
   \      0x280   0x4668             MOV      R0,SP
   \      0x282   0xFB03 0xFE06      MUL      LR,R3,R6
   \      0x286   0x4470             ADD      R0,R0,LR
   \      0x288   0x68C0             LDR      R0,[R0, #+12]
   \      0x28A   0x1E40             SUBS     R0,R0,#+1
   \      0x28C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x290   0x46EE             MOV      LR,SP
   \      0x292   0xFB03 0xFA06      MUL      R10,R3,R6
   \      0x296   0x44D6             ADD      LR,LR,R10
   \      0x298   0xF8DE 0xE00C      LDR      LR,[LR, #+12]
   \      0x29C   0xF1BE 0x0E01      SUBS     LR,LR,#+1
   \      0x2A0   0xF01E 0x0E01      ANDS     LR,LR,#0x1
   \      0x2A4   0xF852 0xE02E      LDR      LR,[R2, LR, LSL #+2]
   \      0x2A8   0xF43E 0x3E80      BICS     LR,LR,#0x10000
   \      0x2AC   0xF842 0xE020      STR      LR,[R2, R0, LSL #+2]
   2559                  }
   2560                  if (IOM_cfg[instance].IOHighPort != HAL_OSPIM_IOPORT_NONE)
   \                     ??HAL_OSPIM_Config_13: (+1)
   \      0x2B0   0x4668             MOV      R0,SP
   \      0x2B2   0xFB03 0xFE06      MUL      LR,R3,R6
   \      0x2B6   0x4470             ADD      R0,R0,LR
   \      0x2B8   0x6900             LDR      R0,[R0, #+16]
   \      0x2BA   0x2800             CMP      R0,#+0
   \      0x2BC   0xD017             BEQ.N    ??HAL_OSPIM_Config_9
   2561                  {
   2562                    CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[instance].IOHighPort-1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOHEN);
   \      0x2BE   0x4668             MOV      R0,SP
   \      0x2C0   0xFB03 0xFE06      MUL      LR,R3,R6
   \      0x2C4   0x4470             ADD      R0,R0,LR
   \      0x2C6   0x6900             LDR      R0,[R0, #+16]
   \      0x2C8   0x1E40             SUBS     R0,R0,#+1
   \      0x2CA   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x2CE   0x46EE             MOV      LR,SP
   \      0x2D0   0xFB03 0xFA06      MUL      R10,R3,R6
   \      0x2D4   0x44D6             ADD      LR,LR,R10
   \      0x2D6   0xF8DE 0xE010      LDR      LR,[LR, #+16]
   \      0x2DA   0xF1BE 0x0E01      SUBS     LR,LR,#+1
   \      0x2DE   0xF01E 0x0E01      ANDS     LR,LR,#0x1
   \      0x2E2   0xF852 0xE02E      LDR      LR,[R2, LR, LSL #+2]
   \      0x2E6   0xF03E 0x7E80      BICS     LR,LR,#0x1000000
   \      0x2EA   0xF842 0xE020      STR      LR,[R2, R0, LSL #+2]
   2563                  }
   2564                }
   2565              }
   2566          
   2567              /********************* Deactivation of other instance *********************/
   2568              if ((cfg->ClkPort == IOM_cfg[other_instance].ClkPort) || (cfg->DQSPort == IOM_cfg[other_instance].DQSPort)     ||
   2569                  (cfg->NCSPort == IOM_cfg[other_instance].NCSPort) || (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) ||
   2570                  (cfg->IOHighPort == IOM_cfg[other_instance].IOHighPort))
   \                     ??HAL_OSPIM_Config_9: (+1)
   \      0x2EE   0x4668             MOV      R0,SP
   \      0x2F0   0xF8D4 0xE000      LDR      LR,[R4, #+0]
   \      0x2F4   0x46BA             MOV      R10,R7
   \      0x2F6   0xFA5F 0xFA8A      UXTB     R10,R10
   \      0x2FA   0xFB03 0xFA0A      MUL      R10,R3,R10
   \      0x2FE   0xF850 0xA00A      LDR      R10,[R0, R10]
   \      0x302   0x45D6             CMP      LR,R10
   \      0x304   0xD034             BEQ.N    ??HAL_OSPIM_Config_14
   \      0x306   0xF8D4 0xE004      LDR      LR,[R4, #+4]
   \      0x30A   0x46EA             MOV      R10,SP
   \      0x30C   0x46BB             MOV      R11,R7
   \      0x30E   0xFA5F 0xFB8B      UXTB     R11,R11
   \      0x312   0xFB03 0xFB0B      MUL      R11,R3,R11
   \      0x316   0x44DA             ADD      R10,R10,R11
   \      0x318   0xF8DA 0xA004      LDR      R10,[R10, #+4]
   \      0x31C   0x45D6             CMP      LR,R10
   \      0x31E   0xD027             BEQ.N    ??HAL_OSPIM_Config_14
   \      0x320   0xF8D4 0xE008      LDR      LR,[R4, #+8]
   \      0x324   0x46EA             MOV      R10,SP
   \      0x326   0x46BB             MOV      R11,R7
   \      0x328   0xFA5F 0xFB8B      UXTB     R11,R11
   \      0x32C   0xFB03 0xFB0B      MUL      R11,R3,R11
   \      0x330   0x44DA             ADD      R10,R10,R11
   \      0x332   0xF8DA 0xA008      LDR      R10,[R10, #+8]
   \      0x336   0x45D6             CMP      LR,R10
   \      0x338   0xD01A             BEQ.N    ??HAL_OSPIM_Config_14
   \      0x33A   0xF8D4 0xE00C      LDR      LR,[R4, #+12]
   \      0x33E   0x46EA             MOV      R10,SP
   \      0x340   0x46BB             MOV      R11,R7
   \      0x342   0xFA5F 0xFB8B      UXTB     R11,R11
   \      0x346   0xFB03 0xFB0B      MUL      R11,R3,R11
   \      0x34A   0x44DA             ADD      R10,R10,R11
   \      0x34C   0xF8DA 0xA00C      LDR      R10,[R10, #+12]
   \      0x350   0x45D6             CMP      LR,R10
   \      0x352   0xD00D             BEQ.N    ??HAL_OSPIM_Config_14
   \      0x354   0xF8D4 0xE010      LDR      LR,[R4, #+16]
   \      0x358   0x46EA             MOV      R10,SP
   \      0x35A   0x46BB             MOV      R11,R7
   \      0x35C   0xFA5F 0xFB8B      UXTB     R11,R11
   \      0x360   0xFB03 0xFB0B      MUL      R11,R3,R11
   \      0x364   0x44DA             ADD      R10,R10,R11
   \      0x366   0xF8DA 0xA010      LDR      R10,[R10, #+16]
   \      0x36A   0x45D6             CMP      LR,R10
   \      0x36C   0xF040 0x80DD      BNE.W    ??HAL_OSPIM_Config_15
   2571              {
   2572                if ((cfg->ClkPort   == IOM_cfg[other_instance].ClkPort)   &&
   2573                    (cfg->DQSPort    == IOM_cfg[other_instance].DQSPort)  &&
   2574                    (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) &&
   2575                    (cfg->IOHighPort == IOM_cfg[other_instance].IOHighPort))
   \                     ??HAL_OSPIM_Config_14: (+1)
   \      0x370   0xF8D4 0xE000      LDR      LR,[R4, #+0]
   \      0x374   0x46BA             MOV      R10,R7
   \      0x376   0xFA5F 0xFA8A      UXTB     R10,R10
   \      0x37A   0xFB03 0xFA0A      MUL      R10,R3,R10
   \      0x37E   0xF850 0xA00A      LDR      R10,[R0, R10]
   \      0x382   0x45D6             CMP      LR,R10
   \      0x384   0xD12D             BNE.N    ??HAL_OSPIM_Config_16
   \      0x386   0xF8D4 0xE004      LDR      LR,[R4, #+4]
   \      0x38A   0x46EA             MOV      R10,SP
   \      0x38C   0x46BB             MOV      R11,R7
   \      0x38E   0xFA5F 0xFB8B      UXTB     R11,R11
   \      0x392   0xFB03 0xFB0B      MUL      R11,R3,R11
   \      0x396   0x44DA             ADD      R10,R10,R11
   \      0x398   0xF8DA 0xA004      LDR      R10,[R10, #+4]
   \      0x39C   0x45D6             CMP      LR,R10
   \      0x39E   0xD120             BNE.N    ??HAL_OSPIM_Config_16
   \      0x3A0   0xF8D4 0xE00C      LDR      LR,[R4, #+12]
   \      0x3A4   0x46EA             MOV      R10,SP
   \      0x3A6   0x46BB             MOV      R11,R7
   \      0x3A8   0xFA5F 0xFB8B      UXTB     R11,R11
   \      0x3AC   0xFB03 0xFB0B      MUL      R11,R3,R11
   \      0x3B0   0x44DA             ADD      R10,R10,R11
   \      0x3B2   0xF8DA 0xA00C      LDR      R10,[R10, #+12]
   \      0x3B6   0x45D6             CMP      LR,R10
   \      0x3B8   0xD113             BNE.N    ??HAL_OSPIM_Config_16
   \      0x3BA   0xF8D4 0xE010      LDR      LR,[R4, #+16]
   \      0x3BE   0x46EA             MOV      R10,SP
   \      0x3C0   0x46BB             MOV      R11,R7
   \      0x3C2   0xFA5F 0xFB8B      UXTB     R11,R11
   \      0x3C6   0xFB03 0xFB0B      MUL      R11,R3,R11
   \      0x3CA   0x44DA             ADD      R10,R10,R11
   \      0x3CC   0xF8DA 0xA010      LDR      R10,[R10, #+16]
   \      0x3D0   0x45D6             CMP      LR,R10
   \      0x3D2   0xD106             BNE.N    ??HAL_OSPIM_Config_16
   2576                {
   2577                  /* Multiplexing should be performed */
   2578                  SET_BIT(OCTOSPIM->CR, OCTOSPIM_CR_MUXEN);
   \      0x3D4   0xF8DC 0x0000      LDR      R0,[R12, #+0]
   \      0x3D8   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x3DC   0xF8CC 0x0000      STR      R0,[R12, #+0]
   \      0x3E0   0xE0A3             B.N      ??HAL_OSPIM_Config_15
   2579                }
   2580                else
   2581                {
   2582                  CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].ClkPort-1U)], OCTOSPIM_PCR_CLKEN);
   \                     ??HAL_OSPIM_Config_16: (+1)
   \      0x3E2   0x46BE             MOV      LR,R7
   \      0x3E4   0xFA5F 0xFE8E      UXTB     LR,LR
   \      0x3E8   0xFB03 0xFE0E      MUL      LR,R3,LR
   \      0x3EC   0xF850 0xE00E      LDR      LR,[R0, LR]
   \      0x3F0   0xEB02 0x0E8E      ADD      LR,R2,LR, LSL #+2
   \      0x3F4   0x46BA             MOV      R10,R7
   \      0x3F6   0xFA5F 0xFA8A      UXTB     R10,R10
   \      0x3FA   0xFB03 0xFA0A      MUL      R10,R3,R10
   \      0x3FE   0xF850 0x000A      LDR      R0,[R0, R10]
   \      0x402   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \      0x406   0xF850 0x0C04      LDR      R0,[R0, #+4294967292]
   \      0x40A   0x0840             LSRS     R0,R0,#+1
   \      0x40C   0x0040             LSLS     R0,R0,#+1
   \      0x40E   0xF84E 0x0C04      STR      R0,[LR, #+4294967292]
   2583                  if (IOM_cfg[other_instance].DQSPort != 0U)
   \      0x412   0x4668             MOV      R0,SP
   \      0x414   0x46BE             MOV      LR,R7
   \      0x416   0xFA5F 0xFE8E      UXTB     LR,LR
   \      0x41A   0xFB03 0xFE0E      MUL      LR,R3,LR
   \      0x41E   0x4470             ADD      R0,R0,LR
   \      0x420   0x6840             LDR      R0,[R0, #+4]
   \      0x422   0x2800             CMP      R0,#+0
   \      0x424   0xD01A             BEQ.N    ??HAL_OSPIM_Config_17
   2584                  {
   2585                    CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].DQSPort-1U)], OCTOSPIM_PCR_DQSEN);
   \      0x426   0x4668             MOV      R0,SP
   \      0x428   0x46BE             MOV      LR,R7
   \      0x42A   0xFA5F 0xFE8E      UXTB     LR,LR
   \      0x42E   0xFB03 0xFE0E      MUL      LR,R3,LR
   \      0x432   0x4470             ADD      R0,R0,LR
   \      0x434   0x6840             LDR      R0,[R0, #+4]
   \      0x436   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \      0x43A   0x46EE             MOV      LR,SP
   \      0x43C   0x46BA             MOV      R10,R7
   \      0x43E   0xFA5F 0xFA8A      UXTB     R10,R10
   \      0x442   0xFB03 0xFA0A      MUL      R10,R3,R10
   \      0x446   0x44D6             ADD      LR,LR,R10
   \      0x448   0xF8DE 0xE004      LDR      LR,[LR, #+4]
   \      0x44C   0xEB02 0x0E8E      ADD      LR,R2,LR, LSL #+2
   \      0x450   0xF85E 0xEC04      LDR      LR,[LR, #+4294967292]
   \      0x454   0xF03E 0x0E10      BICS     LR,LR,#0x10
   \      0x458   0xF840 0xEC04      STR      LR,[R0, #+4294967292]
   2586                  }
   2587                  CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].NCSPort-1U)], OCTOSPIM_PCR_NCSEN);
   \                     ??HAL_OSPIM_Config_17: (+1)
   \      0x45C   0x4668             MOV      R0,SP
   \      0x45E   0x46BE             MOV      LR,R7
   \      0x460   0xFA5F 0xFE8E      UXTB     LR,LR
   \      0x464   0xFB03 0xFE0E      MUL      LR,R3,LR
   \      0x468   0x4470             ADD      R0,R0,LR
   \      0x46A   0x6880             LDR      R0,[R0, #+8]
   \      0x46C   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \      0x470   0x46EE             MOV      LR,SP
   \      0x472   0x46BA             MOV      R10,R7
   \      0x474   0xFA5F 0xFA8A      UXTB     R10,R10
   \      0x478   0xFB03 0xFA0A      MUL      R10,R3,R10
   \      0x47C   0x44D6             ADD      LR,LR,R10
   \      0x47E   0xF8DE 0xE008      LDR      LR,[LR, #+8]
   \      0x482   0xEB02 0x0E8E      ADD      LR,R2,LR, LSL #+2
   \      0x486   0xF85E 0xEC04      LDR      LR,[LR, #+4294967292]
   \      0x48A   0xF43E 0x7E80      BICS     LR,LR,#0x100
   \      0x48E   0xF840 0xEC04      STR      LR,[R0, #+4294967292]
   2588                  if (IOM_cfg[other_instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
   \      0x492   0x4668             MOV      R0,SP
   \      0x494   0x46BE             MOV      LR,R7
   \      0x496   0xFA5F 0xFE8E      UXTB     LR,LR
   \      0x49A   0xFB03 0xFE0E      MUL      LR,R3,LR
   \      0x49E   0x4470             ADD      R0,R0,LR
   \      0x4A0   0x68C0             LDR      R0,[R0, #+12]
   \      0x4A2   0x2800             CMP      R0,#+0
   \      0x4A4   0xD01D             BEQ.N    ??HAL_OSPIM_Config_18
   2589                  {
   2590                    CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOLowPort-1U)& OSPI_IOM_PORT_MASK)],
   2591                              OCTOSPIM_PCR_IOLEN);
   \      0x4A6   0x4668             MOV      R0,SP
   \      0x4A8   0x46BE             MOV      LR,R7
   \      0x4AA   0xFA5F 0xFE8E      UXTB     LR,LR
   \      0x4AE   0xFB03 0xFE0E      MUL      LR,R3,LR
   \      0x4B2   0x4470             ADD      R0,R0,LR
   \      0x4B4   0x68C0             LDR      R0,[R0, #+12]
   \      0x4B6   0x1E40             SUBS     R0,R0,#+1
   \      0x4B8   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x4BC   0x46EE             MOV      LR,SP
   \      0x4BE   0x46BA             MOV      R10,R7
   \      0x4C0   0xFA5F 0xFA8A      UXTB     R10,R10
   \      0x4C4   0xFB03 0xFA0A      MUL      R10,R3,R10
   \      0x4C8   0x44D6             ADD      LR,LR,R10
   \      0x4CA   0xF8DE 0xE00C      LDR      LR,[LR, #+12]
   \      0x4CE   0xF1BE 0x0E01      SUBS     LR,LR,#+1
   \      0x4D2   0xF01E 0x0E01      ANDS     LR,LR,#0x1
   \      0x4D6   0xF852 0xE02E      LDR      LR,[R2, LR, LSL #+2]
   \      0x4DA   0xF43E 0x3E80      BICS     LR,LR,#0x10000
   \      0x4DE   0xF842 0xE020      STR      LR,[R2, R0, LSL #+2]
   2592                  }
   2593                  if (IOM_cfg[other_instance].IOHighPort != HAL_OSPIM_IOPORT_NONE)
   \                     ??HAL_OSPIM_Config_18: (+1)
   \      0x4E2   0x4668             MOV      R0,SP
   \      0x4E4   0x46BE             MOV      LR,R7
   \      0x4E6   0xFA5F 0xFE8E      UXTB     LR,LR
   \      0x4EA   0xFB03 0xFE0E      MUL      LR,R3,LR
   \      0x4EE   0x4470             ADD      R0,R0,LR
   \      0x4F0   0x6900             LDR      R0,[R0, #+16]
   \      0x4F2   0x2800             CMP      R0,#+0
   \      0x4F4   0xD019             BEQ.N    ??HAL_OSPIM_Config_15
   2594                  {
   2595                    CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOHighPort-1U)& OSPI_IOM_PORT_MASK)],
   2596                              OCTOSPIM_PCR_IOHEN);
   \      0x4F6   0x4668             MOV      R0,SP
   \      0x4F8   0x46BE             MOV      LR,R7
   \      0x4FA   0xFA5F 0xFE8E      UXTB     LR,LR
   \      0x4FE   0xFB03 0xFE0E      MUL      LR,R3,LR
   \      0x502   0x4470             ADD      R0,R0,LR
   \      0x504   0x6900             LDR      R0,[R0, #+16]
   \      0x506   0x1E40             SUBS     R0,R0,#+1
   \      0x508   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x50C   0x46EE             MOV      LR,SP
   \      0x50E   0xB2FF             UXTB     R7,R7
   \      0x510   0x435F             MULS     R7,R3,R7
   \      0x512   0xEB0E 0x0307      ADD      R3,LR,R7
   \      0x516   0x691B             LDR      R3,[R3, #+16]
   \      0x518   0x1E5B             SUBS     R3,R3,#+1
   \      0x51A   0xF013 0x0301      ANDS     R3,R3,#0x1
   \      0x51E   0xF852 0x3023      LDR      R3,[R2, R3, LSL #+2]
   \      0x522   0xF033 0x7380      BICS     R3,R3,#0x1000000
   \      0x526   0xF842 0x3020      STR      R3,[R2, R0, LSL #+2]
   2597                  }
   2598                }
   2599              }
   2600          
   2601              /******************** Activation of new configuration *********************/
   2602                  MODIFY_REG(OCTOSPIM->PCR[(cfg->NCSPort - 1U)], (OCTOSPIM_PCR_NCSEN | OCTOSPIM_PCR_NCSSRC),
   2603                            (OCTOSPIM_PCR_NCSEN | (instance << OCTOSPIM_PCR_NCSSRC_Pos)));
   \                     ??HAL_OSPIM_Config_15: (+1)
   \      0x52A   0x68A0             LDR      R0,[R4, #+8]
   \      0x52C   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \      0x530   0x68A3             LDR      R3,[R4, #+8]
   \      0x532   0xEB02 0x0383      ADD      R3,R2,R3, LSL #+2
   \      0x536   0xF853 0x3C04      LDR      R3,[R3, #+4294967292]
   \      0x53A   0xF433 0x7340      BICS     R3,R3,#0x300
   \      0x53E   0xEA53 0x2346      ORRS     R3,R3,R6, LSL #+9
   \      0x542   0xF453 0x7380      ORRS     R3,R3,#0x100
   \      0x546   0xF840 0x3C04      STR      R3,[R0, #+4294967292]
   2604          
   2605              if ((cfg->Req2AckTime - 1U) > ((OCTOSPIM->CR & OCTOSPIM_CR_REQ2ACK_TIME) >> OCTOSPIM_CR_REQ2ACK_TIME_Pos))
   \      0x54A   0xF8DC 0x0000      LDR      R0,[R12, #+0]
   \      0x54E   0xF3C0 0x4007      UBFX     R0,R0,#+16,#+8
   \      0x552   0x6963             LDR      R3,[R4, #+20]
   \      0x554   0x1E5B             SUBS     R3,R3,#+1
   \      0x556   0x4298             CMP      R0,R3
   \      0x558   0xD209             BCS.N    ??HAL_OSPIM_Config_19
   2606              {
   2607                MODIFY_REG(OCTOSPIM->CR, OCTOSPIM_CR_REQ2ACK_TIME, ((cfg->Req2AckTime - 1U) << OCTOSPIM_CR_REQ2ACK_TIME_Pos));
   \      0x55A   0xF8DC 0x0000      LDR      R0,[R12, #+0]
   \      0x55E   0xF430 0x007F      BICS     R0,R0,#0xFF0000
   \      0x562   0x6963             LDR      R3,[R4, #+20]
   \      0x564   0x1E5B             SUBS     R3,R3,#+1
   \      0x566   0xEA50 0x4003      ORRS     R0,R0,R3, LSL #+16
   \      0x56A   0xF8CC 0x0000      STR      R0,[R12, #+0]
   2608              }
   2609          
   2610              if ((OCTOSPIM->CR & OCTOSPIM_CR_MUXEN) != 0U)
   \                     ??HAL_OSPIM_Config_19: (+1)
   \      0x56E   0xF8DC 0x0000      LDR      R0,[R12, #+0]
   \      0x572   0x07C0             LSLS     R0,R0,#+31
   \      0x574   0xD565             BPL.N    ??HAL_OSPIM_Config_20
   2611              {
   2612                MODIFY_REG(OCTOSPIM->PCR[(cfg->ClkPort-1U)], (OCTOSPIM_PCR_CLKEN | OCTOSPIM_PCR_CLKSRC), OCTOSPIM_PCR_CLKEN);
   \      0x576   0x2301             MOVS     R3,#+1
   \      0x578   0x6820             LDR      R0,[R4, #+0]
   \      0x57A   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \      0x57E   0xF850 0x0C04      LDR      R0,[R0, #+4294967292]
   \      0x582   0xF363 0x0001      BFI      R0,R3,#+0,#+2
   \      0x586   0x6826             LDR      R6,[R4, #+0]
   \      0x588   0xEB02 0x0686      ADD      R6,R2,R6, LSL #+2
   \      0x58C   0xF846 0x0C04      STR      R0,[R6, #+4294967292]
   2613                if (cfg->DQSPort != 0U)
   \      0x590   0x6860             LDR      R0,[R4, #+4]
   \      0x592   0x2800             CMP      R0,#+0
   \      0x594   0xD00B             BEQ.N    ??HAL_OSPIM_Config_21
   2614                {
   2615                  MODIFY_REG(OCTOSPIM->PCR[(cfg->DQSPort-1U)], (OCTOSPIM_PCR_DQSEN | OCTOSPIM_PCR_DQSSRC), OCTOSPIM_PCR_DQSEN);
   \      0x596   0x6860             LDR      R0,[R4, #+4]
   \      0x598   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \      0x59C   0x6866             LDR      R6,[R4, #+4]
   \      0x59E   0xEB02 0x0686      ADD      R6,R2,R6, LSL #+2
   \      0x5A2   0xF856 0x6C04      LDR      R6,[R6, #+4294967292]
   \      0x5A6   0xF363 0x1605      BFI      R6,R3,#+4,#+2
   \      0x5AA   0xF840 0x6C04      STR      R6,[R0, #+4294967292]
   2616                }
   2617          
   2618                if ((cfg->IOLowPort & OCTOSPIM_PCR_IOLEN) != 0U)
   \                     ??HAL_OSPIM_Config_21: (+1)
   \      0x5AE   0x68E0             LDR      R0,[R4, #+12]
   \      0x5B0   0x03C0             LSLS     R0,R0,#+15
   \      0x5B2   0xD50E             BPL.N    ??HAL_OSPIM_Config_22
   2619                {
   2620                  MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort-1U)& OSPI_IOM_PORT_MASK)],
   2621                            (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC), OCTOSPIM_PCR_IOLEN);
   \      0x5B4   0x68E0             LDR      R0,[R4, #+12]
   \      0x5B6   0x1E40             SUBS     R0,R0,#+1
   \      0x5B8   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x5BC   0x68E6             LDR      R6,[R4, #+12]
   \      0x5BE   0x1E76             SUBS     R6,R6,#+1
   \      0x5C0   0xF016 0x0601      ANDS     R6,R6,#0x1
   \      0x5C4   0xF852 0x6026      LDR      R6,[R2, R6, LSL #+2]
   \      0x5C8   0xF363 0x4612      BFI      R6,R3,#+16,#+3
   \      0x5CC   0xF842 0x6020      STR      R6,[R2, R0, LSL #+2]
   \      0x5D0   0xE010             B.N      ??HAL_OSPIM_Config_23
   2622                }
   2623                else if (cfg->IOLowPort != HAL_OSPIM_IOPORT_NONE)
   \                     ??HAL_OSPIM_Config_22: (+1)
   \      0x5D2   0x68E0             LDR      R0,[R4, #+12]
   \      0x5D4   0x2800             CMP      R0,#+0
   \      0x5D6   0xD00D             BEQ.N    ??HAL_OSPIM_Config_23
   2624                {
   2625                  MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort-1U)& OSPI_IOM_PORT_MASK)],
   2626                            (OCTOSPIM_PCR_IOHEN | OCTOSPIM_PCR_IOHSRC), OCTOSPIM_PCR_IOHEN);
   \      0x5D8   0x68E0             LDR      R0,[R4, #+12]
   \      0x5DA   0x1E40             SUBS     R0,R0,#+1
   \      0x5DC   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x5E0   0x68E6             LDR      R6,[R4, #+12]
   \      0x5E2   0x1E76             SUBS     R6,R6,#+1
   \      0x5E4   0xF016 0x0601      ANDS     R6,R6,#0x1
   \      0x5E8   0xF852 0x6026      LDR      R6,[R2, R6, LSL #+2]
   \      0x5EC   0xF363 0x661A      BFI      R6,R3,#+24,#+3
   \      0x5F0   0xF842 0x6020      STR      R6,[R2, R0, LSL #+2]
   2627                }
   2628                else
   2629                {
   2630                   /* Nothing to do */
   2631                }
   2632          
   2633                if ((cfg->IOHighPort & OCTOSPIM_PCR_IOLEN) != 0U)
   \                     ??HAL_OSPIM_Config_23: (+1)
   \      0x5F4   0x6920             LDR      R0,[R4, #+16]
   \      0x5F6   0x03C0             LSLS     R0,R0,#+15
   \      0x5F8   0xD50F             BPL.N    ??HAL_OSPIM_Config_24
   2634                {
   2635                  MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort-1U)& OSPI_IOM_PORT_MASK)],
   2636                            (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC), (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC_0));
   \      0x5FA   0x6920             LDR      R0,[R4, #+16]
   \      0x5FC   0x1E40             SUBS     R0,R0,#+1
   \      0x5FE   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x602   0x2303             MOVS     R3,#+3
   \      0x604   0x6924             LDR      R4,[R4, #+16]
   \      0x606   0x1E64             SUBS     R4,R4,#+1
   \      0x608   0xF014 0x0401      ANDS     R4,R4,#0x1
   \      0x60C   0xF852 0x4024      LDR      R4,[R2, R4, LSL #+2]
   \      0x610   0xF363 0x4412      BFI      R4,R3,#+16,#+3
   \      0x614   0xF842 0x4020      STR      R4,[R2, R0, LSL #+2]
   \      0x618   0xE08C             B.N      ??HAL_OSPIM_Config_25
   2637                }
   2638                else if (cfg->IOHighPort != HAL_OSPIM_IOPORT_NONE)
   \                     ??HAL_OSPIM_Config_24: (+1)
   \      0x61A   0x6920             LDR      R0,[R4, #+16]
   \      0x61C   0x2800             CMP      R0,#+0
   \      0x61E   0xF000 0x8089      BEQ.W    ??HAL_OSPIM_Config_25
   2639                {
   2640                  MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort-1U)& OSPI_IOM_PORT_MASK)],
   2641                            (OCTOSPIM_PCR_IOHEN | OCTOSPIM_PCR_IOHSRC), (OCTOSPIM_PCR_IOHEN | OCTOSPIM_PCR_IOHSRC_0));
   \      0x622   0x6920             LDR      R0,[R4, #+16]
   \      0x624   0x1E40             SUBS     R0,R0,#+1
   \      0x626   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x62A   0x2303             MOVS     R3,#+3
   \      0x62C   0x6924             LDR      R4,[R4, #+16]
   \      0x62E   0x1E64             SUBS     R4,R4,#+1
   \      0x630   0xF014 0x0401      ANDS     R4,R4,#0x1
   \      0x634   0xF852 0x4024      LDR      R4,[R2, R4, LSL #+2]
   \      0x638   0xF363 0x641A      BFI      R4,R3,#+24,#+3
   \      0x63C   0xF842 0x4020      STR      R4,[R2, R0, LSL #+2]
   \      0x640   0xE078             B.N      ??HAL_OSPIM_Config_25
   2642                }
   2643                else
   2644                {
   2645                   /* Nothing to do */
   2646                }
   2647              }
   2648              else
   2649              {
   2650                MODIFY_REG(OCTOSPIM->PCR[(cfg->ClkPort-1U)], (OCTOSPIM_PCR_CLKEN | OCTOSPIM_PCR_CLKSRC),
   2651                          (OCTOSPIM_PCR_CLKEN | (instance << OCTOSPIM_PCR_CLKSRC_Pos)));
   \                     ??HAL_OSPIM_Config_20: (+1)
   \      0x642   0x6820             LDR      R0,[R4, #+0]
   \      0x644   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \      0x648   0xF850 0x0C04      LDR      R0,[R0, #+4294967292]
   \      0x64C   0x0880             LSRS     R0,R0,#+2
   \      0x64E   0x0080             LSLS     R0,R0,#+2
   \      0x650   0xEA50 0x0046      ORRS     R0,R0,R6, LSL #+1
   \      0x654   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x658   0x6823             LDR      R3,[R4, #+0]
   \      0x65A   0xEB02 0x0383      ADD      R3,R2,R3, LSL #+2
   \      0x65E   0xF843 0x0C04      STR      R0,[R3, #+4294967292]
   2652                if (cfg->DQSPort != 0U)
   \      0x662   0x6860             LDR      R0,[R4, #+4]
   \      0x664   0x2800             CMP      R0,#+0
   \      0x666   0xD00F             BEQ.N    ??HAL_OSPIM_Config_26
   2653                {
   2654                  MODIFY_REG(OCTOSPIM->PCR[(cfg->DQSPort-1U)], (OCTOSPIM_PCR_DQSEN | OCTOSPIM_PCR_DQSSRC),
   2655                            (OCTOSPIM_PCR_DQSEN | (instance << OCTOSPIM_PCR_DQSSRC_Pos)));
   \      0x668   0x6860             LDR      R0,[R4, #+4]
   \      0x66A   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \      0x66E   0x6863             LDR      R3,[R4, #+4]
   \      0x670   0xEB02 0x0383      ADD      R3,R2,R3, LSL #+2
   \      0x674   0xF853 0x3C04      LDR      R3,[R3, #+4294967292]
   \      0x678   0xF033 0x0330      BICS     R3,R3,#0x30
   \      0x67C   0xEA53 0x1346      ORRS     R3,R3,R6, LSL #+5
   \      0x680   0xF053 0x0310      ORRS     R3,R3,#0x10
   \      0x684   0xF840 0x3C04      STR      R3,[R0, #+4294967292]
   2656                }
   2657          
   2658                if ((cfg->IOLowPort & OCTOSPIM_PCR_IOLEN) != 0U)
   \                     ??HAL_OSPIM_Config_26: (+1)
   \      0x688   0x68E0             LDR      R0,[R4, #+12]
   \      0x68A   0x03C0             LSLS     R0,R0,#+15
   \      0x68C   0xD512             BPL.N    ??HAL_OSPIM_Config_27
   2659                {
   2660                  MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort-1U)& OSPI_IOM_PORT_MASK)],
   2661                            (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC),
   2662                            (OCTOSPIM_PCR_IOLEN | (instance << (OCTOSPIM_PCR_IOLSRC_Pos+1U))));
   \      0x68E   0x68E0             LDR      R0,[R4, #+12]
   \      0x690   0x1E40             SUBS     R0,R0,#+1
   \      0x692   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x696   0x68E3             LDR      R3,[R4, #+12]
   \      0x698   0x1E5B             SUBS     R3,R3,#+1
   \      0x69A   0xF013 0x0301      ANDS     R3,R3,#0x1
   \      0x69E   0xF852 0x3023      LDR      R3,[R2, R3, LSL #+2]
   \      0x6A2   0xF433 0x23E0      BICS     R3,R3,#0x70000
   \      0x6A6   0xEA53 0x4386      ORRS     R3,R3,R6, LSL #+18
   \      0x6AA   0xF453 0x3380      ORRS     R3,R3,#0x10000
   \      0x6AE   0xF842 0x3020      STR      R3,[R2, R0, LSL #+2]
   \      0x6B2   0xE014             B.N      ??HAL_OSPIM_Config_28
   2663                }
   2664                else if (cfg->IOLowPort != HAL_OSPIM_IOPORT_NONE)
   \                     ??HAL_OSPIM_Config_27: (+1)
   \      0x6B4   0x68E0             LDR      R0,[R4, #+12]
   \      0x6B6   0x2800             CMP      R0,#+0
   \      0x6B8   0xD011             BEQ.N    ??HAL_OSPIM_Config_28
   2665                {
   2666                  MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort-1U)& OSPI_IOM_PORT_MASK)],
   2667                            (OCTOSPIM_PCR_IOHEN | OCTOSPIM_PCR_IOHSRC),
   2668                            (OCTOSPIM_PCR_IOHEN | (instance << (OCTOSPIM_PCR_IOHSRC_Pos+1U))));
   \      0x6BA   0x68E0             LDR      R0,[R4, #+12]
   \      0x6BC   0x1E40             SUBS     R0,R0,#+1
   \      0x6BE   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x6C2   0x68E3             LDR      R3,[R4, #+12]
   \      0x6C4   0x1E5B             SUBS     R3,R3,#+1
   \      0x6C6   0xF013 0x0301      ANDS     R3,R3,#0x1
   \      0x6CA   0xF852 0x3023      LDR      R3,[R2, R3, LSL #+2]
   \      0x6CE   0xF033 0x63E0      BICS     R3,R3,#0x7000000
   \      0x6D2   0xEA53 0x6386      ORRS     R3,R3,R6, LSL #+26
   \      0x6D6   0xF053 0x7380      ORRS     R3,R3,#0x1000000
   \      0x6DA   0xF842 0x3020      STR      R3,[R2, R0, LSL #+2]
   2669                }
   2670                else
   2671                {
   2672                   /* Nothing to do */
   2673                }
   2674          
   2675                if ((cfg->IOHighPort & OCTOSPIM_PCR_IOLEN) != 0U)
   \                     ??HAL_OSPIM_Config_28: (+1)
   \      0x6DE   0x6920             LDR      R0,[R4, #+16]
   \      0x6E0   0x03C0             LSLS     R0,R0,#+15
   \      0x6E2   0xD512             BPL.N    ??HAL_OSPIM_Config_29
   2676                {
   2677                  MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort-1U)& OSPI_IOM_PORT_MASK)],
   2678                            (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC),
   2679                            (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC_0 | (instance << (OCTOSPIM_PCR_IOLSRC_Pos+1U))));
   \      0x6E4   0x6920             LDR      R0,[R4, #+16]
   \      0x6E6   0x1E40             SUBS     R0,R0,#+1
   \      0x6E8   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x6EC   0x6923             LDR      R3,[R4, #+16]
   \      0x6EE   0x1E5B             SUBS     R3,R3,#+1
   \      0x6F0   0xF013 0x0301      ANDS     R3,R3,#0x1
   \      0x6F4   0xF852 0x3023      LDR      R3,[R2, R3, LSL #+2]
   \      0x6F8   0xF433 0x23E0      BICS     R3,R3,#0x70000
   \      0x6FC   0xEA53 0x4386      ORRS     R3,R3,R6, LSL #+18
   \      0x700   0xF453 0x3340      ORRS     R3,R3,#0x30000
   \      0x704   0xF842 0x3020      STR      R3,[R2, R0, LSL #+2]
   \      0x708   0xE014             B.N      ??HAL_OSPIM_Config_25
   2680                }
   2681                else if (cfg->IOHighPort != HAL_OSPIM_IOPORT_NONE)
   \                     ??HAL_OSPIM_Config_29: (+1)
   \      0x70A   0x6920             LDR      R0,[R4, #+16]
   \      0x70C   0x2800             CMP      R0,#+0
   \      0x70E   0xD011             BEQ.N    ??HAL_OSPIM_Config_25
   2682                {
   2683                  MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort-1U)& OSPI_IOM_PORT_MASK)],
   2684                            (OCTOSPIM_PCR_IOHEN | OCTOSPIM_PCR_IOHSRC),
   2685                            (OCTOSPIM_PCR_IOHEN | OCTOSPIM_PCR_IOHSRC_0 | (instance << (OCTOSPIM_PCR_IOHSRC_Pos+1U))));
   \      0x710   0x6920             LDR      R0,[R4, #+16]
   \      0x712   0x1E40             SUBS     R0,R0,#+1
   \      0x714   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x718   0x6923             LDR      R3,[R4, #+16]
   \      0x71A   0x1E5B             SUBS     R3,R3,#+1
   \      0x71C   0xF013 0x0301      ANDS     R3,R3,#0x1
   \      0x720   0xF852 0x3023      LDR      R3,[R2, R3, LSL #+2]
   \      0x724   0xF033 0x63E0      BICS     R3,R3,#0x7000000
   \      0x728   0xEA53 0x6386      ORRS     R3,R3,R6, LSL #+26
   \      0x72C   0xF053 0x7340      ORRS     R3,R3,#0x3000000
   \      0x730   0xF842 0x3020      STR      R3,[R2, R0, LSL #+2]
   2686                }
   2687                else
   2688                {
   2689                   /* Nothing to do */
   2690                }
   2691              }
   2692          
   2693              /******* Re-enable both OctoSPI after configure OctoSPI IO Manager ********/
   2694              if ((ospi_enabled & 0x1U) != 0U)
   \                     ??HAL_OSPIM_Config_25: (+1)
   \      0x734   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \      0x738   0xD503             BPL.N    ??HAL_OSPIM_Config_30
   2695              {
   2696                SET_BIT(OCTOSPI1->CR, OCTOSPI_CR_EN);
   \      0x73A   0x6828             LDR      R0,[R5, #+0]
   \      0x73C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x740   0x6028             STR      R0,[R5, #+0]
   2697              }
   2698              if ((ospi_enabled & 0x2U) != 0U)
   \                     ??HAL_OSPIM_Config_30: (+1)
   \      0x742   0xEA5F 0x7089      LSLS     R0,R9,#+30
   \      0x746   0xD503             BPL.N    ??HAL_OSPIM_Config_5
   2699              {
   2700                SET_BIT(OCTOSPI2->CR, OCTOSPI_CR_EN);
   \      0x748   0x6808             LDR      R0,[R1, #+0]
   \      0x74A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x74E   0x6008             STR      R0,[R1, #+0]
   2701              }
   2702            }
   2703          
   2704            /* Return function status */
   2705            return status;
   \                     ??HAL_OSPIM_Config_5: (+1)
   \      0x750   0x4640             MOV      R0,R8
   \      0x752   0xB2C0             UXTB     R0,R0
   \      0x754   0xB00D             ADD      SP,SP,#+52
   \      0x756   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2706          }
   2707          
   2708          /**
   2709            * @}
   2710            */
   2711          
   2712          /**
   2713            @cond 0
   2714            */
   2715          /**
   2716            * @brief  DMA OSPI process complete callback.
   2717            * @param  hdma : DMA handle
   2718            * @retval None
   2719            */

   \                                 In section .text, align 4, keep-with-next
   2720          static void OSPI_DMACplt(MDMA_HandleTypeDef *hmdma)
   2721          {
   2722            OSPI_HandleTypeDef* hospi = ( OSPI_HandleTypeDef* )(hmdma->Parent);
   \                     OSPI_DMACplt: (+1)
   \        0x0   0x6C01             LDR      R1,[R0, #+64]
   2723            hospi->XferCount = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x64CA             STR      R2,[R1, #+76]
   2724          
   2725            /* Disable the DMA transfer on the OctoSPI side */
   2726            CLEAR_BIT(hospi->Instance->CR, OCTOSPI_CR_DMAEN);
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0xF032 0x0204      BICS     R2,R2,#0x4
   \        0xE   0x680B             LDR      R3,[R1, #+0]
   \       0x10   0x601A             STR      R2,[R3, #+0]
   2727          
   2728            /* Disable the DMA channel */
   2729            __HAL_MDMA_DISABLE(hmdma);
   \       0x12   0x6802             LDR      R2,[R0, #+0]
   \       0x14   0x68D2             LDR      R2,[R2, #+12]
   \       0x16   0x0852             LSRS     R2,R2,#+1
   \       0x18   0x0052             LSLS     R2,R2,#+1
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0x60C2             STR      R2,[R0, #+12]
   2730          
   2731            /* Enable the OSPI transfer complete Interrupt */
   2732            __HAL_OSPI_ENABLE_IT(hospi, HAL_OSPI_IT_TC);
   \       0x1E   0x6808             LDR      R0,[R1, #+0]
   \       0x20   0x6800             LDR      R0,[R0, #+0]
   \       0x22   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \       0x26   0x6809             LDR      R1,[R1, #+0]
   \       0x28   0x6008             STR      R0,[R1, #+0]
   2733          }
   \       0x2A   0x4770             BX       LR
   2734          
   2735          /**
   2736            * @brief  DMA OSPI communication error callback.
   2737            * @param  hdma : DMA handle
   2738            * @retval None
   2739            */

   \                                 In section .text, align 4, keep-with-next
   2740          static void OSPI_DMAError(MDMA_HandleTypeDef *hmdma)
   2741          {
   \                     OSPI_DMAError: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   2742            OSPI_HandleTypeDef* hospi = ( OSPI_HandleTypeDef* )(hmdma->Parent);
   \        0x2   0x6C04             LDR      R4,[R0, #+64]
   2743            hospi->XferCount = 0;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x64E0             STR      R0,[R4, #+76]
   2744            hospi->ErrorCode = HAL_OSPI_ERROR_DMA;
   \        0x8   0x2004             MOVS     R0,#+4
   \        0xA   0x65A0             STR      R0,[R4, #+88]
   2745          
   2746            /* Disable the DMA transfer on the OctoSPI side */
   2747            CLEAR_BIT(hospi->Instance->CR, OCTOSPI_CR_DMAEN);
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x14   0x6821             LDR      R1,[R4, #+0]
   \       0x16   0x6008             STR      R0,[R1, #+0]
   2748          
   2749            /* Abort the OctoSPI */
   2750            if (HAL_OSPI_Abort_IT(hospi) != HAL_OK)
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0x.... 0x....      BL       HAL_OSPI_Abort_IT
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD00A             BEQ.N    ??OSPI_DMAError_0
   2751            {
   2752              /* Disable the interrupts */
   2753              __HAL_OSPI_DISABLE_IT(hospi, HAL_OSPI_IT_TC | HAL_OSPI_IT_FT | HAL_OSPI_IT_TE);
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0xF430 0x20E0      BICS     R0,R0,#0x70000
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
   2754          
   2755              /* Update state */
   2756              hospi->State = HAL_OSPI_STATE_READY;
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0x6560             STR      R0,[R4, #+84]
   2757          
   2758              /* Error callback */
   2759          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
   2760              hospi->ErrorCallback(hospi);
   2761          #else
   2762              HAL_OSPI_ErrorCallback(hospi);
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       HAL_OSPI_ErrorCallback
   2763          #endif /*(USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
   2764            }
   2765          }
   \                     ??OSPI_DMAError_0: (+1)
   \       0x38   0xBD10             POP      {R4,PC}
   2766          
   2767          /**
   2768            * @brief  DMA OSPI abort complete callback.
   2769            * @param  hdma : DMA handle
   2770            * @retval None
   2771            */

   \                                 In section .text, align 4, keep-with-next
   2772          static void OSPI_DMAAbortCplt(MDMA_HandleTypeDef *hmdma)
   2773          {
   \                     OSPI_DMAAbortCplt: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2774            OSPI_HandleTypeDef* hospi = ( OSPI_HandleTypeDef* )(hmdma->Parent);
   \        0x2   0x6C00             LDR      R0,[R0, #+64]
   2775            hospi->XferCount = 0;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x64C1             STR      R1,[R0, #+76]
   2776          
   2777            /* Check the state */
   2778            if (hospi->State == HAL_OSPI_STATE_ABORT)
   \        0x8   0x6D41             LDR      R1,[R0, #+84]
   \        0xA   0xF5B1 0x7F80      CMP      R1,#+256
   \        0xE   0xD118             BNE.N    ??OSPI_DMAAbortCplt_0
   2779            {
   2780              /* DMA abort called by OctoSPI abort */
   2781              if (__HAL_OSPI_GET_FLAG(hospi, HAL_OSPI_FLAG_BUSY) != RESET)
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0x6A09             LDR      R1,[R1, #+32]
   \       0x14   0x0689             LSLS     R1,R1,#+26
   \       0x16   0xD50F             BPL.N    ??OSPI_DMAAbortCplt_1
   2782              {
   2783                /* Clear transfer complete flag */
   2784                __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
   \       0x18   0x2102             MOVS     R1,#+2
   \       0x1A   0x6802             LDR      R2,[R0, #+0]
   \       0x1C   0x6251             STR      R1,[R2, #+36]
   2785          
   2786                /* Enable the transfer complete interrupts */
   2787                __HAL_OSPI_ENABLE_IT(hospi, HAL_OSPI_IT_TC);
   \       0x1E   0x6801             LDR      R1,[R0, #+0]
   \       0x20   0x6809             LDR      R1,[R1, #+0]
   \       0x22   0xF451 0x3100      ORRS     R1,R1,#0x20000
   \       0x26   0x6802             LDR      R2,[R0, #+0]
   \       0x28   0x6011             STR      R1,[R2, #+0]
   2788          
   2789                /* Perform an abort of the OctoSPI */
   2790                SET_BIT(hospi->Instance->CR, OCTOSPI_CR_ABORT);
   \       0x2A   0x6801             LDR      R1,[R0, #+0]
   \       0x2C   0x6809             LDR      R1,[R1, #+0]
   \       0x2E   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0x6001             STR      R1,[R0, #+0]
   \       0x36   0xE008             B.N      ??OSPI_DMAAbortCplt_2
   2791              }
   2792              else
   2793              {
   2794                /* Update state */
   2795                hospi->State = HAL_OSPI_STATE_READY;
   \                     ??OSPI_DMAAbortCplt_1: (+1)
   \       0x38   0x2102             MOVS     R1,#+2
   \       0x3A   0x6541             STR      R1,[R0, #+84]
   2796          
   2797                /* Abort callback */
   2798          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
   2799                hospi->AbortCpltCallback(hospi);
   2800          #else
   2801                HAL_OSPI_AbortCpltCallback(hospi);
   \       0x3C   0x.... 0x....      BL       HAL_OSPI_AbortCpltCallback
   \       0x40   0xE003             B.N      ??OSPI_DMAAbortCplt_2
   2802          #endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */
   2803              }
   2804            }
   2805            else
   2806            {
   2807              /* DMA abort called due to a transfer error interrupt */
   2808              /* Update state */
   2809              hospi->State = HAL_OSPI_STATE_READY;
   \                     ??OSPI_DMAAbortCplt_0: (+1)
   \       0x42   0x2102             MOVS     R1,#+2
   \       0x44   0x6541             STR      R1,[R0, #+84]
   2810          
   2811              /* Error callback */
   2812          #if defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)
   2813              hospi->ErrorCallback(hospi);
   2814          #else
   2815              HAL_OSPI_ErrorCallback(hospi);
   \       0x46   0x.... 0x....      BL       HAL_OSPI_ErrorCallback
   2816          #endif /* (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U)*/
   2817            }
   2818          }
   \                     ??OSPI_DMAAbortCplt_2: (+1)
   \       0x4A   0xBD01             POP      {R0,PC}
   2819          
   2820          /**
   2821            * @brief  Wait for a flag state until timeout.
   2822            * @param  hospi     : OSPI handle
   2823            * @param  Flag      : Flag checked
   2824            * @param  State     : Value of the flag expected
   2825            * @param  Timeout   : Duration of the timeout
   2826            * @param  Tickstart : Tick start value
   2827            * @retval HAL status
   2828            */

   \                                 In section .text, align 2, keep-with-next
   2829          static HAL_StatusTypeDef OSPI_WaitFlagStateUntilTimeout(OSPI_HandleTypeDef *hospi, uint32_t Flag,
   2830                                                                  FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
   2831          {
   \                     OSPI_WaitFlagStateUntilTimeout: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0x9C06             LDR      R4,[SP, #+24]
   2832            /* Wait until flag is in expected state */
   2833            while((__HAL_OSPI_GET_FLAG(hospi, Flag)) != State)
   \                     ??OSPI_WaitFlagStateUntilTimeout_0: (+1)
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x6A00             LDR      R0,[R0, #+32]
   \       0x12   0x4230             TST      R0,R6
   \       0x14   0xD001             BEQ.N    ??OSPI_WaitFlagStateUntilTimeout_1
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xE000             B.N      ??OSPI_WaitFlagStateUntilTimeout_2
   \                     ??OSPI_WaitFlagStateUntilTimeout_1: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \                     ??OSPI_WaitFlagStateUntilTimeout_2: (+1)
   \       0x1C   0x4641             MOV      R1,R8
   \       0x1E   0xB2C9             UXTB     R1,R1
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD012             BEQ.N    ??OSPI_WaitFlagStateUntilTimeout_3
   2834            {
   2835              /* Check for the Timeout */
   2836              if (Timeout != HAL_MAX_DELAY)
   \       0x24   0xF114 0x0F01      CMN      R4,#+1
   \       0x28   0xD0F1             BEQ.N    ??OSPI_WaitFlagStateUntilTimeout_0
   2837              {
   2838                if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x2A   0x.... 0x....      BL       HAL_GetTick
   \       0x2E   0x1BC0             SUBS     R0,R0,R7
   \       0x30   0x4284             CMP      R4,R0
   \       0x32   0xD301             BCC.N    ??OSPI_WaitFlagStateUntilTimeout_4
   \       0x34   0x2C00             CMP      R4,#+0
   \       0x36   0xD1EA             BNE.N    ??OSPI_WaitFlagStateUntilTimeout_0
   2839                {
   2840                  hospi->State     = HAL_OSPI_STATE_ERROR;
   \                     ??OSPI_WaitFlagStateUntilTimeout_4: (+1)
   \       0x38   0xF44F 0x7000      MOV      R0,#+512
   \       0x3C   0x6568             STR      R0,[R5, #+84]
   2841                  hospi->ErrorCode |= HAL_OSPI_ERROR_TIMEOUT;
   \       0x3E   0x6DA8             LDR      R0,[R5, #+88]
   \       0x40   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x44   0x65A8             STR      R0,[R5, #+88]
   2842          
   2843                  return HAL_ERROR;
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0xE000             B.N      ??OSPI_WaitFlagStateUntilTimeout_5
   2844                }
   2845              }
   2846            }
   2847            return HAL_OK;
   \                     ??OSPI_WaitFlagStateUntilTimeout_3: (+1)
   \       0x4A   0x2000             MOVS     R0,#+0
   \                     ??OSPI_WaitFlagStateUntilTimeout_5: (+1)
   \       0x4C   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2848          }
   2849          
   2850          /**
   2851            * @brief  Configure the registers for the regular command mode.
   2852            * @param  hospi : OSPI handle
   2853            * @param  cmd   : structure that contains the command configuration information
   2854            * @retval HAL status
   2855            */

   \                                 In section .text, align 2, keep-with-next
   2856          static HAL_StatusTypeDef OSPI_ConfigCmd(OSPI_HandleTypeDef *hospi, OSPI_RegularCmdTypeDef *cmd)
   2857          {
   \                     OSPI_ConfigCmd: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   2858            HAL_StatusTypeDef status = HAL_OK;
   \        0x2   0x2200             MOVS     R2,#+0
   2859            __IO uint32_t *ccr_reg;
   2860            __IO uint32_t *tcr_reg;
   2861            __IO uint32_t *ir_reg;
   2862            __IO uint32_t *abr_reg;
   2863          
   2864            /* Re-initialize the value of the functional mode */
   2865            MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, 0U);
   \        0x4   0x6803             LDR      R3,[R0, #+0]
   \        0x6   0x681B             LDR      R3,[R3, #+0]
   \        0x8   0xF033 0x5340      BICS     R3,R3,#0x30000000
   \        0xC   0x6804             LDR      R4,[R0, #+0]
   \        0xE   0x6023             STR      R3,[R4, #+0]
   2866          
   2867            /* Configure the flash ID */
   2868            if (hospi->Init.DualQuad == HAL_OSPI_DUALQUAD_DISABLE)
   \       0x10   0x6883             LDR      R3,[R0, #+8]
   \       0x12   0x2B00             CMP      R3,#+0
   \       0x14   0xD107             BNE.N    ??OSPI_ConfigCmd_0
   2869            {
   2870              MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FSEL, cmd->FlashId);
   \       0x16   0x6803             LDR      R3,[R0, #+0]
   \       0x18   0x681C             LDR      R4,[R3, #+0]
   \       0x1A   0xF034 0x0480      BICS     R4,R4,#0x80
   \       0x1E   0x684B             LDR      R3,[R1, #+4]
   \       0x20   0x431C             ORRS     R4,R3,R4
   \       0x22   0x6803             LDR      R3,[R0, #+0]
   \       0x24   0x601C             STR      R4,[R3, #+0]
   2871            }
   2872          
   2873            if (cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG)
   \                     ??OSPI_ConfigCmd_0: (+1)
   \       0x26   0x680B             LDR      R3,[R1, #+0]
   \       0x28   0x2B02             CMP      R3,#+2
   \       0x2A   0xD10C             BNE.N    ??OSPI_ConfigCmd_1
   2874            {
   2875              ccr_reg = &(hospi->Instance->WCCR);
   \       0x2C   0x6803             LDR      R3,[R0, #+0]
   \       0x2E   0xF513 0x74C0      ADDS     R4,R3,#+384
   2876              tcr_reg = &(hospi->Instance->WTCR);
   \       0x32   0x6803             LDR      R3,[R0, #+0]
   \       0x34   0xF513 0x76C4      ADDS     R6,R3,#+392
   2877              ir_reg  = &(hospi->Instance->WIR);
   \       0x38   0x6803             LDR      R3,[R0, #+0]
   \       0x3A   0xF513 0x75C8      ADDS     R5,R3,#+400
   2878              abr_reg = &(hospi->Instance->WABR);
   \       0x3E   0x6803             LDR      R3,[R0, #+0]
   \       0x40   0xF513 0x77D0      ADDS     R7,R3,#+416
   \       0x44   0xE01B             B.N      ??OSPI_ConfigCmd_2
   2879            }
   2880            else if (cmd->OperationType == HAL_OSPI_OPTYPE_WRAP_CFG)
   \                     ??OSPI_ConfigCmd_1: (+1)
   \       0x46   0x680B             LDR      R3,[R1, #+0]
   \       0x48   0x2B03             CMP      R3,#+3
   \       0x4A   0xD10C             BNE.N    ??OSPI_ConfigCmd_3
   2881            {
   2882              ccr_reg = &(hospi->Instance->WPCCR);
   \       0x4C   0x6803             LDR      R3,[R0, #+0]
   \       0x4E   0xF513 0x74A0      ADDS     R4,R3,#+320
   2883              tcr_reg = &(hospi->Instance->WPTCR);
   \       0x52   0x6803             LDR      R3,[R0, #+0]
   \       0x54   0xF513 0x76A4      ADDS     R6,R3,#+328
   2884              ir_reg  = &(hospi->Instance->WPIR);
   \       0x58   0x6803             LDR      R3,[R0, #+0]
   \       0x5A   0xF513 0x75A8      ADDS     R5,R3,#+336
   2885              abr_reg = &(hospi->Instance->WPABR);
   \       0x5E   0x6803             LDR      R3,[R0, #+0]
   \       0x60   0xF513 0x77B0      ADDS     R7,R3,#+352
   \       0x64   0xE00B             B.N      ??OSPI_ConfigCmd_2
   2886            }
   2887            else
   2888            {
   2889              ccr_reg = &(hospi->Instance->CCR);
   \                     ??OSPI_ConfigCmd_3: (+1)
   \       0x66   0x6803             LDR      R3,[R0, #+0]
   \       0x68   0xF513 0x7480      ADDS     R4,R3,#+256
   2890              tcr_reg = &(hospi->Instance->TCR);
   \       0x6C   0x6803             LDR      R3,[R0, #+0]
   \       0x6E   0xF513 0x7684      ADDS     R6,R3,#+264
   2891              ir_reg  = &(hospi->Instance->IR);
   \       0x72   0x6803             LDR      R3,[R0, #+0]
   \       0x74   0xF513 0x7588      ADDS     R5,R3,#+272
   2892              abr_reg = &(hospi->Instance->ABR);
   \       0x78   0x6803             LDR      R3,[R0, #+0]
   \       0x7A   0xF513 0x7790      ADDS     R7,R3,#+288
   2893            }
   2894          
   2895            /* Configure the CCR register with DQS and SIOO modes */
   2896            *ccr_reg = (cmd->DQSMode | cmd->SIOOMode);
   \                     ??OSPI_ConfigCmd_2: (+1)
   \       0x7E   0xF8D1 0xC048      LDR      R12,[R1, #+72]
   \       0x82   0x6CCB             LDR      R3,[R1, #+76]
   \       0x84   0xEA53 0x0C0C      ORRS     R12,R3,R12
   \       0x88   0xF8C4 0xC000      STR      R12,[R4, #+0]
   2897          
   2898            if (cmd->AlternateBytesMode != HAL_OSPI_ALTERNATE_BYTES_NONE)
   \       0x8C   0x6ACB             LDR      R3,[R1, #+44]
   \       0x8E   0x2B00             CMP      R3,#+0
   \       0x90   0xD00B             BEQ.N    ??OSPI_ConfigCmd_4
   2899            {
   2900              /* Configure the ABR register with alternate bytes value */
   2901              *abr_reg = cmd->AlternateBytes;
   \       0x92   0x6A8B             LDR      R3,[R1, #+40]
   \       0x94   0x603B             STR      R3,[R7, #+0]
   2902          
   2903              /* Configure the CCR register with alternate bytes communication parameters */
   2904              MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ABMODE | OCTOSPI_CCR_ABDTR | OCTOSPI_CCR_ABSIZE),
   2905                                     (cmd->AlternateBytesMode | cmd->AlternateBytesDtrMode | cmd->AlternateBytesSize));
   \       0x96   0x6827             LDR      R7,[R4, #+0]
   \       0x98   0xF437 0x177C      BICS     R7,R7,#0x3F0000
   \       0x9C   0x6ACB             LDR      R3,[R1, #+44]
   \       0x9E   0x431F             ORRS     R7,R3,R7
   \       0xA0   0x6B4B             LDR      R3,[R1, #+52]
   \       0xA2   0x431F             ORRS     R7,R3,R7
   \       0xA4   0x6B0B             LDR      R3,[R1, #+48]
   \       0xA6   0x431F             ORRS     R7,R3,R7
   \       0xA8   0x6027             STR      R7,[R4, #+0]
   2906            }
   2907          
   2908            /* Configure the TCR register with the number of dummy cycles */
   2909            MODIFY_REG((*tcr_reg), OCTOSPI_TCR_DCYC, cmd->DummyCycles);
   \                     ??OSPI_ConfigCmd_4: (+1)
   \       0xAA   0x6837             LDR      R7,[R6, #+0]
   \       0xAC   0x097F             LSRS     R7,R7,#+5
   \       0xAE   0x017F             LSLS     R7,R7,#+5
   \       0xB0   0x6C4B             LDR      R3,[R1, #+68]
   \       0xB2   0x431F             ORRS     R7,R3,R7
   \       0xB4   0x6037             STR      R7,[R6, #+0]
   2910          
   2911            if (cmd->DataMode != HAL_OSPI_DATA_NONE)
   \       0xB6   0x6B8B             LDR      R3,[R1, #+56]
   \       0xB8   0x2B00             CMP      R3,#+0
   \       0xBA   0xD006             BEQ.N    ??OSPI_ConfigCmd_5
   2912            {
   2913              if (cmd->OperationType == HAL_OSPI_OPTYPE_COMMON_CFG)
   \       0xBC   0x680B             LDR      R3,[R1, #+0]
   \       0xBE   0x2B00             CMP      R3,#+0
   \       0xC0   0xD103             BNE.N    ??OSPI_ConfigCmd_5
   2914              {
   2915                /* Configure the DLR register with the number of data */
   2916                hospi->Instance->DLR = (cmd->NbData - 1U);
   \       0xC2   0x6BCB             LDR      R3,[R1, #+60]
   \       0xC4   0x1E5B             SUBS     R3,R3,#+1
   \       0xC6   0x6806             LDR      R6,[R0, #+0]
   \       0xC8   0x6433             STR      R3,[R6, #+64]
   2917              }
   2918            }
   2919          
   2920            if (cmd->InstructionMode != HAL_OSPI_INSTRUCTION_NONE)
   \                     ??OSPI_ConfigCmd_5: (+1)
   \       0xCA   0x68CB             LDR      R3,[R1, #+12]
   \       0xCC   0x2B00             CMP      R3,#+0
   \       0xCE   0xD065             BEQ.N    ??OSPI_ConfigCmd_6
   2921            {
   2922              if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
   \       0xD0   0x69CB             LDR      R3,[R1, #+28]
   \       0xD2   0x2B00             CMP      R3,#+0
   \       0xD4   0xD038             BEQ.N    ??OSPI_ConfigCmd_7
   2923              {
   2924                if (cmd->DataMode != HAL_OSPI_DATA_NONE)
   \       0xD6   0x6B8B             LDR      R3,[R1, #+56]
   \       0xD8   0x2B00             CMP      R3,#+0
   \       0xDA   0xD014             BEQ.N    ??OSPI_ConfigCmd_8
   2925                {
   2926                  /* ---- Command with instruction, address and data ---- */
   2927          
   2928                  /* Configure the CCR register with all communication parameters */
   2929                  MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE  | OCTOSPI_CCR_IDTR  | OCTOSPI_CCR_ISIZE  |
   2930                                          OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE |
   2931                                          OCTOSPI_CCR_DMODE  | OCTOSPI_CCR_DDTR),
   2932                                         (cmd->InstructionMode | cmd->InstructionDtrMode | cmd->InstructionSize |
   2933                                          cmd->AddressMode     | cmd->AddressDtrMode     | cmd->AddressSize     |
   2934                                          cmd->DataMode        | cmd->DataDtrMode));
   \       0xDC   0x6826             LDR      R6,[R4, #+0]
   \       0xDE   0x....             LDR.N    R3,??DataTable7_5
   \       0xE0   0x401E             ANDS     R6,R3,R6
   \       0xE2   0x68CB             LDR      R3,[R1, #+12]
   \       0xE4   0x431E             ORRS     R6,R3,R6
   \       0xE6   0x694B             LDR      R3,[R1, #+20]
   \       0xE8   0x431E             ORRS     R6,R3,R6
   \       0xEA   0x690B             LDR      R3,[R1, #+16]
   \       0xEC   0x431E             ORRS     R6,R3,R6
   \       0xEE   0x69CB             LDR      R3,[R1, #+28]
   \       0xF0   0x431E             ORRS     R6,R3,R6
   \       0xF2   0x6A4B             LDR      R3,[R1, #+36]
   \       0xF4   0x431E             ORRS     R6,R3,R6
   \       0xF6   0x6A0B             LDR      R3,[R1, #+32]
   \       0xF8   0x431E             ORRS     R6,R3,R6
   \       0xFA   0x6B8B             LDR      R3,[R1, #+56]
   \       0xFC   0x431E             ORRS     R6,R3,R6
   \       0xFE   0x6C0B             LDR      R3,[R1, #+64]
   \      0x100   0x431E             ORRS     R6,R3,R6
   \      0x102   0x6026             STR      R6,[R4, #+0]
   \      0x104   0xE01A             B.N      ??OSPI_ConfigCmd_9
   2935                }
   2936                else
   2937                {
   2938                  /* ---- Command with instruction and address ---- */
   2939          
   2940                  /* Configure the CCR register with all communication parameters */
   2941                  MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE  | OCTOSPI_CCR_IDTR  | OCTOSPI_CCR_ISIZE  |
   2942                                          OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE),
   2943                                         (cmd->InstructionMode | cmd->InstructionDtrMode | cmd->InstructionSize |
   2944                                          cmd->AddressMode     | cmd->AddressDtrMode     | cmd->AddressSize));
   \                     ??OSPI_ConfigCmd_8: (+1)
   \      0x106   0x6826             LDR      R6,[R4, #+0]
   \      0x108   0x....             LDR.N    R3,??DataTable7_6
   \      0x10A   0x401E             ANDS     R6,R3,R6
   \      0x10C   0x68CB             LDR      R3,[R1, #+12]
   \      0x10E   0x431E             ORRS     R6,R3,R6
   \      0x110   0x694B             LDR      R3,[R1, #+20]
   \      0x112   0x431E             ORRS     R6,R3,R6
   \      0x114   0x690B             LDR      R3,[R1, #+16]
   \      0x116   0x431E             ORRS     R6,R3,R6
   \      0x118   0x69CB             LDR      R3,[R1, #+28]
   \      0x11A   0x431E             ORRS     R6,R3,R6
   \      0x11C   0x6A4B             LDR      R3,[R1, #+36]
   \      0x11E   0x431E             ORRS     R6,R3,R6
   \      0x120   0x6A0B             LDR      R3,[R1, #+32]
   \      0x122   0x431E             ORRS     R6,R3,R6
   \      0x124   0x6026             STR      R6,[R4, #+0]
   2945          
   2946                  /* The DHQC bit is linked with DDTR bit which should be activated */
   2947                  if ((hospi->Init.DelayHoldQuarterCycle == HAL_OSPI_DHQC_ENABLE) &&
   2948                      (cmd->InstructionDtrMode == HAL_OSPI_INSTRUCTION_DTR_ENABLE))
   \      0x126   0x6AC3             LDR      R3,[R0, #+44]
   \      0x128   0xF1B3 0x5F80      CMP      R3,#+268435456
   \      0x12C   0xD106             BNE.N    ??OSPI_ConfigCmd_9
   \      0x12E   0x694B             LDR      R3,[R1, #+20]
   \      0x130   0x2B08             CMP      R3,#+8
   \      0x132   0xD103             BNE.N    ??OSPI_ConfigCmd_9
   2949                  {
   2950                    MODIFY_REG((*ccr_reg), OCTOSPI_CCR_DDTR, HAL_OSPI_DATA_DTR_ENABLE);
   \      0x134   0x6823             LDR      R3,[R4, #+0]
   \      0x136   0xF053 0x6300      ORRS     R3,R3,#0x8000000
   \      0x13A   0x6023             STR      R3,[R4, #+0]
   2951                  }
   2952                }
   2953          
   2954                /* Configure the IR register with the instruction value */
   2955                *ir_reg = cmd->Instruction;
   \                     ??OSPI_ConfigCmd_9: (+1)
   \      0x13C   0x688B             LDR      R3,[R1, #+8]
   \      0x13E   0x602B             STR      R3,[R5, #+0]
   2956          
   2957                /* Configure the AR register with the address value */
   2958                hospi->Instance->AR = cmd->Address;
   \      0x140   0x6989             LDR      R1,[R1, #+24]
   \      0x142   0x6800             LDR      R0,[R0, #+0]
   \      0x144   0x6481             STR      R1,[R0, #+72]
   \      0x146   0xE04F             B.N      ??OSPI_ConfigCmd_10
   2959              }
   2960              else
   2961              {
   2962                if (cmd->DataMode != HAL_OSPI_DATA_NONE)
   \                     ??OSPI_ConfigCmd_7: (+1)
   \      0x148   0x6B8B             LDR      R3,[R1, #+56]
   \      0x14A   0x2B00             CMP      R3,#+0
   \      0x14C   0xD00E             BEQ.N    ??OSPI_ConfigCmd_11
   2963                {
   2964                  /* ---- Command with instruction and data ---- */
   2965          
   2966                  /* Configure the CCR register with all communication parameters */
   2967                  MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE | OCTOSPI_CCR_IDTR | OCTOSPI_CCR_ISIZE |
   2968                                          OCTOSPI_CCR_DMODE | OCTOSPI_CCR_DDTR),
   2969                                         (cmd->InstructionMode | cmd->InstructionDtrMode | cmd->InstructionSize |
   2970                                          cmd->DataMode        | cmd->DataDtrMode));
   \      0x14E   0x6823             LDR      R3,[R4, #+0]
   \      0x150   0x....             LDR.N    R0,??DataTable7_7
   \      0x152   0x4003             ANDS     R3,R0,R3
   \      0x154   0x68C8             LDR      R0,[R1, #+12]
   \      0x156   0x4303             ORRS     R3,R0,R3
   \      0x158   0x6948             LDR      R0,[R1, #+20]
   \      0x15A   0x4303             ORRS     R3,R0,R3
   \      0x15C   0x6908             LDR      R0,[R1, #+16]
   \      0x15E   0x4303             ORRS     R3,R0,R3
   \      0x160   0x6B88             LDR      R0,[R1, #+56]
   \      0x162   0x4303             ORRS     R3,R0,R3
   \      0x164   0x6C08             LDR      R0,[R1, #+64]
   \      0x166   0x4303             ORRS     R3,R0,R3
   \      0x168   0x6023             STR      R3,[R4, #+0]
   \      0x16A   0xE014             B.N      ??OSPI_ConfigCmd_12
   2971                }
   2972                else
   2973                {
   2974                  /* ---- Command with only instruction ---- */
   2975          
   2976                  /* Configure the CCR register with all communication parameters */
   2977                  MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE | OCTOSPI_CCR_IDTR | OCTOSPI_CCR_ISIZE),
   2978                                         (cmd->InstructionMode | cmd->InstructionDtrMode | cmd->InstructionSize));
   \                     ??OSPI_ConfigCmd_11: (+1)
   \      0x16C   0x6826             LDR      R6,[R4, #+0]
   \      0x16E   0x09B6             LSRS     R6,R6,#+6
   \      0x170   0x01B6             LSLS     R6,R6,#+6
   \      0x172   0x690F             LDR      R7,[R1, #+16]
   \      0x174   0x68CB             LDR      R3,[R1, #+12]
   \      0x176   0x431F             ORRS     R7,R3,R7
   \      0x178   0x694B             LDR      R3,[R1, #+20]
   \      0x17A   0x431F             ORRS     R7,R3,R7
   \      0x17C   0x433E             ORRS     R6,R7,R6
   \      0x17E   0x6026             STR      R6,[R4, #+0]
   2979          
   2980                  /* The DHQC bit is linked with DDTR bit which should be activated */
   2981                  if ((hospi->Init.DelayHoldQuarterCycle == HAL_OSPI_DHQC_ENABLE) &&
   2982                      (cmd->InstructionDtrMode == HAL_OSPI_INSTRUCTION_DTR_ENABLE))
   \      0x180   0x6AC0             LDR      R0,[R0, #+44]
   \      0x182   0xF1B0 0x5F80      CMP      R0,#+268435456
   \      0x186   0xD106             BNE.N    ??OSPI_ConfigCmd_12
   \      0x188   0x6948             LDR      R0,[R1, #+20]
   \      0x18A   0x2808             CMP      R0,#+8
   \      0x18C   0xD103             BNE.N    ??OSPI_ConfigCmd_12
   2983                  {
   2984                    MODIFY_REG((*ccr_reg), OCTOSPI_CCR_DDTR, HAL_OSPI_DATA_DTR_ENABLE);
   \      0x18E   0x6820             LDR      R0,[R4, #+0]
   \      0x190   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \      0x194   0x6020             STR      R0,[R4, #+0]
   2985                  }
   2986                }
   2987          
   2988                /* Configure the IR register with the instruction value */
   2989                *ir_reg = cmd->Instruction;
   \                     ??OSPI_ConfigCmd_12: (+1)
   \      0x196   0x6888             LDR      R0,[R1, #+8]
   \      0x198   0x6028             STR      R0,[R5, #+0]
   \      0x19A   0xE025             B.N      ??OSPI_ConfigCmd_10
   2990          
   2991              }
   2992            }
   2993            else
   2994            {
   2995              if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
   \                     ??OSPI_ConfigCmd_6: (+1)
   \      0x19C   0x69CB             LDR      R3,[R1, #+28]
   \      0x19E   0x2B00             CMP      R3,#+0
   \      0x1A0   0xD01F             BEQ.N    ??OSPI_ConfigCmd_13
   2996              {
   2997                if (cmd->DataMode != HAL_OSPI_DATA_NONE)
   \      0x1A2   0x6B8B             LDR      R3,[R1, #+56]
   \      0x1A4   0x2B00             CMP      R3,#+0
   \      0x1A6   0xD00E             BEQ.N    ??OSPI_ConfigCmd_14
   2998                {
   2999                  /* ---- Command with address and data ---- */
   3000          
   3001                  /* Configure the CCR register with all communication parameters */
   3002                  MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE |
   3003                                          OCTOSPI_CCR_DMODE  | OCTOSPI_CCR_DDTR),
   3004                                         (cmd->AddressMode | cmd->AddressDtrMode | cmd->AddressSize     |
   3005                                          cmd->DataMode    | cmd->DataDtrMode));
   \      0x1A8   0x6825             LDR      R5,[R4, #+0]
   \      0x1AA   0x....             LDR.N    R3,??DataTable7_8
   \      0x1AC   0x401D             ANDS     R5,R3,R5
   \      0x1AE   0x69CB             LDR      R3,[R1, #+28]
   \      0x1B0   0x431D             ORRS     R5,R3,R5
   \      0x1B2   0x6A4B             LDR      R3,[R1, #+36]
   \      0x1B4   0x431D             ORRS     R5,R3,R5
   \      0x1B6   0x6A0B             LDR      R3,[R1, #+32]
   \      0x1B8   0x431D             ORRS     R5,R3,R5
   \      0x1BA   0x6B8B             LDR      R3,[R1, #+56]
   \      0x1BC   0x431D             ORRS     R5,R3,R5
   \      0x1BE   0x6C0B             LDR      R3,[R1, #+64]
   \      0x1C0   0x431D             ORRS     R5,R3,R5
   \      0x1C2   0x6025             STR      R5,[R4, #+0]
   \      0x1C4   0xE009             B.N      ??OSPI_ConfigCmd_15
   3006                }
   3007                else
   3008                {
   3009                  /* ---- Command with only address ---- */
   3010          
   3011                  /* Configure the CCR register with all communication parameters */
   3012                  MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE),
   3013                                         (cmd->AddressMode | cmd->AddressDtrMode | cmd->AddressSize));
   \                     ??OSPI_ConfigCmd_14: (+1)
   \      0x1C6   0x6825             LDR      R5,[R4, #+0]
   \      0x1C8   0xF435 0x557C      BICS     R5,R5,#0x3F00
   \      0x1CC   0x69CB             LDR      R3,[R1, #+28]
   \      0x1CE   0x431D             ORRS     R5,R3,R5
   \      0x1D0   0x6A4B             LDR      R3,[R1, #+36]
   \      0x1D2   0x431D             ORRS     R5,R3,R5
   \      0x1D4   0x6A0B             LDR      R3,[R1, #+32]
   \      0x1D6   0x431D             ORRS     R5,R3,R5
   \      0x1D8   0x6025             STR      R5,[R4, #+0]
   3014                }
   3015          
   3016                /* Configure the AR register with the instruction value */
   3017                hospi->Instance->AR = cmd->Address;
   \                     ??OSPI_ConfigCmd_15: (+1)
   \      0x1DA   0x6989             LDR      R1,[R1, #+24]
   \      0x1DC   0x6800             LDR      R0,[R0, #+0]
   \      0x1DE   0x6481             STR      R1,[R0, #+72]
   \      0x1E0   0xE002             B.N      ??OSPI_ConfigCmd_10
   3018              }
   3019              else
   3020              {
   3021                /* ---- Invalid command configuration (no instruction, no address) ---- */
   3022                status = HAL_ERROR;
   \                     ??OSPI_ConfigCmd_13: (+1)
   \      0x1E2   0x2201             MOVS     R2,#+1
   3023                hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
   \      0x1E4   0x2108             MOVS     R1,#+8
   \      0x1E6   0x6581             STR      R1,[R0, #+88]
   3024              }
   3025            }
   3026          
   3027            /* Return function status */
   3028            return status;
   \                     ??OSPI_ConfigCmd_10: (+1)
   \      0x1E8   0x0010             MOVS     R0,R2
   \      0x1EA   0xB2C0             UXTB     R0,R0
   \      0x1EC   0xBCF0             POP      {R4-R7}
   \      0x1EE   0x4770             BX       LR
   3029          }
   3030          
   3031          /**
   3032            * @brief  Get the current IOM configuration for an OctoSPI instance.
   3033            * @param  instance_nb : number of the instance
   3034            * @param  cfg         : configuration of the IO Manager for the instance
   3035            * @retval HAL status
   3036            */

   \                                 In section .text, align 2, keep-with-next
   3037          static HAL_StatusTypeDef OSPIM_GetConfig(uint8_t instance_nb, OSPIM_CfgTypeDef *cfg)
   3038          {
   \                     OSPIM_GetConfig: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   3039            HAL_StatusTypeDef status = HAL_OK;
   \        0x2   0x2200             MOVS     R2,#+0
   3040            uint32_t reg;
   3041            uint32_t value = 0U;
   \        0x4   0x2400             MOVS     R4,#+0
   3042            uint32_t index;
   3043          
   3044            if ((instance_nb == 0U) || (instance_nb > OSPI_NB_INSTANCE) || (cfg == NULL))
   \        0x6   0x0003             MOVS     R3,R0
   \        0x8   0xB2DB             UXTB     R3,R3
   \        0xA   0x2B00             CMP      R3,#+0
   \        0xC   0xD005             BEQ.N    ??OSPIM_GetConfig_0
   \        0xE   0x0003             MOVS     R3,R0
   \       0x10   0xB2DB             UXTB     R3,R3
   \       0x12   0x2B03             CMP      R3,#+3
   \       0x14   0xD201             BCS.N    ??OSPIM_GetConfig_0
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD104             BNE.N    ??OSPIM_GetConfig_1
   3045            {
   3046              /* Invalid parameter -> error returned */
   3047              status = HAL_ERROR;
   \                     ??OSPIM_GetConfig_0: (+1)
   \       0x1A   0x2201             MOVS     R2,#+1
   3048            }
   3049            else
   3050            {
   3051              /* Initialize the structure */
   3052              cfg->ClkPort    = 0U;
   3053              cfg->DQSPort    = 0U;
   3054              cfg->NCSPort    = 0U;
   3055              cfg->IOLowPort  = 0U;
   3056              cfg->IOHighPort = 0U;
   3057          
   3058              if (instance_nb == 2U)
   3059              {
   3060                if ((OCTOSPIM->CR & OCTOSPIM_CR_MUXEN) == 0U)
   3061                {
   3062                  value = (OCTOSPIM_PCR_CLKSRC | OCTOSPIM_PCR_DQSSRC | OCTOSPIM_PCR_NCSSRC
   3063                         | OCTOSPIM_PCR_IOLSRC_1 | OCTOSPIM_PCR_IOHSRC_1);
   3064                }
   3065                else
   3066                {
   3067                  value = OCTOSPIM_PCR_NCSSRC;
   3068                }
   3069              }
   3070          
   3071              /* Get the information about the instance */
   3072              for (index = 0U; index < OSPI_IOM_NB_PORTS; index ++)
   3073              {
   3074                reg = OCTOSPIM->PCR[index];
   3075          
   3076                if ((reg & OCTOSPIM_PCR_CLKEN) != 0U)
   3077                {
   3078                  /* The clock is enabled on this port */
   3079                  if ((reg & OCTOSPIM_PCR_CLKSRC) == (value & OCTOSPIM_PCR_CLKSRC))
   3080                  {
   3081                    /* The clock correspond to the instance passed as parameter */
   3082                    cfg->ClkPort = index+1U;
   3083                  }
   3084                }
   3085          
   3086                if ((reg & OCTOSPIM_PCR_DQSEN) != 0U)
   3087                {
   3088                  /* The DQS is enabled on this port */
   3089                  if ((reg & OCTOSPIM_PCR_DQSSRC) == (value & OCTOSPIM_PCR_DQSSRC))
   3090                  {
   3091                    /* The DQS correspond to the instance passed as parameter */
   3092                    cfg->DQSPort = index+1U;
   3093                  }
   3094                }
   3095          
   3096                if ((reg & OCTOSPIM_PCR_NCSEN) != 0U)
   3097                {
   3098                  /* The nCS is enabled on this port */
   3099                  if ((reg & OCTOSPIM_PCR_NCSSRC) == (value & OCTOSPIM_PCR_NCSSRC))
   3100                  {
   3101                    /* The nCS correspond to the instance passed as parameter */
   3102                    cfg->NCSPort = index+1U;
   3103                  }
   3104                }
   3105          
   3106                if ((reg & OCTOSPIM_PCR_IOLEN) != 0U)
   3107                {
   3108                  /* The IO Low is enabled on this port */
   3109                  if ((reg & OCTOSPIM_PCR_IOLSRC_1) == (value & OCTOSPIM_PCR_IOLSRC_1))
   3110                  {
   3111                    /* The IO Low correspond to the instance passed as parameter */
   3112                    if ((reg & OCTOSPIM_PCR_IOLSRC_0) == 0U)
   3113                    {
   3114                      cfg->IOLowPort = (OCTOSPIM_PCR_IOLEN | (index+1U));
   3115                    }
   3116                    else
   3117                    {
   3118                      cfg->IOLowPort = (OCTOSPIM_PCR_IOHEN | (index+1U));
   3119                    }
   3120                  }
   3121                }
   3122          
   3123                if ((reg & OCTOSPIM_PCR_IOHEN) != 0U)
   3124                {
   3125                  /* The IO High is enabled on this port */
   3126                  if ((reg & OCTOSPIM_PCR_IOHSRC_1) == (value & OCTOSPIM_PCR_IOHSRC_1))
   3127                  {
   3128                    /* The IO High correspond to the instance passed as parameter */
   3129                    if ((reg & OCTOSPIM_PCR_IOHSRC_0) == 0U)
   3130                    {
   3131                      cfg->IOHighPort = (OCTOSPIM_PCR_IOLEN | (index+1U));
   3132                    }
   3133                    else
   3134                    {
   3135                      cfg->IOHighPort = (OCTOSPIM_PCR_IOHEN | (index+1U));
   3136                    }
   3137                  }
   3138                }
   3139              }
   3140            }
   3141          
   3142            /* Return function status */
   3143            return status;
   \                     ??OSPIM_GetConfig_2: (+1)
   \       0x1C   0x0010             MOVS     R0,R2
   \       0x1E   0xB2C0             UXTB     R0,R0
   \       0x20   0xBC70             POP      {R4-R6}
   \       0x22   0x4770             BX       LR
   \                     ??OSPIM_GetConfig_1: (+1)
   \       0x24   0x2300             MOVS     R3,#+0
   \       0x26   0x600B             STR      R3,[R1, #+0]
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x604B             STR      R3,[R1, #+4]
   \       0x2C   0x2300             MOVS     R3,#+0
   \       0x2E   0x608B             STR      R3,[R1, #+8]
   \       0x30   0x2300             MOVS     R3,#+0
   \       0x32   0x60CB             STR      R3,[R1, #+12]
   \       0x34   0x2300             MOVS     R3,#+0
   \       0x36   0x610B             STR      R3,[R1, #+16]
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0x2802             CMP      R0,#+2
   \       0x3C   0xD107             BNE.N    ??OSPIM_GetConfig_3
   \       0x3E   0x....             LDR.N    R0,??DataTable7_4
   \       0x40   0x6800             LDR      R0,[R0, #+0]
   \       0x42   0x07C0             LSLS     R0,R0,#+31
   \       0x44   0xD401             BMI.N    ??OSPIM_GetConfig_4
   \       0x46   0x....             LDR.N    R4,??DataTable7_9
   \       0x48   0xE001             B.N      ??OSPIM_GetConfig_3
   \                     ??OSPIM_GetConfig_4: (+1)
   \       0x4A   0xF44F 0x7400      MOV      R4,#+512
   \                     ??OSPIM_GetConfig_3: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xE004             B.N      ??OSPIM_GetConfig_5
   \                     ??OSPIM_GetConfig_6: (+1)
   \       0x52   0x1C43             ADDS     R3,R0,#+1
   \       0x54   0xF053 0x7380      ORRS     R3,R3,#0x1000000
   \       0x58   0x610B             STR      R3,[R1, #+16]
   \                     ??OSPIM_GetConfig_7: (+1)
   \       0x5A   0x1C40             ADDS     R0,R0,#+1
   \                     ??OSPIM_GetConfig_5: (+1)
   \       0x5C   0x2802             CMP      R0,#+2
   \       0x5E   0xD2DD             BCS.N    ??OSPIM_GetConfig_2
   \       0x60   0x....             LDR.N    R3,??DataTable7_3
   \       0x62   0xF853 0x3020      LDR      R3,[R3, R0, LSL #+2]
   \       0x66   0x07DD             LSLS     R5,R3,#+31
   \       0x68   0xD507             BPL.N    ??OSPIM_GetConfig_8
   \       0x6A   0xF013 0x0502      ANDS     R5,R3,#0x2
   \       0x6E   0xF014 0x0602      ANDS     R6,R4,#0x2
   \       0x72   0x42B5             CMP      R5,R6
   \       0x74   0xD101             BNE.N    ??OSPIM_GetConfig_8
   \       0x76   0x1C45             ADDS     R5,R0,#+1
   \       0x78   0x600D             STR      R5,[R1, #+0]
   \                     ??OSPIM_GetConfig_8: (+1)
   \       0x7A   0x06DD             LSLS     R5,R3,#+27
   \       0x7C   0xD507             BPL.N    ??OSPIM_GetConfig_9
   \       0x7E   0xF013 0x0520      ANDS     R5,R3,#0x20
   \       0x82   0xF014 0x0620      ANDS     R6,R4,#0x20
   \       0x86   0x42B5             CMP      R5,R6
   \       0x88   0xD101             BNE.N    ??OSPIM_GetConfig_9
   \       0x8A   0x1C45             ADDS     R5,R0,#+1
   \       0x8C   0x604D             STR      R5,[R1, #+4]
   \                     ??OSPIM_GetConfig_9: (+1)
   \       0x8E   0x05DD             LSLS     R5,R3,#+23
   \       0x90   0xD507             BPL.N    ??OSPIM_GetConfig_10
   \       0x92   0xF413 0x7500      ANDS     R5,R3,#0x200
   \       0x96   0xF414 0x7600      ANDS     R6,R4,#0x200
   \       0x9A   0x42B5             CMP      R5,R6
   \       0x9C   0xD101             BNE.N    ??OSPIM_GetConfig_10
   \       0x9E   0x1C45             ADDS     R5,R0,#+1
   \       0xA0   0x608D             STR      R5,[R1, #+8]
   \                     ??OSPIM_GetConfig_10: (+1)
   \       0xA2   0x03DD             LSLS     R5,R3,#+15
   \       0xA4   0xD510             BPL.N    ??OSPIM_GetConfig_11
   \       0xA6   0xF413 0x2580      ANDS     R5,R3,#0x40000
   \       0xAA   0xF414 0x2680      ANDS     R6,R4,#0x40000
   \       0xAE   0x42B5             CMP      R5,R6
   \       0xB0   0xD10A             BNE.N    ??OSPIM_GetConfig_11
   \       0xB2   0x039D             LSLS     R5,R3,#+14
   \       0xB4   0xD404             BMI.N    ??OSPIM_GetConfig_12
   \       0xB6   0x1C45             ADDS     R5,R0,#+1
   \       0xB8   0xF455 0x3580      ORRS     R5,R5,#0x10000
   \       0xBC   0x60CD             STR      R5,[R1, #+12]
   \       0xBE   0xE003             B.N      ??OSPIM_GetConfig_11
   \                     ??OSPIM_GetConfig_12: (+1)
   \       0xC0   0x1C45             ADDS     R5,R0,#+1
   \       0xC2   0xF055 0x7580      ORRS     R5,R5,#0x1000000
   \       0xC6   0x60CD             STR      R5,[R1, #+12]
   \                     ??OSPIM_GetConfig_11: (+1)
   \       0xC8   0x01DD             LSLS     R5,R3,#+7
   \       0xCA   0xD5C6             BPL.N    ??OSPIM_GetConfig_7
   \       0xCC   0xF013 0x6580      ANDS     R5,R3,#0x4000000
   \       0xD0   0xF014 0x6680      ANDS     R6,R4,#0x4000000
   \       0xD4   0x42B5             CMP      R5,R6
   \       0xD6   0xD1C0             BNE.N    ??OSPIM_GetConfig_7
   \       0xD8   0x019B             LSLS     R3,R3,#+6
   \       0xDA   0xD4BA             BMI.N    ??OSPIM_GetConfig_6
   \       0xDC   0x1C43             ADDS     R3,R0,#+1
   \       0xDE   0xF453 0x3380      ORRS     R3,R3,#0x10000
   \       0xE2   0x610B             STR      R3,[R1, #+16]
   \       0xE4   0xE7B9             B.N      ??OSPIM_GetConfig_7
   3144          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0xF8E0'F88C        DC32     0xf8e0f88c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x....'....        DC32     OSPI_DMAAbortCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0xFFFF'F3F3        DC32     0xfffff3f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0xFFFF'FCFC        DC32     0xfffffcfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0xCFFF'FFF7        DC32     0xcffffff7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x5200'5000        DC32     0x52005000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x5200'A000        DC32     0x5200a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0x5200'B404        DC32     0x5200b404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0x5200'B400        DC32     0x5200b400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \        0x0   0xF0FF'C0C0        DC32     0xf0ffc0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \        0x0   0xFFFF'C0C0        DC32     0xffffc0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \        0x0   0xF0FF'FFC0        DC32     0xf0ffffc0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \        0x0   0xF0FF'C0FF        DC32     0xf0ffc0ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \        0x0   0x0404'0222        DC32     0x4040222
   3145          
   3146          /**
   3147            @endcond
   3148            */
   3149          
   3150          /**
   3151            * @}
   3152            */
   3153          
   3154          #endif /* HAL_OSPI_MODULE_ENABLED */
   3155          
   3156          /**
   3157            * @}
   3158            */
   3159          
   3160          /**
   3161            * @}
   3162            */
   3163          
   3164          #endif /* OCTOSPI || OCTOSPI1 || OCTOSPI2 */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      88   HAL_OSPIM_Config
        88   -> OSPIM_GetConfig
      24   HAL_OSPI_Abort
        24   -> HAL_GetTick
        24   -> HAL_MDMA_Abort
        24   -> OSPI_WaitFlagStateUntilTimeout
       0   HAL_OSPI_AbortCpltCallback
      16   HAL_OSPI_Abort_IT
        16   -> HAL_MDMA_Abort_IT
        16   -> HAL_OSPI_AbortCpltCallback
      32   HAL_OSPI_AutoPolling
        32   -> HAL_GetTick
        32   -> OSPI_WaitFlagStateUntilTimeout
      24   HAL_OSPI_AutoPolling_IT
        24   -> HAL_GetTick
        24   -> OSPI_WaitFlagStateUntilTimeout
       0   HAL_OSPI_CmdCpltCallback
      24   HAL_OSPI_Command
        24   -> HAL_GetTick
        24   -> OSPI_ConfigCmd
        24   -> OSPI_WaitFlagStateUntilTimeout
      16   HAL_OSPI_Command_IT
        16   -> HAL_GetTick
        16   -> OSPI_ConfigCmd
        16   -> OSPI_WaitFlagStateUntilTimeout
      16   HAL_OSPI_DeInit
        16   -> HAL_OSPI_MspDeInit
       0   HAL_OSPI_ErrorCallback
       0   HAL_OSPI_FifoThresholdCallback
       0   HAL_OSPI_GetError
       0   HAL_OSPI_GetFifoThreshold
       0   HAL_OSPI_GetState
      24   HAL_OSPI_HyperbusCfg
        24   -> HAL_GetTick
        24   -> OSPI_WaitFlagStateUntilTimeout
      24   HAL_OSPI_HyperbusCmd
        24   -> HAL_GetTick
        24   -> OSPI_WaitFlagStateUntilTimeout
      16   HAL_OSPI_IRQHandler
        16   -> HAL_MDMA_Abort_IT
        16   -> HAL_OSPI_AbortCpltCallback
        16   -> HAL_OSPI_CmdCpltCallback
        16   -> HAL_OSPI_ErrorCallback
        16   -> HAL_OSPI_FifoThresholdCallback
        16   -> HAL_OSPI_RxCpltCallback
        16   -> HAL_OSPI_StatusMatchCallback
        16   -> HAL_OSPI_TimeOutCallback
        16   -> HAL_OSPI_TxCpltCallback
      24   HAL_OSPI_Init
        24   -> HAL_GetTick
        24   -> HAL_OSPI_MspInit
        24   -> HAL_OSPI_SetTimeout
        24   -> OSPI_WaitFlagStateUntilTimeout
      16   HAL_OSPI_MemoryMapped
        16   -> HAL_GetTick
        16   -> OSPI_WaitFlagStateUntilTimeout
       0   HAL_OSPI_MspDeInit
       0   HAL_OSPI_MspInit
      32   HAL_OSPI_Receive
        32   -> HAL_GetTick
        32   -> OSPI_WaitFlagStateUntilTimeout
      24   HAL_OSPI_Receive_DMA
        24   -> HAL_MDMA_Start_IT
       8   HAL_OSPI_Receive_IT
       0   HAL_OSPI_RxCpltCallback
       0   HAL_OSPI_RxHalfCpltCallback
       0   HAL_OSPI_SetFifoThreshold
       0   HAL_OSPI_SetTimeout
       0   HAL_OSPI_StatusMatchCallback
       0   HAL_OSPI_TimeOutCallback
      32   HAL_OSPI_Transmit
        32   -> HAL_GetTick
        32   -> OSPI_WaitFlagStateUntilTimeout
      16   HAL_OSPI_Transmit_DMA
        16   -> HAL_MDMA_Start_IT
       0   HAL_OSPI_Transmit_IT
       0   HAL_OSPI_TxCpltCallback
       0   HAL_OSPI_TxHalfCpltCallback
      12   OSPIM_GetConfig
      16   OSPI_ConfigCmd
       8   OSPI_DMAAbortCplt
         8   -> HAL_OSPI_AbortCpltCallback
         8   -> HAL_OSPI_ErrorCallback
       0   OSPI_DMACplt
       8   OSPI_DMAError
         8   -> HAL_OSPI_Abort_IT
         8   -> HAL_OSPI_ErrorCallback
      24   OSPI_WaitFlagStateUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
   1'882  HAL_OSPIM_Config
     162  HAL_OSPI_Abort
       2  HAL_OSPI_AbortCpltCallback
     146  HAL_OSPI_Abort_IT
     206  HAL_OSPI_AutoPolling
     170  HAL_OSPI_AutoPolling_IT
       2  HAL_OSPI_CmdCpltCallback
     226  HAL_OSPI_Command
     134  HAL_OSPI_Command_IT
      54  HAL_OSPI_DeInit
       2  HAL_OSPI_ErrorCallback
       2  HAL_OSPI_FifoThresholdCallback
       4  HAL_OSPI_GetError
      12  HAL_OSPI_GetFifoThreshold
       4  HAL_OSPI_GetState
      84  HAL_OSPI_HyperbusCfg
     138  HAL_OSPI_HyperbusCmd
     422  HAL_OSPI_IRQHandler
     282  HAL_OSPI_Init
     110  HAL_OSPI_MemoryMapped
       2  HAL_OSPI_MspDeInit
       2  HAL_OSPI_MspInit
     220  HAL_OSPI_Receive
     322  HAL_OSPI_Receive_DMA
     136  HAL_OSPI_Receive_IT
       2  HAL_OSPI_RxCpltCallback
       2  HAL_OSPI_RxHalfCpltCallback
      44  HAL_OSPI_SetFifoThreshold
       6  HAL_OSPI_SetTimeout
       2  HAL_OSPI_StatusMatchCallback
       2  HAL_OSPI_TimeOutCallback
     170  HAL_OSPI_Transmit
     268  HAL_OSPI_Transmit_DMA
      82  HAL_OSPI_Transmit_IT
       2  HAL_OSPI_TxCpltCallback
       2  HAL_OSPI_TxHalfCpltCallback
     230  OSPIM_GetConfig
     496  OSPI_ConfigCmd
      76  OSPI_DMAAbortCplt
      44  OSPI_DMACplt
      58  OSPI_DMAError
      80  OSPI_WaitFlagStateUntilTimeout

 
 6'348 bytes in section .text
 
 6'324 bytes of CODE memory (+ 24 bytes shared)

Errors: none
Warnings: none
