###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         08/Feb/2022  20:54:23
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\Core\Src\main.c [UTF-8]
#    Command line                 =
#        -f
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Application\User\Core\main.o.rsp
#        (D:\99_Project\GitHub\TouchGFX\MyApplication\Core\Src\main.c -D
#        USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Application\User\Core
#        -lA
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Application\User\Core
#        -o
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Application\User\Core
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Core/Inc\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/App\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Application\User\Core\main.o.d
#    Locale                       =  C
#    List file                    =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Application\User\Core\main.lst
#    Object file                  =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Application\User\Core\main.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  1
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

D:\99_Project\GitHub\TouchGFX\MyApplication\Core\Src\main.c
      1          /* USER CODE BEGIN Header */
      2          /**
      3            ******************************************************************************
      4            * @file           : main.c
      5            * @brief          : Main program body
      6            ******************************************************************************
      7            * @attention
      8            *
      9            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     10            * All rights reserved.</center></h2>
     11            *
     12            * This software component is licensed by ST under Ultimate Liberty license
     13            * SLA0044, the "License"; You may not use this file except in compliance with
     14            * the License. You may obtain a copy of the License at:
     15            *                             www.st.com/SLA0044
     16            *
     17            ******************************************************************************
     18            */
     19          /* USER CODE END Header */
     20          /* Includes ------------------------------------------------------------------*/
     21          #include "main.h"
     22          #include "cmsis_os.h"
     23          #include "app_touchgfx.h"
     24          
     25          /* Private includes ----------------------------------------------------------*/
     26          /* USER CODE BEGIN Includes */
     27          #include "stm32h7b3i_discovery_ospi.h"
     28          #include "stm32h7b3i_discovery.h"
     29          #include "User_Include.h"
     30          /* USER CODE END Includes */
     31          
     32          /* Private typedef -----------------------------------------------------------*/
     33          /* USER CODE BEGIN PTD */
     34          
     35          /* USER CODE END PTD */
     36          
     37          /* Private define ------------------------------------------------------------*/
     38          /* USER CODE BEGIN PD */
     39          /* USER CODE END PD */
     40          
     41          /* Private macro -------------------------------------------------------------*/
     42          /* USER CODE BEGIN PM */
     43          
     44          /* USER CODE END PM */
     45          
     46          /* Private variables ---------------------------------------------------------*/
     47          

   \                                 In section .bss, align 4
     48          CRC_HandleTypeDef hcrc;
   \                     hcrc:
   \        0x0                      DS8 36
     49          

   \                                 In section .bss, align 4
     50          DMA2D_HandleTypeDef hdma2d;
   \                     hdma2d:
   \        0x0                      DS8 104
     51          

   \                                 In section .bss, align 4
     52          I2C_HandleTypeDef hi2c4;
   \                     hi2c4:
   \        0x0                      DS8 76
     53          

   \                                 In section .bss, align 4
     54          LTDC_HandleTypeDef hltdc;
   \                     hltdc:
   \        0x0                      DS8 168
     55          

   \                                 In section .bss, align 4
     56          OSPI_HandleTypeDef hospi1;
   \                     hospi1:
   \        0x0                      DS8 96
     57          

   \                                 In section .bss, align 4
     58          UART_HandleTypeDef huart1;
   \                     huart1:
   \        0x0                      DS8 144
     59          
     60          /* Definitions for defaultTask */

   \                                 In section .bss, align 4
     61          osThreadId_t defaultTaskHandle;
   \                     defaultTaskHandle:
   \        0x0                      DS8 4

   \                                 In section .rodata, align 4
     62          const osThreadAttr_t defaultTask_attributes = {
   \                     defaultTask_attributes:
   \        0x0   0x....'....        DC32 ?_0, 0, 0x0, 0, 0x0, 512, 24

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0200  

   \              0x0000'0018
   \       0x1C                      DS8 8
     63            .name = "defaultTask",
     64            .stack_size = 128 * 4,
     65            .priority = (osPriority_t) osPriorityNormal,
     66          };
     67          /* Definitions for GUI_Task */

   \                                 In section .bss, align 4
     68          osThreadId_t GUI_TaskHandle;
   \                     GUI_TaskHandle:
   \        0x0                      DS8 4

   \                                 In section .rodata, align 4
     69          const osThreadAttr_t GUI_Task_attributes = {
   \                     GUI_Task_attributes:
   \        0x0   0x....'....        DC32 ?_1, 0, 0x0, 0, 0x0, 16'384, 24

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'4000  

   \              0x0000'0018
   \       0x1C                      DS8 8
     70            .name = "GUI_Task",
     71            .stack_size = 4096 * 4,
     72            .priority = (osPriority_t) osPriorityNormal,
     73          };
     74          /* Definitions for testTimer */
     75          //osTimerId_t testTimerHandle;
     76          //const osTimerAttr_t testTimer_attributes = {
     77          //  .name = "testTimer"
     78          //};
     79          /* USER CODE BEGIN PV */

   \                                 In section .bss, align 4
     80          osThreadId_t buttonReadTaskHandle;
   \                     buttonReadTaskHandle:
   \        0x0                      DS8 4

   \                                 In section .rodata, align 4
     81          const osThreadAttr_t buttonReadTask_attributes = {
   \                     buttonReadTask_attributes:
   \        0x0   0x....'....        DC32 ?_2, 0, 0x0, 0, 0x0, 512, 24

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0200  

   \              0x0000'0018
   \       0x1C                      DS8 8
     82            .name = "buttonReadTask",
     83            .stack_size = 128 * 4,
     84            .priority = (osPriority_t) osPriorityNormal,
     85          };
     86          /* USER CODE END PV */
     87          
     88          /* Private function prototypes -----------------------------------------------*/
     89          void SystemClock_Config(void);
     90          static void MPU_Config(void);
     91          static void MX_CRC_Init(void);
     92          static void MX_GPIO_Init(void);
     93          static void MX_DMA2D_Init(void);
     94          static void MX_LTDC_Init(void);
     95          static void MX_I2C4_Init(void);
     96          static void MX_OCTOSPI1_Init(void);
     97          static void MX_USART1_UART_Init(void);
     98          void StartDefaultTask(void *argument);
     99          extern void TouchGFX_Task(void *argument);
    100          void testTmrCallback(void *argument);
    101          
    102          /* USER CODE BEGIN PFP */
    103          
    104          /* USER CODE END PFP */
    105          
    106          /* Private user code ---------------------------------------------------------*/
    107          /* USER CODE BEGIN 0 */
    108          
    109          /* USER CODE END 0 */
    110          
    111          /**
    112            * @brief  The application entry point.
    113            * @retval int
    114            */

   \                                 In section .text, align 2, keep-with-next
    115          int main(void)
    116          {
   \                     main: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    117            /* USER CODE BEGIN 1 */
    118          
    119            /* USER CODE END 1 */
    120          
    121            /* MPU Configuration--------------------------------------------------------*/
    122            MPU_Config();
   \        0x2   0x.... 0x....      BL       MPU_Config
    123          
    124            /* Enable I-Cache---------------------------------------------------------*/
    125            SCB_EnableICache();
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable11
   \        0xA   0x6808             LDR      R0,[R1, #+0]
   \        0xC   0x0380             LSLS     R0,R0,#+14
   \        0xE   0xD413             BMI.N    ??main_0
   \                     ??main_1: (+1)
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x.... 0x....      LDR.W    R2,??DataTable11_1
   \       0x1E   0x6010             STR      R0,[R2, #+0]
   \       0x20   0xF3BF 0x8F4F      DSB      SY
   \       0x24   0xF3BF 0x8F6F      ISB      SY
   \       0x28   0x6808             LDR      R0,[R1, #+0]
   \       0x2A   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \       0x2E   0x6008             STR      R0,[R1, #+0]
   \       0x30   0xF3BF 0x8F4F      DSB      SY
   \       0x34   0xF3BF 0x8F6F      ISB      SY
    126          
    127            /* Enable D-Cache---------------------------------------------------------*/
    128            SCB_EnableDCache();
   \                     ??main_0: (+1)
   \       0x38   0x6808             LDR      R0,[R1, #+0]
   \       0x3A   0x03C0             LSLS     R0,R0,#+15
   \       0x3C   0xD427             BMI.N    ??main_2
   \                     ??main_3: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x.... 0x....      LDR.W    R2,??DataTable11_2
   \       0x44   0x6010             STR      R0,[R2, #+0]
   \       0x46   0xF3BF 0x8F4F      DSB      SY
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x4E   0x6802             LDR      R2,[R0, #+0]
   \       0x50   0xF3C2 0x334E      UBFX     R3,R2,#+13,#+15
   \                     ??main_4: (+1)
   \       0x54   0xF3C2 0x04C9      UBFX     R4,R2,#+3,#+10
   \                     ??main_5: (+1)
   \       0x58   0xF643 0x70E0      MOVW     R0,#+16352
   \       0x5C   0xEA10 0x1043      ANDS     R0,R0,R3, LSL #+5
   \       0x60   0xEA50 0x7084      ORRS     R0,R0,R4, LSL #+30
   \       0x64   0x.... 0x....      LDR.W    R5,??DataTable11_4
   \       0x68   0x6028             STR      R0,[R5, #+0]
   \       0x6A   0x0020             MOVS     R0,R4
   \       0x6C   0x1E44             SUBS     R4,R0,#+1
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD1F2             BNE.N    ??main_5
   \       0x72   0x0018             MOVS     R0,R3
   \       0x74   0x1E43             SUBS     R3,R0,#+1
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD1EC             BNE.N    ??main_4
   \       0x7A   0xF3BF 0x8F4F      DSB      SY
   \       0x7E   0x6808             LDR      R0,[R1, #+0]
   \       0x80   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \       0x84   0x6008             STR      R0,[R1, #+0]
   \       0x86   0xF3BF 0x8F4F      DSB      SY
   \       0x8A   0xF3BF 0x8F6F      ISB      SY
    129          
    130            /* MCU Configuration--------------------------------------------------------*/
    131          
    132            /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
    133            HAL_Init();
   \                     ??main_2: (+1)
   \       0x8E   0x.... 0x....      BL       HAL_Init
    134          
    135            /* USER CODE BEGIN Init */
    136          
    137            /* USER CODE END Init */
    138          
    139            /* Configure the system clock */
    140            SystemClock_Config();
   \       0x92   0x.... 0x....      BL       SystemClock_Config
    141          
    142            /* USER CODE BEGIN SysInit */
    143          
    144            /* USER CODE END SysInit */
    145          
    146            /* Initialize all configured peripherals */
    147            MX_CRC_Init();
   \       0x96   0x.... 0x....      BL       MX_CRC_Init
    148            MX_GPIO_Init();
   \       0x9A   0x.... 0x....      BL       MX_GPIO_Init
    149            MX_DMA2D_Init();
   \       0x9E   0x.... 0x....      BL       MX_DMA2D_Init
    150            MX_LTDC_Init();
   \       0xA2   0x.... 0x....      BL       MX_LTDC_Init
    151            MX_I2C4_Init();
   \       0xA6   0x.... 0x....      BL       MX_I2C4_Init
    152            MX_OCTOSPI1_Init();
   \       0xAA   0x.... 0x....      BL       MX_OCTOSPI1_Init
    153            MX_USART1_UART_Init();
   \       0xAE   0x.... 0x....      BL       MX_USART1_UART_Init
    154            MX_TouchGFX_Init();
   \       0xB2   0x.... 0x....      BL       MX_TouchGFX_Init
    155            /* USER CODE BEGIN 2 */
    156          
    157            /* USER CODE END 2 */
    158          
    159            /* Init scheduler */
    160            osKernelInitialize();
   \       0xB6   0x.... 0x....      BL       osKernelInitialize
    161          
    162            /* USER CODE BEGIN RTOS_MUTEX */
    163            /* add mutexes, ... */
    164            /* USER CODE END RTOS_MUTEX */
    165          
    166            /* USER CODE BEGIN RTOS_SEMAPHORES */
    167            /* add semaphores, ... */
    168            /* USER CODE END RTOS_SEMAPHORES */
    169          
    170            /* Create the timer(s) */
    171            /* creation of testTimer */
    172          //  testTimerHandle = osTimerNew(testTmrCallback, osTimerPeriodic, NULL, &testTimer_attributes);
    173          
    174            /* USER CODE BEGIN RTOS_TIMERS */
    175            /* start timers, add new ones, ... */
    176            /* USER CODE END RTOS_TIMERS */
    177          
    178            /* USER CODE BEGIN RTOS_QUEUES */
    179            /* add queues, ... */
    180            /* USER CODE END RTOS_QUEUES */
    181          
    182            /* Create the thread(s) */
    183            /* creation of defaultTask */
    184            defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &defaultTask_attributes);
   \       0xBA   0x.... 0x....      LDR.W    R2,??DataTable11_5
   \       0xBE   0x2100             MOVS     R1,#+0
   \       0xC0   0x.... 0x....      ADR.W    R0,StartDefaultTask
   \       0xC4   0x.... 0x....      BL       osThreadNew
   \       0xC8   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \       0xCC   0x6008             STR      R0,[R1, #+0]
    185          
    186            /* creation of GUI_Task */
    187            GUI_TaskHandle = osThreadNew(TouchGFX_Task, NULL, &GUI_Task_attributes);
   \       0xCE   0x.... 0x....      LDR.W    R2,??DataTable11_7
   \       0xD2   0x2100             MOVS     R1,#+0
   \       0xD4   0x.... 0x....      LDR.W    R0,??DataTable11_8
   \       0xD8   0x.... 0x....      BL       osThreadNew
   \       0xDC   0x.... 0x....      LDR.W    R1,??DataTable11_9
   \       0xE0   0x6008             STR      R0,[R1, #+0]
    188          
    189            /* USER CODE BEGIN RTOS_THREADS */
    190            /* add threads, ... */
    191            buttonReadTaskHandle = osThreadNew(ButtonReadTask, NULL, &buttonReadTask_attributes);
   \       0xE2   0x.... 0x....      LDR.W    R2,??DataTable11_10
   \       0xE6   0x2100             MOVS     R1,#+0
   \       0xE8   0x.... 0x....      LDR.W    R0,??DataTable11_11
   \       0xEC   0x.... 0x....      BL       osThreadNew
   \       0xF0   0x.... 0x....      LDR.W    R1,??DataTable11_12
   \       0xF4   0x6008             STR      R0,[R1, #+0]
    192            /* USER CODE END RTOS_THREADS */
    193          
    194            /* USER CODE BEGIN RTOS_EVENTS */
    195            /* add events, ... */
    196            /* USER CODE END RTOS_EVENTS */
    197          
    198            /* Start scheduler */
    199            osKernelStart();
   \       0xF6   0x.... 0x....      BL       osKernelStart
    200          
    201            /* We should never get here as control is now taken by the scheduler */
    202            /* Infinite loop */
    203            /* USER CODE BEGIN WHILE */
    204          
    205            while (1)
   \                     ??main_6: (+1)
   \       0xFA   0xE7FE             B.N      ??main_6
    206            {
    207              /* USER CODE END WHILE */
    208          
    209              /* USER CODE BEGIN 3 */
    210            }
    211            /* USER CODE END 3 */
    212          }
    213          
    214          /**
    215            * @brief System Clock Configuration
    216            * @retval None
    217            */

   \                                 In section .text, align 2, keep-with-next
    218          void SystemClock_Config(void)
    219          {
   \                     SystemClock_Config: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB09C             SUB      SP,SP,#+112
   \        0x4   0x214C             MOVS     R1,#+76
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0xAC09             ADD      R4,SP,#+36
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x.... 0x....      BL       __aeabi_memset
   \       0x10   0x2120             MOVS     R1,#+32
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0xAC01             ADD      R4,SP,#+4
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       __aeabi_memset
    220            RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    221            RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
    222          
    223            /** Supply configuration update enable
    224            */
    225            HAL_PWREx_ConfigSupply(PWR_DIRECT_SMPS_SUPPLY);
   \       0x1C   0x2004             MOVS     R0,#+4
   \       0x1E   0x.... 0x....      BL       HAL_PWREx_ConfigSupply
    226            /** Configure the main internal regulator output voltage
    227            */
    228            __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x9000             STR      R0,[SP, #+0]
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable11_13
   \       0x2A   0x6801             LDR      R1,[R0, #+0]
   \       0x2C   0xF451 0x4140      ORRS     R1,R1,#0xC000
   \       0x30   0x6001             STR      R1,[R0, #+0]
   \       0x32   0x6801             LDR      R1,[R0, #+0]
   \       0x34   0xF411 0x4140      ANDS     R1,R1,#0xC000
   \       0x38   0x9100             STR      R1,[SP, #+0]
   \       0x3A   0x9900             LDR      R1,[SP, #+0]
    229          
    230            while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
   \                     ??SystemClock_Config_0: (+1)
   \       0x3C   0x6801             LDR      R1,[R0, #+0]
   \       0x3E   0x0489             LSLS     R1,R1,#+18
   \       0x40   0xD5FC             BPL.N    ??SystemClock_Config_0
    231            /** Macro to configure the PLL clock source
    232            */
    233            __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable11_14
   \       0x46   0x2102             MOVS     R1,#+2
   \       0x48   0x6802             LDR      R2,[R0, #+0]
   \       0x4A   0xF361 0x0201      BFI      R2,R1,#+0,#+2
   \       0x4E   0x6002             STR      R2,[R0, #+0]
    234            /** Initializes the RCC Oscillators according to the specified parameters
    235            * in the RCC_OscInitTypeDef structure.
    236            */
    237            RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0x9009             STR      R0,[SP, #+36]
    238            RCC_OscInitStruct.HSEState = RCC_HSE_ON;
   \       0x54   0xF45F 0x3080      MOVS     R0,#+65536
   \       0x58   0x900A             STR      R0,[SP, #+40]
    239            RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
   \       0x5A   0x2002             MOVS     R0,#+2
   \       0x5C   0x9012             STR      R0,[SP, #+72]
    240            RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
   \       0x5E   0x2002             MOVS     R0,#+2
   \       0x60   0x9013             STR      R0,[SP, #+76]
    241            RCC_OscInitStruct.PLL.PLLM = 12;
   \       0x62   0x200C             MOVS     R0,#+12
   \       0x64   0x9014             STR      R0,[SP, #+80]
    242            RCC_OscInitStruct.PLL.PLLN = 280;
   \       0x66   0xF44F 0x708C      MOV      R0,#+280
   \       0x6A   0x9015             STR      R0,[SP, #+84]
    243            RCC_OscInitStruct.PLL.PLLP = 2;
   \       0x6C   0x2002             MOVS     R0,#+2
   \       0x6E   0x9016             STR      R0,[SP, #+88]
    244            RCC_OscInitStruct.PLL.PLLQ = 2;
   \       0x70   0x2002             MOVS     R0,#+2
   \       0x72   0x9017             STR      R0,[SP, #+92]
    245            RCC_OscInitStruct.PLL.PLLR = 2;
   \       0x74   0x2002             MOVS     R0,#+2
   \       0x76   0x9018             STR      R0,[SP, #+96]
    246            RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_1;
   \       0x78   0x2004             MOVS     R0,#+4
   \       0x7A   0x9019             STR      R0,[SP, #+100]
    247            RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x901A             STR      R0,[SP, #+104]
    248            RCC_OscInitStruct.PLL.PLLFRACN = 0;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0x901B             STR      R0,[SP, #+108]
    249            if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
   \       0x84   0xA809             ADD      R0,SP,#+36
   \       0x86   0x.... 0x....      BL       HAL_RCC_OscConfig
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD001             BEQ.N    ??SystemClock_Config_1
    250            {
    251              Error_Handler();
   \       0x8E   0x.... 0x....      BL       Error_Handler
    252            }
    253            /** Initializes the CPU, AHB and APB buses clocks
    254            */
    255            RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
    256                                        |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
    257                                        |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
   \                     ??SystemClock_Config_1: (+1)
   \       0x92   0x203F             MOVS     R0,#+63
   \       0x94   0x9001             STR      R0,[SP, #+4]
    258            RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
   \       0x96   0x2003             MOVS     R0,#+3
   \       0x98   0x9002             STR      R0,[SP, #+8]
    259            RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0x9003             STR      R0,[SP, #+12]
    260            RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
   \       0x9E   0x2008             MOVS     R0,#+8
   \       0xA0   0x9004             STR      R0,[SP, #+16]
    261            RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV1;
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0x9005             STR      R0,[SP, #+20]
    262            RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0x9006             STR      R0,[SP, #+24]
    263            RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0x9007             STR      R0,[SP, #+28]
    264            RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;
   \       0xAE   0x2000             MOVS     R0,#+0
   \       0xB0   0x9008             STR      R0,[SP, #+32]
    265          
    266            if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
   \       0xB2   0x2103             MOVS     R1,#+3
   \       0xB4   0xA801             ADD      R0,SP,#+4
   \       0xB6   0x.... 0x....      BL       HAL_RCC_ClockConfig
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD001             BEQ.N    ??SystemClock_Config_2
    267            {
    268              Error_Handler();
   \       0xBE   0x.... 0x....      BL       Error_Handler
    269            }
    270          }
   \                     ??SystemClock_Config_2: (+1)
   \       0xC2   0xB01C             ADD      SP,SP,#+112
   \       0xC4   0xBD10             POP      {R4,PC}
    271          
    272          /**
    273            * @brief CRC Initialization Function
    274            * @param None
    275            * @retval None
    276            */

   \                                 In section .text, align 2, keep-with-next
    277          static void MX_CRC_Init(void)
    278          {
   \                     MX_CRC_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    279          
    280            /* USER CODE BEGIN CRC_Init 0 */
    281          
    282            /* USER CODE END CRC_Init 0 */
    283          
    284            /* USER CODE BEGIN CRC_Init 1 */
    285          
    286            /* USER CODE END CRC_Init 1 */
    287            hcrc.Instance = CRC;
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable11_15
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable11_16
   \        0xA   0x6001             STR      R1,[R0, #+0]
    288            hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x7101             STRB     R1,[R0, #+4]
    289            hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x7141             STRB     R1,[R0, #+5]
    290            hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6141             STR      R1,[R0, #+20]
    291            hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x6181             STR      R1,[R0, #+24]
    292            hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
   \       0x1C   0x2101             MOVS     R1,#+1
   \       0x1E   0x6201             STR      R1,[R0, #+32]
    293            if (HAL_CRC_Init(&hcrc) != HAL_OK)
   \       0x20   0x.... 0x....      BL       HAL_CRC_Init
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD001             BEQ.N    ??MX_CRC_Init_0
    294            {
    295              Error_Handler();
   \       0x28   0x.... 0x....      BL       Error_Handler
    296            }
    297            /* USER CODE BEGIN CRC_Init 2 */
    298          
    299            /* USER CODE END CRC_Init 2 */
    300          
    301          }
   \                     ??MX_CRC_Init_0: (+1)
   \       0x2C   0xBD01             POP      {R0,PC}
    302          
    303          /**
    304            * @brief DMA2D Initialization Function
    305            * @param None
    306            * @retval None
    307            */

   \                                 In section .text, align 2, keep-with-next
    308          static void MX_DMA2D_Init(void)
    309          {
   \                     MX_DMA2D_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    310          
    311            /* USER CODE BEGIN DMA2D_Init 0 */
    312          
    313            /* USER CODE END DMA2D_Init 0 */
    314          
    315            /* USER CODE BEGIN DMA2D_Init 1 */
    316          
    317            /* USER CODE END DMA2D_Init 1 */
    318            hdma2d.Instance = DMA2D;
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable11_17
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable11_18
   \        0xA   0x6020             STR      R0,[R4, #+0]
    319            hdma2d.Init.Mode = DMA2D_M2M;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x6060             STR      R0,[R4, #+4]
    320            hdma2d.Init.ColorMode = DMA2D_OUTPUT_RGB565;
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0x60A0             STR      R0,[R4, #+8]
    321            hdma2d.Init.OutputOffset = 0;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x60E0             STR      R0,[R4, #+12]
    322            hdma2d.LayerCfg[1].InputOffset = 0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6460             STR      R0,[R4, #+68]
    323            hdma2d.LayerCfg[1].InputColorMode = DMA2D_INPUT_RGB565;
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0x64A0             STR      R0,[R4, #+72]
    324            hdma2d.LayerCfg[1].AlphaMode = DMA2D_NO_MODIF_ALPHA;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x64E0             STR      R0,[R4, #+76]
    325            hdma2d.LayerCfg[1].InputAlpha = 0;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x6520             STR      R0,[R4, #+80]
    326            hdma2d.LayerCfg[1].AlphaInverted = DMA2D_REGULAR_ALPHA;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x6560             STR      R0,[R4, #+84]
    327            hdma2d.LayerCfg[1].RedBlueSwap = DMA2D_RB_REGULAR;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x65A0             STR      R0,[R4, #+88]
    328            hdma2d.LayerCfg[1].ChromaSubSampling = DMA2D_NO_CSS;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x65E0             STR      R0,[R4, #+92]
    329            if (HAL_DMA2D_Init(&hdma2d) != HAL_OK)
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       HAL_DMA2D_Init
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD001             BEQ.N    ??MX_DMA2D_Init_0
    330            {
    331              Error_Handler();
   \       0x3E   0x.... 0x....      BL       Error_Handler
    332            }
    333            if (HAL_DMA2D_ConfigLayer(&hdma2d, 1) != HAL_OK)
   \                     ??MX_DMA2D_Init_0: (+1)
   \       0x42   0x2101             MOVS     R1,#+1
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x.... 0x....      BL       HAL_DMA2D_ConfigLayer
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD001             BEQ.N    ??MX_DMA2D_Init_1
    334            {
    335              Error_Handler();
   \       0x4E   0x.... 0x....      BL       Error_Handler
    336            }
    337            /* USER CODE BEGIN DMA2D_Init 2 */
    338          
    339            /* USER CODE END DMA2D_Init 2 */
    340          
    341          }
   \                     ??MX_DMA2D_Init_1: (+1)
   \       0x52   0xBD10             POP      {R4,PC}
    342          
    343          /**
    344            * @brief I2C4 Initialization Function
    345            * @param None
    346            * @retval None
    347            */

   \                                 In section .text, align 2, keep-with-next
    348          static void MX_I2C4_Init(void)
    349          {
   \                     MX_I2C4_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    350          
    351            /* USER CODE BEGIN I2C4_Init 0 */
    352          
    353            /* USER CODE END I2C4_Init 0 */
    354          
    355            /* USER CODE BEGIN I2C4_Init 1 */
    356          
    357            /* USER CODE END I2C4_Init 1 */
    358            hi2c4.Instance = I2C4;
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable11_19
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable11_20
   \        0xA   0x6020             STR      R0,[R4, #+0]
    359            hi2c4.Init.Timing = 0x30808BD0;
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable11_21
   \       0x10   0x6060             STR      R0,[R4, #+4]
    360            hi2c4.Init.OwnAddress1 = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x60A0             STR      R0,[R4, #+8]
    361            hi2c4.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x60E0             STR      R0,[R4, #+12]
    362            hi2c4.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x6120             STR      R0,[R4, #+16]
    363            hi2c4.Init.OwnAddress2 = 0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6160             STR      R0,[R4, #+20]
    364            hi2c4.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x61A0             STR      R0,[R4, #+24]
    365            hi2c4.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x61E0             STR      R0,[R4, #+28]
    366            hi2c4.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x6220             STR      R0,[R4, #+32]
    367            if (HAL_I2C_Init(&hi2c4) != HAL_OK)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       HAL_I2C_Init
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD001             BEQ.N    ??MX_I2C4_Init_0
    368            {
    369              Error_Handler();
   \       0x38   0x.... 0x....      BL       Error_Handler
    370            }
    371            /** Configure Analogue filter
    372            */
    373            if (HAL_I2CEx_ConfigAnalogFilter(&hi2c4, I2C_ANALOGFILTER_DISABLE) != HAL_OK)
   \                     ??MX_I2C4_Init_0: (+1)
   \       0x3C   0xF44F 0x5180      MOV      R1,#+4096
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x.... 0x....      BL       HAL_I2CEx_ConfigAnalogFilter
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD001             BEQ.N    ??MX_I2C4_Init_1
    374            {
    375              Error_Handler();
   \       0x4A   0x.... 0x....      BL       Error_Handler
    376            }
    377            /** Configure Digital filter
    378            */
    379            if (HAL_I2CEx_ConfigDigitalFilter(&hi2c4, 0) != HAL_OK)
   \                     ??MX_I2C4_Init_1: (+1)
   \       0x4E   0x2100             MOVS     R1,#+0
   \       0x50   0x0020             MOVS     R0,R4
   \       0x52   0x.... 0x....      BL       HAL_I2CEx_ConfigDigitalFilter
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD001             BEQ.N    ??MX_I2C4_Init_2
    380            {
    381              Error_Handler();
   \       0x5A   0x.... 0x....      BL       Error_Handler
    382            }
    383            /* USER CODE BEGIN I2C4_Init 2 */
    384          
    385            /* USER CODE END I2C4_Init 2 */
    386          
    387          }
   \                     ??MX_I2C4_Init_2: (+1)
   \       0x5E   0xBD10             POP      {R4,PC}
    388          
    389          /**
    390            * @brief LTDC Initialization Function
    391            * @param None
    392            * @retval None
    393            */

   \                                 In section .text, align 2, keep-with-next
    394          static void MX_LTDC_Init(void)
    395          {
   \                     MX_LTDC_Init: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB08D             SUB      SP,SP,#+52
   \        0x4   0x2134             MOVS     R1,#+52
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x466C             MOV      R4,SP
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x.... 0x....      BL       __aeabi_memset
    396          
    397            /* USER CODE BEGIN LTDC_Init 0 */
    398          
    399            /* USER CODE END LTDC_Init 0 */
    400          
    401            LTDC_LayerCfgTypeDef pLayerCfg = {0};
    402          
    403            /* USER CODE BEGIN LTDC_Init 1 */
    404          
    405            /* USER CODE END LTDC_Init 1 */
    406            hltdc.Instance = LTDC;
   \       0x10   0x.... 0x....      LDR.W    R4,??DataTable11_22
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable11_23
   \       0x18   0x6020             STR      R0,[R4, #+0]
    407            hltdc.Init.HSPolarity = LTDC_HSPOLARITY_AL;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x6060             STR      R0,[R4, #+4]
    408            hltdc.Init.VSPolarity = LTDC_VSPOLARITY_AL;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x60A0             STR      R0,[R4, #+8]
    409            hltdc.Init.DEPolarity = LTDC_DEPOLARITY_AL;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x60E0             STR      R0,[R4, #+12]
    410            hltdc.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x6120             STR      R0,[R4, #+16]
    411            hltdc.Init.HorizontalSync = 40;
   \       0x2A   0x2028             MOVS     R0,#+40
   \       0x2C   0x6160             STR      R0,[R4, #+20]
    412            hltdc.Init.VerticalSync = 9;
   \       0x2E   0x2009             MOVS     R0,#+9
   \       0x30   0x61A0             STR      R0,[R4, #+24]
    413            hltdc.Init.AccumulatedHBP = 42;
   \       0x32   0x202A             MOVS     R0,#+42
   \       0x34   0x61E0             STR      R0,[R4, #+28]
    414            hltdc.Init.AccumulatedVBP = 11;
   \       0x36   0x200B             MOVS     R0,#+11
   \       0x38   0x6220             STR      R0,[R4, #+32]
    415            hltdc.Init.AccumulatedActiveW = 522;
   \       0x3A   0xF240 0x200A      MOVW     R0,#+522
   \       0x3E   0x6260             STR      R0,[R4, #+36]
    416            hltdc.Init.AccumulatedActiveH = 283;
   \       0x40   0xF240 0x101B      MOVW     R0,#+283
   \       0x44   0x62A0             STR      R0,[R4, #+40]
    417            hltdc.Init.TotalWidth = 554;
   \       0x46   0xF240 0x202A      MOVW     R0,#+554
   \       0x4A   0x62E0             STR      R0,[R4, #+44]
    418            hltdc.Init.TotalHeigh = 285;
   \       0x4C   0xF240 0x101D      MOVW     R0,#+285
   \       0x50   0x6320             STR      R0,[R4, #+48]
    419            hltdc.Init.Backcolor.Blue = 0;
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xF884 0x0034      STRB     R0,[R4, #+52]
    420            hltdc.Init.Backcolor.Green = 0;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF884 0x0035      STRB     R0,[R4, #+53]
    421            hltdc.Init.Backcolor.Red = 0;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xF884 0x0036      STRB     R0,[R4, #+54]
    422            if (HAL_LTDC_Init(&hltdc) != HAL_OK)
   \       0x64   0x0020             MOVS     R0,R4
   \       0x66   0x.... 0x....      BL       HAL_LTDC_Init
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD001             BEQ.N    ??MX_LTDC_Init_0
    423            {
    424              Error_Handler();
   \       0x6E   0x.... 0x....      BL       Error_Handler
    425            }
    426            pLayerCfg.WindowX0 = 0;
   \                     ??MX_LTDC_Init_0: (+1)
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x9000             STR      R0,[SP, #+0]
    427            pLayerCfg.WindowX1 = 480;
   \       0x76   0xF44F 0x70F0      MOV      R0,#+480
   \       0x7A   0x9001             STR      R0,[SP, #+4]
    428            pLayerCfg.WindowY0 = 0;
   \       0x7C   0x2100             MOVS     R1,#+0
   \       0x7E   0x9102             STR      R1,[SP, #+8]
    429            pLayerCfg.WindowY1 = 272;
   \       0x80   0xF44F 0x7188      MOV      R1,#+272
   \       0x84   0x9103             STR      R1,[SP, #+12]
    430            pLayerCfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB888;
   \       0x86   0x2201             MOVS     R2,#+1
   \       0x88   0x9204             STR      R2,[SP, #+16]
    431            pLayerCfg.Alpha = 255;
   \       0x8A   0x22FF             MOVS     R2,#+255
   \       0x8C   0x9205             STR      R2,[SP, #+20]
    432            pLayerCfg.Alpha0 = 0;
   \       0x8E   0x2300             MOVS     R3,#+0
   \       0x90   0x9306             STR      R3,[SP, #+24]
    433            pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_CA;
   \       0x92   0xF44F 0x6380      MOV      R3,#+1024
   \       0x96   0x9307             STR      R3,[SP, #+28]
    434            pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_CA;
   \       0x98   0x2305             MOVS     R3,#+5
   \       0x9A   0x9308             STR      R3,[SP, #+32]
    435            pLayerCfg.FBStartAdress = 0;
   \       0x9C   0x2300             MOVS     R3,#+0
   \       0x9E   0x9309             STR      R3,[SP, #+36]
    436            pLayerCfg.ImageWidth = 480;
   \       0xA0   0x900A             STR      R0,[SP, #+40]
    437            pLayerCfg.ImageHeight = 272;
   \       0xA2   0x910B             STR      R1,[SP, #+44]
    438            pLayerCfg.Backcolor.Blue = 255;
   \       0xA4   0xF88D 0x2030      STRB     R2,[SP, #+48]
    439            pLayerCfg.Backcolor.Green = 0;
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0xF88D 0x0031      STRB     R0,[SP, #+49]
    440            pLayerCfg.Backcolor.Red = 0;
   \       0xAE   0x2000             MOVS     R0,#+0
   \       0xB0   0xF88D 0x0032      STRB     R0,[SP, #+50]
    441            if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
   \       0xB4   0x2200             MOVS     R2,#+0
   \       0xB6   0x4669             MOV      R1,SP
   \       0xB8   0x0020             MOVS     R0,R4
   \       0xBA   0x.... 0x....      BL       HAL_LTDC_ConfigLayer
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD001             BEQ.N    ??MX_LTDC_Init_1
    442            {
    443              Error_Handler();
   \       0xC2   0x.... 0x....      BL       Error_Handler
    444            }
    445            /* USER CODE BEGIN LTDC_Init 2 */
    446          
    447            /* USER CODE END LTDC_Init 2 */
    448          
    449          }
   \                     ??MX_LTDC_Init_1: (+1)
   \       0xC6   0xB00E             ADD      SP,SP,#+56
   \       0xC8   0xBD10             POP      {R4,PC}
    450          
    451          /**
    452            * @brief OCTOSPI1 Initialization Function
    453            * @param None
    454            * @retval None
    455            */

   \                                 In section .text, align 2, keep-with-next
    456          static void MX_OCTOSPI1_Init(void)
    457          {
   \                     MX_OCTOSPI1_Init: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x2118             MOVS     R1,#+24
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0xAC01             ADD      R4,SP,#+4
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x.... 0x....      BL       __aeabi_memset
    458          
    459            /* USER CODE BEGIN OCTOSPI1_Init 0 */
    460          
    461            /* USER CODE END OCTOSPI1_Init 0 */
    462          
    463            OSPIM_CfgTypeDef sOspiManagerCfg = {0};
    464          
    465            /* USER CODE BEGIN OCTOSPI1_Init 1 */
    466          
    467            /* USER CODE END OCTOSPI1_Init 1 */
    468            /* OCTOSPI1 parameter configuration*/
    469            hospi1.Instance = OCTOSPI1;
   \       0x10   0x.... 0x....      LDR.W    R4,??DataTable11_24
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable11_25
   \       0x18   0x6020             STR      R0,[R4, #+0]
    470            hospi1.Init.FifoThreshold = 1;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0x6060             STR      R0,[R4, #+4]
    471            hospi1.Init.DualQuad = HAL_OSPI_DUALQUAD_DISABLE;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x60A0             STR      R0,[R4, #+8]
    472            hospi1.Init.MemoryType = HAL_OSPI_MEMTYPE_MICRON;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x60E0             STR      R0,[R4, #+12]
    473            hospi1.Init.DeviceSize = 26;
   \       0x26   0x201A             MOVS     R0,#+26
   \       0x28   0x6120             STR      R0,[R4, #+16]
    474            hospi1.Init.ChipSelectHighTime = 2;
   \       0x2A   0x2002             MOVS     R0,#+2
   \       0x2C   0x6160             STR      R0,[R4, #+20]
    475            hospi1.Init.FreeRunningClock = HAL_OSPI_FREERUNCLK_DISABLE;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x61A0             STR      R0,[R4, #+24]
    476            hospi1.Init.ClockMode = HAL_OSPI_CLOCK_MODE_0;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x61E0             STR      R0,[R4, #+28]
    477            hospi1.Init.WrapSize = HAL_OSPI_WRAP_NOT_SUPPORTED;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x6220             STR      R0,[R4, #+32]
    478            hospi1.Init.ClockPrescaler = 3;
   \       0x3A   0x2003             MOVS     R0,#+3
   \       0x3C   0x6260             STR      R0,[R4, #+36]
    479            hospi1.Init.SampleShifting = HAL_OSPI_SAMPLE_SHIFTING_NONE;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x62A0             STR      R0,[R4, #+40]
    480            hospi1.Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_DISABLE;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x62E0             STR      R0,[R4, #+44]
    481            hospi1.Init.ChipSelectBoundary = 0;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x6320             STR      R0,[R4, #+48]
    482            hospi1.Init.ClkChipSelectHighTime = 0;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x6360             STR      R0,[R4, #+52]
    483            hospi1.Init.DelayBlockBypass = HAL_OSPI_DELAY_BLOCK_BYPASSED;
   \       0x4E   0x2008             MOVS     R0,#+8
   \       0x50   0x63A0             STR      R0,[R4, #+56]
    484            hospi1.Init.MaxTran = 0;
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x63E0             STR      R0,[R4, #+60]
    485            hospi1.Init.Refresh = 0;
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x6420             STR      R0,[R4, #+64]
    486            if (HAL_OSPI_Init(&hospi1) != HAL_OK)
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x.... 0x....      BL       HAL_OSPI_Init
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD001             BEQ.N    ??MX_OCTOSPI1_Init_0
    487            {
    488              Error_Handler();
   \       0x64   0x.... 0x....      BL       Error_Handler
    489            }
    490            sOspiManagerCfg.ClkPort = 1;
   \                     ??MX_OCTOSPI1_Init_0: (+1)
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0x9001             STR      R0,[SP, #+4]
    491            sOspiManagerCfg.DQSPort = 1;
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0x9002             STR      R0,[SP, #+8]
    492            sOspiManagerCfg.NCSPort = 1;
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0x9003             STR      R0,[SP, #+12]
    493            sOspiManagerCfg.IOLowPort = HAL_OSPIM_IOPORT_1_LOW;
   \       0x74   0xF05F 0x1001      MOVS     R0,#+65537
   \       0x78   0x9004             STR      R0,[SP, #+16]
    494            sOspiManagerCfg.IOHighPort = HAL_OSPIM_IOPORT_1_HIGH;
   \       0x7A   0x.... 0x....      LDR.W    R0,??DataTable11_26
   \       0x7E   0x9005             STR      R0,[SP, #+20]
    495            if (HAL_OSPIM_Config(&hospi1, &sOspiManagerCfg, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
   \       0x80   0xF241 0x3288      MOVW     R2,#+5000
   \       0x84   0xA901             ADD      R1,SP,#+4
   \       0x86   0x0020             MOVS     R0,R4
   \       0x88   0x.... 0x....      BL       HAL_OSPIM_Config
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD001             BEQ.N    ??MX_OCTOSPI1_Init_1
    496            {
    497              Error_Handler();
   \       0x90   0x.... 0x....      BL       Error_Handler
    498            }
    499            /* USER CODE BEGIN OCTOSPI1_Init 2 */
    500            BSP_OSPI_NOR_Init_t Flash;
    501            Flash.InterfaceMode = BSP_OSPI_NOR_OPI_MODE;
   \                     ??MX_OCTOSPI1_Init_1: (+1)
   \       0x94   0x2001             MOVS     R0,#+1
   \       0x96   0xF88D 0x0000      STRB     R0,[SP, #+0]
    502            Flash.TransferRate  = BSP_OSPI_NOR_DTR_TRANSFER;
   \       0x9A   0x2001             MOVS     R0,#+1
   \       0x9C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    503            BSP_OSPI_NOR_DeInit(0);
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0x.... 0x....      BL       BSP_OSPI_NOR_DeInit
    504            int32_t RetVal = BSP_OSPI_NOR_Init(0, &Flash);
   \       0xA6   0x4669             MOV      R1,SP
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0x.... 0x....      BL       BSP_OSPI_NOR_Init
    505            if(RetVal != BSP_ERROR_NONE)
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD001             BEQ.N    ??MX_OCTOSPI1_Init_2
    506            {
    507              Error_Handler();
   \       0xB2   0x.... 0x....      BL       Error_Handler
    508            }
    509            RetVal = BSP_OSPI_NOR_EnableMemoryMappedMode(0);
   \                     ??MX_OCTOSPI1_Init_2: (+1)
   \       0xB6   0x2000             MOVS     R0,#+0
   \       0xB8   0x.... 0x....      BL       BSP_OSPI_NOR_EnableMemoryMappedMode
    510            if(RetVal != BSP_ERROR_NONE)
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xD001             BEQ.N    ??MX_OCTOSPI1_Init_3
    511            {
    512              Error_Handler();
   \       0xC0   0x.... 0x....      BL       Error_Handler
    513            }
    514            /* USER CODE END OCTOSPI1_Init 2 */
    515          
    516          }
   \                     ??MX_OCTOSPI1_Init_3: (+1)
   \       0xC4   0xB008             ADD      SP,SP,#+32
   \       0xC6   0xBD10             POP      {R4,PC}
    517          
    518          /**
    519            * @brief USART1 Initialization Function
    520            * @param None
    521            * @retval None
    522            */

   \                                 In section .text, align 2, keep-with-next
    523          static void MX_USART1_UART_Init(void)
    524          {
   \                     MX_USART1_UART_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    525          
    526            /* USER CODE BEGIN USART1_Init 0 */
    527          
    528            /* USER CODE END USART1_Init 0 */
    529          
    530            /* USER CODE BEGIN USART1_Init 1 */
    531          
    532            /* USER CODE END USART1_Init 1 */
    533            huart1.Instance = USART1;
   \        0x2   0x....             LDR.N    R4,??DataTable11_27
   \        0x4   0x....             LDR.N    R0,??DataTable11_28
   \        0x6   0x6020             STR      R0,[R4, #+0]
    534            huart1.Init.BaudRate = 115200;
   \        0x8   0xF45F 0x30E1      MOVS     R0,#+115200
   \        0xC   0x6060             STR      R0,[R4, #+4]
    535            huart1.Init.WordLength = UART_WORDLENGTH_8B;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x60A0             STR      R0,[R4, #+8]
    536            huart1.Init.StopBits = UART_STOPBITS_1;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x60E0             STR      R0,[R4, #+12]
    537            huart1.Init.Parity = UART_PARITY_NONE;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x6120             STR      R0,[R4, #+16]
    538            huart1.Init.Mode = UART_MODE_TX_RX;
   \       0x1A   0x200C             MOVS     R0,#+12
   \       0x1C   0x6160             STR      R0,[R4, #+20]
    539            huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x61A0             STR      R0,[R4, #+24]
    540            huart1.Init.OverSampling = UART_OVERSAMPLING_16;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x61E0             STR      R0,[R4, #+28]
    541            huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x6220             STR      R0,[R4, #+32]
    542            huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x6260             STR      R0,[R4, #+36]
    543            huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x62A0             STR      R0,[R4, #+40]
    544            if (HAL_UART_Init(&huart1) != HAL_OK)
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       HAL_UART_Init
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD001             BEQ.N    ??MX_USART1_UART_Init_0
    545            {
    546              Error_Handler();
   \       0x3C   0x.... 0x....      BL       Error_Handler
    547            }
    548            if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
   \                     ??MX_USART1_UART_Init_0: (+1)
   \       0x40   0x2100             MOVS     R1,#+0
   \       0x42   0x0020             MOVS     R0,R4
   \       0x44   0x.... 0x....      BL       HAL_UARTEx_SetTxFifoThreshold
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD001             BEQ.N    ??MX_USART1_UART_Init_1
    549            {
    550              Error_Handler();
   \       0x4C   0x.... 0x....      BL       Error_Handler
    551            }
    552            if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
   \                     ??MX_USART1_UART_Init_1: (+1)
   \       0x50   0x2100             MOVS     R1,#+0
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x.... 0x....      BL       HAL_UARTEx_SetRxFifoThreshold
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD001             BEQ.N    ??MX_USART1_UART_Init_2
    553            {
    554              Error_Handler();
   \       0x5C   0x.... 0x....      BL       Error_Handler
    555            }
    556            if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
   \                     ??MX_USART1_UART_Init_2: (+1)
   \       0x60   0x0020             MOVS     R0,R4
   \       0x62   0x.... 0x....      BL       HAL_UARTEx_DisableFifoMode
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD001             BEQ.N    ??MX_USART1_UART_Init_3
    557            {
    558              Error_Handler();
   \       0x6A   0x.... 0x....      BL       Error_Handler
    559            }
    560            /* USER CODE BEGIN USART1_Init 2 */
    561          
    562            /* USER CODE END USART1_Init 2 */
    563          
    564          }
   \                     ??MX_USART1_UART_Init_3: (+1)
   \       0x6E   0xBD10             POP      {R4,PC}
    565          
    566          /**
    567            * @brief GPIO Initialization Function
    568            * @param None
    569            * @retval None
    570            */

   \                                 In section .text, align 2, keep-with-next
    571          static void MX_GPIO_Init(void)
    572          {
   \                     MX_GPIO_Init: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x2114             MOVS     R1,#+20
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x466C             MOV      R4,SP
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x.... 0x....      BL       __aeabi_memset
    573            GPIO_InitTypeDef GPIO_InitStruct = {0};
    574          
    575            /* GPIO Ports Clock Enable */
    576            __HAL_RCC_GPIOK_CLK_ENABLE();
   \       0x12   0x....             LDR.N    R0,??DataTable11_29
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0xF451 0x6180      ORRS     R1,R1,#0x400
   \       0x1A   0x6001             STR      R1,[R0, #+0]
   \       0x1C   0x6801             LDR      R1,[R0, #+0]
   \       0x1E   0xF411 0x6180      ANDS     R1,R1,#0x400
   \       0x22   0x9105             STR      R1,[SP, #+20]
   \       0x24   0x9905             LDR      R1,[SP, #+20]
    577            __HAL_RCC_GPIOG_CLK_ENABLE();
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0x2C   0x6001             STR      R1,[R0, #+0]
   \       0x2E   0x6801             LDR      R1,[R0, #+0]
   \       0x30   0xF011 0x0140      ANDS     R1,R1,#0x40
   \       0x34   0x9105             STR      R1,[SP, #+20]
   \       0x36   0x9905             LDR      R1,[SP, #+20]
    578            __HAL_RCC_GPIOD_CLK_ENABLE();
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0xF051 0x0108      ORRS     R1,R1,#0x8
   \       0x3E   0x6001             STR      R1,[R0, #+0]
   \       0x40   0x6801             LDR      R1,[R0, #+0]
   \       0x42   0xF011 0x0108      ANDS     R1,R1,#0x8
   \       0x46   0x9105             STR      R1,[SP, #+20]
   \       0x48   0x9905             LDR      R1,[SP, #+20]
    579            __HAL_RCC_GPIOJ_CLK_ENABLE();
   \       0x4A   0x6801             LDR      R1,[R0, #+0]
   \       0x4C   0xF451 0x7100      ORRS     R1,R1,#0x200
   \       0x50   0x6001             STR      R1,[R0, #+0]
   \       0x52   0x6801             LDR      R1,[R0, #+0]
   \       0x54   0xF411 0x7100      ANDS     R1,R1,#0x200
   \       0x58   0x9105             STR      R1,[SP, #+20]
   \       0x5A   0x9905             LDR      R1,[SP, #+20]
    580            __HAL_RCC_GPIOI_CLK_ENABLE();
   \       0x5C   0x6801             LDR      R1,[R0, #+0]
   \       0x5E   0xF451 0x7180      ORRS     R1,R1,#0x100
   \       0x62   0x6001             STR      R1,[R0, #+0]
   \       0x64   0x6801             LDR      R1,[R0, #+0]
   \       0x66   0xF411 0x7180      ANDS     R1,R1,#0x100
   \       0x6A   0x9105             STR      R1,[SP, #+20]
   \       0x6C   0x9905             LDR      R1,[SP, #+20]
    581            __HAL_RCC_GPIOA_CLK_ENABLE();
   \       0x6E   0x6801             LDR      R1,[R0, #+0]
   \       0x70   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x74   0x6001             STR      R1,[R0, #+0]
   \       0x76   0x6801             LDR      R1,[R0, #+0]
   \       0x78   0xF011 0x0101      ANDS     R1,R1,#0x1
   \       0x7C   0x9105             STR      R1,[SP, #+20]
   \       0x7E   0x9905             LDR      R1,[SP, #+20]
    582            __HAL_RCC_GPIOC_CLK_ENABLE();
   \       0x80   0x6801             LDR      R1,[R0, #+0]
   \       0x82   0xF051 0x0104      ORRS     R1,R1,#0x4
   \       0x86   0x6001             STR      R1,[R0, #+0]
   \       0x88   0x6801             LDR      R1,[R0, #+0]
   \       0x8A   0xF011 0x0104      ANDS     R1,R1,#0x4
   \       0x8E   0x9105             STR      R1,[SP, #+20]
   \       0x90   0x9905             LDR      R1,[SP, #+20]
    583            __HAL_RCC_GPIOF_CLK_ENABLE();
   \       0x92   0x6801             LDR      R1,[R0, #+0]
   \       0x94   0xF051 0x0120      ORRS     R1,R1,#0x20
   \       0x98   0x6001             STR      R1,[R0, #+0]
   \       0x9A   0x6801             LDR      R1,[R0, #+0]
   \       0x9C   0xF011 0x0120      ANDS     R1,R1,#0x20
   \       0xA0   0x9105             STR      R1,[SP, #+20]
   \       0xA2   0x9905             LDR      R1,[SP, #+20]
    584            __HAL_RCC_GPIOH_CLK_ENABLE();
   \       0xA4   0x6801             LDR      R1,[R0, #+0]
   \       0xA6   0xF051 0x0180      ORRS     R1,R1,#0x80
   \       0xAA   0x6001             STR      R1,[R0, #+0]
   \       0xAC   0x6801             LDR      R1,[R0, #+0]
   \       0xAE   0xF011 0x0180      ANDS     R1,R1,#0x80
   \       0xB2   0x9105             STR      R1,[SP, #+20]
   \       0xB4   0x9905             LDR      R1,[SP, #+20]
    585            __HAL_RCC_GPIOB_CLK_ENABLE();
   \       0xB6   0x6801             LDR      R1,[R0, #+0]
   \       0xB8   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0xBC   0x6001             STR      R1,[R0, #+0]
   \       0xBE   0x6800             LDR      R0,[R0, #+0]
   \       0xC0   0xF010 0x0002      ANDS     R0,R0,#0x2
   \       0xC4   0x9005             STR      R0,[SP, #+20]
   \       0xC6   0x9805             LDR      R0,[SP, #+20]
    586          
    587            /*Configure GPIO pin Output Level */
    588            HAL_GPIO_WritePin(GPIOG, LED3_Pin|LED2_Pin, GPIO_PIN_RESET);
   \       0xC8   0xF640 0x0804      MOVW     R8,#+2052
   \       0xCC   0x....             LDR.N    R7,??DataTable11_30
   \       0xCE   0x2200             MOVS     R2,#+0
   \       0xD0   0x4641             MOV      R1,R8
   \       0xD2   0x0038             MOVS     R0,R7
   \       0xD4   0x.... 0x....      BL       HAL_GPIO_WritePin
    589          
    590            /*Configure GPIO pin Output Level */
    591            HAL_GPIO_WritePin(MCU_ACTIVE_GPIO_Port, MCU_ACTIVE_Pin, GPIO_PIN_RESET);
   \       0xD8   0x....             LDR.N    R4,??DataTable11_31
   \       0xDA   0x2200             MOVS     R2,#+0
   \       0xDC   0x2101             MOVS     R1,#+1
   \       0xDE   0x0020             MOVS     R0,R4
   \       0xE0   0x.... 0x....      BL       HAL_GPIO_WritePin
    592          
    593            /*Configure GPIO pin Output Level */
    594            HAL_GPIO_WritePin(GPIOA, VSYNC_FREQ_Pin|LCD_BL_CTRL_Pin|LCD_ON_OFF_Pin, GPIO_PIN_RESET);
   \       0xE4   0x....             LDR.N    R5,??DataTable11_32
   \       0xE6   0x2200             MOVS     R2,#+0
   \       0xE8   0xF241 0x0106      MOVW     R1,#+4102
   \       0xEC   0x0028             MOVS     R0,R5
   \       0xEE   0x.... 0x....      BL       HAL_GPIO_WritePin
    595          
    596            /*Configure GPIO pin Output Level */
    597            HAL_GPIO_WritePin(GPIOB, RENDER_TIME_Pin|FRAME_RATE_Pin, GPIO_PIN_RESET);
   \       0xF2   0x....             LDR.N    R6,??DataTable11_33
   \       0xF4   0x2200             MOVS     R2,#+0
   \       0xF6   0xF44F 0x4140      MOV      R1,#+49152
   \       0xFA   0x0030             MOVS     R0,R6
   \       0xFC   0x.... 0x....      BL       HAL_GPIO_WritePin
    598          
    599            /*Configure GPIO pins : LED3_Pin LED2_Pin */
    600            GPIO_InitStruct.Pin = LED3_Pin|LED2_Pin;
   \      0x100   0xF8CD 0x8000      STR      R8,[SP, #+0]
    601            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \      0x104   0x2001             MOVS     R0,#+1
   \      0x106   0x9001             STR      R0,[SP, #+4]
    602            GPIO_InitStruct.Pull = GPIO_PULLUP;
   \      0x108   0x2001             MOVS     R0,#+1
   \      0x10A   0x9002             STR      R0,[SP, #+8]
    603            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   \      0x10C   0x2000             MOVS     R0,#+0
   \      0x10E   0x9003             STR      R0,[SP, #+12]
    604            HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   \      0x110   0x4669             MOV      R1,SP
   \      0x112   0x0038             MOVS     R0,R7
   \      0x114   0x.... 0x....      BL       HAL_GPIO_Init
    605          
    606            /*Configure GPIO pin : MCU_ACTIVE_Pin */
    607            GPIO_InitStruct.Pin = MCU_ACTIVE_Pin;
   \      0x118   0x2001             MOVS     R0,#+1
   \      0x11A   0x9000             STR      R0,[SP, #+0]
    608            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \      0x11C   0x2001             MOVS     R0,#+1
   \      0x11E   0x9001             STR      R0,[SP, #+4]
    609            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \      0x120   0x2000             MOVS     R0,#+0
   \      0x122   0x9002             STR      R0,[SP, #+8]
    610            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   \      0x124   0x2000             MOVS     R0,#+0
   \      0x126   0x9003             STR      R0,[SP, #+12]
    611            HAL_GPIO_Init(MCU_ACTIVE_GPIO_Port, &GPIO_InitStruct);
   \      0x128   0x4669             MOV      R1,SP
   \      0x12A   0x0020             MOVS     R0,R4
   \      0x12C   0x.... 0x....      BL       HAL_GPIO_Init
    612          
    613            /*Configure GPIO pins : VSYNC_FREQ_Pin LCD_BL_CTRL_Pin */
    614            GPIO_InitStruct.Pin = VSYNC_FREQ_Pin|LCD_BL_CTRL_Pin;
   \      0x130   0xF241 0x0002      MOVW     R0,#+4098
   \      0x134   0x9000             STR      R0,[SP, #+0]
    615            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \      0x136   0x2001             MOVS     R0,#+1
   \      0x138   0x9001             STR      R0,[SP, #+4]
    616            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \      0x13A   0x2000             MOVS     R0,#+0
   \      0x13C   0x9002             STR      R0,[SP, #+8]
    617            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   \      0x13E   0x2000             MOVS     R0,#+0
   \      0x140   0x9003             STR      R0,[SP, #+12]
    618            HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \      0x142   0x4669             MOV      R1,SP
   \      0x144   0x0028             MOVS     R0,R5
   \      0x146   0x.... 0x....      BL       HAL_GPIO_Init
    619          
    620            /*Configure GPIO pin : WakeupButton_Pin */
    621            GPIO_InitStruct.Pin = WakeupButton_Pin;
   \      0x14A   0xF44F 0x5000      MOV      R0,#+8192
   \      0x14E   0x9000             STR      R0,[SP, #+0]
    622            GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
   \      0x150   0x2000             MOVS     R0,#+0
   \      0x152   0x9001             STR      R0,[SP, #+4]
    623            GPIO_InitStruct.Pull = GPIO_PULLDOWN;
   \      0x154   0x2002             MOVS     R0,#+2
   \      0x156   0x9002             STR      R0,[SP, #+8]
    624            HAL_GPIO_Init(WakeupButton_GPIO_Port, &GPIO_InitStruct);
   \      0x158   0x4669             MOV      R1,SP
   \      0x15A   0x....             LDR.N    R0,??DataTable11_34
   \      0x15C   0x.... 0x....      BL       HAL_GPIO_Init
    625          
    626            /*Configure GPIO pin : LCD_INT_Pin */
    627            GPIO_InitStruct.Pin = LCD_INT_Pin;
   \      0x160   0x2004             MOVS     R0,#+4
   \      0x162   0x9000             STR      R0,[SP, #+0]
    628            GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
   \      0x164   0xF45F 0x1088      MOVS     R0,#+1114112
   \      0x168   0x9001             STR      R0,[SP, #+4]
    629            GPIO_InitStruct.Pull = GPIO_PULLUP;
   \      0x16A   0x2001             MOVS     R0,#+1
   \      0x16C   0x9002             STR      R0,[SP, #+8]
    630            HAL_GPIO_Init(LCD_INT_GPIO_Port, &GPIO_InitStruct);
   \      0x16E   0x4669             MOV      R1,SP
   \      0x170   0x....             LDR.N    R0,??DataTable11_35
   \      0x172   0x.... 0x....      BL       HAL_GPIO_Init
    631          
    632            /*Configure GPIO pins : RENDER_TIME_Pin FRAME_RATE_Pin */
    633            GPIO_InitStruct.Pin = RENDER_TIME_Pin|FRAME_RATE_Pin;
   \      0x176   0xF44F 0x4040      MOV      R0,#+49152
   \      0x17A   0x9000             STR      R0,[SP, #+0]
    634            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \      0x17C   0x2001             MOVS     R0,#+1
   \      0x17E   0x9001             STR      R0,[SP, #+4]
    635            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \      0x180   0x2000             MOVS     R0,#+0
   \      0x182   0x9002             STR      R0,[SP, #+8]
    636            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   \      0x184   0x2000             MOVS     R0,#+0
   \      0x186   0x9003             STR      R0,[SP, #+12]
    637            HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \      0x188   0x4669             MOV      R1,SP
   \      0x18A   0x0030             MOVS     R0,R6
   \      0x18C   0x.... 0x....      BL       HAL_GPIO_Init
    638          
    639            /*Configure GPIO pin : LCD_ON_OFF_Pin */
    640            GPIO_InitStruct.Pin = LCD_ON_OFF_Pin;
   \      0x190   0x2004             MOVS     R0,#+4
   \      0x192   0x9000             STR      R0,[SP, #+0]
    641            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \      0x194   0x2001             MOVS     R0,#+1
   \      0x196   0x9001             STR      R0,[SP, #+4]
    642            GPIO_InitStruct.Pull = GPIO_PULLUP;
   \      0x198   0x2001             MOVS     R0,#+1
   \      0x19A   0x9002             STR      R0,[SP, #+8]
    643            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   \      0x19C   0x2000             MOVS     R0,#+0
   \      0x19E   0x9003             STR      R0,[SP, #+12]
    644            HAL_GPIO_Init(LCD_ON_OFF_GPIO_Port, &GPIO_InitStruct);
   \      0x1A0   0x4669             MOV      R1,SP
   \      0x1A2   0x0028             MOVS     R0,R5
   \      0x1A4   0x.... 0x....      BL       HAL_GPIO_Init
    645          
    646            /* EXTI interrupt init*/
    647            HAL_NVIC_SetPriority(EXTI2_IRQn, 5, 0);
   \      0x1A8   0x2200             MOVS     R2,#+0
   \      0x1AA   0x2105             MOVS     R1,#+5
   \      0x1AC   0x2008             MOVS     R0,#+8
   \      0x1AE   0x.... 0x....      BL       HAL_NVIC_SetPriority
    648            HAL_NVIC_EnableIRQ(EXTI2_IRQn);
   \      0x1B2   0x2008             MOVS     R0,#+8
   \      0x1B4   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    649          
    650          }
   \      0x1B8   0xB006             ADD      SP,SP,#+24
   \      0x1BA   0xE8BD 0x81F0      POP      {R4-R8,PC}
    651          
    652          /* USER CODE BEGIN 4 */
    653          
    654          /* USER CODE END 4 */
    655          
    656          /* USER CODE BEGIN Header_StartDefaultTask */
    657          /**
    658            * @brief  Function implementing the defaultTask thread.
    659            * @param  argument: Not used
    660            * @retval None
    661            */
    662          /* USER CODE END Header_StartDefaultTask */

   \                                 In section .text, align 4, keep-with-next
    663          void StartDefaultTask(void *argument)
    664          {
   \                     StartDefaultTask: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    665            /* USER CODE BEGIN 5 */
    666              startTimer(testTmrCallback, osTimerPeriodic, NULL, 1000);
   \        0x2   0xF44F 0x737A      MOV      R3,#+1000
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0x.... 0x....      ADR.W    R0,testTmrCallback
   \        0xE   0x.... 0x....      BL       startTimer
    667              startTimer(TimerHandleTest, osTimerPeriodic, 10, 1000);
   \       0x12   0xF44F 0x737A      MOV      R3,#+1000
   \       0x16   0x220A             MOVS     R2,#+10
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x....             LDR.N    R0,??DataTable11_36
   \       0x1C   0x.... 0x....      BL       startTimer
    668          
    669            /* Infinite loop */
    670            for(;;)
    671            {
    672              osDelay(100);
   \                     ??StartDefaultTask_0: (+1)
   \       0x20   0x2064             MOVS     R0,#+100
   \       0x22   0x.... 0x....      BL       osDelay
   \       0x26   0xE7FB             B.N      ??StartDefaultTask_0
    673            }
    674            /* USER CODE END 5 */
    675          }
    676          
    677          /* testTmrCallback function */

   \                                 In section .text, align 4, keep-with-next
    678          void testTmrCallback(void *argument)
    679          {
   \                     testTmrCallback: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    680            /* USER CODE BEGIN testTmrCallback */
    681              HAL_GPIO_TogglePin(GPIOG, GPIO_PIN_2);
   \        0x2   0x....             LDR.N    R4,??DataTable11_30
   \        0x4   0x2104             MOVS     R1,#+4
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x.... 0x....      BL       HAL_GPIO_TogglePin
    682              HAL_GPIO_TogglePin(GPIOG, GPIO_PIN_11);
   \        0xC   0xF44F 0x6100      MOV      R1,#+2048
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0x.... 0x....      BL       HAL_GPIO_TogglePin
    683            /* USER CODE END testTmrCallback */
    684          }
   \       0x16   0xBD10             POP      {R4,PC}
    685          
    686          /* MPU Configuration */
    687          

   \                                 In section .text, align 2, keep-with-next
    688          void MPU_Config(void)
    689          {
   \                     MPU_Config: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x2110             MOVS     R1,#+16
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x466C             MOV      R4,SP
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       __aeabi_memset
    690            MPU_Region_InitTypeDef MPU_InitStruct = {0};
    691          
    692            /* Disables the MPU */
    693            HAL_MPU_Disable();
   \        0xE   0x.... 0x....      BL       HAL_MPU_Disable
    694            /** Initializes and configures the Region and the memory to be protected
    695            */
    696            MPU_InitStruct.Enable = MPU_REGION_ENABLE;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xF88D 0x0000      STRB     R0,[SP, #+0]
    697            MPU_InitStruct.Number = MPU_REGION_NUMBER0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    698            MPU_InitStruct.BaseAddress = 0x90000000;
   \       0x1E   0xF05F 0x4010      MOVS     R0,#+2415919104
   \       0x22   0x9001             STR      R0,[SP, #+4]
    699            MPU_InitStruct.Size = MPU_REGION_SIZE_256MB;
   \       0x24   0x201B             MOVS     R0,#+27
   \       0x26   0xF88D 0x0008      STRB     R0,[SP, #+8]
    700            MPU_InitStruct.SubRegionDisable = 0x0;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xF88D 0x0009      STRB     R0,[SP, #+9]
    701            MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xF88D 0x000A      STRB     R0,[SP, #+10]
    702            MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xF88D 0x000B      STRB     R0,[SP, #+11]
    703            MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xF88D 0x000C      STRB     R0,[SP, #+12]
    704            MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xF88D 0x000D      STRB     R0,[SP, #+13]
    705            MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xF88D 0x000E      STRB     R0,[SP, #+14]
    706            MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xF88D 0x000F      STRB     R0,[SP, #+15]
    707          
    708            HAL_MPU_ConfigRegion(&MPU_InitStruct);
   \       0x54   0x4668             MOV      R0,SP
   \       0x56   0x.... 0x....      BL       HAL_MPU_ConfigRegion
    709            /** Initializes and configures the Region and the memory to be protected
    710            */
    711            MPU_InitStruct.Number = MPU_REGION_NUMBER1;
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    712            MPU_InitStruct.Size = MPU_REGION_SIZE_64MB;
   \       0x60   0x2019             MOVS     R0,#+25
   \       0x62   0xF88D 0x0008      STRB     R0,[SP, #+8]
    713            MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
   \       0x66   0x2003             MOVS     R0,#+3
   \       0x68   0xF88D 0x000B      STRB     R0,[SP, #+11]
    714            MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0xF88D 0x000E      STRB     R0,[SP, #+14]
    715          
    716            HAL_MPU_ConfigRegion(&MPU_InitStruct);
   \       0x72   0x4668             MOV      R0,SP
   \       0x74   0x.... 0x....      BL       HAL_MPU_ConfigRegion
    717            /** Initializes and configures the Region and the memory to be protected
    718            */
    719            MPU_InitStruct.Number = MPU_REGION_NUMBER2;
   \       0x78   0x2002             MOVS     R0,#+2
   \       0x7A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    720            MPU_InitStruct.BaseAddress = 0x24000000;
   \       0x7E   0xF05F 0x5010      MOVS     R0,#+603979776
   \       0x82   0x9001             STR      R0,[SP, #+4]
    721            MPU_InitStruct.Size = MPU_REGION_SIZE_1MB;
   \       0x84   0x2013             MOVS     R0,#+19
   \       0x86   0xF88D 0x0008      STRB     R0,[SP, #+8]
    722          
    723            HAL_MPU_ConfigRegion(&MPU_InitStruct);
   \       0x8A   0x4668             MOV      R0,SP
   \       0x8C   0x.... 0x....      BL       HAL_MPU_ConfigRegion
    724            /** Initializes and configures the Region and the memory to be protected
    725            */
    726            MPU_InitStruct.Number = MPU_REGION_NUMBER3;
   \       0x90   0x2003             MOVS     R0,#+3
   \       0x92   0xF88D 0x0001      STRB     R0,[SP, #+1]
    727            MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
   \       0x96   0x2011             MOVS     R0,#+17
   \       0x98   0xF88D 0x0008      STRB     R0,[SP, #+8]
    728            MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
   \       0x9C   0x2001             MOVS     R0,#+1
   \       0x9E   0xF88D 0x000F      STRB     R0,[SP, #+15]
    729          
    730            HAL_MPU_ConfigRegion(&MPU_InitStruct);
   \       0xA2   0x4668             MOV      R0,SP
   \       0xA4   0x.... 0x....      BL       HAL_MPU_ConfigRegion
    731            /* Enables the MPU */
    732            HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
   \       0xA8   0x2004             MOVS     R0,#+4
   \       0xAA   0x.... 0x....      BL       HAL_MPU_Enable
    733          
    734          }
   \       0xAE   0xBD1F             POP      {R0-R4,PC}
    735          
    736          /**
    737            * @brief  Period elapsed callback in non blocking mode
    738            * @note   This function is called  when TIM6 interrupt took place, inside
    739            * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
    740            * a global variable "uwTick" used as application time base.
    741            * @param  htim : TIM handle
    742            * @retval None
    743            */

   \                                 In section .text, align 2, keep-with-next
    744          void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
    745          {
   \                     HAL_TIM_PeriodElapsedCallback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    746            /* USER CODE BEGIN Callback 0 */
    747          
    748            /* USER CODE END Callback 0 */
    749            if (htim->Instance == TIM6) {
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....             LDR.N    R1,??DataTable11_37
   \        0x6   0x4288             CMP      R0,R1
   \        0x8   0xD101             BNE.N    ??HAL_TIM_PeriodElapsedCallback_0
    750              HAL_IncTick();
   \        0xA   0x.... 0x....      BL       HAL_IncTick
    751            }
    752            /* USER CODE BEGIN Callback 1 */
    753          
    754            /* USER CODE END Callback 1 */
    755          }
   \                     ??HAL_TIM_PeriodElapsedCallback_0: (+1)
   \        0xE   0xBD01             POP      {R0,PC}
    756          
    757          /**
    758            * @brief  This function is executed in case of error occurrence.
    759            * @retval None
    760            */

   \                                 In section .text, align 2, keep-with-next
    761          void Error_Handler(void)
    762          {
    763            /* USER CODE BEGIN Error_Handler_Debug */
    764            /* User can add his own implementation to report the HAL error return state */
    765          
    766            /* USER CODE END Error_Handler_Debug */
    767          }
   \                     Error_Handler: (+1)
   \        0x0   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0xE000'ED14        DC32     0xe000ed14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0xE000'EF50        DC32     0xe000ef50

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0xE000'ED84        DC32     0xe000ed84

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0xE000'ED80        DC32     0xe000ed80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0xE000'EF60        DC32     0xe000ef60

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \        0x0   0x....'....        DC32     defaultTask_attributes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \        0x0   0x....'....        DC32     defaultTaskHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \        0x0   0x....'....        DC32     GUI_Task_attributes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \        0x0   0x....'....        DC32     TouchGFX_Task

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \        0x0   0x....'....        DC32     GUI_TaskHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \        0x0   0x....'....        DC32     buttonReadTask_attributes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \        0x0   0x....'....        DC32     ButtonReadTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \        0x0   0x....'....        DC32     buttonReadTaskHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \        0x0   0x5802'4818        DC32     0x58024818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \        0x0   0x5802'4428        DC32     0x58024428

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \        0x0   0x....'....        DC32     hcrc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \        0x0   0x4002'3000        DC32     0x40023000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_17:
   \        0x0   0x....'....        DC32     hdma2d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_18:
   \        0x0   0x5200'1000        DC32     0x52001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_19:
   \        0x0   0x....'....        DC32     hi2c4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_20:
   \        0x0   0x5800'1C00        DC32     0x58001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_21:
   \        0x0   0x3080'8BD0        DC32     0x30808bd0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_22:
   \        0x0   0x....'....        DC32     hltdc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_23:
   \        0x0   0x5000'1000        DC32     0x50001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_24:
   \        0x0   0x....'....        DC32     hospi1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_25:
   \        0x0   0x5200'5000        DC32     0x52005000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_26:
   \        0x0   0x0100'0001        DC32     0x1000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_27:
   \        0x0   0x....'....        DC32     huart1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_28:
   \        0x0   0x4001'1000        DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_29:
   \        0x0   0x5802'4540        DC32     0x58024540

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_30:
   \        0x0   0x5802'1800        DC32     0x58021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_31:
   \        0x0   0x5802'2000        DC32     0x58022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_32:
   \        0x0   0x5802'0000        DC32     0x58020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_33:
   \        0x0   0x5802'0400        DC32     0x58020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_34:
   \        0x0   0x5802'0800        DC32     0x58020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_35:
   \        0x0   0x5802'1C00        DC32     0x58021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_36:
   \        0x0   0x....'....        DC32     TimerHandleTest

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_37:
   \        0x0   0x4000'1000        DC32     0x40001000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x64 0x65          DC8 "defaultTask"

   \              0x66 0x61    

   \              0x75 0x6C    

   \              0x74 0x54    

   \              0x61 0x73    

   \              0x6B 0x00

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x47 0x55          DC8 "GUI_Task"

   \              0x49 0x5F    

   \              0x54 0x61    

   \              0x73 0x6B    

   \              0x00
   \        0x9                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x62 0x75          DC8 "buttonReadTask"

   \              0x74 0x74    

   \              0x6F 0x6E    

   \              0x52 0x65    

   \              0x61 0x64    

   \              0x54 0x61    

   \              0x73 0x6B    

   \              0x00
   \        0xF                      DS8 1
    768          
    769          #ifdef  USE_FULL_ASSERT
    770          /**
    771            * @brief  Reports the name of the source file and the source line number
    772            *         where the assert_param error has occurred.
    773            * @param  file: pointer to the source file name
    774            * @param  line: assert_param error line source number
    775            * @retval None
    776            */
    777          void assert_failed(uint8_t *file, uint32_t line)
    778          {
    779            /* USER CODE BEGIN 6 */
    780            /* User can add his own implementation to report the file name and line number,
    781               tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    782            /* USER CODE END 6 */
    783          }
    784          #endif /* USE_FULL_ASSERT */
    785          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Error_Handler
       8   HAL_TIM_PeriodElapsedCallback
         8   -> HAL_IncTick
      24   MPU_Config
        24   -> HAL_MPU_ConfigRegion
        24   -> HAL_MPU_Disable
        24   -> HAL_MPU_Enable
        24   -> __aeabi_memset
       8   MX_CRC_Init
         8   -> Error_Handler
         8   -> HAL_CRC_Init
       8   MX_DMA2D_Init
         8   -> Error_Handler
         8   -> HAL_DMA2D_ConfigLayer
         8   -> HAL_DMA2D_Init
      48   MX_GPIO_Init
        48   -> HAL_GPIO_Init
        48   -> HAL_GPIO_WritePin
        48   -> HAL_NVIC_EnableIRQ
        48   -> HAL_NVIC_SetPriority
        48   -> __aeabi_memset
       8   MX_I2C4_Init
         8   -> Error_Handler
         8   -> HAL_I2CEx_ConfigAnalogFilter
         8   -> HAL_I2CEx_ConfigDigitalFilter
         8   -> HAL_I2C_Init
      64   MX_LTDC_Init
        64   -> Error_Handler
        64   -> HAL_LTDC_ConfigLayer
        64   -> HAL_LTDC_Init
        64   -> __aeabi_memset
      40   MX_OCTOSPI1_Init
        40   -> BSP_OSPI_NOR_DeInit
        40   -> BSP_OSPI_NOR_EnableMemoryMappedMode
        40   -> BSP_OSPI_NOR_Init
        40   -> Error_Handler
        40   -> HAL_OSPIM_Config
        40   -> HAL_OSPI_Init
        40   -> __aeabi_memset
       8   MX_USART1_UART_Init
         8   -> Error_Handler
         8   -> HAL_UARTEx_DisableFifoMode
         8   -> HAL_UARTEx_SetRxFifoThreshold
         8   -> HAL_UARTEx_SetTxFifoThreshold
         8   -> HAL_UART_Init
       8   StartDefaultTask
         8   -> osDelay
         8   -> startTimer
     120   SystemClock_Config
       120   -> Error_Handler
       120   -> HAL_PWREx_ConfigSupply
       120   -> HAL_RCC_ClockConfig
       120   -> HAL_RCC_OscConfig
       120   -> __aeabi_memset
      16   main
        16   -> HAL_Init
        16   -> MPU_Config
        16   -> MX_CRC_Init
        16   -> MX_DMA2D_Init
        16   -> MX_GPIO_Init
        16   -> MX_I2C4_Init
        16   -> MX_LTDC_Init
        16   -> MX_OCTOSPI1_Init
        16   -> MX_TouchGFX_Init
        16   -> MX_USART1_UART_Init
        16   -> SystemClock_Config
        16   -> osKernelInitialize
        16   -> osKernelStart
        16   -> osThreadNew
       8   testTmrCallback
         8   -> HAL_GPIO_TogglePin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_19
       4  ??DataTable11_2
       4  ??DataTable11_20
       4  ??DataTable11_21
       4  ??DataTable11_22
       4  ??DataTable11_23
       4  ??DataTable11_24
       4  ??DataTable11_25
       4  ??DataTable11_26
       4  ??DataTable11_27
       4  ??DataTable11_28
       4  ??DataTable11_29
       4  ??DataTable11_3
       4  ??DataTable11_30
       4  ??DataTable11_31
       4  ??DataTable11_32
       4  ??DataTable11_33
       4  ??DataTable11_34
       4  ??DataTable11_35
       4  ??DataTable11_36
       4  ??DataTable11_37
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      12  ?_0
      12  ?_1
      16  ?_2
       2  Error_Handler
       4  GUI_TaskHandle
      36  GUI_Task_attributes
      16  HAL_TIM_PeriodElapsedCallback
     176  MPU_Config
      46  MX_CRC_Init
      84  MX_DMA2D_Init
     446  MX_GPIO_Init
      96  MX_I2C4_Init
     202  MX_LTDC_Init
     200  MX_OCTOSPI1_Init
     112  MX_USART1_UART_Init
      40  StartDefaultTask
     198  SystemClock_Config
       4  buttonReadTaskHandle
      36  buttonReadTask_attributes
       4  defaultTaskHandle
      36  defaultTask_attributes
      36  hcrc
     104  hdma2d
      76  hi2c4
     168  hltdc
      96  hospi1
     144  huart1
     252  main
      24  testTmrCallback

 
   636 bytes in section .bss
   148 bytes in section .rodata
 2'046 bytes in section .text
 
 2'046 bytes of CODE  memory
   148 bytes of CONST memory
   636 bytes of DATA  memory

Errors: none
Warnings: none
