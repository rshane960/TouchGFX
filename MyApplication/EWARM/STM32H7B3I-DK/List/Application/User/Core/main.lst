###############################################################################
#
# IAR ANSI C/C++ Compiler V9.20.1.318/W64 for ARM         07/Feb/2022  20:39:54
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\Core\Src\main.c [UTF-8]
#    Command line                 =
#        -f
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Application\User\Core\main.o.rsp
#        (D:\99_Project\GitHub\TouchGFX\MyApplication\Core\Src\main.c -D
#        USE_HAL_DRIVER -D STM32H7B3xxQ -D USE_BPP=24 -lC
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Application\User\Core
#        -lA
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Application\User\Core
#        -o
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Application\User\Core
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_d16 --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\inc\c\DLib_Config_Full.h" -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Core/Inc\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/App\ -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target/generated\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/target\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/STM32H7xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM4F\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Device/ST/STM32H7xx/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Drivers/BSP/STM32H7B3I-DK\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../Middlewares/ST/touchgfx/framework/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/fonts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/gui_generated/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/images/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/texts/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/gui/include\
#        -I
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM/../TouchGFX/generated/videos/include\
#        -Ol --source_encoding utf8 --text_out utf8 --utf8_text_in)
#        --dependencies=n
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Application\User\Core\main.o.d
#    Locale                       =  C
#    List file                    =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\List\Application\User\Core\main.lst
#    Object file                  =
#        D:\99_Project\GitHub\TouchGFX\MyApplication\EWARM\STM32H7B3I-DK\Obj\Application\User\Core\main.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  1
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

D:\99_Project\GitHub\TouchGFX\MyApplication\Core\Src\main.c
      1          /* USER CODE BEGIN Header */
      2          /**
      3            ******************************************************************************
      4            * @file           : main.c
      5            * @brief          : Main program body
      6            ******************************************************************************
      7            * @attention
      8            *
      9            * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
     10            * All rights reserved.</center></h2>
     11            *
     12            * This software component is licensed by ST under Ultimate Liberty license
     13            * SLA0044, the "License"; You may not use this file except in compliance with
     14            * the License. You may obtain a copy of the License at:
     15            *                             www.st.com/SLA0044
     16            *
     17            ******************************************************************************
     18            */
     19          /* USER CODE END Header */
     20          /* Includes ------------------------------------------------------------------*/
     21          #include "main.h"
     22          #include "cmsis_os.h"
     23          #include "app_touchgfx.h"
     24          
     25          /* Private includes ----------------------------------------------------------*/
     26          /* USER CODE BEGIN Includes */
     27          #include "stm32h7b3i_discovery_ospi.h"
     28          #include "stm32h7b3i_discovery.h"
     29          #include "User_Include.h"
     30          /* USER CODE END Includes */
     31          
     32          /* Private typedef -----------------------------------------------------------*/
     33          /* USER CODE BEGIN PTD */
     34          
     35          /* USER CODE END PTD */
     36          
     37          /* Private define ------------------------------------------------------------*/
     38          /* USER CODE BEGIN PD */
     39          /* USER CODE END PD */
     40          
     41          /* Private macro -------------------------------------------------------------*/
     42          /* USER CODE BEGIN PM */
     43          
     44          /* USER CODE END PM */
     45          
     46          /* Private variables ---------------------------------------------------------*/
     47          

   \                                 In section .bss, align 4
     48          CRC_HandleTypeDef hcrc;
   \                     hcrc:
   \        0x0                      DS8 36
     49          

   \                                 In section .bss, align 4
     50          DMA2D_HandleTypeDef hdma2d;
   \                     hdma2d:
   \        0x0                      DS8 104
     51          

   \                                 In section .bss, align 4
     52          I2C_HandleTypeDef hi2c4;
   \                     hi2c4:
   \        0x0                      DS8 76
     53          

   \                                 In section .bss, align 4
     54          LTDC_HandleTypeDef hltdc;
   \                     hltdc:
   \        0x0                      DS8 168
     55          

   \                                 In section .bss, align 4
     56          OSPI_HandleTypeDef hospi1;
   \                     hospi1:
   \        0x0                      DS8 96
     57          

   \                                 In section .bss, align 4
     58          UART_HandleTypeDef huart1;
   \                     huart1:
   \        0x0                      DS8 144
     59          
     60          /* Definitions for defaultTask */

   \                                 In section .bss, align 4
     61          osThreadId_t defaultTaskHandle;
   \                     defaultTaskHandle:
   \        0x0                      DS8 4

   \                                 In section .rodata, align 4
     62          const osThreadAttr_t defaultTask_attributes = {
   \                     defaultTask_attributes:
   \        0x0   0x....'....        DC32 ?_0, 0, 0x0, 0, 0x0, 512, 24

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0200  

   \              0x0000'0018
   \       0x1C                      DS8 8
     63            .name = "defaultTask",
     64            .stack_size = 128 * 4,
     65            .priority = (osPriority_t) osPriorityNormal,
     66          };
     67          /* Definitions for GUI_Task */

   \                                 In section .bss, align 4
     68          osThreadId_t GUI_TaskHandle;
   \                     GUI_TaskHandle:
   \        0x0                      DS8 4

   \                                 In section .rodata, align 4
     69          const osThreadAttr_t GUI_Task_attributes = {
   \                     GUI_Task_attributes:
   \        0x0   0x....'....        DC32 ?_1, 0, 0x0, 0, 0x0, 16'384, 24

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'0000  

   \              0x0000'4000  

   \              0x0000'0018
   \       0x1C                      DS8 8
     70            .name = "GUI_Task",
     71            .stack_size = 4096 * 4,
     72            .priority = (osPriority_t) osPriorityNormal,
     73          };
     74          /* Definitions for testTimer */
     75          //osTimerId_t testTimerHandle;
     76          //const osTimerAttr_t testTimer_attributes = {
     77          //  .name = "testTimer"
     78          //};
     79          /* USER CODE BEGIN PV */
     80          
     81          /* USER CODE END PV */
     82          
     83          /* Private function prototypes -----------------------------------------------*/
     84          void SystemClock_Config(void);
     85          static void MPU_Config(void);
     86          static void MX_CRC_Init(void);
     87          static void MX_GPIO_Init(void);
     88          static void MX_DMA2D_Init(void);
     89          static void MX_LTDC_Init(void);
     90          static void MX_I2C4_Init(void);
     91          static void MX_OCTOSPI1_Init(void);
     92          static void MX_USART1_UART_Init(void);
     93          void StartDefaultTask(void *argument);
     94          extern void TouchGFX_Task(void *argument);
     95          void testTmrCallback(void *argument);
     96          
     97          /* USER CODE BEGIN PFP */
     98          
     99          /* USER CODE END PFP */
    100          
    101          /* Private user code ---------------------------------------------------------*/
    102          /* USER CODE BEGIN 0 */
    103          
    104          /* USER CODE END 0 */
    105          
    106          /**
    107            * @brief  The application entry point.
    108            * @retval int
    109            */

   \                                 In section .text, align 2, keep-with-next
    110          int main(void)
    111          {
   \                     main: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    112            /* USER CODE BEGIN 1 */
    113          
    114            /* USER CODE END 1 */
    115          
    116            /* MPU Configuration--------------------------------------------------------*/
    117            MPU_Config();
   \        0x2   0x.... 0x....      BL       MPU_Config
    118          
    119            /* Enable I-Cache---------------------------------------------------------*/
    120            SCB_EnableICache();
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable11
   \        0xA   0x6808             LDR      R0,[R1, #+0]
   \        0xC   0x0380             LSLS     R0,R0,#+14
   \        0xE   0xD413             BMI.N    ??main_0
   \                     ??main_1: (+1)
   \       0x10   0xF3BF 0x8F4F      DSB      SY
   \       0x14   0xF3BF 0x8F6F      ISB      SY
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x.... 0x....      LDR.W    R2,??DataTable11_1
   \       0x1E   0x6010             STR      R0,[R2, #+0]
   \       0x20   0xF3BF 0x8F4F      DSB      SY
   \       0x24   0xF3BF 0x8F6F      ISB      SY
   \       0x28   0x6808             LDR      R0,[R1, #+0]
   \       0x2A   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \       0x2E   0x6008             STR      R0,[R1, #+0]
   \       0x30   0xF3BF 0x8F4F      DSB      SY
   \       0x34   0xF3BF 0x8F6F      ISB      SY
    121          
    122            /* Enable D-Cache---------------------------------------------------------*/
    123            SCB_EnableDCache();
   \                     ??main_0: (+1)
   \       0x38   0x6808             LDR      R0,[R1, #+0]
   \       0x3A   0x03C0             LSLS     R0,R0,#+15
   \       0x3C   0xD427             BMI.N    ??main_2
   \                     ??main_3: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x.... 0x....      LDR.W    R2,??DataTable11_2
   \       0x44   0x6010             STR      R0,[R2, #+0]
   \       0x46   0xF3BF 0x8F4F      DSB      SY
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x4E   0x6802             LDR      R2,[R0, #+0]
   \       0x50   0xF3C2 0x334E      UBFX     R3,R2,#+13,#+15
   \                     ??main_4: (+1)
   \       0x54   0xF3C2 0x04C9      UBFX     R4,R2,#+3,#+10
   \                     ??main_5: (+1)
   \       0x58   0xF643 0x70E0      MOVW     R0,#+16352
   \       0x5C   0xEA10 0x1043      ANDS     R0,R0,R3, LSL #+5
   \       0x60   0xEA50 0x7084      ORRS     R0,R0,R4, LSL #+30
   \       0x64   0x.... 0x....      LDR.W    R5,??DataTable11_4
   \       0x68   0x6028             STR      R0,[R5, #+0]
   \       0x6A   0x0020             MOVS     R0,R4
   \       0x6C   0x1E44             SUBS     R4,R0,#+1
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD1F2             BNE.N    ??main_5
   \       0x72   0x0018             MOVS     R0,R3
   \       0x74   0x1E43             SUBS     R3,R0,#+1
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD1EC             BNE.N    ??main_4
   \       0x7A   0xF3BF 0x8F4F      DSB      SY
   \       0x7E   0x6808             LDR      R0,[R1, #+0]
   \       0x80   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \       0x84   0x6008             STR      R0,[R1, #+0]
   \       0x86   0xF3BF 0x8F4F      DSB      SY
   \       0x8A   0xF3BF 0x8F6F      ISB      SY
    124          
    125            /* MCU Configuration--------------------------------------------------------*/
    126          
    127            /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
    128            HAL_Init();
   \                     ??main_2: (+1)
   \       0x8E   0x.... 0x....      BL       HAL_Init
    129          
    130            /* USER CODE BEGIN Init */
    131          
    132            /* USER CODE END Init */
    133          
    134            /* Configure the system clock */
    135            SystemClock_Config();
   \       0x92   0x.... 0x....      BL       SystemClock_Config
    136          
    137            /* USER CODE BEGIN SysInit */
    138          
    139            /* USER CODE END SysInit */
    140          
    141            /* Initialize all configured peripherals */
    142            MX_CRC_Init();
   \       0x96   0x.... 0x....      BL       MX_CRC_Init
    143            MX_GPIO_Init();
   \       0x9A   0x.... 0x....      BL       MX_GPIO_Init
    144            MX_DMA2D_Init();
   \       0x9E   0x.... 0x....      BL       MX_DMA2D_Init
    145            MX_LTDC_Init();
   \       0xA2   0x.... 0x....      BL       MX_LTDC_Init
    146            MX_I2C4_Init();
   \       0xA6   0x.... 0x....      BL       MX_I2C4_Init
    147            MX_OCTOSPI1_Init();
   \       0xAA   0x.... 0x....      BL       MX_OCTOSPI1_Init
    148            MX_USART1_UART_Init();
   \       0xAE   0x.... 0x....      BL       MX_USART1_UART_Init
    149            MX_TouchGFX_Init();
   \       0xB2   0x.... 0x....      BL       MX_TouchGFX_Init
    150            /* USER CODE BEGIN 2 */
    151          
    152            /* USER CODE END 2 */
    153          
    154            /* Init scheduler */
    155            osKernelInitialize();
   \       0xB6   0x.... 0x....      BL       osKernelInitialize
    156          
    157            /* USER CODE BEGIN RTOS_MUTEX */
    158            /* add mutexes, ... */
    159            /* USER CODE END RTOS_MUTEX */
    160          
    161            /* USER CODE BEGIN RTOS_SEMAPHORES */
    162            /* add semaphores, ... */
    163            /* USER CODE END RTOS_SEMAPHORES */
    164          
    165            /* Create the timer(s) */
    166            /* creation of testTimer */
    167          //  testTimerHandle = osTimerNew(testTmrCallback, osTimerPeriodic, NULL, &testTimer_attributes);
    168          
    169            /* USER CODE BEGIN RTOS_TIMERS */
    170            /* start timers, add new ones, ... */
    171            /* USER CODE END RTOS_TIMERS */
    172          
    173            /* USER CODE BEGIN RTOS_QUEUES */
    174            /* add queues, ... */
    175            /* USER CODE END RTOS_QUEUES */
    176          
    177            /* Create the thread(s) */
    178            /* creation of defaultTask */
    179            defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &defaultTask_attributes);
   \       0xBA   0x.... 0x....      LDR.W    R2,??DataTable11_5
   \       0xBE   0x2100             MOVS     R1,#+0
   \       0xC0   0x.... 0x....      ADR.W    R0,StartDefaultTask
   \       0xC4   0x.... 0x....      BL       osThreadNew
   \       0xC8   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \       0xCC   0x6008             STR      R0,[R1, #+0]
    180          
    181            /* creation of GUI_Task */
    182            GUI_TaskHandle = osThreadNew(TouchGFX_Task, NULL, &GUI_Task_attributes);
   \       0xCE   0x.... 0x....      LDR.W    R2,??DataTable11_7
   \       0xD2   0x2100             MOVS     R1,#+0
   \       0xD4   0x.... 0x....      LDR.W    R0,??DataTable11_8
   \       0xD8   0x.... 0x....      BL       osThreadNew
   \       0xDC   0x.... 0x....      LDR.W    R1,??DataTable11_9
   \       0xE0   0x6008             STR      R0,[R1, #+0]
    183          
    184            /* USER CODE BEGIN RTOS_THREADS */
    185            /* add threads, ... */
    186            /* USER CODE END RTOS_THREADS */
    187          
    188            /* USER CODE BEGIN RTOS_EVENTS */
    189            /* add events, ... */
    190            /* USER CODE END RTOS_EVENTS */
    191          
    192            /* Start scheduler */
    193            osKernelStart();
   \       0xE2   0x.... 0x....      BL       osKernelStart
    194          
    195            /* We should never get here as control is now taken by the scheduler */
    196            /* Infinite loop */
    197            /* USER CODE BEGIN WHILE */
    198          
    199            while (1)
   \                     ??main_6: (+1)
   \       0xE6   0xE7FE             B.N      ??main_6
    200            {
    201              /* USER CODE END WHILE */
    202          
    203              /* USER CODE BEGIN 3 */
    204            }
    205            /* USER CODE END 3 */
    206          }
    207          
    208          /**
    209            * @brief System Clock Configuration
    210            * @retval None
    211            */

   \                                 In section .text, align 2, keep-with-next
    212          void SystemClock_Config(void)
    213          {
   \                     SystemClock_Config: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB09C             SUB      SP,SP,#+112
   \        0x4   0x214C             MOVS     R1,#+76
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0xAC09             ADD      R4,SP,#+36
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x.... 0x....      BL       __aeabi_memset
   \       0x10   0x2120             MOVS     R1,#+32
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0xAC01             ADD      R4,SP,#+4
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       __aeabi_memset
    214            RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    215            RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
    216          
    217            /** Supply configuration update enable
    218            */
    219            HAL_PWREx_ConfigSupply(PWR_DIRECT_SMPS_SUPPLY);
   \       0x1C   0x2004             MOVS     R0,#+4
   \       0x1E   0x.... 0x....      BL       HAL_PWREx_ConfigSupply
    220            /** Configure the main internal regulator output voltage
    221            */
    222            __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x9000             STR      R0,[SP, #+0]
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable11_10
   \       0x2A   0x6801             LDR      R1,[R0, #+0]
   \       0x2C   0xF451 0x4140      ORRS     R1,R1,#0xC000
   \       0x30   0x6001             STR      R1,[R0, #+0]
   \       0x32   0x6801             LDR      R1,[R0, #+0]
   \       0x34   0xF411 0x4140      ANDS     R1,R1,#0xC000
   \       0x38   0x9100             STR      R1,[SP, #+0]
   \       0x3A   0x9900             LDR      R1,[SP, #+0]
    223          
    224            while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
   \                     ??SystemClock_Config_0: (+1)
   \       0x3C   0x6801             LDR      R1,[R0, #+0]
   \       0x3E   0x0489             LSLS     R1,R1,#+18
   \       0x40   0xD5FC             BPL.N    ??SystemClock_Config_0
    225            /** Macro to configure the PLL clock source
    226            */
    227            __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable11_11
   \       0x46   0x2102             MOVS     R1,#+2
   \       0x48   0x6802             LDR      R2,[R0, #+0]
   \       0x4A   0xF361 0x0201      BFI      R2,R1,#+0,#+2
   \       0x4E   0x6002             STR      R2,[R0, #+0]
    228            /** Initializes the RCC Oscillators according to the specified parameters
    229            * in the RCC_OscInitTypeDef structure.
    230            */
    231            RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0x9009             STR      R0,[SP, #+36]
    232            RCC_OscInitStruct.HSEState = RCC_HSE_ON;
   \       0x54   0xF45F 0x3080      MOVS     R0,#+65536
   \       0x58   0x900A             STR      R0,[SP, #+40]
    233            RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
   \       0x5A   0x2002             MOVS     R0,#+2
   \       0x5C   0x9012             STR      R0,[SP, #+72]
    234            RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
   \       0x5E   0x2002             MOVS     R0,#+2
   \       0x60   0x9013             STR      R0,[SP, #+76]
    235            RCC_OscInitStruct.PLL.PLLM = 12;
   \       0x62   0x200C             MOVS     R0,#+12
   \       0x64   0x9014             STR      R0,[SP, #+80]
    236            RCC_OscInitStruct.PLL.PLLN = 280;
   \       0x66   0xF44F 0x708C      MOV      R0,#+280
   \       0x6A   0x9015             STR      R0,[SP, #+84]
    237            RCC_OscInitStruct.PLL.PLLP = 2;
   \       0x6C   0x2002             MOVS     R0,#+2
   \       0x6E   0x9016             STR      R0,[SP, #+88]
    238            RCC_OscInitStruct.PLL.PLLQ = 2;
   \       0x70   0x2002             MOVS     R0,#+2
   \       0x72   0x9017             STR      R0,[SP, #+92]
    239            RCC_OscInitStruct.PLL.PLLR = 2;
   \       0x74   0x2002             MOVS     R0,#+2
   \       0x76   0x9018             STR      R0,[SP, #+96]
    240            RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_1;
   \       0x78   0x2004             MOVS     R0,#+4
   \       0x7A   0x9019             STR      R0,[SP, #+100]
    241            RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x901A             STR      R0,[SP, #+104]
    242            RCC_OscInitStruct.PLL.PLLFRACN = 0;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0x901B             STR      R0,[SP, #+108]
    243            if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
   \       0x84   0xA809             ADD      R0,SP,#+36
   \       0x86   0x.... 0x....      BL       HAL_RCC_OscConfig
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD001             BEQ.N    ??SystemClock_Config_1
    244            {
    245              Error_Handler();
   \       0x8E   0x.... 0x....      BL       Error_Handler
    246            }
    247            /** Initializes the CPU, AHB and APB buses clocks
    248            */
    249            RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
    250                                        |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
    251                                        |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
   \                     ??SystemClock_Config_1: (+1)
   \       0x92   0x203F             MOVS     R0,#+63
   \       0x94   0x9001             STR      R0,[SP, #+4]
    252            RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
   \       0x96   0x2003             MOVS     R0,#+3
   \       0x98   0x9002             STR      R0,[SP, #+8]
    253            RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0x9003             STR      R0,[SP, #+12]
    254            RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
   \       0x9E   0x2008             MOVS     R0,#+8
   \       0xA0   0x9004             STR      R0,[SP, #+16]
    255            RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV1;
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0x9005             STR      R0,[SP, #+20]
    256            RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0x9006             STR      R0,[SP, #+24]
    257            RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0x9007             STR      R0,[SP, #+28]
    258            RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;
   \       0xAE   0x2000             MOVS     R0,#+0
   \       0xB0   0x9008             STR      R0,[SP, #+32]
    259          
    260            if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
   \       0xB2   0x2103             MOVS     R1,#+3
   \       0xB4   0xA801             ADD      R0,SP,#+4
   \       0xB6   0x.... 0x....      BL       HAL_RCC_ClockConfig
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD001             BEQ.N    ??SystemClock_Config_2
    261            {
    262              Error_Handler();
   \       0xBE   0x.... 0x....      BL       Error_Handler
    263            }
    264          }
   \                     ??SystemClock_Config_2: (+1)
   \       0xC2   0xB01C             ADD      SP,SP,#+112
   \       0xC4   0xBD10             POP      {R4,PC}
    265          
    266          /**
    267            * @brief CRC Initialization Function
    268            * @param None
    269            * @retval None
    270            */

   \                                 In section .text, align 2, keep-with-next
    271          static void MX_CRC_Init(void)
    272          {
   \                     MX_CRC_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    273          
    274            /* USER CODE BEGIN CRC_Init 0 */
    275          
    276            /* USER CODE END CRC_Init 0 */
    277          
    278            /* USER CODE BEGIN CRC_Init 1 */
    279          
    280            /* USER CODE END CRC_Init 1 */
    281            hcrc.Instance = CRC;
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable11_12
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable11_13
   \        0xA   0x6001             STR      R1,[R0, #+0]
    282            hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x7101             STRB     R1,[R0, #+4]
    283            hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x7141             STRB     R1,[R0, #+5]
    284            hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6141             STR      R1,[R0, #+20]
    285            hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x6181             STR      R1,[R0, #+24]
    286            hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
   \       0x1C   0x2101             MOVS     R1,#+1
   \       0x1E   0x6201             STR      R1,[R0, #+32]
    287            if (HAL_CRC_Init(&hcrc) != HAL_OK)
   \       0x20   0x.... 0x....      BL       HAL_CRC_Init
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD001             BEQ.N    ??MX_CRC_Init_0
    288            {
    289              Error_Handler();
   \       0x28   0x.... 0x....      BL       Error_Handler
    290            }
    291            /* USER CODE BEGIN CRC_Init 2 */
    292          
    293            /* USER CODE END CRC_Init 2 */
    294          
    295          }
   \                     ??MX_CRC_Init_0: (+1)
   \       0x2C   0xBD01             POP      {R0,PC}
    296          
    297          /**
    298            * @brief DMA2D Initialization Function
    299            * @param None
    300            * @retval None
    301            */

   \                                 In section .text, align 2, keep-with-next
    302          static void MX_DMA2D_Init(void)
    303          {
   \                     MX_DMA2D_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    304          
    305            /* USER CODE BEGIN DMA2D_Init 0 */
    306          
    307            /* USER CODE END DMA2D_Init 0 */
    308          
    309            /* USER CODE BEGIN DMA2D_Init 1 */
    310          
    311            /* USER CODE END DMA2D_Init 1 */
    312            hdma2d.Instance = DMA2D;
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable11_14
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable11_15
   \        0xA   0x6020             STR      R0,[R4, #+0]
    313            hdma2d.Init.Mode = DMA2D_M2M;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x6060             STR      R0,[R4, #+4]
    314            hdma2d.Init.ColorMode = DMA2D_OUTPUT_RGB565;
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0x60A0             STR      R0,[R4, #+8]
    315            hdma2d.Init.OutputOffset = 0;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x60E0             STR      R0,[R4, #+12]
    316            hdma2d.LayerCfg[1].InputOffset = 0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6460             STR      R0,[R4, #+68]
    317            hdma2d.LayerCfg[1].InputColorMode = DMA2D_INPUT_RGB565;
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0x64A0             STR      R0,[R4, #+72]
    318            hdma2d.LayerCfg[1].AlphaMode = DMA2D_NO_MODIF_ALPHA;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x64E0             STR      R0,[R4, #+76]
    319            hdma2d.LayerCfg[1].InputAlpha = 0;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x6520             STR      R0,[R4, #+80]
    320            hdma2d.LayerCfg[1].AlphaInverted = DMA2D_REGULAR_ALPHA;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x6560             STR      R0,[R4, #+84]
    321            hdma2d.LayerCfg[1].RedBlueSwap = DMA2D_RB_REGULAR;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x65A0             STR      R0,[R4, #+88]
    322            hdma2d.LayerCfg[1].ChromaSubSampling = DMA2D_NO_CSS;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x65E0             STR      R0,[R4, #+92]
    323            if (HAL_DMA2D_Init(&hdma2d) != HAL_OK)
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       HAL_DMA2D_Init
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD001             BEQ.N    ??MX_DMA2D_Init_0
    324            {
    325              Error_Handler();
   \       0x3E   0x.... 0x....      BL       Error_Handler
    326            }
    327            if (HAL_DMA2D_ConfigLayer(&hdma2d, 1) != HAL_OK)
   \                     ??MX_DMA2D_Init_0: (+1)
   \       0x42   0x2101             MOVS     R1,#+1
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x.... 0x....      BL       HAL_DMA2D_ConfigLayer
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD001             BEQ.N    ??MX_DMA2D_Init_1
    328            {
    329              Error_Handler();
   \       0x4E   0x.... 0x....      BL       Error_Handler
    330            }
    331            /* USER CODE BEGIN DMA2D_Init 2 */
    332          
    333            /* USER CODE END DMA2D_Init 2 */
    334          
    335          }
   \                     ??MX_DMA2D_Init_1: (+1)
   \       0x52   0xBD10             POP      {R4,PC}
    336          
    337          /**
    338            * @brief I2C4 Initialization Function
    339            * @param None
    340            * @retval None
    341            */

   \                                 In section .text, align 2, keep-with-next
    342          static void MX_I2C4_Init(void)
    343          {
   \                     MX_I2C4_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    344          
    345            /* USER CODE BEGIN I2C4_Init 0 */
    346          
    347            /* USER CODE END I2C4_Init 0 */
    348          
    349            /* USER CODE BEGIN I2C4_Init 1 */
    350          
    351            /* USER CODE END I2C4_Init 1 */
    352            hi2c4.Instance = I2C4;
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable11_16
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable11_17
   \        0xA   0x6020             STR      R0,[R4, #+0]
    353            hi2c4.Init.Timing = 0x30808BD0;
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable11_18
   \       0x10   0x6060             STR      R0,[R4, #+4]
    354            hi2c4.Init.OwnAddress1 = 0;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x60A0             STR      R0,[R4, #+8]
    355            hi2c4.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x60E0             STR      R0,[R4, #+12]
    356            hi2c4.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x6120             STR      R0,[R4, #+16]
    357            hi2c4.Init.OwnAddress2 = 0;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6160             STR      R0,[R4, #+20]
    358            hi2c4.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x61A0             STR      R0,[R4, #+24]
    359            hi2c4.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x61E0             STR      R0,[R4, #+28]
    360            hi2c4.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x6220             STR      R0,[R4, #+32]
    361            if (HAL_I2C_Init(&hi2c4) != HAL_OK)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       HAL_I2C_Init
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD001             BEQ.N    ??MX_I2C4_Init_0
    362            {
    363              Error_Handler();
   \       0x38   0x.... 0x....      BL       Error_Handler
    364            }
    365            /** Configure Analogue filter
    366            */
    367            if (HAL_I2CEx_ConfigAnalogFilter(&hi2c4, I2C_ANALOGFILTER_DISABLE) != HAL_OK)
   \                     ??MX_I2C4_Init_0: (+1)
   \       0x3C   0xF44F 0x5180      MOV      R1,#+4096
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x.... 0x....      BL       HAL_I2CEx_ConfigAnalogFilter
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD001             BEQ.N    ??MX_I2C4_Init_1
    368            {
    369              Error_Handler();
   \       0x4A   0x.... 0x....      BL       Error_Handler
    370            }
    371            /** Configure Digital filter
    372            */
    373            if (HAL_I2CEx_ConfigDigitalFilter(&hi2c4, 0) != HAL_OK)
   \                     ??MX_I2C4_Init_1: (+1)
   \       0x4E   0x2100             MOVS     R1,#+0
   \       0x50   0x0020             MOVS     R0,R4
   \       0x52   0x.... 0x....      BL       HAL_I2CEx_ConfigDigitalFilter
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD001             BEQ.N    ??MX_I2C4_Init_2
    374            {
    375              Error_Handler();
   \       0x5A   0x.... 0x....      BL       Error_Handler
    376            }
    377            /* USER CODE BEGIN I2C4_Init 2 */
    378          
    379            /* USER CODE END I2C4_Init 2 */
    380          
    381          }
   \                     ??MX_I2C4_Init_2: (+1)
   \       0x5E   0xBD10             POP      {R4,PC}
    382          
    383          /**
    384            * @brief LTDC Initialization Function
    385            * @param None
    386            * @retval None
    387            */

   \                                 In section .text, align 2, keep-with-next
    388          static void MX_LTDC_Init(void)
    389          {
   \                     MX_LTDC_Init: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB08D             SUB      SP,SP,#+52
   \        0x4   0x2134             MOVS     R1,#+52
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x466C             MOV      R4,SP
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x.... 0x....      BL       __aeabi_memset
    390          
    391            /* USER CODE BEGIN LTDC_Init 0 */
    392          
    393            /* USER CODE END LTDC_Init 0 */
    394          
    395            LTDC_LayerCfgTypeDef pLayerCfg = {0};
    396          
    397            /* USER CODE BEGIN LTDC_Init 1 */
    398          
    399            /* USER CODE END LTDC_Init 1 */
    400            hltdc.Instance = LTDC;
   \       0x10   0x.... 0x....      LDR.W    R4,??DataTable11_19
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable11_20
   \       0x18   0x6020             STR      R0,[R4, #+0]
    401            hltdc.Init.HSPolarity = LTDC_HSPOLARITY_AL;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x6060             STR      R0,[R4, #+4]
    402            hltdc.Init.VSPolarity = LTDC_VSPOLARITY_AL;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x60A0             STR      R0,[R4, #+8]
    403            hltdc.Init.DEPolarity = LTDC_DEPOLARITY_AL;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x60E0             STR      R0,[R4, #+12]
    404            hltdc.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x6120             STR      R0,[R4, #+16]
    405            hltdc.Init.HorizontalSync = 40;
   \       0x2A   0x2028             MOVS     R0,#+40
   \       0x2C   0x6160             STR      R0,[R4, #+20]
    406            hltdc.Init.VerticalSync = 9;
   \       0x2E   0x2009             MOVS     R0,#+9
   \       0x30   0x61A0             STR      R0,[R4, #+24]
    407            hltdc.Init.AccumulatedHBP = 42;
   \       0x32   0x202A             MOVS     R0,#+42
   \       0x34   0x61E0             STR      R0,[R4, #+28]
    408            hltdc.Init.AccumulatedVBP = 11;
   \       0x36   0x200B             MOVS     R0,#+11
   \       0x38   0x6220             STR      R0,[R4, #+32]
    409            hltdc.Init.AccumulatedActiveW = 522;
   \       0x3A   0xF240 0x200A      MOVW     R0,#+522
   \       0x3E   0x6260             STR      R0,[R4, #+36]
    410            hltdc.Init.AccumulatedActiveH = 283;
   \       0x40   0xF240 0x101B      MOVW     R0,#+283
   \       0x44   0x62A0             STR      R0,[R4, #+40]
    411            hltdc.Init.TotalWidth = 554;
   \       0x46   0xF240 0x202A      MOVW     R0,#+554
   \       0x4A   0x62E0             STR      R0,[R4, #+44]
    412            hltdc.Init.TotalHeigh = 285;
   \       0x4C   0xF240 0x101D      MOVW     R0,#+285
   \       0x50   0x6320             STR      R0,[R4, #+48]
    413            hltdc.Init.Backcolor.Blue = 0;
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xF884 0x0034      STRB     R0,[R4, #+52]
    414            hltdc.Init.Backcolor.Green = 0;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF884 0x0035      STRB     R0,[R4, #+53]
    415            hltdc.Init.Backcolor.Red = 0;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xF884 0x0036      STRB     R0,[R4, #+54]
    416            if (HAL_LTDC_Init(&hltdc) != HAL_OK)
   \       0x64   0x0020             MOVS     R0,R4
   \       0x66   0x.... 0x....      BL       HAL_LTDC_Init
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD001             BEQ.N    ??MX_LTDC_Init_0
    417            {
    418              Error_Handler();
   \       0x6E   0x.... 0x....      BL       Error_Handler
    419            }
    420            pLayerCfg.WindowX0 = 0;
   \                     ??MX_LTDC_Init_0: (+1)
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x9000             STR      R0,[SP, #+0]
    421            pLayerCfg.WindowX1 = 480;
   \       0x76   0xF44F 0x70F0      MOV      R0,#+480
   \       0x7A   0x9001             STR      R0,[SP, #+4]
    422            pLayerCfg.WindowY0 = 0;
   \       0x7C   0x2100             MOVS     R1,#+0
   \       0x7E   0x9102             STR      R1,[SP, #+8]
    423            pLayerCfg.WindowY1 = 272;
   \       0x80   0xF44F 0x7188      MOV      R1,#+272
   \       0x84   0x9103             STR      R1,[SP, #+12]
    424            pLayerCfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB888;
   \       0x86   0x2201             MOVS     R2,#+1
   \       0x88   0x9204             STR      R2,[SP, #+16]
    425            pLayerCfg.Alpha = 255;
   \       0x8A   0x22FF             MOVS     R2,#+255
   \       0x8C   0x9205             STR      R2,[SP, #+20]
    426            pLayerCfg.Alpha0 = 0;
   \       0x8E   0x2300             MOVS     R3,#+0
   \       0x90   0x9306             STR      R3,[SP, #+24]
    427            pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_CA;
   \       0x92   0xF44F 0x6380      MOV      R3,#+1024
   \       0x96   0x9307             STR      R3,[SP, #+28]
    428            pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_CA;
   \       0x98   0x2305             MOVS     R3,#+5
   \       0x9A   0x9308             STR      R3,[SP, #+32]
    429            pLayerCfg.FBStartAdress = 0;
   \       0x9C   0x2300             MOVS     R3,#+0
   \       0x9E   0x9309             STR      R3,[SP, #+36]
    430            pLayerCfg.ImageWidth = 480;
   \       0xA0   0x900A             STR      R0,[SP, #+40]
    431            pLayerCfg.ImageHeight = 272;
   \       0xA2   0x910B             STR      R1,[SP, #+44]
    432            pLayerCfg.Backcolor.Blue = 255;
   \       0xA4   0xF88D 0x2030      STRB     R2,[SP, #+48]
    433            pLayerCfg.Backcolor.Green = 0;
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0xF88D 0x0031      STRB     R0,[SP, #+49]
    434            pLayerCfg.Backcolor.Red = 0;
   \       0xAE   0x2000             MOVS     R0,#+0
   \       0xB0   0xF88D 0x0032      STRB     R0,[SP, #+50]
    435            if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
   \       0xB4   0x2200             MOVS     R2,#+0
   \       0xB6   0x4669             MOV      R1,SP
   \       0xB8   0x0020             MOVS     R0,R4
   \       0xBA   0x.... 0x....      BL       HAL_LTDC_ConfigLayer
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD001             BEQ.N    ??MX_LTDC_Init_1
    436            {
    437              Error_Handler();
   \       0xC2   0x.... 0x....      BL       Error_Handler
    438            }
    439            /* USER CODE BEGIN LTDC_Init 2 */
    440          
    441            /* USER CODE END LTDC_Init 2 */
    442          
    443          }
   \                     ??MX_LTDC_Init_1: (+1)
   \       0xC6   0xB00E             ADD      SP,SP,#+56
   \       0xC8   0xBD10             POP      {R4,PC}
    444          
    445          /**
    446            * @brief OCTOSPI1 Initialization Function
    447            * @param None
    448            * @retval None
    449            */

   \                                 In section .text, align 2, keep-with-next
    450          static void MX_OCTOSPI1_Init(void)
    451          {
   \                     MX_OCTOSPI1_Init: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x2118             MOVS     R1,#+24
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0xAC01             ADD      R4,SP,#+4
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x.... 0x....      BL       __aeabi_memset
    452          
    453            /* USER CODE BEGIN OCTOSPI1_Init 0 */
    454          
    455            /* USER CODE END OCTOSPI1_Init 0 */
    456          
    457            OSPIM_CfgTypeDef sOspiManagerCfg = {0};
    458          
    459            /* USER CODE BEGIN OCTOSPI1_Init 1 */
    460          
    461            /* USER CODE END OCTOSPI1_Init 1 */
    462            /* OCTOSPI1 parameter configuration*/
    463            hospi1.Instance = OCTOSPI1;
   \       0x10   0x.... 0x....      LDR.W    R4,??DataTable11_21
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable11_22
   \       0x18   0x6020             STR      R0,[R4, #+0]
    464            hospi1.Init.FifoThreshold = 1;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0x6060             STR      R0,[R4, #+4]
    465            hospi1.Init.DualQuad = HAL_OSPI_DUALQUAD_DISABLE;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x60A0             STR      R0,[R4, #+8]
    466            hospi1.Init.MemoryType = HAL_OSPI_MEMTYPE_MICRON;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x60E0             STR      R0,[R4, #+12]
    467            hospi1.Init.DeviceSize = 26;
   \       0x26   0x201A             MOVS     R0,#+26
   \       0x28   0x6120             STR      R0,[R4, #+16]
    468            hospi1.Init.ChipSelectHighTime = 2;
   \       0x2A   0x2002             MOVS     R0,#+2
   \       0x2C   0x6160             STR      R0,[R4, #+20]
    469            hospi1.Init.FreeRunningClock = HAL_OSPI_FREERUNCLK_DISABLE;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x61A0             STR      R0,[R4, #+24]
    470            hospi1.Init.ClockMode = HAL_OSPI_CLOCK_MODE_0;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x61E0             STR      R0,[R4, #+28]
    471            hospi1.Init.WrapSize = HAL_OSPI_WRAP_NOT_SUPPORTED;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x6220             STR      R0,[R4, #+32]
    472            hospi1.Init.ClockPrescaler = 3;
   \       0x3A   0x2003             MOVS     R0,#+3
   \       0x3C   0x6260             STR      R0,[R4, #+36]
    473            hospi1.Init.SampleShifting = HAL_OSPI_SAMPLE_SHIFTING_NONE;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x62A0             STR      R0,[R4, #+40]
    474            hospi1.Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_DISABLE;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x62E0             STR      R0,[R4, #+44]
    475            hospi1.Init.ChipSelectBoundary = 0;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x6320             STR      R0,[R4, #+48]
    476            hospi1.Init.ClkChipSelectHighTime = 0;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x6360             STR      R0,[R4, #+52]
    477            hospi1.Init.DelayBlockBypass = HAL_OSPI_DELAY_BLOCK_BYPASSED;
   \       0x4E   0x2008             MOVS     R0,#+8
   \       0x50   0x63A0             STR      R0,[R4, #+56]
    478            hospi1.Init.MaxTran = 0;
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x63E0             STR      R0,[R4, #+60]
    479            hospi1.Init.Refresh = 0;
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x6420             STR      R0,[R4, #+64]
    480            if (HAL_OSPI_Init(&hospi1) != HAL_OK)
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x.... 0x....      BL       HAL_OSPI_Init
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD001             BEQ.N    ??MX_OCTOSPI1_Init_0
    481            {
    482              Error_Handler();
   \       0x64   0x.... 0x....      BL       Error_Handler
    483            }
    484            sOspiManagerCfg.ClkPort = 1;
   \                     ??MX_OCTOSPI1_Init_0: (+1)
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0x9001             STR      R0,[SP, #+4]
    485            sOspiManagerCfg.DQSPort = 1;
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0x9002             STR      R0,[SP, #+8]
    486            sOspiManagerCfg.NCSPort = 1;
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0x9003             STR      R0,[SP, #+12]
    487            sOspiManagerCfg.IOLowPort = HAL_OSPIM_IOPORT_1_LOW;
   \       0x74   0xF05F 0x1001      MOVS     R0,#+65537
   \       0x78   0x9004             STR      R0,[SP, #+16]
    488            sOspiManagerCfg.IOHighPort = HAL_OSPIM_IOPORT_1_HIGH;
   \       0x7A   0x.... 0x....      LDR.W    R0,??DataTable11_23
   \       0x7E   0x9005             STR      R0,[SP, #+20]
    489            if (HAL_OSPIM_Config(&hospi1, &sOspiManagerCfg, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
   \       0x80   0xF241 0x3288      MOVW     R2,#+5000
   \       0x84   0xA901             ADD      R1,SP,#+4
   \       0x86   0x0020             MOVS     R0,R4
   \       0x88   0x.... 0x....      BL       HAL_OSPIM_Config
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD001             BEQ.N    ??MX_OCTOSPI1_Init_1
    490            {
    491              Error_Handler();
   \       0x90   0x.... 0x....      BL       Error_Handler
    492            }
    493            /* USER CODE BEGIN OCTOSPI1_Init 2 */
    494            BSP_OSPI_NOR_Init_t Flash;
    495            Flash.InterfaceMode = BSP_OSPI_NOR_OPI_MODE;
   \                     ??MX_OCTOSPI1_Init_1: (+1)
   \       0x94   0x2001             MOVS     R0,#+1
   \       0x96   0xF88D 0x0000      STRB     R0,[SP, #+0]
    496            Flash.TransferRate  = BSP_OSPI_NOR_DTR_TRANSFER;
   \       0x9A   0x2001             MOVS     R0,#+1
   \       0x9C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    497            BSP_OSPI_NOR_DeInit(0);
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0x.... 0x....      BL       BSP_OSPI_NOR_DeInit
    498            int32_t RetVal = BSP_OSPI_NOR_Init(0, &Flash);
   \       0xA6   0x4669             MOV      R1,SP
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0x.... 0x....      BL       BSP_OSPI_NOR_Init
    499            if(RetVal != BSP_ERROR_NONE)
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD001             BEQ.N    ??MX_OCTOSPI1_Init_2
    500            {
    501              Error_Handler();
   \       0xB2   0x.... 0x....      BL       Error_Handler
    502            }
    503            RetVal = BSP_OSPI_NOR_EnableMemoryMappedMode(0);
   \                     ??MX_OCTOSPI1_Init_2: (+1)
   \       0xB6   0x2000             MOVS     R0,#+0
   \       0xB8   0x.... 0x....      BL       BSP_OSPI_NOR_EnableMemoryMappedMode
    504            if(RetVal != BSP_ERROR_NONE)
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xD001             BEQ.N    ??MX_OCTOSPI1_Init_3
    505            {
    506              Error_Handler();
   \       0xC0   0x.... 0x....      BL       Error_Handler
    507            }
    508            /* USER CODE END OCTOSPI1_Init 2 */
    509          
    510          }
   \                     ??MX_OCTOSPI1_Init_3: (+1)
   \       0xC4   0xB008             ADD      SP,SP,#+32
   \       0xC6   0xBD10             POP      {R4,PC}
    511          
    512          /**
    513            * @brief USART1 Initialization Function
    514            * @param None
    515            * @retval None
    516            */

   \                                 In section .text, align 2, keep-with-next
    517          static void MX_USART1_UART_Init(void)
    518          {
   \                     MX_USART1_UART_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    519          
    520            /* USER CODE BEGIN USART1_Init 0 */
    521          
    522            /* USER CODE END USART1_Init 0 */
    523          
    524            /* USER CODE BEGIN USART1_Init 1 */
    525          
    526            /* USER CODE END USART1_Init 1 */
    527            huart1.Instance = USART1;
   \        0x2   0x....             LDR.N    R4,??DataTable11_24
   \        0x4   0x....             LDR.N    R0,??DataTable11_25
   \        0x6   0x6020             STR      R0,[R4, #+0]
    528            huart1.Init.BaudRate = 115200;
   \        0x8   0xF45F 0x30E1      MOVS     R0,#+115200
   \        0xC   0x6060             STR      R0,[R4, #+4]
    529            huart1.Init.WordLength = UART_WORDLENGTH_8B;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x60A0             STR      R0,[R4, #+8]
    530            huart1.Init.StopBits = UART_STOPBITS_1;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x60E0             STR      R0,[R4, #+12]
    531            huart1.Init.Parity = UART_PARITY_NONE;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x6120             STR      R0,[R4, #+16]
    532            huart1.Init.Mode = UART_MODE_TX_RX;
   \       0x1A   0x200C             MOVS     R0,#+12
   \       0x1C   0x6160             STR      R0,[R4, #+20]
    533            huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x61A0             STR      R0,[R4, #+24]
    534            huart1.Init.OverSampling = UART_OVERSAMPLING_16;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x61E0             STR      R0,[R4, #+28]
    535            huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x6220             STR      R0,[R4, #+32]
    536            huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x6260             STR      R0,[R4, #+36]
    537            huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x62A0             STR      R0,[R4, #+40]
    538            if (HAL_UART_Init(&huart1) != HAL_OK)
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       HAL_UART_Init
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD001             BEQ.N    ??MX_USART1_UART_Init_0
    539            {
    540              Error_Handler();
   \       0x3C   0x.... 0x....      BL       Error_Handler
    541            }
    542            if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
   \                     ??MX_USART1_UART_Init_0: (+1)
   \       0x40   0x2100             MOVS     R1,#+0
   \       0x42   0x0020             MOVS     R0,R4
   \       0x44   0x.... 0x....      BL       HAL_UARTEx_SetTxFifoThreshold
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD001             BEQ.N    ??MX_USART1_UART_Init_1
    543            {
    544              Error_Handler();
   \       0x4C   0x.... 0x....      BL       Error_Handler
    545            }
    546            if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
   \                     ??MX_USART1_UART_Init_1: (+1)
   \       0x50   0x2100             MOVS     R1,#+0
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x.... 0x....      BL       HAL_UARTEx_SetRxFifoThreshold
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD001             BEQ.N    ??MX_USART1_UART_Init_2
    547            {
    548              Error_Handler();
   \       0x5C   0x.... 0x....      BL       Error_Handler
    549            }
    550            if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
   \                     ??MX_USART1_UART_Init_2: (+1)
   \       0x60   0x0020             MOVS     R0,R4
   \       0x62   0x.... 0x....      BL       HAL_UARTEx_DisableFifoMode
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD001             BEQ.N    ??MX_USART1_UART_Init_3
    551            {
    552              Error_Handler();
   \       0x6A   0x.... 0x....      BL       Error_Handler
    553            }
    554            /* USER CODE BEGIN USART1_Init 2 */
    555          
    556            /* USER CODE END USART1_Init 2 */
    557          
    558          }
   \                     ??MX_USART1_UART_Init_3: (+1)
   \       0x6E   0xBD10             POP      {R4,PC}
    559          
    560          /**
    561            * @brief GPIO Initialization Function
    562            * @param None
    563            * @retval None
    564            */

   \                                 In section .text, align 2, keep-with-next
    565          static void MX_GPIO_Init(void)
    566          {
   \                     MX_GPIO_Init: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x2114             MOVS     R1,#+20
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x466C             MOV      R4,SP
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x.... 0x....      BL       __aeabi_memset
    567            GPIO_InitTypeDef GPIO_InitStruct = {0};
    568          
    569            /* GPIO Ports Clock Enable */
    570            __HAL_RCC_GPIOK_CLK_ENABLE();
   \       0x12   0x....             LDR.N    R0,??DataTable11_26
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0xF451 0x6180      ORRS     R1,R1,#0x400
   \       0x1A   0x6001             STR      R1,[R0, #+0]
   \       0x1C   0x6801             LDR      R1,[R0, #+0]
   \       0x1E   0xF411 0x6180      ANDS     R1,R1,#0x400
   \       0x22   0x9105             STR      R1,[SP, #+20]
   \       0x24   0x9905             LDR      R1,[SP, #+20]
    571            __HAL_RCC_GPIOG_CLK_ENABLE();
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0x2C   0x6001             STR      R1,[R0, #+0]
   \       0x2E   0x6801             LDR      R1,[R0, #+0]
   \       0x30   0xF011 0x0140      ANDS     R1,R1,#0x40
   \       0x34   0x9105             STR      R1,[SP, #+20]
   \       0x36   0x9905             LDR      R1,[SP, #+20]
    572            __HAL_RCC_GPIOD_CLK_ENABLE();
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0xF051 0x0108      ORRS     R1,R1,#0x8
   \       0x3E   0x6001             STR      R1,[R0, #+0]
   \       0x40   0x6801             LDR      R1,[R0, #+0]
   \       0x42   0xF011 0x0108      ANDS     R1,R1,#0x8
   \       0x46   0x9105             STR      R1,[SP, #+20]
   \       0x48   0x9905             LDR      R1,[SP, #+20]
    573            __HAL_RCC_GPIOJ_CLK_ENABLE();
   \       0x4A   0x6801             LDR      R1,[R0, #+0]
   \       0x4C   0xF451 0x7100      ORRS     R1,R1,#0x200
   \       0x50   0x6001             STR      R1,[R0, #+0]
   \       0x52   0x6801             LDR      R1,[R0, #+0]
   \       0x54   0xF411 0x7100      ANDS     R1,R1,#0x200
   \       0x58   0x9105             STR      R1,[SP, #+20]
   \       0x5A   0x9905             LDR      R1,[SP, #+20]
    574            __HAL_RCC_GPIOI_CLK_ENABLE();
   \       0x5C   0x6801             LDR      R1,[R0, #+0]
   \       0x5E   0xF451 0x7180      ORRS     R1,R1,#0x100
   \       0x62   0x6001             STR      R1,[R0, #+0]
   \       0x64   0x6801             LDR      R1,[R0, #+0]
   \       0x66   0xF411 0x7180      ANDS     R1,R1,#0x100
   \       0x6A   0x9105             STR      R1,[SP, #+20]
   \       0x6C   0x9905             LDR      R1,[SP, #+20]
    575            __HAL_RCC_GPIOA_CLK_ENABLE();
   \       0x6E   0x6801             LDR      R1,[R0, #+0]
   \       0x70   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x74   0x6001             STR      R1,[R0, #+0]
   \       0x76   0x6801             LDR      R1,[R0, #+0]
   \       0x78   0xF011 0x0101      ANDS     R1,R1,#0x1
   \       0x7C   0x9105             STR      R1,[SP, #+20]
   \       0x7E   0x9905             LDR      R1,[SP, #+20]
    576            __HAL_RCC_GPIOC_CLK_ENABLE();
   \       0x80   0x6801             LDR      R1,[R0, #+0]
   \       0x82   0xF051 0x0104      ORRS     R1,R1,#0x4
   \       0x86   0x6001             STR      R1,[R0, #+0]
   \       0x88   0x6801             LDR      R1,[R0, #+0]
   \       0x8A   0xF011 0x0104      ANDS     R1,R1,#0x4
   \       0x8E   0x9105             STR      R1,[SP, #+20]
   \       0x90   0x9905             LDR      R1,[SP, #+20]
    577            __HAL_RCC_GPIOF_CLK_ENABLE();
   \       0x92   0x6801             LDR      R1,[R0, #+0]
   \       0x94   0xF051 0x0120      ORRS     R1,R1,#0x20
   \       0x98   0x6001             STR      R1,[R0, #+0]
   \       0x9A   0x6801             LDR      R1,[R0, #+0]
   \       0x9C   0xF011 0x0120      ANDS     R1,R1,#0x20
   \       0xA0   0x9105             STR      R1,[SP, #+20]
   \       0xA2   0x9905             LDR      R1,[SP, #+20]
    578            __HAL_RCC_GPIOH_CLK_ENABLE();
   \       0xA4   0x6801             LDR      R1,[R0, #+0]
   \       0xA6   0xF051 0x0180      ORRS     R1,R1,#0x80
   \       0xAA   0x6001             STR      R1,[R0, #+0]
   \       0xAC   0x6801             LDR      R1,[R0, #+0]
   \       0xAE   0xF011 0x0180      ANDS     R1,R1,#0x80
   \       0xB2   0x9105             STR      R1,[SP, #+20]
   \       0xB4   0x9905             LDR      R1,[SP, #+20]
    579            __HAL_RCC_GPIOB_CLK_ENABLE();
   \       0xB6   0x6801             LDR      R1,[R0, #+0]
   \       0xB8   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0xBC   0x6001             STR      R1,[R0, #+0]
   \       0xBE   0x6800             LDR      R0,[R0, #+0]
   \       0xC0   0xF010 0x0002      ANDS     R0,R0,#0x2
   \       0xC4   0x9005             STR      R0,[SP, #+20]
   \       0xC6   0x9805             LDR      R0,[SP, #+20]
    580          
    581            /*Configure GPIO pin Output Level */
    582            HAL_GPIO_WritePin(GPIOG, LED3_Pin|LED2_Pin, GPIO_PIN_RESET);
   \       0xC8   0xF640 0x0804      MOVW     R8,#+2052
   \       0xCC   0x....             LDR.N    R7,??DataTable11_27
   \       0xCE   0x2200             MOVS     R2,#+0
   \       0xD0   0x4641             MOV      R1,R8
   \       0xD2   0x0038             MOVS     R0,R7
   \       0xD4   0x.... 0x....      BL       HAL_GPIO_WritePin
    583          
    584            /*Configure GPIO pin Output Level */
    585            HAL_GPIO_WritePin(MCU_ACTIVE_GPIO_Port, MCU_ACTIVE_Pin, GPIO_PIN_RESET);
   \       0xD8   0x....             LDR.N    R4,??DataTable11_28
   \       0xDA   0x2200             MOVS     R2,#+0
   \       0xDC   0x2101             MOVS     R1,#+1
   \       0xDE   0x0020             MOVS     R0,R4
   \       0xE0   0x.... 0x....      BL       HAL_GPIO_WritePin
    586          
    587            /*Configure GPIO pin Output Level */
    588            HAL_GPIO_WritePin(GPIOA, VSYNC_FREQ_Pin|LCD_BL_CTRL_Pin|LCD_ON_OFF_Pin, GPIO_PIN_RESET);
   \       0xE4   0x....             LDR.N    R5,??DataTable11_29
   \       0xE6   0x2200             MOVS     R2,#+0
   \       0xE8   0xF241 0x0106      MOVW     R1,#+4102
   \       0xEC   0x0028             MOVS     R0,R5
   \       0xEE   0x.... 0x....      BL       HAL_GPIO_WritePin
    589          
    590            /*Configure GPIO pin Output Level */
    591            HAL_GPIO_WritePin(GPIOB, RENDER_TIME_Pin|FRAME_RATE_Pin, GPIO_PIN_RESET);
   \       0xF2   0x....             LDR.N    R6,??DataTable11_30
   \       0xF4   0x2200             MOVS     R2,#+0
   \       0xF6   0xF44F 0x4140      MOV      R1,#+49152
   \       0xFA   0x0030             MOVS     R0,R6
   \       0xFC   0x.... 0x....      BL       HAL_GPIO_WritePin
    592          
    593            /*Configure GPIO pins : LED3_Pin LED2_Pin */
    594            GPIO_InitStruct.Pin = LED3_Pin|LED2_Pin;
   \      0x100   0xF8CD 0x8000      STR      R8,[SP, #+0]
    595            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \      0x104   0x2001             MOVS     R0,#+1
   \      0x106   0x9001             STR      R0,[SP, #+4]
    596            GPIO_InitStruct.Pull = GPIO_PULLUP;
   \      0x108   0x2001             MOVS     R0,#+1
   \      0x10A   0x9002             STR      R0,[SP, #+8]
    597            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   \      0x10C   0x2000             MOVS     R0,#+0
   \      0x10E   0x9003             STR      R0,[SP, #+12]
    598            HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
   \      0x110   0x4669             MOV      R1,SP
   \      0x112   0x0038             MOVS     R0,R7
   \      0x114   0x.... 0x....      BL       HAL_GPIO_Init
    599          
    600            /*Configure GPIO pin : MCU_ACTIVE_Pin */
    601            GPIO_InitStruct.Pin = MCU_ACTIVE_Pin;
   \      0x118   0x2001             MOVS     R0,#+1
   \      0x11A   0x9000             STR      R0,[SP, #+0]
    602            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \      0x11C   0x2001             MOVS     R0,#+1
   \      0x11E   0x9001             STR      R0,[SP, #+4]
    603            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \      0x120   0x2000             MOVS     R0,#+0
   \      0x122   0x9002             STR      R0,[SP, #+8]
    604            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   \      0x124   0x2000             MOVS     R0,#+0
   \      0x126   0x9003             STR      R0,[SP, #+12]
    605            HAL_GPIO_Init(MCU_ACTIVE_GPIO_Port, &GPIO_InitStruct);
   \      0x128   0x4669             MOV      R1,SP
   \      0x12A   0x0020             MOVS     R0,R4
   \      0x12C   0x.... 0x....      BL       HAL_GPIO_Init
    606          
    607            /*Configure GPIO pins : VSYNC_FREQ_Pin LCD_BL_CTRL_Pin */
    608            GPIO_InitStruct.Pin = VSYNC_FREQ_Pin|LCD_BL_CTRL_Pin;
   \      0x130   0xF241 0x0002      MOVW     R0,#+4098
   \      0x134   0x9000             STR      R0,[SP, #+0]
    609            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \      0x136   0x2001             MOVS     R0,#+1
   \      0x138   0x9001             STR      R0,[SP, #+4]
    610            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \      0x13A   0x2000             MOVS     R0,#+0
   \      0x13C   0x9002             STR      R0,[SP, #+8]
    611            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   \      0x13E   0x2000             MOVS     R0,#+0
   \      0x140   0x9003             STR      R0,[SP, #+12]
    612            HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
   \      0x142   0x4669             MOV      R1,SP
   \      0x144   0x0028             MOVS     R0,R5
   \      0x146   0x.... 0x....      BL       HAL_GPIO_Init
    613          
    614            /*Configure GPIO pin : WakeupButton_Pin */
    615            GPIO_InitStruct.Pin = WakeupButton_Pin;
   \      0x14A   0xF44F 0x5000      MOV      R0,#+8192
   \      0x14E   0x9000             STR      R0,[SP, #+0]
    616            GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
   \      0x150   0x2000             MOVS     R0,#+0
   \      0x152   0x9001             STR      R0,[SP, #+4]
    617            GPIO_InitStruct.Pull = GPIO_PULLDOWN;
   \      0x154   0x2002             MOVS     R0,#+2
   \      0x156   0x9002             STR      R0,[SP, #+8]
    618            HAL_GPIO_Init(WakeupButton_GPIO_Port, &GPIO_InitStruct);
   \      0x158   0x4669             MOV      R1,SP
   \      0x15A   0x....             LDR.N    R0,??DataTable11_31
   \      0x15C   0x.... 0x....      BL       HAL_GPIO_Init
    619          
    620            /*Configure GPIO pin : LCD_INT_Pin */
    621            GPIO_InitStruct.Pin = LCD_INT_Pin;
   \      0x160   0x2004             MOVS     R0,#+4
   \      0x162   0x9000             STR      R0,[SP, #+0]
    622            GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
   \      0x164   0xF45F 0x1088      MOVS     R0,#+1114112
   \      0x168   0x9001             STR      R0,[SP, #+4]
    623            GPIO_InitStruct.Pull = GPIO_PULLUP;
   \      0x16A   0x2001             MOVS     R0,#+1
   \      0x16C   0x9002             STR      R0,[SP, #+8]
    624            HAL_GPIO_Init(LCD_INT_GPIO_Port, &GPIO_InitStruct);
   \      0x16E   0x4669             MOV      R1,SP
   \      0x170   0x....             LDR.N    R0,??DataTable11_32
   \      0x172   0x.... 0x....      BL       HAL_GPIO_Init
    625          
    626            /*Configure GPIO pins : RENDER_TIME_Pin FRAME_RATE_Pin */
    627            GPIO_InitStruct.Pin = RENDER_TIME_Pin|FRAME_RATE_Pin;
   \      0x176   0xF44F 0x4040      MOV      R0,#+49152
   \      0x17A   0x9000             STR      R0,[SP, #+0]
    628            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \      0x17C   0x2001             MOVS     R0,#+1
   \      0x17E   0x9001             STR      R0,[SP, #+4]
    629            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \      0x180   0x2000             MOVS     R0,#+0
   \      0x182   0x9002             STR      R0,[SP, #+8]
    630            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   \      0x184   0x2000             MOVS     R0,#+0
   \      0x186   0x9003             STR      R0,[SP, #+12]
    631            HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \      0x188   0x4669             MOV      R1,SP
   \      0x18A   0x0030             MOVS     R0,R6
   \      0x18C   0x.... 0x....      BL       HAL_GPIO_Init
    632          
    633            /*Configure GPIO pin : LCD_ON_OFF_Pin */
    634            GPIO_InitStruct.Pin = LCD_ON_OFF_Pin;
   \      0x190   0x2004             MOVS     R0,#+4
   \      0x192   0x9000             STR      R0,[SP, #+0]
    635            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \      0x194   0x2001             MOVS     R0,#+1
   \      0x196   0x9001             STR      R0,[SP, #+4]
    636            GPIO_InitStruct.Pull = GPIO_PULLUP;
   \      0x198   0x2001             MOVS     R0,#+1
   \      0x19A   0x9002             STR      R0,[SP, #+8]
    637            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   \      0x19C   0x2000             MOVS     R0,#+0
   \      0x19E   0x9003             STR      R0,[SP, #+12]
    638            HAL_GPIO_Init(LCD_ON_OFF_GPIO_Port, &GPIO_InitStruct);
   \      0x1A0   0x4669             MOV      R1,SP
   \      0x1A2   0x0028             MOVS     R0,R5
   \      0x1A4   0x.... 0x....      BL       HAL_GPIO_Init
    639          
    640            /* EXTI interrupt init*/
    641            HAL_NVIC_SetPriority(EXTI2_IRQn, 5, 0);
   \      0x1A8   0x2200             MOVS     R2,#+0
   \      0x1AA   0x2105             MOVS     R1,#+5
   \      0x1AC   0x2008             MOVS     R0,#+8
   \      0x1AE   0x.... 0x....      BL       HAL_NVIC_SetPriority
    642            HAL_NVIC_EnableIRQ(EXTI2_IRQn);
   \      0x1B2   0x2008             MOVS     R0,#+8
   \      0x1B4   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    643          
    644          }
   \      0x1B8   0xB006             ADD      SP,SP,#+24
   \      0x1BA   0xE8BD 0x81F0      POP      {R4-R8,PC}
    645          
    646          /* USER CODE BEGIN 4 */
    647          
    648          /* USER CODE END 4 */
    649          
    650          /* USER CODE BEGIN Header_StartDefaultTask */
    651          /**
    652            * @brief  Function implementing the defaultTask thread.
    653            * @param  argument: Not used
    654            * @retval None
    655            */
    656          /* USER CODE END Header_StartDefaultTask */

   \                                 In section .text, align 4, keep-with-next
    657          void StartDefaultTask(void *argument)
    658          {
   \                     StartDefaultTask: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    659            /* USER CODE BEGIN 5 */
    660          
    661          //    osTimerStart(testTimerHandle, 1000);
    662              startTimer(testTmrCallback, osTimerPeriodic, NULL, 1000);
   \        0x2   0xF44F 0x737A      MOV      R3,#+1000
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0x.... 0x....      ADR.W    R0,testTmrCallback
   \        0xE   0x.... 0x....      BL       startTimer
    663              startTimer(TimerHandleTest, osTimerPeriodic, 10, 1000);
   \       0x12   0xF44F 0x737A      MOV      R3,#+1000
   \       0x16   0x220A             MOVS     R2,#+10
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x....             LDR.N    R0,??DataTable11_33
   \       0x1C   0x.... 0x....      BL       startTimer
    664          
    665            /* Infinite loop */
    666            for(;;)
    667            {
    668              osDelay(100);
   \                     ??StartDefaultTask_0: (+1)
   \       0x20   0x2064             MOVS     R0,#+100
   \       0x22   0x.... 0x....      BL       osDelay
   \       0x26   0xE7FB             B.N      ??StartDefaultTask_0
    669            }
    670            /* USER CODE END 5 */
    671          }
    672          
    673          /* testTmrCallback function */

   \                                 In section .text, align 4, keep-with-next
    674          void testTmrCallback(void *argument)
    675          {
   \                     testTmrCallback: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    676            /* USER CODE BEGIN testTmrCallback */
    677              HAL_GPIO_TogglePin(GPIOG, GPIO_PIN_2);
   \        0x2   0x....             LDR.N    R4,??DataTable11_27
   \        0x4   0x2104             MOVS     R1,#+4
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x.... 0x....      BL       HAL_GPIO_TogglePin
    678              HAL_GPIO_TogglePin(GPIOG, GPIO_PIN_11);
   \        0xC   0xF44F 0x6100      MOV      R1,#+2048
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0x.... 0x....      BL       HAL_GPIO_TogglePin
    679            /* USER CODE END testTmrCallback */
    680          }
   \       0x16   0xBD10             POP      {R4,PC}
    681          
    682          /* MPU Configuration */
    683          

   \                                 In section .text, align 2, keep-with-next
    684          void MPU_Config(void)
    685          {
   \                     MPU_Config: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x2110             MOVS     R1,#+16
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x466C             MOV      R4,SP
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       __aeabi_memset
    686            MPU_Region_InitTypeDef MPU_InitStruct = {0};
    687          
    688            /* Disables the MPU */
    689            HAL_MPU_Disable();
   \        0xE   0x.... 0x....      BL       HAL_MPU_Disable
    690            /** Initializes and configures the Region and the memory to be protected
    691            */
    692            MPU_InitStruct.Enable = MPU_REGION_ENABLE;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xF88D 0x0000      STRB     R0,[SP, #+0]
    693            MPU_InitStruct.Number = MPU_REGION_NUMBER0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    694            MPU_InitStruct.BaseAddress = 0x90000000;
   \       0x1E   0xF05F 0x4010      MOVS     R0,#+2415919104
   \       0x22   0x9001             STR      R0,[SP, #+4]
    695            MPU_InitStruct.Size = MPU_REGION_SIZE_256MB;
   \       0x24   0x201B             MOVS     R0,#+27
   \       0x26   0xF88D 0x0008      STRB     R0,[SP, #+8]
    696            MPU_InitStruct.SubRegionDisable = 0x0;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xF88D 0x0009      STRB     R0,[SP, #+9]
    697            MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xF88D 0x000A      STRB     R0,[SP, #+10]
    698            MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xF88D 0x000B      STRB     R0,[SP, #+11]
    699            MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xF88D 0x000C      STRB     R0,[SP, #+12]
    700            MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xF88D 0x000D      STRB     R0,[SP, #+13]
    701            MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xF88D 0x000E      STRB     R0,[SP, #+14]
    702            MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xF88D 0x000F      STRB     R0,[SP, #+15]
    703          
    704            HAL_MPU_ConfigRegion(&MPU_InitStruct);
   \       0x54   0x4668             MOV      R0,SP
   \       0x56   0x.... 0x....      BL       HAL_MPU_ConfigRegion
    705            /** Initializes and configures the Region and the memory to be protected
    706            */
    707            MPU_InitStruct.Number = MPU_REGION_NUMBER1;
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    708            MPU_InitStruct.Size = MPU_REGION_SIZE_64MB;
   \       0x60   0x2019             MOVS     R0,#+25
   \       0x62   0xF88D 0x0008      STRB     R0,[SP, #+8]
    709            MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
   \       0x66   0x2003             MOVS     R0,#+3
   \       0x68   0xF88D 0x000B      STRB     R0,[SP, #+11]
    710            MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0xF88D 0x000E      STRB     R0,[SP, #+14]
    711          
    712            HAL_MPU_ConfigRegion(&MPU_InitStruct);
   \       0x72   0x4668             MOV      R0,SP
   \       0x74   0x.... 0x....      BL       HAL_MPU_ConfigRegion
    713            /** Initializes and configures the Region and the memory to be protected
    714            */
    715            MPU_InitStruct.Number = MPU_REGION_NUMBER2;
   \       0x78   0x2002             MOVS     R0,#+2
   \       0x7A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    716            MPU_InitStruct.BaseAddress = 0x24000000;
   \       0x7E   0xF05F 0x5010      MOVS     R0,#+603979776
   \       0x82   0x9001             STR      R0,[SP, #+4]
    717            MPU_InitStruct.Size = MPU_REGION_SIZE_1MB;
   \       0x84   0x2013             MOVS     R0,#+19
   \       0x86   0xF88D 0x0008      STRB     R0,[SP, #+8]
    718          
    719            HAL_MPU_ConfigRegion(&MPU_InitStruct);
   \       0x8A   0x4668             MOV      R0,SP
   \       0x8C   0x.... 0x....      BL       HAL_MPU_ConfigRegion
    720            /** Initializes and configures the Region and the memory to be protected
    721            */
    722            MPU_InitStruct.Number = MPU_REGION_NUMBER3;
   \       0x90   0x2003             MOVS     R0,#+3
   \       0x92   0xF88D 0x0001      STRB     R0,[SP, #+1]
    723            MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
   \       0x96   0x2011             MOVS     R0,#+17
   \       0x98   0xF88D 0x0008      STRB     R0,[SP, #+8]
    724            MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
   \       0x9C   0x2001             MOVS     R0,#+1
   \       0x9E   0xF88D 0x000F      STRB     R0,[SP, #+15]
    725          
    726            HAL_MPU_ConfigRegion(&MPU_InitStruct);
   \       0xA2   0x4668             MOV      R0,SP
   \       0xA4   0x.... 0x....      BL       HAL_MPU_ConfigRegion
    727            /* Enables the MPU */
    728            HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
   \       0xA8   0x2004             MOVS     R0,#+4
   \       0xAA   0x.... 0x....      BL       HAL_MPU_Enable
    729          
    730          }
   \       0xAE   0xBD1F             POP      {R0-R4,PC}
    731          
    732          /**
    733            * @brief  Period elapsed callback in non blocking mode
    734            * @note   This function is called  when TIM6 interrupt took place, inside
    735            * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
    736            * a global variable "uwTick" used as application time base.
    737            * @param  htim : TIM handle
    738            * @retval None
    739            */

   \                                 In section .text, align 2, keep-with-next
    740          void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
    741          {
   \                     HAL_TIM_PeriodElapsedCallback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    742            /* USER CODE BEGIN Callback 0 */
    743          
    744            /* USER CODE END Callback 0 */
    745            if (htim->Instance == TIM6) {
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x....             LDR.N    R1,??DataTable11_34
   \        0x6   0x4288             CMP      R0,R1
   \        0x8   0xD101             BNE.N    ??HAL_TIM_PeriodElapsedCallback_0
    746              HAL_IncTick();
   \        0xA   0x.... 0x....      BL       HAL_IncTick
    747            }
    748            /* USER CODE BEGIN Callback 1 */
    749          
    750            /* USER CODE END Callback 1 */
    751          }
   \                     ??HAL_TIM_PeriodElapsedCallback_0: (+1)
   \        0xE   0xBD01             POP      {R0,PC}
    752          
    753          /**
    754            * @brief  This function is executed in case of error occurrence.
    755            * @retval None
    756            */

   \                                 In section .text, align 2, keep-with-next
    757          void Error_Handler(void)
    758          {
    759            /* USER CODE BEGIN Error_Handler_Debug */
    760            /* User can add his own implementation to report the HAL error return state */
    761          
    762            /* USER CODE END Error_Handler_Debug */
    763          }
   \                     Error_Handler: (+1)
   \        0x0   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0xE000'ED14        DC32     0xe000ed14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0xE000'EF50        DC32     0xe000ef50

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0xE000'ED84        DC32     0xe000ed84

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0xE000'ED80        DC32     0xe000ed80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0xE000'EF60        DC32     0xe000ef60

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \        0x0   0x....'....        DC32     defaultTask_attributes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \        0x0   0x....'....        DC32     defaultTaskHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \        0x0   0x....'....        DC32     GUI_Task_attributes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \        0x0   0x....'....        DC32     TouchGFX_Task

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \        0x0   0x....'....        DC32     GUI_TaskHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \        0x0   0x5802'4818        DC32     0x58024818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \        0x0   0x5802'4428        DC32     0x58024428

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \        0x0   0x....'....        DC32     hcrc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \        0x0   0x4002'3000        DC32     0x40023000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \        0x0   0x....'....        DC32     hdma2d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \        0x0   0x5200'1000        DC32     0x52001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \        0x0   0x....'....        DC32     hi2c4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_17:
   \        0x0   0x5800'1C00        DC32     0x58001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_18:
   \        0x0   0x3080'8BD0        DC32     0x30808bd0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_19:
   \        0x0   0x....'....        DC32     hltdc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_20:
   \        0x0   0x5000'1000        DC32     0x50001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_21:
   \        0x0   0x....'....        DC32     hospi1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_22:
   \        0x0   0x5200'5000        DC32     0x52005000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_23:
   \        0x0   0x0100'0001        DC32     0x1000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_24:
   \        0x0   0x....'....        DC32     huart1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_25:
   \        0x0   0x4001'1000        DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_26:
   \        0x0   0x5802'4540        DC32     0x58024540

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_27:
   \        0x0   0x5802'1800        DC32     0x58021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_28:
   \        0x0   0x5802'2000        DC32     0x58022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_29:
   \        0x0   0x5802'0000        DC32     0x58020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_30:
   \        0x0   0x5802'0400        DC32     0x58020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_31:
   \        0x0   0x5802'0800        DC32     0x58020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_32:
   \        0x0   0x5802'1C00        DC32     0x58021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_33:
   \        0x0   0x....'....        DC32     TimerHandleTest

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_34:
   \        0x0   0x4000'1000        DC32     0x40001000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x64 0x65          DC8 "defaultTask"

   \              0x66 0x61    

   \              0x75 0x6C    

   \              0x74 0x54    

   \              0x61 0x73    

   \              0x6B 0x00

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x47 0x55          DC8 "GUI_Task"

   \              0x49 0x5F    

   \              0x54 0x61    

   \              0x73 0x6B    

   \              0x00
   \        0x9                      DS8 3
    764          
    765          #ifdef  USE_FULL_ASSERT
    766          /**
    767            * @brief  Reports the name of the source file and the source line number
    768            *         where the assert_param error has occurred.
    769            * @param  file: pointer to the source file name
    770            * @param  line: assert_param error line source number
    771            * @retval None
    772            */
    773          void assert_failed(uint8_t *file, uint32_t line)
    774          {
    775            /* USER CODE BEGIN 6 */
    776            /* User can add his own implementation to report the file name and line number,
    777               tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    778            /* USER CODE END 6 */
    779          }
    780          #endif /* USE_FULL_ASSERT */
    781          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Error_Handler
       8   HAL_TIM_PeriodElapsedCallback
         8   -> HAL_IncTick
      24   MPU_Config
        24   -> HAL_MPU_ConfigRegion
        24   -> HAL_MPU_Disable
        24   -> HAL_MPU_Enable
        24   -> __aeabi_memset
       8   MX_CRC_Init
         8   -> Error_Handler
         8   -> HAL_CRC_Init
       8   MX_DMA2D_Init
         8   -> Error_Handler
         8   -> HAL_DMA2D_ConfigLayer
         8   -> HAL_DMA2D_Init
      48   MX_GPIO_Init
        48   -> HAL_GPIO_Init
        48   -> HAL_GPIO_WritePin
        48   -> HAL_NVIC_EnableIRQ
        48   -> HAL_NVIC_SetPriority
        48   -> __aeabi_memset
       8   MX_I2C4_Init
         8   -> Error_Handler
         8   -> HAL_I2CEx_ConfigAnalogFilter
         8   -> HAL_I2CEx_ConfigDigitalFilter
         8   -> HAL_I2C_Init
      64   MX_LTDC_Init
        64   -> Error_Handler
        64   -> HAL_LTDC_ConfigLayer
        64   -> HAL_LTDC_Init
        64   -> __aeabi_memset
      40   MX_OCTOSPI1_Init
        40   -> BSP_OSPI_NOR_DeInit
        40   -> BSP_OSPI_NOR_EnableMemoryMappedMode
        40   -> BSP_OSPI_NOR_Init
        40   -> Error_Handler
        40   -> HAL_OSPIM_Config
        40   -> HAL_OSPI_Init
        40   -> __aeabi_memset
       8   MX_USART1_UART_Init
         8   -> Error_Handler
         8   -> HAL_UARTEx_DisableFifoMode
         8   -> HAL_UARTEx_SetRxFifoThreshold
         8   -> HAL_UARTEx_SetTxFifoThreshold
         8   -> HAL_UART_Init
       8   StartDefaultTask
         8   -> osDelay
         8   -> startTimer
     120   SystemClock_Config
       120   -> Error_Handler
       120   -> HAL_PWREx_ConfigSupply
       120   -> HAL_RCC_ClockConfig
       120   -> HAL_RCC_OscConfig
       120   -> __aeabi_memset
      16   main
        16   -> HAL_Init
        16   -> MPU_Config
        16   -> MX_CRC_Init
        16   -> MX_DMA2D_Init
        16   -> MX_GPIO_Init
        16   -> MX_I2C4_Init
        16   -> MX_LTDC_Init
        16   -> MX_OCTOSPI1_Init
        16   -> MX_TouchGFX_Init
        16   -> MX_USART1_UART_Init
        16   -> SystemClock_Config
        16   -> osKernelInitialize
        16   -> osKernelStart
        16   -> osThreadNew
       8   testTmrCallback
         8   -> HAL_GPIO_TogglePin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_19
       4  ??DataTable11_2
       4  ??DataTable11_20
       4  ??DataTable11_21
       4  ??DataTable11_22
       4  ??DataTable11_23
       4  ??DataTable11_24
       4  ??DataTable11_25
       4  ??DataTable11_26
       4  ??DataTable11_27
       4  ??DataTable11_28
       4  ??DataTable11_29
       4  ??DataTable11_3
       4  ??DataTable11_30
       4  ??DataTable11_31
       4  ??DataTable11_32
       4  ??DataTable11_33
       4  ??DataTable11_34
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      12  ?_0
      12  ?_1
       2  Error_Handler
       4  GUI_TaskHandle
      36  GUI_Task_attributes
      16  HAL_TIM_PeriodElapsedCallback
     176  MPU_Config
      46  MX_CRC_Init
      84  MX_DMA2D_Init
     446  MX_GPIO_Init
      96  MX_I2C4_Init
     202  MX_LTDC_Init
     200  MX_OCTOSPI1_Init
     112  MX_USART1_UART_Init
      40  StartDefaultTask
     198  SystemClock_Config
       4  defaultTaskHandle
      36  defaultTask_attributes
      36  hcrc
     104  hdma2d
      76  hi2c4
     168  hltdc
      96  hospi1
     144  huart1
     232  main
      24  testTmrCallback

 
   632 bytes in section .bss
    96 bytes in section .rodata
 2'014 bytes in section .text
 
 2'014 bytes of CODE  memory
    96 bytes of CONST memory
   632 bytes of DATA  memory

Errors: none
Warnings: none
